[{"references": [],
  "name": "Lean.Omega.Constraint.upperBound",
  "constType": "Omega.Constraint → Omega.UpperBound",
  "constCategory": "Definition"},
 {"references": ["Std.TreeSet.empty", "Lean.Name.quickCmp"],
  "name": "Lean.NameSet.empty",
  "constType": "NameSet",
  "constCategory": "Definition"},
 {"references":
  ["Lean.MacroScopesView.imported",
   "_private.Init.Prelude.0.Lean.MacroScopesView.review.match_1",
   "Lean.MacroScopesView.ctx",
   "Lean.Name.appendCore",
   "Lean.Name.mkNum",
   "Lean.MacroScopesView.scopes",
   "List.foldl",
   "Lean.MacroScope",
   "Lean.Name.mkStr",
   "Lean.MacroScopesView.name",
   "Unit"],
  "name": "Lean.MacroScopesView.review",
  "constType": "MacroScopesView → Name",
  "constCategory": "Definition"},
 {"references":
  ["CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "sorryAx",
   "Set",
   "Membership.mem",
   "CellularAutomatas.CellAutomaton.dead",
   "CellularAutomatas.tCellAutomaton.similar",
   "CellularAutomatas.CA_lt",
   "CellularAutomatas.LCellAutomaton.border",
   "Subtype.val",
   "OfNat.ofNat",
   "CellularAutomatas.tCellAutomaton.toLCellAutomaton",
   "Set.Elem"],
  "name": "CellularAutomatas.results_unproven.linear_time_dead_border",
  "constType":
  "∀ {α : Type} [inst : CellularAutomatas.Alphabet α] (C : ↑(CellularAutomatas.CA_lt α)),\n  ∃ C', C'.dead C'.border ∧ C'.similar ↑C",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "SizeOf.sizeOf",
   "CellularAutomatas.CellAutomaton.Q",
   "OfNat.ofNat"],
  "name": "CellularAutomatas.tCellAutomaton._sizeOf_1",
  "constType":
  "{α : Type} → [SizeOf α] → CellularAutomatas.tCellAutomaton α → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["rfl",
   "absurd",
   "Not",
   "_private.Init.Core.0.Bool.of_not_eq_true.match_1_1"],
  "name": "Bool.of_not_eq_true",
  "constType": "∀ {b : Bool}, ¬b = true → b = false",
  "constCategory": "Theorem"},
 {"references": ["Lean.Grind.CommRing.Expr.casesOn", "Lean.Grind.CommRing.Var"],
  "name": "Lean.Grind.CommRing.Expr.toPoly.match_4",
  "constType":
  "(motive : Grind.CommRing.Expr → Sort u_1) →\n  (x : Grind.CommRing.Expr) →\n    ((k : ℤ) → motive (Grind.CommRing.Expr.num k)) →\n      ((k : ℤ) → motive (Grind.CommRing.Expr.intCast k)) →\n        ((k : ℕ) → motive (Grind.CommRing.Expr.natCast k)) →\n          ((x : Grind.CommRing.Var) → motive (Grind.CommRing.Expr.var x)) →\n            ((a b : Grind.CommRing.Expr) → motive (a.add b)) →\n              ((a b : Grind.CommRing.Expr) → motive (a.mul b)) →\n                ((a : Grind.CommRing.Expr) → motive a.neg) →\n                  ((a b : Grind.CommRing.Expr) → motive (a.sub b)) →\n                    ((a : Grind.CommRing.Expr) → (k : ℕ) → motive (a.pow k)) → motive x",
  "constCategory": "Definition"},
 {"references": ["Eq.subst"],
  "name": "heq_of_eq",
  "constType": "∀ {α : Sort u} {a a' : α}, a = a' → a ≍ a'",
  "constCategory": "Theorem"},
 {"references": ["eq_true", "trivial"],
  "name": "or_true",
  "constType": "∀ (p : Prop), (p ∨ True) = True",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Lean.Name.casesOn",
  "constType":
  "{motive : Name → Sort u} →\n  (t : Name) →\n    motive Name.anonymous →\n      ((pre : Name) → (str : String) → motive (pre.str str)) → ((pre : Name) → (i : ℕ) → motive (pre.num i)) → motive t",
  "constCategory": "Definition"},
 {"references": ["Multiset.mem_singleton"],
  "name": "Finset.mem_singleton",
  "constType": "∀ {α : Type u_1} {a b : α}, b ∈ {a} ↔ b = a",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CellularAutomatas.LCellAutomaton.toCellAutomaton",
  "constType":
  "{α : Type} → CellularAutomatas.LCellAutomaton α → CellularAutomatas.CellAutomaton",
  "constCategory": "Definition"},
 {"references":
  ["CellularAutomatas.Word",
   "CellularAutomatas.FiniteStateTransducer.advice._proof_1",
   "CellularAutomatas.FiniteStateTransducer.scanr",
   "CellularAutomatas.FiniteStateTransducer.M_id",
   "congrArg",
   "CellularAutomatas.Advice.f",
   "congrFun",
   "CellularAutomatas.Advice.mk.congr_simp",
   "funext",
   "id",
   "CellularAutomatas.FiniteStateTransducer.M_id_scanr_eq",
   "Eq.mpr",
   "CellularAutomatas.FiniteStateTransducer.advice",
   "Eq.ndrec",
   "List.length"],
  "name": "CellularAutomatas.FiniteStateTransducer.M_id_advice_eq",
  "constType":
  "∀ {α : Type} [inst : CellularAutomatas.Alphabet α], (CellularAutomatas.FiniteStateTransducer.M_id α).advice.f = id",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Bool.casesOn",
  "constType":
  "{motive : Bool → Sort u} → (t : Bool) → motive false → motive true → motive t",
  "constCategory": "Definition"},
 {"references":
  ["CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "CellularAutomatas.Word",
   "CellularAutomatas.CellAutomaton.Q",
   "CellularAutomatas.LCellAutomaton.comp",
   "CellularAutomatas.Config"],
  "name": "CellularAutomatas.LCellAutomaton.comp.eq_1",
  "constType":
  "∀ {α : Type} (C : CellularAutomatas.LCellAutomaton α) (w : CellularAutomatas.Word α),\n  C.comp w = C.nextt (C.embed_word w)",
  "constCategory": "Theorem"},
 {"references": ["rfl"],
  "name": "congrFun",
  "constType":
  "∀ {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x}, f = g → ∀ (a : α), f a = g a",
  "constCategory": "Theorem"},
 {"references":
  ["List.ctorIdx", "False.elim", "noConfusion_of_Nat", "Eq.casesOn"],
  "name":
  "_private.Init.Data.List.Lemmas.0.List.getLast?_eq_getElem?.match_1_3",
  "constType":
  "∀ {α : Type u_1} (a : α) (l : List α) (motive : a :: l = [] → Prop) (a : a :: l = []), motive a",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Nat.Linear.PolyCnstr.eq",
  "constType": "Nat.Linear.PolyCnstr → Bool",
  "constCategory": "Definition"},
 {"references": ["LT.lt"],
  "name": "Int.add_one_le_of_lt",
  "constType": "∀ {a b : ℤ}, a < b → a + 1 ≤ b",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "HAdd.hAdd",
   "Lean.Grind.Nat.lt_eq",
   "Eq.substr",
   "List.drop",
   "List.take",
   "LE.le",
   "HSub.hSub",
   "OfNat.ofNat",
   "List.length"],
  "name": "CellularAutomatas.PrefixStableProof.getLastOfTake._proof_1_23",
  "constType":
  "∀ {i : ℕ} {α : Type u_1} {w : List α},\n  (List.take i w).length + ((List.take (List.take 1 w⟦i..*⟧).length w⟦(List.take i w).length..*⟧).length - 1) + 1 ≤\n      w.length →\n    (List.take i w).length + ((List.take (List.take 1 w⟦i..*⟧).length w⟦(List.take i w).length..*⟧).length - 1) <\n      w.length",
  "constCategory": "Theorem"},
 {"references": ["CellularAutomatas.Word", "CellularAutomatas.Word.get'?"],
  "name": "CellularAutomatas.Word.get'?.eq_1",
  "constType":
  "∀ {α : Type u} (w : CellularAutomatas.Word α) (i : ℤ), w.get'? i = if h : i ∈ w.range then some (w.get' i h) else none",
  "constCategory": "Theorem"},
 {"references":
  ["Ordering.ctorIdx",
   "_private.Lean.Data.Name.0.Lean.Name.cmp._sparseCasesOn_1",
   "Ne",
   "OfNat.ofNat",
   "Unit.unit",
   "Unit"],
  "name": "_private.Lean.Data.Name.0.Lean.Name.cmp.match_1",
  "constType":
  "(motive : Ordering → Sort u_1) →\n  (x : Ordering) → (Unit → motive Ordering.eq) → ((ord : Ordering) → motive ord) → motive x",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CellularAutomatas.FiniteStateTransducer.rec",
  "constType":
  "{α β : Type} →\n  {motive : CellularAutomatas.FiniteStateTransducer α β → Sort u} →\n    ((Q : Type) →\n        [alphabetQ : CellularAutomatas.Alphabet Q] →\n          (δ : Q → α → Q) →\n            (q0 : Q) → (f : Q → β) → motive { Q := Q, alphabetQ := alphabetQ, δ := δ, q0 := q0, f := f }) →\n      (t : CellularAutomatas.FiniteStateTransducer α β) → motive t",
  "constCategory": "Other"},
 {"references":
  ["Lean.Grind.instToIntFinCoOfNatIntCast._proof_1",
   "Nat.cast",
   "Lean.Grind.instToIntFinCoOfNatIntCast.eq_1",
   "Lean.Grind.instToIntFinCoOfNatIntCast._proof_2",
   "OfNat.ofNat",
   "congrArg",
   "Fin.val",
   "NatCast.natCast",
   "id",
   "Eq.symm",
   "Lean.Grind.ToInt.toInt.eq_1",
   "Lean.Grind.ToInt.toInt",
   "Eq.mpr"],
  "name": "Nat.ToInt.finVal",
  "constType": "∀ {n : ℕ} {a : Fin n} {a' : ℤ}, ↑a = a' → ↑↑a = a'",
  "constCategory": "Theorem"},
 {"references": ["CellularAutomatas.Word", "CellularAutomatas.Word.snd"],
  "name": "CellularAutomatas.Word.snd.eq_1",
  "constType":
  "∀ {α β : Type} (w : CellularAutomatas.Word (α ⨉ β)), w.snd = List.map Prod.snd w",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "eq_self",
   "Eq.trans",
   "of_eq_true",
   "CellularAutomatas.CellAutomaton.next",
   "CellularAutomatas.apply_iterated_succ_apply'",
   "CellularAutomatas.apply_iterated",
   "CellularAutomatas.CellAutomaton.Q",
   "CellularAutomatas.Config",
   "OfNat.ofNat",
   "congrArg"],
  "name": "CellularAutomatas.LCellAutomaton.nextt_succ_eq",
  "constType":
  "∀ {α : Type} {t : ℕ} (C : CellularAutomatas.LCellAutomaton α) (c : CellularAutomatas.Config C.Q),\n  C.nextt c (t + 1) = C.next (C.nextt c t)",
  "constCategory": "Theorem"},
 {"references":
  ["Int.Linear.Poly.mul_k",
   "Int.beq'",
   "Int.Linear.hugeFuel",
   "Int.Linear.Poly.combine_mul_k'",
   "OfNat.ofNat"],
  "name": "Int.Linear.Poly.combine_mul_k",
  "constType": "ℤ → ℤ → Int.Linear.Poly → Int.Linear.Poly → Int.Linear.Poly",
  "constCategory": "Definition"},
 {"references":
  ["rfl",
   "HAdd.hAdd",
   "eq_self",
   "Int.subNatNat",
   "Eq.trans",
   "of_eq_true",
   "_private.Init.Data.Int.Lemmas.0.Int.add_left_neg.match_1_1",
   "Neg.neg",
   "Int.subNat_eq_zero_iff._simp_1",
   "OfNat.ofNat",
   "Unit"],
  "name": "Int.add_left_neg",
  "constType": "∀ (a : ℤ), -a + a = 0",
  "constCategory": "Theorem"},
 {"references": ["Nat.le_of_succ_le_succ"],
  "name": "Nat.le_of_lt_succ",
  "constType": "∀ {m n : ℕ}, m < n.succ → m ≤ n",
  "constCategory": "Theorem"},
 {"references": ["Int.negOfNat.match_1", "OfNat.ofNat", "Unit"],
  "name": "Int.negOfNat",
  "constType": "ℕ → ℤ",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Grind.AC.Var",
   "Eq.propIntro",
   "Eq.symm",
   "Lean.Grind.AC.Seq.cons.noConfusion",
   "Eq.ndrec",
   "Eq.casesOn",
   "And.casesOn"],
  "name": "Lean.Grind.AC.Seq.cons.injEq",
  "constType":
  "∀ (x : Grind.AC.Var) (s : Grind.AC.Seq) (x_1 : Grind.AC.Var) (s_1 : Grind.AC.Seq),\n  (Grind.AC.Seq.cons x s = Grind.AC.Seq.cons x_1 s_1) = (x = x_1 ∧ s = s_1)",
  "constCategory": "Theorem"},
 {"references": ["rfl", "Option.map"],
  "name": "Option.map_none",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} (f : α → β), Option.map f none = none",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Grind.AC.Var",
   "Lean.Grind.AC.Seq.insert",
   "Lean.Grind.AC.Seq.brecOn",
   "Lean.Grind.AC.Seq.below",
   "Lean.Grind.AC.Seq.erase0.match_1"],
  "name": "Lean.Grind.AC.Seq.sort'",
  "constType": "Grind.AC.Seq → Grind.AC.Seq → Grind.AC.Seq",
  "constCategory": "Definition"},
 {"references":
  ["Int.add_assoc",
   "Nat.cast",
   "Eq.trans",
   "Neg.neg",
   "Int.add_zero",
   "_private.Init.Data.Int.Order.0.Int.le.dest.match_1_1",
   "OfNat.ofNat",
   "congrArg",
   "HAdd.hAdd",
   "eq_self",
   "of_eq_true",
   "Int.add_left_neg",
   "LE.le",
   "Int.add_comm",
   "HSub.hSub",
   "id",
   "Eq.symm",
   "Int.le.dest_sub",
   "Eq.mpr"],
  "name": "Int.le.dest",
  "constType": "∀ {a b : ℤ}, a ≤ b → ∃ n, a + ↑n = b",
  "constCategory": "Theorem"},
 {"references":
  ["Multiset.mem_dedup",
   "DecidableEq",
   "Membership.mem",
   "Multiset.dedup",
   "Multiset",
   "propext"],
  "name": "_private.Mathlib.Data.Finset.Image.0.Finset.mem_image._simp_1_2",
  "constType":
  "∀ {α : Type u_1} [inst : DecidableEq α] {a : α} {s : Multiset α}, (a ∈ s.dedup) = (a ∈ s)",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "SizeOf.sizeOf",
   "CellularAutomatas.CellAutomaton.Q",
   "OfNat.ofNat"],
  "name": "CellularAutomatas.tCellAutomaton.mk.sizeOf_spec",
  "constType":
  "∀ {α : Type} [inst : SizeOf α] (toLCellAutomaton : CellularAutomatas.LCellAutomaton α) (t p : ℕ → ℕ)\n  (F_pos : toLCellAutomaton.Q → Bool),\n  sizeOf { toLCellAutomaton := toLCellAutomaton, t := t, p := p, F_pos := F_pos } = 1 + sizeOf toLCellAutomaton",
  "constCategory": "Theorem"},
 {"references": ["HSub.hSub", "Eq.ndrec"],
  "name": "Lean.Omega.Int.sub_congr",
  "constType": "∀ {a b c d : ℤ}, a = b → c = d → a - c = b - d",
  "constCategory": "Theorem"},
 {"references": ["Eq.ndrec"],
  "name": "Eq.subst",
  "constType":
  "∀ {α : Sort u} {motive : α → Prop} {a b : α}, a = b → motive a → motive b",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "Int.Linear.Poly.beq'",
   "Eq.trans",
   "Int.Linear.Poly.denote'_eq_denote",
   "Int.neg_le_zero_iff._simp_1",
   "Int.Linear.Poly.mul_k_eq_mul",
   "Int.Linear.Poly.denote",
   "eq_true",
   "HMul.hMul",
   "Int.neg_one_mul",
   "congrArg",
   "Int.Linear.Poly.mul_k",
   "congr",
   "Eq.symm",
   "Int.Linear.Poly.denote'",
   "Eq.ndrec",
   "_private.Init.Data.Int.Linear.0.Int.Linear.eq_of_le_ge._simp_1_2",
   "Neg.neg",
   "Int.Linear.Poly.mul",
   "OfNat.ofNat",
   "Int.Linear.Poly.denote_mul",
   "Int.Linear.eq_of_le_ge_cert",
   "and_self",
   "Int.Linear.Context",
   "of_eq_true",
   "LE.le",
   "id",
   "Int.Linear.Poly.beq'_eq",
   "Eq.mpr"],
  "name": "Int.Linear.eq_of_le_ge",
  "constType":
  "∀ (ctx : Int.Linear.Context) (p₁ p₂ : Int.Linear.Poly),\n  Int.Linear.eq_of_le_ge_cert p₁ p₂ = true →\n    Int.Linear.Poly.denote' ctx p₁ ≤ 0 → Int.Linear.Poly.denote' ctx p₂ ≤ 0 → Int.Linear.Poly.denote' ctx p₁ = 0",
  "constCategory": "Theorem"},
 {"references":
  ["_private.Init.Data.List.Lemmas.0.List.ne_nil_of_length_pos.match_1_1",
   "LT.lt",
   "OfNat.ofNat",
   "List.length"],
  "name": "List.ne_nil_of_length_pos",
  "constType": "∀ {α : Type u_1} {l : List α}, 0 < l.length → l ≠ []",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Bool.and'",
  "constType": "Bool → Bool → Bool",
  "constCategory": "Definition"},
 {"references": ["Iff.rfl", "GT.gt"],
  "name": "gt_iff_lt",
  "constType": "∀ {α : Type u_1} [inst : LT α] {x y : α}, x > y ↔ y < x",
  "constCategory": "Theorem"},
 {"references": ["HAdd.hAdd", "SizeOf.sizeOf", "OfNat.ofNat"],
  "name": "CellularAutomatas.VerificationError.mk.sizeOf_spec",
  "constType":
  "∀ (module : Name) (message : String) (details : List String),\n  sizeOf { module := module, message := message, details := details } =\n    1 + sizeOf module + sizeOf message + sizeOf details",
  "constCategory": "Theorem"},
 {"references":
  ["Bind.bind",
   "_private.Lean.Environment.0.Lean.Environment.findAsyncCore?",
   "GetElem?.getElem?",
   "Lean.AsyncConstantInfo.toConstantInfo",
   "Lean.Kernel.Environment.constants",
   "_private.Lean.Environment.0.Lean.VisibilityMap.get",
   "Lean.SMap.map₁",
   "Membership.mem",
   "Pure.pure",
   "_private.Lean.Environment.0.Lean.Environment.addDeclCore.match_5",
   "Option.map",
   "_private.Lean.Environment.0.Lean.Environment.base"],
  "name": "Lean.Environment.find?",
  "constType": "Environment → Name → optParam Bool false → Option ConstantInfo",
  "constCategory": "Definition"},
 {"references":
  ["CellularAutomatas.FiniteStateTransducer.scanr_reduce_q",
   "CellularAutomatas.FiniteStateTransducer.q0"],
  "name": "CellularAutomatas.FiniteStateTransducer.scanr_reduce",
  "constType":
  "{α β : Type} → (M : CellularAutomatas.FiniteStateTransducer α β) → CellularAutomatas.Word α → M.Q",
  "constCategory": "Definition"},
 {"references":
  ["Nat.Linear.Context",
   "Nat.Linear.ExprCnstr.toNormPoly",
   "Eq.mp",
   "Nat.Linear.ExprCnstr.denote_toNormPoly",
   "congr",
   "Nat.Linear.ExprCnstr.denote_toPoly",
   "Nat.Linear.PolyCnstr.denote",
   "LawfulBEq.eq_of_beq",
   "Nat.Linear.ExprCnstr.toPoly",
   "BEq.beq",
   "Nat.Linear.ExprCnstr.denote",
   "congrArg"],
  "name": "Nat.Linear.ExprCnstr.eq_of_toNormPoly_eq",
  "constType":
  "∀ (ctx : Nat.Linear.Context) (c d : Nat.Linear.ExprCnstr),\n  (c.toNormPoly == d.toPoly) = true → Nat.Linear.ExprCnstr.denote ctx c = Nat.Linear.ExprCnstr.denote ctx d",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Nat.le_refl",
  "constType": "∀ (n : ℕ), n ≤ n",
  "constCategory": "Theorem"},
 {"references": ["HAdd.hAdd", "SizeOf.sizeOf", "OfNat.ofNat"],
  "name": "CellularAutomatas.CellAutomaton._sizeOf_1",
  "constType": "CellularAutomatas.CellAutomaton → ℕ",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Prod.fst",
  "constType": "{α : Type u} → {β : Type v} → α ⨉ β → α",
  "constCategory": "Definition"},
 {"references":
  ["Not",
   "Nat.cast",
   "Eq.trans",
   "Iff.mp",
   "and_true",
   "Nat.not_le",
   "OfNat.ofNat",
   "congrArg",
   "LT.lt",
   "eq_self",
   "gt_iff_lt._simp_1",
   "LE.le",
   "Lean.Omega.Int.ofNat_sub_eq_zero",
   "HSub.hSub",
   "id",
   "Int.ofNat_sub",
   "Eq.mpr",
   "dite"],
  "name": "Lean.Omega.Int.ofNat_sub_dichotomy",
  "constType": "∀ {a b : ℕ}, b ≤ a ∧ ↑(a - b) = ↑a - ↑b ∨ a < b ∧ ↑(a - b) = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Int.Linear.Poly.beq'",
   "Int.Linear.Poly.coeff",
   "Int.Linear.Poly.combine_mul_k",
   "Neg.neg",
   "Int.ble'",
   "Bool.and'",
   "OfNat.ofNat",
   "Int.Linear.Var"],
  "name": "Int.Linear.eq_le_subst_nonneg_cert",
  "constType":
  "Int.Linear.Var → Int.Linear.Poly → Int.Linear.Poly → Int.Linear.Poly → Bool",
  "constCategory": "Definition"},
 {"references":
  ["Nat.cast",
   "Eq.trans",
   "Int.negOfNat_mul_negSucc",
   "Int.casesOn",
   "HMul.hMul",
   "Int.negOfNat_mul_ofNat",
   "OfNat.ofNat",
   "Int.negSucc_mul_negOfNat",
   "congrArg",
   "HAdd.hAdd",
   "eq_self",
   "of_eq_true",
   "congr",
   "Eq.symm",
   "Int.negOfNat",
   "Eq.ndrec",
   "Nat.mul_assoc",
   "Int.ofNat_mul_negOfNat"],
  "name": "Int.mul_assoc",
  "constType": "∀ (a b c : ℤ), a * b * c = a * (b * c)",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.simulation.Params.C_ctl",
   "CellularAutomatas.CellAutomaton.Q",
   "CellularAutomatas.simulation.Q1.casesOn",
   "OfNat.ofNat"],
  "name": "CellularAutomatas.simulation.instDecidableEqQ1.decEq.match_1",
  "constType":
  "{e : CellularAutomatas.simulation.Params} →\n  (motive : CellularAutomatas.simulation.Q1 e → CellularAutomatas.simulation.Q1 e → Sort u_1) →\n    (x x_1 : CellularAutomatas.simulation.Q1 e) →\n      ((a : e.C_ctl.Q) →\n          (a_1 : Fin 3) →\n            (b : e.C_ctl.Q) → (b_1 : Fin 3) → motive { state := a, counter := a_1 } { state := b, counter := b_1 }) →\n        motive x x_1",
  "constCategory": "Definition"},
 {"references": ["Std.TreeMap.inner", "Std.DTreeMap.insertIfNew"],
  "name": "Std.TreeMap.insertIfNew",
  "constType":
  "{α : Type u} → {β : Type v} → {cmp : α → α → Ordering} → TreeMap α β cmp → α → β → TreeMap α β cmp",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Lean.ConstantVal.type",
  "constType": "ConstantVal → Expr",
  "constCategory": "Definition"},
 {"references": ["Min.min", "LE.le", "eq_true", "Nat.min_le_right"],
  "name":
  "_private.Init.Data.List.Nat.TakeDrop.0.List.length_take_le'._simp_1_1",
  "constType": "∀ (a b : ℕ), (min a b ≤ b) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans",
   "noConfusion_of_Nat",
   "Lean.Grind.CommRing.Power.beq'_eq",
   "Bool.coe_iff_coe._simp_1",
   "Bool.false_eq_true",
   "congrArg",
   "Lean.Grind.CommRing.Power.beq'",
   "Bool.and",
   "False.elim",
   "Lean.Grind.CommRing.Mon.casesOn",
   "congr",
   "funext",
   "Eq.symm",
   "and_congr_right_iff._simp_1",
   "Eq.ndrec",
   "Bool.and'_eq_and",
   "_private.Init.Grind.Ring.CommSolver.0.Lean.Grind.CommRing.Mon.beq'_eq._simp_1_2",
   "eq_false'",
   "eq_iff_iff._simp_1",
   "Lean.Grind.CommRing.Mon.beq'",
   "Lean.Grind.CommRing.Mon.ctorIdx",
   "eq_self",
   "Lean.Grind.CommRing.Mon.mult.injEq",
   "of_eq_true",
   "id",
   "Eq.mpr",
   "Bool.and_eq_true",
   "Bool.and'"],
  "name": "Lean.Grind.CommRing.Mon.beq'_eq",
  "constType":
  "∀ (m₁ m₂ : Grind.CommRing.Mon), (m₁.beq' m₂ = true) = (m₁ = m₂)",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "Nat.le_add_left",
   "OfNat.ofNat",
   "_private.Mathlib.Data.Nat.Find.0.Nat.wf_lbp.match_1",
   "congrArg",
   "_private.Mathlib.Data.Nat.Find.0.Nat.wf_lbp.match_3",
   "HAdd.hAdd",
   "absurd",
   "_private.Mathlib.Data.Nat.Find.0.Nat.lbp",
   "LE.le",
   "Nat.add_right_comm",
   "id",
   "Eq.mpr",
   "Nat.recOn"],
  "name": "_private.Mathlib.Data.Nat.Find.0.Nat.wf_lbp",
  "constType": "∀ {p : ℕ → Prop}, (∃ n, p n) → WellFounded Nat.lbp✝",
  "constCategory": "Definition"},
 {"references": ["forall_and", "propext"],
  "name": "Lean.Grind.forall_and",
  "constType":
  "∀ {α : Sort u_1} {p q : α → Prop}, (∀ (x : α), p x ∧ q x) = ((∀ (x : α), p x) ∧ ∀ (x : α), q x)",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "implies_congr",
   "Nat.not_lt_zero._simp_1",
   "Nat.find",
   "Eq.trans",
   "_private.Mathlib.Data.Nat.Find.0.Nat.find_eq_zero._simp_1_1",
   "DecidablePred",
   "and_true",
   "OfNat.ofNat",
   "congrArg",
   "LT.lt",
   "implies_true",
   "iff_self",
   "of_eq_true",
   "forall_congr",
   "false_implies"],
  "name": "Nat.find_eq_zero",
  "constType":
  "∀ {p : ℕ → Prop} [inst : DecidablePred p] (h : ∃ n, p n), Nat.find h = 0 ↔ p 0",
  "constCategory": "Theorem"},
 {"references": ["inf_le_right", "Min.min", "LE.le", "eq_true"],
  "name": "inf_le_right._simp_1",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeInf α] {a b : α}, (a ⊓ b ≤ b) = True",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "_private.Init.Data.Int.Lemmas.0.Int.add_left_cancel._simp_1_1",
   "Eq.trans",
   "Eq.mp",
   "Neg.neg",
   "Int.add_left_neg",
   "congr",
   "Int.zero_add",
   "id",
   "Eq.mpr",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Int.add_left_cancel",
  "constType": "∀ {a b c : ℤ}, a + b = a + c → b = c",
  "constCategory": "Theorem"},
 {"references": ["Lean.AsyncConstantInfo.constInfo", "Task.get"],
  "name": "Lean.AsyncConstantInfo.toConstantInfo",
  "constType": "AsyncConstantInfo → ConstantInfo",
  "constCategory": "Definition"},
 {"references": ["Not", "LT.lt"],
  "name": "Nat.findX._proof_1",
  "constType":
  "∀ {p : ℕ → Prop} (m : ℕ), (∀ n < m, ¬p n) → p m → p m ∧ ∀ m_1 < m, ¬p m_1",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Grind.CommRing.Poly.pow",
   "Lean.Grind.CommRing.Poly.combine_k",
   "Nat.cast",
   "Lean.Grind.CommRing.Poly.ofVar",
   "Neg.neg",
   "Nat.beq",
   "Lean.Grind.CommRing.Poly.mul",
   "Lean.Grind.CommRing.Poly.ofMon",
   "HPow.hPow",
   "Lean.Grind.CommRing.Var",
   "OfNat.ofNat",
   "Lean.Grind.CommRing.Poly.mulConst_k"],
  "name": "Lean.Grind.CommRing.Expr.toPoly_k",
  "constType": "Grind.CommRing.Expr → Grind.CommRing.Poly",
  "constCategory": "Definition"},
 {"references":
  ["HAdd.hAdd",
   "Lean.Grind.Order.lt_le_trans",
   "LT.lt",
   "LE.le",
   "Lean.Grind.OrderedAdd.add_le_left",
   "Lean.Grind.OrderedAdd.add_lt_right"],
  "name": "_private.Init.Grind.Order.0.Lean.Grind.Order.add_lt_add_of_le_of_lt",
  "constType":
  "∀ {α : Type u_1} [inst : LE α] [inst_1 : LT α] [LawfulOrderLT α] [inst_3 : Std.IsPreorder α] [inst_4 : Grind.Ring α]\n  [Grind.OrderedRing α] {a b c d : α}, a ≤ b → c < d → a + c < b + d",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "HAdd.hAdd",
   "Lean.Grind.Nat.lt_eq",
   "Eq.substr",
   "List.take",
   "LE.le",
   "HSub.hSub",
   "OfNat.ofNat",
   "List.length"],
  "name": "CellularAutomatas.PrefixStableProof.getLastOfTake._proof_1_2",
  "constType":
  "∀ {i : ℕ} {α : Type u_1} {w : List α},\n  (List.take (i + 1) w).length - 1 + 1 ≤ (List.take (i + 1) w).length →\n    (List.take (i + 1) w).length - 1 < (List.take (i + 1) w).length",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "Nat.le_refl._simp_1",
   "Eq.trans",
   "ite",
   "eq_true",
   "ite_cond_eq_true",
   "ite_cond_eq_false",
   "congrArg",
   "of_eq_true",
   "Min.min",
   "eq_false",
   "LE.le",
   "dite"],
  "name": "Nat.min_le_right",
  "constType": "∀ (a b : ℕ), min a b ≤ b",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CellularAutomatas.Alphabet",
  "constType": "Type → Type",
  "constCategory": "Other"},
 {"references": [],
  "name": "CellularAutomatas.simulation.Params.f",
  "constType":
  "(self : CellularAutomatas.simulation.Params) → self.C_ctl.Q → Option self.C_inr.Q",
  "constCategory": "Definition"},
 {"references": ["Neg.neg", "Int.natAbs", "Int.blt'", "OfNat.ofNat"],
  "name": "Lean.Grind.CommRing.denoteInt",
  "constType": "{α : Type u_1} → [Grind.Ring α] → ℤ → α",
  "constCategory": "Definition"},
 {"references": ["Bool.casesOn"],
  "name": "Bool.noConfusionType",
  "constType": "Sort u → Bool → Bool → Sort u",
  "constCategory": "Definition"},
 {"references":
  ["rfl",
   "Int.toNat",
   "LE.le",
   "OfNat.ofNat",
   "_private.Init.Data.Int.Lemmas.0.Int.toNat_of_nonpos.match_1_1"],
  "name": "Int.toNat_of_nonpos",
  "constType": "∀ {z : ℤ}, z ≤ 0 → z.toNat = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "Eq.trans",
   "Classical.propDecidable",
   "iff_true",
   "eq_true",
   "eq_iff_iff._simp_1",
   "iff_false",
   "congrArg",
   "eq_self",
   "of_eq_true",
   "iff_self",
   "congr",
   "eq_false",
   "not_true_eq_false",
   "dite"],
  "name": "Lean.Grind.iff_eq",
  "constType": "∀ (p q : Prop), (p ↔ q) = (p = q)",
  "constCategory": "Theorem"},
 {"references":
  ["Int.Linear.le_unsat",
   "Eq.trans",
   "eagerReduce",
   "eq_true",
   "Int.Linear.eq_def",
   "HMul.hMul",
   "ite_cond_eq_true",
   "IntCast.intCast",
   "GT.gt",
   "CellularAutomatas.tCellAutomaton.toLCellAutomaton",
   "Nat.ToInt.natCast_ofNat",
   "CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "CellularAutomatas.LCellAutomaton.scan_temporal_rt",
   "NatCast.natCast",
   "HSub.hSub",
   "Eq.symm",
   "Neg.neg",
   "Int.Linear.diseq_unsat",
   "Int.Linear.eq_diseq_subst",
   "Lean.Grind.not_not",
   "CellularAutomatas.LCellAutomaton.comp",
   "eq_false",
   "Classical.byContradiction",
   "Int.Linear.not_eq_norm_expr",
   "id",
   "Lean.Grind.Order.eq_trans_true",
   "Nat.ToInt.of_eq",
   "List.length",
   "Int.Linear.norm_le",
   "Lean.Grind.not_and",
   "Int.Linear.natCast_sub",
   "Eq.mp",
   "Int.Linear.Expr.eq_of_norm_eq",
   "Int.Linear.eq_eq_subst'",
   "congrArg",
   "Lean.Grind.Nat.lt_eq",
   "Int.Linear.eq_norm_expr",
   "Lean.Grind.nestedDecidable",
   "Nat.ToInt.of_diseq",
   "CellularAutomatas.CellAutomaton.Q",
   "Int.Linear.eq_of_core",
   "Not",
   "CellularAutomatas.Word",
   "Lean.Grind.em",
   "Lean.Grind.alreadyNorm",
   "Lean.Grind.Order.eq_trans_true'",
   "ite",
   "Lean.Grind.Order.le_eq_true_of_le_k",
   "Nat.ToInt.add_congr",
   "OfNat.ofNat",
   "ite_congr",
   "Or.casesOn",
   "HAdd.hAdd",
   "LT.lt",
   "Nat.ToInt.le_eq",
   "of_eq_true",
   "Nat.ToInt.toNat_nonneg",
   "LE.le",
   "Int.Linear.eq_le_subst_nonneg",
   "List.length_nil",
   "Lean.Grind.Semiring.natCast",
   "Lean.Grind.intro_with_eq",
   "Lean.Grind.CommRing.le_norm_expr",
   "Lean.Grind.Semiring.natCast_eq_ofNat",
   "Lean.Grind.Order.eq_mp"],
  "name": "CellularAutomatas.LcInRt.scan_temporal_get_last._proof_1_1",
  "constType":
  "∀ {α : Type} {C : CellularAutomatas.tCellAutomaton α} (w : CellularAutomatas.Word α) (n : ℕ),\n  List.length w = n + 1 →\n    List.length w > 0 →\n      List.length (C.scan_temporal_rt w) = List.length w →\n        List.length (C.scan_temporal_rt w) > 0 → ¬w = [] ∧ C.comp w (List.length w - 1) 0 = C.comp w n 0",
  "constCategory": "Theorem"},
 {"references": ["Subtype.forall", "propext"],
  "name": "Subtype.forall._simp_1",
  "constType":
  "∀ {α : Sort u} {p : α → Prop} {q : { a // p a } → Prop}, (∀ (x : { a // p a }), q x) = ∀ (a : α) (b : p a), q ⟨a, b⟩",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Lean.Kernel.Environment.header",
  "constType": "Kernel.Environment → EnvironmentHeader",
  "constCategory": "Definition"},
 {"references":
  ["id", "CellularAutomatas.tCellAutomatonWithAdvice.noConfusion"],
  "name": "CellularAutomatas.tCellAutomatonWithAdvice.mk.noConfusion",
  "constType":
  "{α : Type} →\n  (P : Sort u) →\n    (Γ : Type) →\n      [alphabetΓ : CellularAutomatas.Alphabet Γ] →\n        (adv : CellularAutomatas.Advice α Γ) →\n          (C : CellularAutomatas.tCellAutomaton (α ⨉ Γ)) →\n            (Γ' : Type) →\n              (alphabetΓ' : CellularAutomatas.Alphabet Γ') →\n                (adv' : CellularAutomatas.Advice α Γ') →\n                  (C' : CellularAutomatas.tCellAutomaton (α ⨉ Γ')) →\n                    { Γ := Γ, alphabetΓ := alphabetΓ, adv := adv, C := C } =\n                        { Γ := Γ', alphabetΓ := alphabetΓ', adv := adv', C := C' } →\n                      (Γ = Γ' → alphabetΓ ≍ alphabetΓ' → adv ≍ adv' → C ≍ C' → P) → P",
  "constCategory": "Definition"},
 {"references": ["Not", "not_not_intro", "Decidable.of_not_not"],
  "name": "Decidable.not_not",
  "constType": "∀ {p : Prop} [Decidable p], ¬¬p ↔ p",
  "constCategory": "Theorem"},
 {"references": ["Lean.Grind.AC.Var"],
  "name": "Lean.Grind.AC.Seq.casesOn",
  "constType":
  "{motive : Grind.AC.Seq → Sort u} →\n  (t : Grind.AC.Seq) →\n    ((x : Grind.AC.Var) → motive (Grind.AC.Seq.var x)) →\n      ((x : Grind.AC.Var) → (s : Grind.AC.Seq) → motive (Grind.AC.Seq.cons x s)) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Grind.Order.eq_trans_false",
   "Eq.trans",
   "Lean.Grind.Order.of_nat_eq",
   "eagerReduce",
   "HMul.hMul",
   "eq_true",
   "ite_cond_eq_true",
   "IntCast.intCast",
   "Lean.Grind.Order.le_of_offset_eq_2_k",
   "Nat.ToInt.natCast_ofNat",
   "Lean.Grind.Order.int_lt",
   "NatCast.natCast",
   "HSub.hSub",
   "Eq.symm",
   "of_eq_false",
   "List.drop",
   "Neg.neg",
   "Lean.Grind.Order.le_of_eq_2_k",
   "Lean.Grind.Order.le_of_offset_eq_1_k",
   "CellularAutomatas.PrefixStableProof.getLastOfTake._proof_1_17",
   "id",
   "Lean.Grind.Order.le_trans_k",
   "Lean.Grind.Order.le_eq_false_of_le_k",
   "Lean.Grind.Order.eq_trans_true",
   "List.length",
   "Int.Linear.norm_le",
   "Int.Linear.natCast_sub",
   "Eq.mp",
   "Lean.Grind.Order.le_of_eq_1_k",
   "Int.Linear.Expr.eq_of_norm_eq",
   "List.length_take",
   "min_def",
   "congrArg",
   "Lean.Grind.nestedDecidable",
   "Lean.Grind.Order.eq_of_le_of_le_0",
   "Lean.Grind.Order.lt_of_not_le_k",
   "Not",
   "ite",
   "Lean.Grind.Order.eq_trans_true'",
   "Nat.ToInt.add_congr",
   "Lean.Grind.Order.le_eq_true_of_le_k",
   "Lean.Grind.Order.eq_mp_not",
   "OfNat.ofNat",
   "ite_congr",
   "HAdd.hAdd",
   "Nat.ToInt.le_eq",
   "of_eq_true",
   "Lean.Grind.CommRing.Expr.eq_of_toPoly_eq",
   "Min.min",
   "List.take",
   "LE.le",
   "Lean.Grind.Semiring.natCast",
   "Lean.Grind.CommRing.le_norm_expr",
   "Lean.Grind.Semiring.natCast_eq_ofNat",
   "Lean.Grind.Order.eq_mp"],
  "name": "CellularAutomatas.PrefixStableProof.getLastOfTake._proof_1_27",
  "constType":
  "∀ {i : ℕ} {α : Type u_1} {w : List α},\n  i + 1 ≤ w.length →\n    -1 * ↑(List.take 1 w⟦i..*⟧).length + 1 ≤ 0 →\n      ¬-1 * ↑(List.take i w).length + 1 ≤ 0 →\n        -1 * ↑(List.take (i + 1) w).length + 1 ≤ 0 →\n          (List.take (i + 1) w).length - ((List.take (List.take i w).length w).length + 1) <\n            (List.take (List.take 1 w⟦i..*⟧).length w⟦(List.take i w).length..*⟧).length",
  "constCategory": "Theorem"},
 {"references": ["eq_false", "And.left"],
  "name": "false_and",
  "constType": "∀ (p : Prop), (False ∧ p) = False",
  "constCategory": "Theorem"},
 {"references":
  ["neg_eq_zero_sub", "Neg.neg", "HSub.hSub", "Eq.symm", "OfNat.ofNat"],
  "name": "zero_sub",
  "constType": "∀ {G : Type u_1} [inst : SubNegMonoid G] (a : G), 0 - a = -a",
  "constCategory": "Theorem"},
 {"references": ["Nat.cast", "Int.ofNat_le", "LE.le", "propext"],
  "name": "Int.ofNat_le._simp_1",
  "constType": "∀ {m n : ℕ}, (↑m ≤ ↑n) = (m ≤ n)",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Nat.iterate",
   "Eq.trans",
   "of_eq_true",
   "Function.iterate_succ_apply'",
   "congrArg"],
  "name": "CellularAutomatas.apply_iterated_succ_apply'",
  "constType":
  "∀ {n : ℕ} {α : Type u} {m : α} {f : α → α},\n  CellularAutomatas.apply_iterated f m (n + 1) = f (CellularAutomatas.apply_iterated f m n)",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Data.AC.Context.eval_norm",
   "Lean.Data.AC.evalList",
   "Eq.mp",
   "LawfulBEq.eq_of_beq",
   "Lean.Data.AC.norm",
   "BEq.beq",
   "Lean.Data.AC.eval",
   "congrArg"],
  "name": "Lean.Data.AC.Context.eq_of_norm",
  "constType":
  "∀ {α : Sort u_1} (ctx : Data.AC.Context α) (a b : Data.AC.Expr),\n  (Data.AC.norm ctx a == Data.AC.norm ctx b) = true → Data.AC.eval α ctx a = Data.AC.eval α ctx b",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "SizeOf.sizeOf",
   "CellularAutomatas.CellAutomaton.Q",
   "OfNat.ofNat"],
  "name": "CellularAutomatas.LCellAutomaton.mk.sizeOf_spec",
  "constType":
  "∀ {α : Type} [inst : SizeOf α] (toCellAutomaton : CellularAutomatas.CellAutomaton) (embed : α → toCellAutomaton.Q)\n  (border : toCellAutomaton.Q),\n  sizeOf { toCellAutomaton := toCellAutomaton, embed := embed, border := border } =\n    1 + sizeOf toCellAutomaton + sizeOf border",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Grind.CommRing.Poly.mul.go",
   "Lean.Grind.Ring.intCast",
   "Eq.trans",
   "HMul.hMul",
   "Lean.Grind.CommRing.Poly.denote_mul_go",
   "Int.cast",
   "OfNat.ofNat",
   "congrArg",
   "HAdd.hAdd",
   "eq_self",
   "of_eq_true",
   "Lean.Grind.AddCommMonoid.zero_add",
   "Lean.Grind.Ring.intCast_zero",
   "Lean.Grind.CommRing.Poly.denote",
   "Lean.Grind.CommRing.Context"],
  "name": "Lean.Grind.CommRing.Poly.denote_mul",
  "constType":
  "∀ {α : Type u_1} [inst : Grind.CommRing α] (ctx : Grind.CommRing.Context α) (p₁ p₂ : Grind.CommRing.Poly),\n  Grind.CommRing.Poly.denote ctx (p₁.mul p₂) = Grind.CommRing.Poly.denote ctx p₁ * Grind.CommRing.Poly.denote ctx p₂",
  "constCategory": "Theorem"},
 {"references": ["rfl", "Nat.cast"],
  "name": "Int.natCast_succ",
  "constType": "∀ (n : ℕ), ↑n.succ = ↑n + 1",
  "constCategory": "Theorem"},
 {"references":
  ["List.getElem_map",
   "Not",
   "CellularAutomatas.Word",
   "Eq.trans",
   "List.map",
   "GetElem.getElem",
   "List.length_map",
   "congrArg",
   "Prod.fst",
   "LT.lt",
   "eq_self",
   "Decidable.byContradiction",
   "Fin.val",
   "of_eq_true",
   "Fin.val_lt_of_le",
   "LE.le",
   "id",
   "CellularAutomatas.Word.fst_len",
   "CellularAutomatas.Word.fst",
   "CellularAutomatas.Word.get_fst._proof_1",
   "Eq.ndrec",
   "le_refl._simp_1",
   "List.length"],
  "name": "CellularAutomatas.Word.get_fst",
  "constType":
  "∀ {α β : Type} (w : CellularAutomatas.Word (α ⨉ β)) (t : Fin (List.length w)), w.fst[t] = w[t].1",
  "constCategory": "Theorem"},
 {"references": ["CellularAutomatas.t_2n", "CellularAutomatas.CA"],
  "name": "CellularAutomatas.CA_2n",
  "constType": "(α : Type) → Set (CellularAutomatas.tCellAutomaton α)",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CellularAutomatas.backwards_fsm.Params",
  "constType": "Type 1",
  "constCategory": "Other"},
 {"references":
  ["Lean.Grind.Ring.intCast_mul",
   "Lean.Grind.Ring.intCast",
   "Eq.trans",
   "Lean.Grind.Ring.intCast_one",
   "Nat.recAux",
   "HMul.hMul",
   "Lean.Grind.Semiring.pow_zero",
   "HPow.hPow",
   "Int.cast",
   "Int.pow_zero",
   "OfNat.ofNat",
   "congrArg",
   "Int.pow_succ",
   "HAdd.hAdd",
   "eq_self",
   "of_eq_true",
   "Lean.Grind.Semiring.pow_succ",
   "congr"],
  "name": "Lean.Grind.Ring.intCast_pow",
  "constType":
  "∀ {α : Type u} [inst : Grind.Ring α] (x : ℤ) (k : ℕ), ↑(x ^ k) = ↑x ^ k",
  "constCategory": "Theorem"},
 {"references": ["CellularAutomatas.simulation.Q1._sizeOf_1"],
  "name": "CellularAutomatas.simulation.Q1._sizeOf_inst",
  "constType":
  "(e : CellularAutomatas.simulation.Params) → SizeOf (CellularAutomatas.simulation.Q1 e)",
  "constCategory": "Definition"},
 {"references":
  ["Nat.cast",
   "Int.add_assoc",
   "Eq.trans",
   "Neg.neg",
   "Int.add_zero",
   "OfNat.ofNat",
   "congrArg",
   "Int.add_right_neg",
   "HAdd.hAdd",
   "eq_self",
   "of_eq_true",
   "Int.add_comm",
   "HSub.hSub",
   "id",
   "Eq.symm",
   "Int.le.intro_sub",
   "Eq.mpr"],
  "name": "Int.le.intro",
  "constType": "∀ {a b : ℤ} (n : ℕ), a + ↑n = b → a ≤ b",
  "constCategory": "Theorem"},
 {"references": ["False.elim", "eq_true"],
  "name": "false_implies",
  "constType": "∀ (p : Prop), (False → p) = True",
  "constCategory": "Theorem"},
 {"references": ["Not", "dite"],
  "name": "Decidable.not_or_of_imp",
  "constType": "∀ {a b : Prop} [Decidable a], (a → b) → ¬a ∨ b",
  "constCategory": "Theorem"},
 {"references": ["CellularAutomatas.LCellAutomaton._sizeOf_1"],
  "name": "CellularAutomatas.LCellAutomaton._sizeOf_inst",
  "constType":
  "(α : Type) → [SizeOf α] → SizeOf (CellularAutomatas.LCellAutomaton α)",
  "constCategory": "Definition"},
 {"references": ["LE.le", "Int.negSucc_not_nonneg", "OfNat.ofNat", "propext"],
  "name": "Int.negSucc_not_nonneg._simp_1",
  "constType": "∀ (n : ℕ), (0 ≤ Int.negSucc n) = False",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.Word.get'",
   "CellularAutomatas.Word",
   "Set",
   "Membership.mem",
   "CellularAutomatas.Word.range",
   "Eq.ndrec"],
  "name": "CellularAutomatas.Word.get'.congr_simp",
  "constType":
  "∀ {α : Type u} (w w_1 : CellularAutomatas.Word α) (e_w : w = w_1) (i i_1 : ℤ) (e_i : i = i_1) (h : i ∈ w.range),\n  w.get' i h = w_1.get' i_1 ⋯",
  "constCategory": "Theorem"},
 {"references": ["HAdd.hAdd", "Nat.casesOn", "OfNat.ofNat"],
  "name": "Nat.casesAuxOn",
  "constType":
  "{motive : ℕ → Sort u} → (t : ℕ) → motive 0 → ((n : ℕ) → motive (n + 1)) → motive t",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CellularAutomatas.composition.Params.α",
  "constType": "CellularAutomatas.composition.Params → Type",
  "constCategory": "Definition"},
 {"references": ["List.zipWith"],
  "name": "List.zip",
  "constType": "{α : Type u} → {β : Type v} → List α → List β → List (α ⨉ β)",
  "constCategory": "Definition"},
 {"references":
  ["False.elim", "Nat.cast", "Int.ctorIdx", "noConfusion_of_Nat", "Eq.casesOn"],
  "name": "_private.Init.Data.Int.Order.0.Int.negSucc_lt_zero.match_1_1",
  "constType":
  "∀ (n w : ℕ) (motive : Int.negSucc n = ↑w → Prop) (h : Int.negSucc n = ↑w), motive h",
  "constCategory": "Definition"},
 {"references":
  ["implies_congr",
   "CellularAutomatas.Word.get'",
   "not_lt._simp_1",
   "Eq.trans",
   "zero_sub",
   "Membership.mem",
   "GE.ge",
   "CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "CellularAutomatas.LCellAutomaton.scan_temporal_rt",
   "dif_pos",
   "False.elim",
   "List.map_take",
   "List.mem_range",
   "funext",
   "Eq.symm",
   "HSub.hSub",
   "CellularAutomatas.Word.range",
   "dif_neg",
   "not_and._simp_1",
   "HAppend.hAppend",
   "CellularAutomatas.LCellAutomaton.scan_temporal_independence._proof_1_3",
   "Neg.neg",
   "List.map",
   "CellularAutomatas.LCellAutomaton.comp",
   "List.length_append",
   "zero_add",
   "id",
   "Eq.mpr",
   "setOf",
   "List.length",
   "CellularAutomatas.Word.get'._proof_1",
   "Int.toNat",
   "Nat.cast",
   "Eq.mp",
   "min_eq_left",
   "CellularAutomatas.LCellAutomaton.scan_temporal",
   "List.getElem_append_left",
   "congrArg",
   "CellularAutomatas.LCellAutomaton.embed",
   "le_add_iff_nonneg_right._simp_4",
   "zero_le._simp_4",
   "List.get",
   "congr",
   "CellularAutomatas.LCellAutomaton.embed_word",
   "CellularAutomatas.CellAutomaton.Q",
   "CellularAutomatas.LCellAutomaton.border",
   "ge_iff_le._simp_1",
   "propext",
   "Not",
   "List.take_range",
   "CellularAutomatas.Word",
   "Set",
   "CellularAutomatas.LCellAutomaton.scan_temporal_independence._proof_1_2",
   "OfNat.ofNat",
   "Nat.cast_add",
   "LT.lt",
   "HAdd.hAdd",
   "List.range",
   "of_eq_true",
   "Min.min",
   "List.take",
   "LE.le",
   "_private.CellularAutomatas.proofs.cart_transducers.0.CellularAutomatas.list_map_congr",
   "CellularAutomatas.nextt_congr",
   "dite",
   "Fin.isLt"],
  "name": "CellularAutomatas.LCellAutomaton.scan_temporal_independence",
  "constType":
  "∀ {α : Type} [CellularAutomatas.Alphabet α] (C : CellularAutomatas.LCellAutomaton α) (p s : CellularAutomatas.Word α),\n  List.take (List.length p) (C.scan_temporal_rt (p ++ s)) = C.scan_temporal_rt p",
  "constCategory": "Theorem"},
 {"references":
  ["Neg.neg", "Lean.Omega.Constraint.map", "Lean.Omega.Constraint.flip"],
  "name": "Lean.Omega.Constraint.neg",
  "constType": "Omega.Constraint → Omega.Constraint",
  "constCategory": "Definition"},
 {"references": [],
  "name": "outParam",
  "constType": "Sort u → Sort u",
  "constCategory": "Definition"},
 {"references":
  ["ite",
   "_private.Lean.Environment.0.Lean.VisibilityMap.private",
   "_private.Lean.Environment.0.Lean.VisibilityMap.public",
   "Lean.Environment.isExporting"],
  "name": "_private.Lean.Environment.0.Lean.VisibilityMap.get",
  "constType": "{α : Type} → Lean.VisibilityMap✝ α → Environment → α",
  "constCategory": "Definition"},
 {"references": ["Nat.succ_le_succ", "Nat.zero_le", "OfNat.ofNat"],
  "name": "Nat.zero_lt_succ",
  "constType": "∀ (n : ℕ), 0 < n.succ",
  "constCategory": "Theorem"},
 {"references": ["rfl", "Option.map"],
  "name": "Option.map_some",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} (a : α) (f : α → β), Option.map f (some a) = some (f a)",
  "constCategory": "Theorem"},
 {"references": ["Set.univ"],
  "name": "CellularAutomatas.tCellAutomatons",
  "constType": "(α : Type) → Set (CellularAutomatas.tCellAutomaton α)",
  "constCategory": "Definition"},
 {"references":
  ["rfl",
   "HAppend.hAppend",
   "CellularAutomatas.Word",
   "CellularAutomatas.FiniteStateTransducer.scanr_foldr_state",
   "List.foldr_append",
   "CellularAutomatas.FiniteStateTransducer.scanr_q",
   "CellularAutomatas.FiniteStateTransducer.Q",
   "Prod.snd",
   "List.foldr",
   "congrArg",
   "Prod.fst",
   "CellularAutomatas.FiniteStateTransducer.scanr_reduce_q",
   "CellularAutomatas.FiniteStateTransducer.scanr_step",
   "id",
   "Eq.mpr",
   "CellularAutomatas.FiniteStateTransducer.scanr_foldr_cons"],
  "name": "CellularAutomatas.FiniteStateTransducer.scanr_q_append",
  "constType":
  "∀ {α β : Type} {M : CellularAutomatas.FiniteStateTransducer α β} (p s : CellularAutomatas.Word α) (q : M.Q),\n  M.scanr_q q (p ++ s) = M.scanr_q (M.scanr_reduce_q q s) p ++ M.scanr_q q s",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Omega.IntList",
   "Lean.Omega.IntList.set.match_1",
   "Nat.below",
   "Nat.brecOn",
   "OfNat.ofNat",
   "Unit"],
  "name": "Lean.Omega.IntList.set",
  "constType": "Omega.IntList → ℕ → ℤ → Omega.IntList",
  "constCategory": "Definition"},
 {"references":
  ["implies_congr",
   "Int.Linear.Poly.coeff",
   "Int.Linear.Poly.beq'",
   "Eq.trans",
   "Eq.mp",
   "Int.neg_le_zero_iff._simp_1",
   "Int.Linear.Poly.denote'_eq_denote",
   "and_imp._simp_1",
   "Int.mul_comm",
   "Int.mul_le_mul_of_nonpos_left",
   "Int.zero_add",
   "Int.Linear.Poly.denote",
   "Int.Linear.Poly.denote_combine_mul_k",
   "HMul.hMul",
   "congrArg",
   "Bool.and",
   "congr",
   "Eq.symm",
   "Int.ble'_eq_true",
   "Int.Linear.Poly.denote'",
   "Int.neg_mul",
   "Eq.ndrec",
   "Bool.and'_eq_and",
   "Neg.neg",
   "Int.ble'",
   "OfNat.ofNat",
   "Int.mul_zero",
   "HAdd.hAdd",
   "Int.Linear.Poly.combine_mul_k",
   "Int.Linear.Context",
   "LE.le",
   "id",
   "Int.Linear.Poly.beq'_eq",
   "Eq.mpr",
   "Bool.and_eq_true",
   "Int.Linear.eq_le_subst_nonpos_cert",
   "Bool.and'",
   "Int.Linear.Var"],
  "name": "Int.Linear.eq_le_subst_nonpos",
  "constType":
  "∀ (ctx : Int.Linear.Context) (x : Int.Linear.Var) (p₁ p₂ p₃ : Int.Linear.Poly),\n  Int.Linear.eq_le_subst_nonpos_cert x p₁ p₂ p₃ = true →\n    Int.Linear.Poly.denote' ctx p₁ = 0 → Int.Linear.Poly.denote' ctx p₂ ≤ 0 → Int.Linear.Poly.denote' ctx p₃ ≤ 0",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.Linear.Context",
   "Nat.Linear.Expr.toPoly",
   "Eq.trans",
   "Eq.mp",
   "Nat.zero_add",
   "Nat.add_comm",
   "Nat.Linear.Expr.denote_toPoly",
   "OfNat.ofNat",
   "Nat.Linear.Var",
   "Nat.Linear.Poly",
   "congrArg",
   "HAdd.hAdd",
   "Nat.Linear.Expr.toNormPoly",
   "Nat.Linear.Expr.denote",
   "Nat.Linear.Poly.norm.go",
   "congr",
   "Nat.Linear.Poly.denote",
   "LawfulBEq.eq_of_beq",
   "Nat.Linear.Poly.denote_norm_go",
   "BEq.beq"],
  "name": "Nat.Linear.Expr.eq_of_toNormPoly_eq",
  "constType":
  "∀ (ctx : Nat.Linear.Context) (e e' : Nat.Linear.Expr),\n  (e.toNormPoly == e'.toPoly) = true → Nat.Linear.Expr.denote ctx e = Nat.Linear.Expr.denote ctx e'",
  "constCategory": "Theorem"},
 {"references": ["Bool.casesOn", "Unit.unit", "Unit"],
  "name": "List.filter.match_1",
  "constType":
  "(motive : Bool → Sort u_1) → (x : Bool) → (Unit → motive true) → (Unit → motive false) → motive x",
  "constCategory": "Definition"},
 {"references": ["_private.Init.Data.Subtype.Basic.0.Subtype.forall.match_1_1"],
  "name": "Subtype.forall",
  "constType":
  "∀ {α : Sort u} {p : α → Prop} {q : { a // p a } → Prop}, (∀ (x : { a // p a }), q x) ↔ ∀ (a : α) (b : p a), q ⟨a, b⟩",
  "constCategory": "Theorem"},
 {"references": ["Nonempty.elim"],
  "name": "forall_const",
  "constType":
  "∀ {b : Prop} (α : Sort u_1) [i : Nonempty α], (∀ (a : α), b) ↔ b",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Int.natAbs_negOfNat",
   "of_eq_true",
   "Int.negOfNat",
   "Eq.symm",
   "id",
   "HMul.hMul",
   "Int.casesOn",
   "Eq.mpr",
   "Int.natAbs",
   "Eq.ndrec",
   "congrArg"],
  "name": "Int.natAbs_mul",
  "constType": "∀ (a b : ℤ), (a * b).natAbs = a.natAbs * b.natAbs",
  "constCategory": "Theorem"},
 {"references":
  ["HAppend.hAppend",
   "List.append_nil",
   "List.drop",
   "Eq.mp",
   "List.take",
   "LE.le",
   "List.drop_of_length_le",
   "List.take_append_drop",
   "congrArg",
   "List.length"],
  "name": "List.take_of_length_le",
  "constType":
  "∀ {α : Type u_1} {i : ℕ} {l : List α}, l.length ≤ i → List.take i l = l",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Grind.Ring.zsmul_eq_intCast_mul",
   "Lean.Grind.Ring.intCast",
   "Eq.trans",
   "Lean.Grind.CommRing.Mon.denote",
   "Lean.Grind.Ring.intCast_one",
   "HMul.hMul",
   "Lean.Grind.AddCommMonoid.add_zero",
   "Lean.Grind.Semiring.one_mul",
   "Int.cast",
   "OfNat.ofNat",
   "congrArg",
   "HAdd.hAdd",
   "eq_self",
   "of_eq_true",
   "congr",
   "Lean.Grind.Ring.intCast_zero",
   "HSMul.hSMul",
   "Lean.Grind.Ring.zsmul",
   "Lean.Grind.CommRing.Context"],
  "name": "Lean.Grind.CommRing.Poly.denote_ofMon",
  "constType":
  "∀ {α : Type u_1} [inst : Grind.Ring α] (ctx : Grind.CommRing.Context α) (m : Grind.CommRing.Mon),\n  Grind.CommRing.Poly.denote ctx (Grind.CommRing.Poly.ofMon m) = Grind.CommRing.Mon.denote ctx m",
  "constCategory": "Theorem"},
 {"references":
  ["HAppend.hAppend",
   "List.drop",
   "List.getElem_append_left",
   "GetElem.getElem",
   "List.getElem_of_eq",
   "List.take_append_drop",
   "List.length_take",
   "LT.lt",
   "Nat.lt_min",
   "Min.min",
   "List.take",
   "Iff.mpr",
   "Eq.symm",
   "List.length"],
  "name": "List.getElem_take'",
  "constType":
  "∀ {α : Type u_1} {xs : List α} {i j : ℕ} (hi : i < xs.length) (hj : i < j), xs[i] = (List.take j xs)[i]",
  "constCategory": "Theorem"},
 {"references": ["Eq.mp", "Eq.mpr", "propext"],
  "name": "implies_dep_congr_ctx",
  "constType":
  "∀ {p₁ p₂ q₁ : Prop}, p₁ = p₂ → ∀ {q₂ : p₂ → Prop}, (∀ (h : p₂), q₁ = q₂ h) → (p₁ → q₁) = ∀ (h : p₂), q₂ h",
  "constCategory": "Theorem"},
 {"references": ["Preorder.le_trans"],
  "name": "le_trans",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] {a b c : α}, a ≤ b → b ≤ c → a ≤ c",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "Int.Linear.Var.denote",
   "Int.Linear.Poly.brecOn",
   "Int.Linear.Context",
   "Int.Linear.Poly.denote.match_1",
   "HMul.hMul",
   "Int.Linear.Var",
   "Int.Linear.Poly.below"],
  "name": "Int.Linear.Poly.denote",
  "constType": "Int.Linear.Context → Int.Linear.Poly → ℤ",
  "constCategory": "Definition"},
 {"references":
  ["CellularAutomatas.Word", "Set", "CellularAutomatas.Word.cone"],
  "name": "CellularAutomatas.Word.cone.eq_1",
  "constType":
  "∀ {α : Type u_1} (w : CellularAutomatas.Word α) (t : ℕ), w.cone t = {i | -↑t ≤ i ∧ i < ↑(List.length w) + ↑t}",
  "constCategory": "Theorem"},
 {"references":
  ["Option.ctorIdx", "Ne", "Nat.ne_of_beq_eq_false", "OfNat.ofNat"],
  "name": "Lean.Omega.Constraint.isImpossible._sparseCasesOn_1",
  "constType":
  "{α : Type u} →\n  {motive : Option α → Sort u_1} →\n    (t : Option α) → ((val : α) → motive (some val)) → (t.ctorIdx ≠ 1 → motive t) → motive t",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Lean.Grind.AddCommGroup.neg_add_cancel",
  "constType":
  "∀ {M : Type u} [self : Grind.AddCommGroup M] (a : M), -a + a = 0",
  "constCategory": "Theorem"},
 {"references":
  ["sorryAx",
   "CellularAutomatas.Advice.exp_middle",
   "CellularAutomatas.Advice.is_two_stage_advice",
   "OfNat.ofNat"],
  "name": "CellularAutomatas.results_unproven.exp_middle_two_stage_advice",
  "constType":
  "∀ {α : Type} [inst : CellularAutomatas.Alphabet α], (CellularAutomatas.Advice.exp_middle α).is_two_stage_advice",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.simulation.Params.C_ctl",
   "CellularAutomatas.CellAutomaton.Q",
   "CellularAutomatas.simulation.Q1.mk.noConfusion",
   "OfNat.ofNat"],
  "name": "CellularAutomatas.simulation.Q1.mk.inj",
  "constType":
  "∀ {e : CellularAutomatas.simulation.Params} {state : e.C_ctl.Q} {counter : Fin 3} {state_1 : e.C_ctl.Q}\n  {counter_1 : Fin 3},\n  { state := state, counter := counter } = { state := state_1, counter := counter_1 } →\n    state = state_1 ∧ counter = counter_1",
  "constCategory": "Theorem"},
 {"references": ["Int.le_refl", "LE.le", "eq_true"],
  "name": "Int.le_refl._simp_1",
  "constType": "∀ (a : ℤ), (a ≤ a) = True",
  "constCategory": "Theorem"},
 {"references": ["List.below", "List.brecOn", "List.concat.match_1"],
  "name": "List.concat",
  "constType": "{α : Type u} → List α → α → List α",
  "constCategory": "Definition"},
 {"references": ["CellularAutomatas.backwards_fsm.Params.mk.noConfusion"],
  "name": "CellularAutomatas.backwards_fsm.Params.mk.inj",
  "constType":
  "∀ {α β γ : Type} {inst1 : CellularAutomatas.Alphabet α} {inst2 : CellularAutomatas.Alphabet β}\n  {inst3 : CellularAutomatas.Alphabet γ} {M : CellularAutomatas.FiniteStateTransducer α β}\n  {C : CellularAutomatas.CArtTransducer β γ} {α_1 β_1 γ_1 : Type} {inst1_1 : CellularAutomatas.Alphabet α_1}\n  {inst2_1 : CellularAutomatas.Alphabet β_1} {inst3_1 : CellularAutomatas.Alphabet γ_1}\n  {M_1 : CellularAutomatas.FiniteStateTransducer α_1 β_1} {C_1 : CellularAutomatas.CArtTransducer β_1 γ_1},\n  { α := α, β := β, γ := γ, inst1 := inst1, inst2 := inst2, inst3 := inst3, M := M, C := C } =\n      { α := α_1, β := β_1, γ := γ_1, inst1 := inst1_1, inst2 := inst2_1, inst3 := inst3_1, M := M_1, C := C_1 } →\n    α = α_1 ∧ β = β_1 ∧ γ = γ_1 ∧ inst1 ≍ inst1_1 ∧ inst2 ≍ inst2_1 ∧ inst3 ≍ inst3_1 ∧ M ≍ M_1 ∧ C ≍ C_1",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.tCellAutomaton.p",
   "Set",
   "Membership.mem",
   "CellularAutomatas.tCellAutomatons",
   "OfNat.ofNat",
   "setOf"],
  "name": "CellularAutomatas.CA",
  "constType": "(α : Type) → Set (CellularAutomatas.tCellAutomaton α)",
  "constCategory": "Definition"},
 {"references": ["Lean.Name.mkStr1", "Lean.Name.mkStr3", "OfNat.ofNat"],
  "name": "CellularAutomatas.Word.«term_⟦_.._⟧»",
  "constType": "TrailingParserDescr",
  "constCategory": "Definition"},
 {"references": ["Nat.cast", "LE.le", "HSub.hSub", "Iff.mp", "Int.nonneg_def"],
  "name": "Int.le.dest_sub",
  "constType": "∀ {a b : ℤ}, a ≤ b → ∃ n, b - a = ↑n",
  "constCategory": "Theorem"},
 {"references": ["CellularAutomatas.FiniteStateTransducer.M_map"],
  "name": "CellularAutomatas.FiniteStateTransducer.M_map.eq_1",
  "constType":
  "∀ {α β : Type} [inst : CellularAutomatas.Alphabet α] [inst_1 : CellularAutomatas.Alphabet β] (f : α → β),\n  CellularAutomatas.FiniteStateTransducer.M_map f =\n    { Q := α, alphabetQ := inst, δ := fun x a => a, q0 := default, f := f }",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Omega.Coeffs",
   "Lean.Omega.Constraint.not_sat_of_isImpossible",
   "Lean.Omega.Constraint.isImpossible",
   "Lean.Omega.Coeffs.dot"],
  "name": "Lean.Omega.Constraint.not_sat'_of_isImpossible",
  "constType":
  "∀ {c : Omega.Constraint}, c.isImpossible = true → ∀ {x y : Omega.Coeffs}, ¬c.sat' x y = true",
  "constCategory": "Theorem"},
 {"references": ["CellularAutomatas.t_lt", "CellularAutomatas.OCAr"],
  "name": "CellularAutomatas.OCAr_lt",
  "constType": "(α : Type) → Set (CellularAutomatas.tCellAutomaton α)",
  "constCategory": "Definition"},
 {"references":
  ["AddLECancellable.add_tsub_cancel_right",
   "Contravariant.AddLECancellable",
   "AddLeftReflectLE"],
  "name": "add_tsub_cancel_right",
  "constType":
  "∀ {α : Type u_1} [inst : PartialOrder α] [inst_1 : AddCommSemigroup α] [inst_2 : Sub α] [OrderedSub α]\n  [AddLeftReflectLE α] (a b : α), a + b - b = a",
  "constCategory": "Theorem"},
 {"references":
  ["Int.mul_add",
   "Eq.trans",
   "Lean.Omega.IntList.dot_of_left_zero",
   "Lean.Omega.LinearCombo.coeffs",
   "Int.mul_comm",
   "Int.zero_add",
   "HMul.hMul",
   "Lean.Omega.Coeffs",
   "Int.add_zero",
   "Lean.Omega.LinearCombo.const",
   "congrArg",
   "Lean.Omega.IntList",
   "congr",
   "HSub.hSub",
   "Int.add_sub_cancel",
   "Lean.Omega.IntList.dot",
   "Neg.neg",
   "Lean.Omega.IntList.dot_smul_left",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "Int.mul_zero",
   "eq_self",
   "of_eq_true",
   "Lean.Omega.Coeffs.isZero",
   "Lean.Omega.Coeffs.dot_distrib_left",
   "Lean.Omega.IntList.add_nil",
   "Lean.Omega.Coeffs.sub_eq_add_neg",
   "Lean.Omega.Coeffs.dot"],
  "name": "Lean.Omega.LinearCombo.mul_eval_of_const_left",
  "constType":
  "∀ (l₁ l₂ : Omega.LinearCombo) (v : Omega.Coeffs), l₁.coeffs.isZero → (l₁.mul l₂).eval v = l₁.eval v * l₂.eval v",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.propIntro",
   "Int.Linear.Poly.num.noConfusion",
   "Eq.symm",
   "Eq.ndrec",
   "Eq.casesOn"],
  "name": "Int.Linear.Poly.num.injEq",
  "constType":
  "∀ (k k_1 : ℤ), (Int.Linear.Poly.num k = Int.Linear.Poly.num k_1) = (k = k_1)",
  "constCategory": "Theorem"},
 {"references": ["Classical.propDecidable", "Decidable.not_and_iff_not_or_not"],
  "name": "not_and_or",
  "constType": "∀ {a b : Prop}, ¬(a ∧ b) ↔ ¬a ∨ ¬b",
  "constCategory": "Theorem"},
 {"references": ["Classical.em"],
  "name": "Lean.Grind.em",
  "constType": "∀ (p : Prop), Grind.alreadyNorm p ∨ Grind.alreadyNorm ¬p",
  "constCategory": "Theorem"},
 {"references": ["Subtype.casesOn"],
  "name": "_private.Init.Data.Subtype.Basic.0.Subtype.forall.match_1_1",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} (motive : { a // p a } → Prop) (x : { a // p a }),\n  (∀ (a : α) (b : p a), motive ⟨a, b⟩) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["CellularAutomatas.ℒ",
   "sorryAx",
   "Set",
   "CellularAutomatas.CA_rt",
   "Language",
   "OfNat.ofNat",
   "CellularAutomatas.OCAr_lt"],
  "name": "CellularAutomatas.results_unproven.ocar_lt_eq_ca_rt",
  "constType":
  "∀ {α : Type} [CellularAutomatas.Alphabet α],\n  CellularAutomatas.ℒ (CellularAutomatas.OCAr_lt α) = CellularAutomatas.ℒ (CellularAutomatas.CA_rt α)",
  "constCategory": "Theorem"},
 {"references": ["Prod.casesOn", "Option.casesOn", "Lean.Omega.Coeffs"],
  "name": "_private.Init.Omega.Constraint.0.Lean.Omega.tidy?.match_1.splitter",
  "constType":
  "(motive : Option (Omega.Constraint ⨉ Omega.Coeffs) → Sort u_1) →\n  (x : Option (Omega.Constraint ⨉ Omega.Coeffs)) →\n    motive none → ((s' : Omega.Constraint) → (x' : Omega.Coeffs) → motive (some (s', x'))) → motive x",
  "constCategory": "Definition"},
 {"references": ["ZeroLEOneClass.zero_le_one"],
  "name": "zero_le_one",
  "constType":
  "∀ {α : Type u_1} [inst : Zero α] [inst_1 : One α] [inst_2 : LE α] [ZeroLEOneClass α], 0 ≤ 1",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "Eq.trans",
   "Lean.Grind.Order.of_nat_eq",
   "eagerReduce",
   "HMul.hMul",
   "eq_true",
   "ite_cond_eq_true",
   "IntCast.intCast",
   "List.getLast?_append",
   "Nat.ToInt.natCast_ofNat",
   "List.getLast?",
   "Lean.Grind.Order.int_lt",
   "GetElem?.getElem?",
   "False.elim",
   "NatCast.natCast",
   "Lean.Grind.eq_false_of_imp_eq_true",
   "Eq.symm",
   "HSub.hSub",
   "CellularAutomatas.PrefixStableProof.getLastOfTake._proof_1_8",
   "forall_prop_domain_congr",
   "Lean.Grind.forall_propagator",
   "HAppend.hAppend",
   "of_eq_false",
   "List.drop",
   "getElem?_pos",
   "Neg.neg",
   "Lean.Grind.Order.le_of_eq_2_k",
   "Lean.Grind.Order.le_of_offset_eq_1_k",
   "List.take_add",
   "Lean.Grind.nestedProof",
   "eq_false",
   "id",
   "Lean.Grind.Order.le_trans_k",
   "Lean.Grind.Order.eq_trans_false'",
   "Lean.Grind.Order.eq_trans_true",
   "getElem?_neg",
   "List.length",
   "Int.Linear.norm_le",
   "Eq.substr",
   "Option.some_or",
   "Int.Linear.natCast_sub",
   "Eq.mp",
   "noConfusion_of_Nat",
   "GetElem.getElem",
   "Nat.Linear.ExprCnstr.eq_of_toNormPoly_eq",
   "List.length_take",
   "Int.Linear.Expr.eq_of_norm_eq",
   "min_def",
   "congrArg",
   "Lean.Grind.Nat.lt_eq",
   "Option.or",
   "Nat.not_le_eq",
   "Lean.Grind.nestedDecidable",
   "CellularAutomatas.PrefixStableProof.getLastOfTake._proof_1_3",
   "List.getLast?_eq_getElem?",
   "Lean.Grind.Order.lt_of_not_le_k",
   "Not",
   "Lean.Grind.Order.eq_trans_true'",
   "ite",
   "Lean.Grind.Order.le_eq_true_of_le_k",
   "Nat.ToInt.add_congr",
   "Lean.Grind.Order.eq_mp_not",
   "OfNat.ofNat",
   "ite_congr",
   "HAdd.hAdd",
   "LT.lt",
   "Nat.ToInt.le_eq",
   "of_eq_true",
   "Min.min",
   "Lean.Grind.CommRing.Expr.eq_of_toPoly_eq",
   "List.take",
   "LE.le",
   "Lean.Grind.Semiring.natCast",
   "CellularAutomatas.PrefixStableProof.getLastOfTake._proof_1_5",
   "Lean.Grind.CommRing.le_norm_expr",
   "Lean.Grind.Semiring.natCast_eq_ofNat",
   "Lean.Grind.Order.eq_mp"],
  "name": "CellularAutomatas.PrefixStableProof.getLastOfTake._proof_1_9",
  "constType":
  "∀ {i : ℕ} {α : Type u_1} {w : List α},\n  i + 1 ≤ w.length → -1 * ↑(List.take 1 w⟦i..*⟧).length + 1 ≤ 0 → (List.take (i + 1) w).length - 1 < w.length",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.CellAutomaton.next",
   "CellularAutomatas.CellAutomaton.Q",
   "CellularAutomatas.Config"],
  "name": "CellularAutomatas.CellAutomaton.next.eq_1",
  "constType":
  "∀ (C : CellularAutomatas.CellAutomaton) (c : CellularAutomatas.Config C.Q) (p : ℤ),\n  C.next c p = C.δ (c (p - 1)) (c p) (c (p + 1))",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.PrettyPrinter.UnexpandM",
   "Lean.TSyntax.raw",
   "EStateM",
   "Lean.Name.mkStr3",
   "Lean.Syntax.isOfKind",
   "Lean.MonadQuotation.getCurrMacroScope",
   "Lean.MacroScope",
   "Lean.Syntax.matchesNull",
   "Lean.MonadRef.mkInfoFromRefPos",
   "Lean.MonadQuotation.getContext",
   "Unit.unit",
   "MonadExcept.throw",
   "Lean.Name.mkStr4",
   "Bind.bind",
   "Lean.SyntaxNodeKind",
   "Lean.Name.mkStr1",
   "ite",
   "Bool.or",
   "Lean.Syntax.node3",
   "cond",
   "OfNat.ofNat",
   "Unit",
   "Lean.Syntax.getArg",
   "Pure.pure",
   "Lean.withRef"],
  "name":
  "CellularAutomatas.FiniteStateTransducer._aux_CellularAutomatas_proofs_finite_state_transducers___unexpand_CellularAutomatas_FiniteStateTransducer_comp_1",
  "constType": "PrettyPrinter.Unexpander",
  "constCategory": "Definition"},
 {"references":
  ["Int.Linear.Poly.beq'", "Int.Linear.Poly.mul_k", "Neg.neg", "OfNat.ofNat"],
  "name": "Int.Linear.eq_of_le_ge_cert",
  "constType": "Int.Linear.Poly → Int.Linear.Poly → Bool",
  "constCategory": "Definition"},
 {"references":
  ["Or.elim",
   "Lean.Omega.LinearCombo.coordinate_eval_2",
   "Nat.cast",
   "Eq.trans",
   "le_of_le_of_eq",
   "Lean.Omega.LinearCombo.coordinate_eval_0",
   "Lean.Omega.Constraint.combine_sat'",
   "Int.sub_eq_zero_of_eq",
   "GE.ge",
   "Decidable.decide",
   "Lean.Omega.LinearCombo.neg_eval",
   "Lean.Omega.Coeffs.ofList",
   "Lean.Omega.Int.ofNat_sub_dichotomy",
   "HSub.hSub",
   "Lean.Omega.tidy_sat",
   "Eq.symm",
   "Lean.Omega.LinearCombo.add_eval",
   "Lean.Omega.Int.neg_congr",
   "Int.add_one_le_of_lt",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "And.left",
   "of_decide_eq_true",
   "Not",
   "Int.lt_or_gt_of_ne",
   "Neg.neg",
   "And.right",
   "Lean.Omega.Constraint.addInequality_sat",
   "Lean.Omega.Int.add_congr",
   "Lean.Omega.Constraint.isImpossible",
   "Lean.Omega.LinearCombo.coordinate",
   "Int.sub_nonneg_of_le",
   "OfNat.ofNat",
   "Lean.Omega.LinearCombo.coordinate_eval_1",
   "LT.lt",
   "HAdd.hAdd",
   "Lean.Omega.Int.ofNat_lt_of_lt",
   "Lean.Omega.LinearCombo.sub_eval",
   "Nat.lt_of_not_le",
   "LE.le",
   "Int.natCast_add",
   "id",
   "Lean.Omega.Constraint.addEquality_sat",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.Int.sub_congr"],
  "name":
  "_private.Init.Grind.Ring.Basic.0.Lean.Grind.Ring.intCast_add._proof_1_4",
  "constType":
  "∀ (x y : ℕ), ¬x ≥ y + 1 → ¬↑x + -↑(y + 1) = -↑(y + 1 - x) → False",
  "constCategory": "Theorem"},
 {"references": ["Eq.symm", "trivial"],
  "name": "of_eq_true",
  "constType": "∀ {p : Prop}, p = True → p",
  "constCategory": "Theorem"},
 {"references": ["AddSemigroup.add_assoc"],
  "name": "add_assoc",
  "constType":
  "∀ {G : Type u_1} [inst : AddSemigroup G] (a b c : G), a + b + c = a + (b + c)",
  "constCategory": "Theorem"},
 {"references": ["Int.casesOn"],
  "name": "_private.Init.Data.Int.Lemmas.0.Int.add_comm.match_1_1",
  "constType":
  "∀ (motive : ℤ → ℤ → Prop) (x x_1 : ℤ),\n  (∀ (n m : ℕ), motive (Int.ofNat n) (Int.ofNat m)) →\n    (∀ (a a_1 : ℕ), motive (Int.ofNat a) (Int.negSucc a_1)) →\n      (∀ (a a_1 : ℕ), motive (Int.negSucc a) (Int.ofNat a_1)) →\n        (∀ (a a_1 : ℕ), motive (Int.negSucc a) (Int.negSucc a_1)) → motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["CellularAutomatas.FiniteStateTransducer.scanr_step.match_1",
   "CellularAutomatas.FiniteStateTransducer.Q",
   "CellularAutomatas.FiniteStateTransducer.f",
   "CellularAutomatas.FiniteStateTransducer.δ"],
  "name": "CellularAutomatas.FiniteStateTransducer.scanr_step",
  "constType":
  "{α β : Type} → (M : CellularAutomatas.FiniteStateTransducer α β) → α → M.Q ⨉ List β → M.Q ⨉ List β",
  "constCategory": "Definition"},
 {"references": ["CellularAutomatas.Word", "Eq.ndrec", "List.length"],
  "name": "CellularAutomatas.Advice.mk.congr_simp",
  "constType":
  "∀ {α Γ : Type} (f f_1 : CellularAutomatas.Word α → CellularAutomatas.Word Γ) (e_f : f = f_1)\n  (len : ∀ (w : CellularAutomatas.Word α), List.length (f w) = List.length w),\n  { f := f, len := len } = { f := f_1, len := ⋯ }",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd", "Lean.Grind.OrderedAdd.add_le_left_iff", "LE.le", "Iff.mp"],
  "name": "Lean.Grind.OrderedAdd.add_le_left",
  "constType":
  "∀ {M : Type u} [inst : LE M] [inst_1 : Std.IsPreorder M] [inst_2 : Grind.AddCommMonoid M] [Grind.OrderedAdd M]\n  {a b : M}, a ≤ b → ∀ (c : M), a + c ≤ b + c",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Omega.LinearCombo.coordinate_eval_2",
   "Nat.cast",
   "Eq.trans",
   "le_of_le_of_eq",
   "Lean.Omega.Constraint.combine_sat'",
   "Lean.Omega.LinearCombo.coordinate_eval_0",
   "Decidable.decide",
   "Lean.Omega.Coeffs.ofList",
   "Lean.Omega.tidy_sat",
   "HSub.hSub",
   "Eq.symm",
   "Lean.Omega.LinearCombo.add_eval",
   "Lean.Omega.Int.lt_of_not_le",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "Int.add_one_le_of_lt",
   "of_decide_eq_true",
   "Not",
   "Neg.neg",
   "And.right",
   "Lean.Omega.Constraint.addInequality_sat",
   "Lean.Omega.Int.add_congr",
   "Lean.Omega.Constraint.isImpossible",
   "Lean.Omega.LinearCombo.coordinate",
   "OfNat.ofNat",
   "Int.sub_nonneg_of_le",
   "Lean.Omega.LinearCombo.coordinate_eval_1",
   "HAdd.hAdd",
   "Lean.Omega.LinearCombo.sub_eval",
   "LE.le",
   "Int.natCast_add",
   "id",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.Int.sub_congr"],
  "name": "CellularAutomatas.nextt_congr._proof_1_8",
  "constType":
  "∀ (t : ℕ) (i j : ℤ), i - ↑t ≤ j ∧ j ≤ i + ↑t → ¬j ≤ i + ↑(t + 1) → False",
  "constCategory": "Theorem"},
 {"references": ["Int.beq'", "OfNat.ofNat", "Int.Linear.Var"],
  "name": "Int.Linear.Poly.isUnsatDiseq_k",
  "constType": "Int.Linear.Poly → Bool",
  "constCategory": "Definition"},
 {"references": ["Nat.Linear.Expr.brecOn.go", "Nat.Linear.Expr.below"],
  "name": "Nat.Linear.Expr.brecOn",
  "constType":
  "{motive : Nat.Linear.Expr → Sort u} →\n  (t : Nat.Linear.Expr) → ((t : Nat.Linear.Expr) → Nat.Linear.Expr.below t → motive t) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "id",
   "CellularAutomatas.CellAutomaton.Q",
   "CellularAutomatas.CArtTransducer.noConfusion"],
  "name": "CellularAutomatas.CArtTransducer.mk.noConfusion",
  "constType":
  "{α Γ : Type} →\n  [inst : CellularAutomatas.Alphabet α] →\n    [inst_1 : CellularAutomatas.Alphabet Γ] →\n      (P : Sort u) →\n        (toLCellAutomaton : CellularAutomatas.LCellAutomaton α) →\n          (f : toLCellAutomaton.Q → Γ) →\n            (toLCellAutomaton' : CellularAutomatas.LCellAutomaton α) →\n              (f' : toLCellAutomaton'.Q → Γ) →\n                { toLCellAutomaton := toLCellAutomaton, f := f } = { toLCellAutomaton := toLCellAutomaton', f := f' } →\n                  (toLCellAutomaton = toLCellAutomaton' → f ≍ f' → P) → P",
  "constCategory": "Definition"},
 {"references": ["Not", "Decidable.not_and_iff_or_not", "Iff.mp"],
  "name": "Lean.Omega.Decidable.or_not_not_of_not_and",
  "constType": "∀ {p q : Prop} [Decidable p] [Decidable q], ¬(p ∧ q) → ¬p ∨ ¬q",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Lean.ConstructorVal.toConstantVal",
  "constType": "ConstructorVal → ConstantVal",
  "constCategory": "Definition"},
 {"references":
  ["Int.mul_le_mul_of_nonneg_left",
   "Int.mul_comm",
   "LE.le",
   "id",
   "HMul.hMul",
   "Eq.mpr",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Int.mul_le_mul_of_nonneg_right",
  "constType": "∀ {a b c : ℤ}, a ≤ b → 0 ≤ c → a * c ≤ b * c",
  "constCategory": "Theorem"},
 {"references": ["Int.neg_add_cancel_right"],
  "name": "Int.sub_add_cancel",
  "constType": "∀ (a b : ℤ), a - b + b = a",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.Word",
   "Eq.trans",
   "CellularAutomatas.marker_list",
   "CellularAutomatas.Advice.from_len_marker",
   "List.map",
   "OfNat.ofNat",
   "congrArg",
   "CellularAutomatas.Advice.f",
   "HAdd.hAdd",
   "List.range",
   "eq_self",
   "of_eq_true",
   "funext",
   "id",
   "BEq.beq",
   "List.length"],
  "name": "CellularAutomatas.from_len_marker_eq_marker_list",
  "constType":
  "∀ {α : Type} (f : ℕ → Option ℕ) (w : CellularAutomatas.Word α) (k : ℕ),\n  f (List.length w) = some k →\n    (CellularAutomatas.Advice.from_len_marker f).f w = CellularAutomatas.marker_list (List.length w) k",
  "constCategory": "Theorem"},
 {"references":
  ["HAppend.hAppend",
   "Eq.trans",
   "List.reverse_append",
   "List.getLast?",
   "congrArg",
   "_private.Init.Data.List.Lemmas.0.List.getLast?_append._simp_1_1",
   "Option.or",
   "eq_self",
   "of_eq_true",
   "List.reverse",
   "congr",
   "List.head?",
   "List.head?_append"],
  "name": "List.getLast?_append",
  "constType":
  "∀ {α : Type u_1} {l l' : List α}, (l ++ l').getLast? = l'.getLast?.or l.getLast?",
  "constCategory": "Theorem"},
 {"references": ["Or.casesOn", "LT.lt"],
  "name": "_private.Init.Data.Nat.Basic.0.Nat.lt_trichotomy.match_1_1",
  "constType":
  "∀ (a b : ℕ) (motive : b = a ∨ b < a → Prop) (x : b = a ∨ b < a),\n  (∀ (h : b = a), motive ⋯) → (∀ (h : b < a), motive ⋯) → motive x",
  "constCategory": "Definition"},
 {"references": ["SubNegMonoid.sub_eq_add_neg"],
  "name": "sub_eq_add_neg",
  "constType":
  "∀ {G : Type u_1} [inst : SubNegMonoid G] (a b : G), a - b = a + -b",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.Word",
   "CellularAutomatas.LCellAutomaton.scan_temporal",
   "OfNat.ofNat",
   "List.length"],
  "name": "CellularAutomatas.LCellAutomaton.scan_temporal_rt",
  "constType":
  "{α : Type} → (C : CellularAutomatas.LCellAutomaton α) → CellularAutomatas.Word α → CellularAutomatas.Word C.Q",
  "constCategory": "Definition"},
 {"references": ["Int.Linear.Poly.norm", "Int.Linear.Expr.toPoly'"],
  "name": "Int.Linear.Expr.norm",
  "constType": "Int.Linear.Expr → Int.Linear.Poly",
  "constCategory": "Definition"},
 {"references":
  ["_private.Init.Prelude.0.noConfusion_of_Nat.aux.match_1_1",
   "Nat.beq",
   "Nat.below",
   "Nat.brecOn",
   "Unit"],
  "name": "_private.Init.Prelude.0.noConfusion_of_Nat.aux",
  "constType": "∀ (a : ℕ), Bool.rec False True (a.beq a)",
  "constCategory": "Theorem"},
 {"references": ["eq_true", "Iff.rfl"],
  "name": "iff_self",
  "constType": "∀ (p : Prop), (p ↔ p) = True",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.Word",
   "Eq.trans",
   "CellularAutomatas.CellAutomaton.next",
   "CellularAutomatas.CellAutomaton.nextt",
   "CellularAutomatas.LCellAutomaton.comp",
   "CellularAutomatas.LCellAutomaton.nextt_succ_eq",
   "OfNat.ofNat",
   "congrArg",
   "CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "HAdd.hAdd",
   "eq_self",
   "of_eq_true",
   "funext",
   "CellularAutomatas.LCellAutomaton.embed_word",
   "CellularAutomatas.CellAutomaton.Q"],
  "name": "CellularAutomatas.LCellAutomaton.comp_succ_eq",
  "constType":
  "∀ {α : Type} {w : CellularAutomatas.Word α} {t : ℕ} (C : CellularAutomatas.LCellAutomaton α),\n  C.comp w (t + 1) = C.next (C.comp w t)",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "Eq.trans",
   "Eq.mp",
   "ite",
   "eq_true",
   "ite_cond_eq_true",
   "min_def",
   "Lean.Grind.nestedDecidable",
   "Min.min",
   "eq_false",
   "LE.le",
   "Classical.byContradiction",
   "id",
   "Eq.symm"],
  "name": "_private.Mathlib.Order.Defs.LinearOrder.0.min_eq_left._proof_1_1",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrder α] {a b : α}, a ≤ b → min a b = a",
  "constCategory": "Theorem"},
 {"references": ["Lean.Omega.Coeffs", "Lean.Omega.IntList.smul"],
  "name": "Lean.Omega.Coeffs.smul",
  "constType": "Omega.Coeffs → ℤ → Omega.Coeffs",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Omega.LinearCombo.coordinate_eval_2",
   "Eq.trans",
   "le_of_le_of_eq",
   "Lean.Omega.LinearCombo.coordinate_eval_0",
   "Lean.Omega.Constraint.combine_sat'",
   "Decidable.decide",
   "Lean.Omega.Coeffs.ofList",
   "HSub.hSub",
   "Lean.Omega.tidy_sat",
   "Eq.symm",
   "Lean.Omega.LinearCombo.add_eval",
   "Lean.Omega.Int.lt_of_not_le",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "Int.add_one_le_of_lt",
   "of_decide_eq_true",
   "Not",
   "Neg.neg",
   "Lean.Omega.Constraint.addInequality_sat",
   "Lean.Omega.Int.add_congr",
   "Lean.Omega.Constraint.isImpossible",
   "Lean.Omega.LinearCombo.coordinate",
   "OfNat.ofNat",
   "Int.sub_nonneg_of_le",
   "Lean.Omega.LinearCombo.coordinate_eval_1",
   "HAdd.hAdd",
   "LT.lt",
   "Lean.Omega.LinearCombo.sub_eval",
   "LE.le",
   "id",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.Int.sub_congr"],
  "name": "_private.Init.Grind.Order.0.Lean.Grind.Order.int_lt._proof_1_1",
  "constType": "∀ {x y k : ℤ}, x < y + k → ¬x ≤ y + (k - 1) → False",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Grind.AC.Var", "Lean.Grind.AC.Var.denote", "Lean.Grind.AC.Context.op"],
  "name": "Lean.Grind.AC.Expr.denote",
  "constType": "{α : Sort u_1} → Grind.AC.Context α → Grind.AC.Expr → α",
  "constCategory": "Definition"},
 {"references":
  ["HAdd.hAdd",
   "LT.lt",
   "Nat.cast",
   "Fin.intCast",
   "Neg.neg",
   "ite",
   "CellularAutomatas.speedup_factor_k.Q'",
   "LE.le",
   "HSub.hSub",
   "CellularAutomatas.CellAutomaton.Q",
   "OfNat.ofNat"],
  "name": "CellularAutomatas.speedup_factor_k.local_config",
  "constType":
  "(k : ℕ) →\n  [NeZero k] →\n    (C : CellularAutomatas.CellAutomaton) →\n      CellularAutomatas.speedup_factor_k.Q' k C →\n        CellularAutomatas.speedup_factor_k.Q' k C →\n          CellularAutomatas.speedup_factor_k.Q' k C → CellularAutomatas.Config C.Q",
  "constCategory": "Definition"},
 {"references":
  ["Nat.not_lt_zero._simp_1",
   "exists_eq_left'._simp_1",
   "Eq.trans",
   "false_and",
   "Eq.mp",
   "noConfusion_of_Nat",
   "GetElem.getElem",
   "congrArg",
   "GetElem?.getElem?",
   "Option.ctorIdx",
   "not_false_eq_true",
   "False.elim",
   "iff_self",
   "exists_and_left._simp_1",
   "exists_false._simp_1",
   "congr",
   "forall_congr",
   "funext",
   "List.zipWith_nil_right",
   "Eq.symm",
   "Eq.ndrec",
   "propext",
   "Nat.casesAuxOn",
   "Not",
   "Nat.lt_irrefl._simp_1",
   "getElem?_pos",
   "List.casesOn",
   "eq_false'",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "Option.some.injEq",
   "LT.lt",
   "of_eq_true",
   "id",
   "and_false",
   "List.zipWith",
   "Nat.zero_lt_succ._simp_1",
   "getElem?_neg",
   "List.length"],
  "name": "List.getElem?_zipWith_eq_some",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} {f : α → β → γ} {l₁ : List α} {l₂ : List β} {z : γ} {i : ℕ},\n  (List.zipWith f l₁ l₂)[i]? = some z ↔ ∃ x y, l₁[i]? = some x ∧ l₂[i]? = some y ∧ f x y = z",
  "constCategory": "Theorem"},
 {"references": ["Lean.Name.mkStr1", "Lean.Name.mkStr2", "OfNat.ofNat"],
  "name": "CellularAutomatas.«term_⊗_»",
  "constType": "TrailingParserDescr",
  "constCategory": "Definition"},
 {"references":
  ["Eq.trans",
   "le_of_le_of_eq",
   "Lean.Omega.Constraint.combine_sat'",
   "Lean.Omega.LinearCombo.coordinate_eval_0",
   "Decidable.decide",
   "Lean.Omega.Coeffs.ofList",
   "Lean.Omega.tidy_sat",
   "HSub.hSub",
   "Eq.symm",
   "Lean.Omega.LinearCombo.add_eval",
   "Int.add_one_le_of_lt",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "of_decide_eq_true",
   "Not",
   "Neg.neg",
   "Lean.Omega.Constraint.addInequality_sat",
   "Lean.Omega.Int.add_congr",
   "Lean.Omega.Constraint.isImpossible",
   "Lean.Omega.Int.le_of_not_lt",
   "Lean.Omega.LinearCombo.coordinate",
   "OfNat.ofNat",
   "Int.sub_nonneg_of_le",
   "HAdd.hAdd",
   "LT.lt",
   "Lean.Omega.LinearCombo.coordinate_eval_1",
   "Lean.Omega.LinearCombo.sub_eval",
   "id",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.Int.sub_congr"],
  "name":
  "_private.Init.Grind.Order.0.Lean.Grind.Order.lt_eq_true_of_le_k._proof_1_1",
  "constType": "∀ {k₁ k₂ : ℤ}, k₁ < k₂ → ¬0 < k₂ - k₁ → False",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.CellAutomaton.quiescent",
   "CellularAutomatas.CellAutomaton.Q"],
  "name": "CellularAutomatas.CellAutomaton.quiescent.eq_1",
  "constType":
  "∀ (C : CellularAutomatas.CellAutomaton) (q : C.Q), C.quiescent q = C.quiescent_set {q}",
  "constCategory": "Theorem"},
 {"references": ["Function.Commute.iterate_right", "Function.Commute.refl"],
  "name": "Function.Commute.self_iterate",
  "constType": "∀ {α : Type u} (f : α → α) (n : ℕ), Function.Commute f f^[n]",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CellularAutomatas.CellAutomaton.ctorIdx",
  "constType": "CellularAutomatas.CellAutomaton → ℕ",
  "constCategory": "Definition"},
 {"references": ["Id"],
  "name": "Id.run",
  "constType": "{α : Type u_1} → Id α → α",
  "constCategory": "Definition"},
 {"references":
  ["CellularAutomatas.FiniteStateTransducer.scanr_reduce_q",
   "eq_self",
   "CellularAutomatas.FiniteStateTransducer.M_prod",
   "CellularAutomatas.Word",
   "of_eq_true",
   "id",
   "CellularAutomatas.FiniteStateTransducer.Q",
   "Eq.mpr",
   "congrArg",
   "CellularAutomatas.FiniteStateTransducer.δ"],
  "name":
  "_private.CellularAutomatas.proofs.finite_state_transducers.0.CellularAutomatas.FiniteStateTransducer.m_prod_scanr_reduce_q",
  "constType":
  "∀ {α β1 β2 : Type} [inst : CellularAutomatas.Alphabet α] {M1 : CellularAutomatas.FiniteStateTransducer α β1}\n  {M2 : CellularAutomatas.FiniteStateTransducer α β2} (q1 : M1.Q) (q2 : M2.Q) (w : CellularAutomatas.Word α),\n  (M1.M_prod M2).scanr_reduce_q (q1, q2) w = (M1.scanr_reduce_q q1 w, M2.scanr_reduce_q q2 w)",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.not_le_of_gt", "LT.lt", "Not", "LE.le", "Nat.ge_of_not_lt", "flip"],
  "name": "Nat.not_lt",
  "constType": "∀ {a b : ℕ}, ¬a < b ↔ b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.FiniteStateTransducer.M_prod.match_1",
   "CellularAutomatas.FiniteStateTransducer.Q",
   "CellularAutomatas.FiniteStateTransducer.q0",
   "CellularAutomatas.FiniteStateTransducer.f",
   "CellularAutomatas.FiniteStateTransducer.δ"],
  "name": "CellularAutomatas.FiniteStateTransducer.M_prod",
  "constType":
  "{α β1 β2 : Type} →\n  [CellularAutomatas.Alphabet α] →\n    CellularAutomatas.FiniteStateTransducer α β1 →\n      CellularAutomatas.FiniteStateTransducer α β2 → CellularAutomatas.FiniteStateTransducer α (β1 ⨉ β2)",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "Eq.trans",
   "of_eq_true",
   "ite",
   "eq_true",
   "ite_cond_eq_true",
   "congrArg"],
  "name": "CellularAutomatas.ite_eq_of_true",
  "constType":
  "∀ {α : Sort u_1} {p : Prop} [inst : Decidable p], p → ∀ (a b : α), (if p then a else b) = a",
  "constCategory": "Theorem"},
 {"references":
  ["List.dedup",
   "Multiset.dedup._proof_1",
   "Setoid.r",
   "DecidableEq",
   "Quot.liftOn",
   "Multiset.ofList",
   "Multiset"],
  "name": "Multiset.dedup",
  "constType": "{α : Type u_1} → [DecidableEq α] → Multiset α → Multiset α",
  "constCategory": "Definition"},
 {"references":
  ["Inv.inv",
   "Units.mul_inv",
   "Units.inv_mul",
   "Iff.mp",
   "HMul.hMul",
   "OfNat.ofNat",
   "congrArg",
   "Units.val",
   "Nat.units_eq_one",
   "id",
   "Eq.symm",
   "Int.natAbs",
   "Eq.mpr",
   "Int.natAbs_mul",
   "Units.ext_iff"],
  "name": "Int.units_natAbs",
  "constType": "∀ (u : ℤˣ), (↑u).natAbs = 1",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.Linear.fixedVar",
   "Nat.Linear.Expr.brecOn",
   "id",
   "HMul.hMul",
   "Function.comp",
   "BEq.beq",
   "cond",
   "Nat.Linear.Expr.toPoly.go.match_1",
   "Nat.Linear.Expr.below",
   "Nat.Linear.Var",
   "OfNat.ofNat",
   "Nat.Linear.Poly"],
  "name": "Nat.Linear.Expr.toPoly.go",
  "constType": "ℕ → Nat.Linear.Expr → Nat.Linear.Poly → Nat.Linear.Poly",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CellularAutomatas.CellAutomaton.mk",
  "constType":
  "(Q : Type) → [alphabetQ : CellularAutomatas.Alphabet Q] → (Q → Q → Q → Q) → CellularAutomatas.CellAutomaton",
  "constCategory": "Other"},
 {"references":
  ["CellularAutomatas.simulation.Params.mk.noConfusion",
   "CellularAutomatas.CellAutomaton.Q"],
  "name": "CellularAutomatas.simulation.Params.mk.inj",
  "constType":
  "∀ {C_inr C_ctl : CellularAutomatas.CellAutomaton} {f : C_ctl.Q → Option C_inr.Q}\n  {C_inr_1 C_ctl_1 : CellularAutomatas.CellAutomaton} {f_1 : C_ctl_1.Q → Option C_inr_1.Q},\n  { C_inr := C_inr, C_ctl := C_ctl, f := f } = { C_inr := C_inr_1, C_ctl := C_ctl_1, f := f_1 } →\n    C_inr = C_inr_1 ∧ C_ctl = C_ctl_1 ∧ f ≍ f_1",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CellularAutomatas.simulation.Params.C_ctl",
  "constType":
  "CellularAutomatas.simulation.Params → CellularAutomatas.CellAutomaton",
  "constCategory": "Definition"},
 {"references":
  ["Std.HashMap.fold",
   "Lean.PersistentHashMap.foldl",
   "Lean.SMap.map₂",
   "Lean.SMap.map₁"],
  "name": "Lean.SMap.fold",
  "constType":
  "{α : Type u} → {β : Type v} → [inst : BEq α] → [inst_1 : Hashable α] → {σ : Type w} → (σ → α → β → σ) → σ → SMap α β → σ",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Grind.Semiring.ofNat_eq_natCast",
   "Lean.Grind.Ring.intCast_ofNat",
   "Lean.Grind.Ring.intCast",
   "Nat.cast",
   "id",
   "Eq.mpr",
   "Lean.Grind.Semiring.natCast",
   "Int.cast",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Lean.Grind.Ring.intCast_natCast",
  "constType": "∀ {α : Type u} [inst : Grind.Ring α] (n : ℕ), ↑↑n = ↑n",
  "constCategory": "Theorem"},
 {"references": ["Int.mul_assoc", "Eq.symm", "HMul.hMul"],
  "name":
  "_private.Init.Data.Int.Linear.0.Int.Linear.Poly.denote_combine_mul_k._simp_1_2",
  "constType": "∀ (a b c : ℤ), a * (b * c) = a * b * c",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CellularAutomatas.FiniteStateTransducer.Q",
  "constType":
  "{α β : Type} → CellularAutomatas.FiniteStateTransducer α β → Type",
  "constCategory": "Definition"},
 {"references": ["Std.DHashMap.Raw.fold", "Std.DHashMap.inner"],
  "name": "Std.DHashMap.fold",
  "constType":
  "{α : Type u} →\n  {β : α → Type v} → {δ : Type w} → {x : BEq α} → {x_1 : Hashable α} → (δ → (a : α) → β a → δ) → δ → DHashMap α β → δ",
  "constCategory": "Definition"},
 {"references":
  ["sorryAx",
   "Set",
   "Membership.mem",
   "CellularAutomatas.CA_rt",
   "CellularAutomatas.tCellAutomaton.L",
   "Subtype.val",
   "OfNat.ofNat",
   "CellularAutomatas.Advice.prefixes_in_L",
   "Set.Elem",
   "CellularAutomatas.Advice.rt_closed"],
  "name": "CellularAutomatas.results_unproven.advice_prefixes_in_L_rt_closed",
  "constType":
  "∀ {α : Type} [inst : CellularAutomatas.Alphabet α] (C : ↑(CellularAutomatas.CA_rt α)),\n  (CellularAutomatas.Advice.prefixes_in_L (↑C).L).rt_closed",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Prod.casesOn",
  "constType":
  "{α : Type u} →\n  {β : Type v} → {motive : α ⨉ β → Sort u_1} → (t : α ⨉ β) → ((fst : α) → (snd : β) → motive (fst, snd)) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "CellularAutomatas.LcInRt.DiagonalShiftCA",
   "HSub.hSub",
   "CellularAutomatas.CellAutomaton.Q",
   "CellularAutomatas.LcInRt.AdvCALc.match_1",
   "BEq.beq",
   "OfNat.ofNat",
   "Unit"],
  "name": "CellularAutomatas.LcInRt.AdvCALc",
  "constType":
  "{α : Type} →\n  [CellularAutomatas.Alphabet α] →\n    {Γ : Type} → [CellularAutomatas.Alphabet Γ] → Γ → CellularAutomatas.tCellAutomaton (α ⨉ Γ)",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Lean.Omega.IntList",
  "constType": "Type",
  "constCategory": "Definition"},
 {"references": ["le_rfl", "not_le_of_gt", "LT.lt"],
  "name": "lt_irrefl",
  "constType": "∀ {α : Type u_1} [inst : Preorder α] (a : α), ¬a < a",
  "constCategory": "Theorem"},
 {"references": ["namedPattern", "Lean.Name.casesOn"],
  "name": "_private.Lean.Data.Name.0.Lean.Name.isPrefixOf.match_1",
  "constType":
  "(motive : Name → Name → Sort u_1) →\n  (x x_1 : Name) →\n    ((p : Name) → motive p Name.anonymous) →\n      ((p n p' : Name) → (i : ℕ) → (h : n = p'.num i) → motive p (namedPattern n (p'.num i) h)) →\n        ((p n p' : Name) → (str : String) → (h : n = p'.str str) → motive p (namedPattern n (p'.str str) h)) →\n          motive x x_1",
  "constCategory": "Definition"},
 {"references": ["Int.Linear.Var"],
  "name": "Int.Linear.Expr.below",
  "constType":
  "{motive : Int.Linear.Expr → Sort u} → Int.Linear.Expr → Sort (max 1 u)",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Omega.Coeffs.dot_sdiv_left",
   "Nat.cast",
   "Lean.Omega.Constraint.sat",
   "Lean.Omega.Coeffs",
   "Lean.Omega.Coeffs.gcd_dvd_dot_left",
   "OfNat.ofNat",
   "congrArg",
   "HDiv.hDiv",
   "Int.dvd_refl",
   "id",
   "Ne",
   "Eq.mpr",
   "Lean.Omega.Constraint.div_sat",
   "Lean.Omega.Coeffs.dot",
   "Lean.Omega.Coeffs.sdiv",
   "Lean.Omega.Coeffs.gcd",
   "Lean.Omega.Constraint.sat'",
   "Lean.Omega.Constraint.div"],
  "name": "Lean.Omega.Constraint.div_sat'",
  "constType":
  "∀ {c : Omega.Constraint} {x y : Omega.Coeffs},\n  x.gcd ≠ 0 → c.sat (x.dot y) = true → (c.div x.gcd).sat' (x.sdiv ↑x.gcd) y = true",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "Int.Linear.le_unsat",
   "Eq.trans",
   "eagerReduce",
   "eq_true",
   "ite_cond_eq_true",
   "IntCast.intCast",
   "List.getLast?_append",
   "Nat.ToInt.natCast_ofNat",
   "List.getLast?",
   "Lean.Grind.Order.int_lt",
   "GetElem?.getElem?",
   "False.elim",
   "NatCast.natCast",
   "Eq.symm",
   "Lean.Grind.forall_propagator",
   "getElem?_pos",
   "List.take_add",
   "List.length_append",
   "eq_false",
   "Classical.byContradiction",
   "Lean.Grind.Order.le_trans_k",
   "Lean.Grind.Order.eq_trans_false'",
   "Lean.Grind.Order.eq_trans_true",
   "Int.Linear.eq_of_le_ge",
   "Int.Linear.norm_le",
   "Option.some_or",
   "noConfusion_of_Nat",
   "GetElem.getElem",
   "Nat.Linear.ExprCnstr.eq_of_toNormPoly_eq",
   "Lean.Grind.Order.le_of_eq_1_k",
   "min_def",
   "Option.or",
   "Lean.Grind.Nat.lt_eq",
   "Lean.Grind.nestedDecidable",
   "Int.Linear.eq_norm_expr",
   "Lean.Grind.Order.lt_of_not_le_k",
   "List.getElem?_take",
   "ite",
   "Lean.Grind.Order.eq_trans_true'",
   "Lean.Grind.Order.le_eq_true_of_le_k",
   "OfNat.ofNat",
   "ite_congr",
   "HAdd.hAdd",
   "Lean.Grind.CommRing.Expr.eq_of_toPoly_eq",
   "List.take",
   "Int.Linear.eq_le_subst_nonneg",
   "Lean.Grind.Semiring.natCast",
   "Lean.Grind.CommRing.le_norm_expr",
   "Lean.Grind.Order.of_nat_eq",
   "HMul.hMul",
   "Lean.Grind.eq_congr",
   "Lean.Grind.Order.le_of_offset_eq_2_k",
   "Lean.Grind.eq_false_of_imp_eq_true",
   "HSub.hSub",
   "Nat.Simproc.add_le_add_le",
   "forall_prop_domain_congr",
   "CellularAutomatas.PrefixStableProof.getLastOfTake._proof_1_1",
   "HAppend.hAppend",
   "of_eq_false",
   "List.drop",
   "Neg.neg",
   "Lean.Grind.Order.le_of_eq_2_k",
   "Lean.Grind.Order.le_of_offset_eq_1_k",
   "Lean.Grind.nestedProof",
   "Int.Linear.eq_le_subst_nonpos",
   "id",
   "getElem?_neg",
   "Nat.ToInt.of_eq",
   "List.length",
   "Eq.substr",
   "Int.Linear.natCast_sub",
   "Eq.mp",
   "Int.Linear.Expr.eq_of_norm_eq",
   "List.length_take",
   "Int.Linear.eq_eq_subst'",
   "Int.Linear.le_neg",
   "congrArg",
   "Option.ctorIdx",
   "Nat.not_le_eq",
   "CellularAutomatas.PrefixStableProof.getLastOfTake._proof_1_3",
   "Lean.Grind.Order.eq_of_le_of_le_0",
   "List.getLast?_eq_getElem?",
   "of_decide_eq_true",
   "Not",
   "Lean.Grind.em",
   "Lean.Grind.alreadyNorm",
   "Nat.ToInt.add_congr",
   "Lean.Grind.Order.eq_mp_not",
   "LT.lt",
   "Or.casesOn",
   "Nat.ToInt.le_eq",
   "Nat.ToInt.toNat_nonneg",
   "of_eq_true",
   "Min.min",
   "LE.le",
   "Lean.Grind.Order.nat_eq",
   "CellularAutomatas.PrefixStableProof.getLastOfTake._proof_1_5",
   "Lean.Grind.intro_with_eq",
   "Lean.Grind.Semiring.natCast_eq_ofNat",
   "Lean.Grind.Order.eq_mp"],
  "name": "CellularAutomatas.PrefixStableProof.getLastOfTake._proof_1_28",
  "constType":
  "∀ {i : ℕ} {α : Type u_1} {w : List α}, i < w.length → (List.take (i + 1) w).getLast? = w[i]?",
  "constCategory": "Theorem"},
 {"references":
  ["False.elim",
   "Nat.add",
   "Nat.ctorIdx",
   "List.casesOn",
   "noConfusion_of_Nat",
   "Eq.casesOn",
   "OfNat.ofNat",
   "List.length"],
  "name":
  "_private.Init.Data.List.Lemmas.0.List.eq_nil_of_length_eq_zero.match_1_1",
  "constType":
  "∀ {α : Type u_1} (motive : (l : List α) → l.length = 0 → Prop) (l : List α) (x : l.length = 0),\n  (∀ (x : [].length = 0), motive [] x) → motive l x",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Nat.Linear.Context",
  "constType": "Type",
  "constCategory": "Definition"},
 {"references": ["rfl", "Units.val", "OfNat.ofNat"],
  "name": "isUnit_one",
  "constType": "∀ {M : Type u_1} [inst : Monoid M], IsUnit 1",
  "constCategory": "Theorem"},
 {"references":
  ["GetElem?.getElem?", "getElem?_pos", "Eq.symm", "GetElem.getElem"],
  "name": "CellularAutomatas.LcInRt.DiagonalShiftCA_scan_temporal._simp_1_1",
  "constType":
  "∀ {cont : Type u_1} {idx : Type u_2} {elem : Type u_3} {dom : cont → idx → Prop} [inst : GetElem? cont idx elem dom]\n  [LawfulGetElem cont idx elem dom] (c : cont) (i : idx) (h : dom c i), some c[i] = c[i]?",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Omega.LinearCombo.coordinate_eval_2",
   "Nat.cast",
   "Eq.trans",
   "le_of_le_of_eq",
   "Lean.Omega.LinearCombo.coordinate_eval_0",
   "Lean.Omega.Constraint.combine_sat'",
   "Decidable.decide",
   "Lean.Omega.Coeffs.ofList",
   "HSub.hSub",
   "Lean.Omega.tidy_sat",
   "Eq.symm",
   "Lean.Omega.LinearCombo.add_eval",
   "Lean.Omega.Int.lt_of_not_le",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "Int.add_one_le_of_lt",
   "And.left",
   "of_decide_eq_true",
   "Not",
   "Neg.neg",
   "Lean.Omega.Constraint.addInequality_sat",
   "Lean.Omega.Int.add_congr",
   "Lean.Omega.Constraint.isImpossible",
   "Lean.Omega.LinearCombo.coordinate",
   "OfNat.ofNat",
   "Int.sub_nonneg_of_le",
   "Lean.Omega.LinearCombo.coordinate_eval_1",
   "HAdd.hAdd",
   "Lean.Omega.LinearCombo.sub_eval",
   "LE.le",
   "Int.natCast_add",
   "id",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.Int.sub_congr"],
  "name": "CellularAutomatas.nextt_congr._proof_1_9",
  "constType":
  "∀ (t : ℕ) (i j : ℤ), i - ↑t ≤ j ∧ j ≤ i + ↑t → ¬i - ↑(t + 1) ≤ j + 1 → False",
  "constCategory": "Theorem"},
 {"references":
  ["sub_eq_add_neg",
   "HAdd.hAdd",
   "zero_add",
   "Neg.neg",
   "id",
   "HSub.hSub",
   "Eq.mpr",
   "OfNat.ofNat",
   "congrArg"],
  "name": "neg_eq_zero_sub",
  "constType": "∀ {G : Type u_1} [inst : SubNegMonoid G] (x : G), -x = 0 - x",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "HAdd.hAdd",
   "rel_iff_cov",
   "AddRightStrictMono",
   "Function.swap",
   "AddRightReflectLT"],
  "name": "add_lt_add_iff_right",
  "constType":
  "∀ {α : Type u_1} [inst : Add α] [inst_1 : LT α] [AddRightStrictMono α] [AddRightReflectLT α] (a : α) {b c : α},\n  b + a < c + a ↔ b < c",
  "constCategory": "Theorem"},
 {"references": ["rfl", "Function.comp"],
  "name": "Function.comp_apply",
  "constType":
  "∀ {β : Sort u_1} {δ : Sort u_2} {α : Sort u_3} {f : β → δ} {g : α → β} {x : α}, (f ∘ g) x = f (g x)",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans",
   "Eq.mp",
   "eq_true",
   "OfNat.ofNat",
   "Inhabited.default",
   "congrArg",
   "HAdd.hAdd",
   "CellularAutomatas.ProdCA.zipMany_get?._proof_1_2",
   "List.range",
   "of_eq_true",
   "List.length_range",
   "LE.le",
   "List.length"],
  "name": "CellularAutomatas.ProdCA.zipMany_get?._proof_1_3",
  "constType":
  "∀ {β : Type} [inst : CellularAutomatas.Alphabet β] {γ : β → Type u_1} (f : (b : β) → List (γ b)) (i : ℕ),\n  i + 1 ≤ (f default).length → i < (List.range (f default).length).length",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Grind.Ring.intCast",
   "Neg.neg",
   "HMul.hMul",
   "IntCast.intCast",
   "HPow.hPow",
   "Lean.Grind.CommRing.denoteInt",
   "HAdd.hAdd",
   "NatCast.natCast",
   "Lean.Grind.CommRing.Var.denote",
   "HSub.hSub",
   "Lean.Grind.Semiring.natCast",
   "Lean.Grind.CommRing.Var",
   "Lean.Grind.CommRing.Context"],
  "name": "Lean.Grind.CommRing.Expr.denote",
  "constType":
  "{α : Type u_1} → [Grind.Ring α] → Grind.CommRing.Context α → Grind.CommRing.Expr → α",
  "constCategory": "Definition"},
 {"references":
  ["Classical.choose_spec",
   "Set",
   "CellularAutomatas.L_c",
   "Membership.mem",
   "CellularAutomatas.CA_rt",
   "CellularAutomatas.L_c_in_rt",
   "CellularAutomatas.tCellAutomaton.L",
   "Language",
   "Classical.choose",
   "And.left",
   "CellularAutomatas.Advice.rt_closed"],
  "name": "CellularAutomatas.CALc_spec_1",
  "constType":
  "∀ {α : Type} [inst : CellularAutomatas.Alphabet α] {Γ : Type} [inst_1 : CellularAutomatas.Alphabet Γ]\n  (adv : CellularAutomatas.Advice α Γ) (h : adv.rt_closed) (c : Γ),\n  CellularAutomatas.CALc adv h c ∈ CellularAutomatas.CA_rt α",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "eq_self",
   "Eq.trans",
   "of_eq_true",
   "Lean.Omega.IntList",
   "Int.neg_add",
   "Neg.neg",
   "congr",
   "Lean.Omega.IntList.sum",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Lean.Omega.IntList.sum_neg",
  "constType": "∀ (xs : Omega.IntList), (-xs).sum = -xs.sum",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.apply_iterated_zero",
   "Eq.trans",
   "CellularAutomatas.CellAutomaton.next",
   "CellularAutomatas.δδt",
   "CellularAutomatas.uniform_config",
   "CellularAutomatas.apply_iterated_succ_apply'",
   "CellularAutomatas.Config",
   "congrArg",
   "CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "congrFun",
   "congr",
   "funext",
   "HSub.hSub",
   "CellularAutomatas.CellAutomaton.Q",
   "CellularAutomatas.CellAutomaton.δ",
   "CellularAutomatas.δδ",
   "CellularAutomatas.CellAutomaton.nextt",
   "Nat.recAux",
   "Function.comp",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "eq_self",
   "of_eq_true",
   "CellularAutomatas.apply_iterated",
   "id"],
  "name": "CellularAutomatas.LCellAutomaton.uniform_state_eq",
  "constType":
  "∀ {α : Type} {C : CellularAutomatas.LCellAutomaton α} {q : C.Q},\n  C.nextt (CellularAutomatas.uniform_config q) = CellularAutomatas.uniform_config ∘ CellularAutomatas.δδt q",
  "constCategory": "Theorem"},
 {"references":
  ["sorryAx",
   "CellularAutomatas.CellAutomaton.nextt",
   "CellularAutomatas.CellAutomaton.next",
   "CellularAutomatas.speedup_factor_k.compress",
   "CellularAutomatas.CellAutomaton.Q",
   "CellularAutomatas.Config",
   "CellularAutomatas.speedup_factor_k.C'",
   "OfNat.ofNat"],
  "name": "CellularAutomatas.speedup_factor_k.compression_k_step",
  "constType":
  "∀ (k : ℕ) [inst : NeZero k] (C : CellularAutomatas.CellAutomaton) (c : CellularAutomatas.Config C.Q),\n  (CellularAutomatas.speedup_factor_k.C' k C).next (CellularAutomatas.speedup_factor_k.compress k c) =\n    CellularAutomatas.speedup_factor_k.compress k (C.nextt c k)",
  "constCategory": "Theorem"},
 {"references":
  ["rfl",
   "HAdd.hAdd",
   "eq_self",
   "Nat.cast",
   "Eq.trans",
   "of_eq_true",
   "_private.Init.Data.Int.Lemmas.0.Int.add_comm.match_1_1",
   "Nat.add_comm",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Int.add_comm",
  "constType": "∀ (a b : ℤ), a + b = b + a",
  "constCategory": "Theorem"},
 {"references":
  ["_private.Init.Data.List.Basic.0.List.zipWith.match_1.eq_2",
   "List.brecOn.go",
   "List.brecOn",
   "congrArg",
   "List.below",
   "_private.Init.Data.List.Basic.0.List.zipWith.match_1.splitter",
   "congr",
   "id",
   "Eq.symm",
   "List.zipWith",
   "Eq.mpr",
   "Eq.ndrec",
   "List.zipWith.match_1",
   "List.brecOn.eq"],
  "name": "List.zipWith.eq_def",
  "constType":
  "∀ {α : Type u} {β : Type v} {γ : Type w} (f : α → β → γ) (x : List α) (x_1 : List β),\n  List.zipWith f x x_1 =\n    match x, x_1 with\n    | x :: xs, y :: ys => f x y :: List.zipWith f xs ys\n    | x, x_2 => []",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "HAdd.hAdd",
   "Lean.Grind.Nat.lt_eq",
   "Int.toNat",
   "Eq.substr",
   "Fin.val",
   "LE.le",
   "CellularAutomatas.FiniteStateTransducer.scanr",
   "CellularAutomatas.FiniteStateTransducer.scanr_get'_eq._proof_1_2",
   "Lean.Grind.nestedProof",
   "OfNat.ofNat",
   "List.length"],
  "name": "CellularAutomatas.FiniteStateTransducer.scanr_get'_eq._proof_1_6",
  "constType":
  "∀ {α β : Type} {M : CellularAutomatas.FiniteStateTransducer α β} (w : List α) (i : ℤ)\n  (h_nat_lt : i.toNat + 1 ≤ w.length), i.toNat + 1 ≤ List.length (M.scanr w) → ↑⟨i.toNat, ⋯⟩ < List.length (M.scanr w)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Subtype.casesOn",
  "constType":
  "{α : Sort u} →\n  {p : α → Prop} →\n    {motive : Subtype p → Sort u_1} →\n      (t : Subtype p) → ((val : α) → (property : p val) → motive ⟨val, property⟩) → motive t",
  "constCategory": "Definition"},
 {"references": ["Not", "Decidable.not_not", "propext"],
  "name": "Decidable.not_not._simp_1",
  "constType": "∀ {p : Prop} [Decidable p], (¬¬p) = p",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.cast_ne_zero", "Nat.cast", "Iff.mpr", "Ne", "NeZero.ne", "OfNat.ofNat"],
  "name": "OfNat.ofNat_ne_zero",
  "constType":
  "∀ {R : Type u_1} [inst : AddMonoidWithOne R] [CharZero R] (n : ℕ) [inst_2 : n.AtLeastTwo], OfNat.ofNat n ≠ 0",
  "constCategory": "Theorem"},
 {"references": ["Unit"],
  "name": "CellularAutomatas.AlphabetUnit",
  "constType": "CellularAutomatas.Alphabet Unit",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "Eq.trans",
   "of_eq_true",
   "NatCast.natCast",
   "Eq.ndrec",
   "congrArg"],
  "name": "Lean.Grind.Order.of_nat_eq",
  "constType": "∀ (a b : ℕ) (x y : ℤ), ↑a = x → ↑b = y → a = b → x = y",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "CellularAutomatas.CArtTransducer.casesOn",
   "CellularAutomatas.CellAutomaton.Q"],
  "name": "CellularAutomatas.CArtTransducer.noConfusionType",
  "constType":
  "{α Γ : Type} →\n  [inst : CellularAutomatas.Alphabet α] →\n    [inst_1 : CellularAutomatas.Alphabet Γ] →\n      Sort u → CellularAutomatas.CArtTransducer α Γ → CellularAutomatas.CArtTransducer α Γ → Sort u",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Omega.Coeffs", "Lean.Omega.IntList.combo_eq_smul_add_smul"],
  "name": "Lean.Omega.Coeffs.combo_eq_smul_add_smul",
  "constType":
  "∀ (a : ℤ) (xs : Omega.Coeffs) (b : ℤ) (ys : Omega.Coeffs), Omega.Coeffs.combo a xs b ys = a * xs + b * ys",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.LCellAutomaton.casesOn",
   "CellularAutomatas.CellAutomaton.Q"],
  "name": "CellularAutomatas.LCellAutomaton.noConfusionType",
  "constType":
  "{α : Type} → Sort u → CellularAutomatas.LCellAutomaton α → CellularAutomatas.LCellAutomaton α → Sort u",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Lean.RecursorVal.all",
  "constType": "RecursorVal → List Name",
  "constCategory": "Definition"},
 {"references":
  ["HAdd.hAdd",
   "Neg.neg",
   "Int.add_left_neg",
   "Int.add_comm",
   "id",
   "Eq.mpr",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Int.add_right_neg",
  "constType": "∀ (a : ℤ), a + -a = 0",
  "constCategory": "Theorem"},
 {"references": ["HAdd.hAdd", "LE.le"],
  "name": "AddLECancellable",
  "constType": "{α : Type u_1} → [Add α] → [LE α] → α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["HAdd.hAdd",
   "rfl",
   "_private.Init.Data.List.Range.0.List.length_range'.match_1_1",
   "List.range'",
   "Nat.below",
   "Nat.brecOn",
   "OfNat.ofNat",
   "congrArg",
   "Unit",
   "List.length"],
  "name": "List.length_range'",
  "constType": "∀ {s step n : ℕ}, (List.range' s n step).length = n",
  "constCategory": "Theorem"},
 {"references": ["HAdd.hAdd", "SizeOf.sizeOf", "OfNat.ofNat"],
  "name": "CellularAutomatas.backwards_fsm.Params._sizeOf_1",
  "constType": "CellularAutomatas.backwards_fsm.Params → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Grind.AC.Var",
   "Lean.Grind.AC.Seq.insert",
   "Lean.Grind.AC.Seq.contains_k",
   "Lean.Grind.AC.Seq.beq'",
   "Bool.and'"],
  "name": "Lean.Grind.AC.superpose_ac_idempotent_cert",
  "constType":
  "Grind.AC.Var → Grind.AC.Seq → Grind.AC.Seq → Grind.AC.Seq → Bool",
  "constCategory": "Definition"},
 {"references": ["LT.lt", "lt_self_iff_false", "propext"],
  "name": "lt_self_iff_false._simp_1",
  "constType": "∀ {α : Type u_2} [inst : Preorder α] (x : α), (x < x) = False",
  "constCategory": "Theorem"},
 {"references": ["Int.add_neg_cancel_right"],
  "name": "Int.add_sub_cancel",
  "constType": "∀ (a b : ℤ), a + b - b = a",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Omega.LinearCombo.mul_eval",
   "Or.elim",
   "Nat.cast",
   "Eq.trans",
   "le_of_le_of_eq",
   "HMul.hMul",
   "Lean.Omega.LinearCombo.coordinate_eval_0",
   "Lean.Omega.Constraint.combine_sat'",
   "Int.sub_eq_zero_of_eq",
   "Decidable.decide",
   "Lean.Omega.Int.mul_congr",
   "Lean.Omega.Coeffs.ofList",
   "Lean.Omega.Int.ofNat_sub_dichotomy",
   "HSub.hSub",
   "Lean.Omega.tidy_sat",
   "Eq.symm",
   "Lean.Omega.LinearCombo.add_eval",
   "Int.add_one_le_of_lt",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "And.left",
   "of_decide_eq_true",
   "Not",
   "Neg.neg",
   "And.right",
   "Lean.Omega.Constraint.addInequality_sat",
   "Lean.Omega.Int.add_congr",
   "Lean.Omega.Constraint.isImpossible",
   "Lean.Omega.LinearCombo.coordinate",
   "Int.ofNat_nonneg",
   "Int.sub_nonneg_of_le",
   "OfNat.ofNat",
   "Lean.Omega.LinearCombo.coordinate_eval_1",
   "LT.lt",
   "HAdd.hAdd",
   "Lean.Omega.LinearCombo.mul",
   "Lean.Omega.Int.ofNat_lt_of_lt",
   "Lean.Omega.LinearCombo.sub_eval",
   "Lean.Omega.Coeffs.isZero",
   "Nat.lt_of_not_le",
   "LE.le",
   "Int.natCast_add",
   "id",
   "Lean.Omega.Constraint.addEquality_sat",
   "Int.natCast_mul",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.Int.sub_congr"],
  "name": "CellularAutomatas.middle_reachable_card._proof_1_4",
  "constType": "∀ (k' : ℕ), ¬k' + 1 ≤ 2 * (k' + 1) + 1 - (k' + 1) → False",
  "constCategory": "Theorem"},
 {"references": ["Bool.casesOn"],
  "name": "_private.Init.Prelude.0.ne_true_of_eq_false.match_1_1",
  "constType":
  "∀ (motive : (x : Bool) → x = false → Prop) (x : Bool) (x_1 : x = false),\n  (∀ (h : true = false), motive true h) → (∀ (x : false = false), motive false x) → motive x x_1",
  "constCategory": "Definition"},
 {"references": [],
  "name": "MulOneClass.one_mul",
  "constType": "∀ {M : Type u} [self : MulOneClass M] (a : M), 1 * a = a",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans",
   "eq_true",
   "eagerReduce",
   "HMul.hMul",
   "IntCast.intCast",
   "Nat.ToInt.natCast_ofNat",
   "Fin.val",
   "NatCast.natCast",
   "Eq.symm",
   "forall_prop_domain_congr",
   "Lean.Grind.forall_propagator",
   "CellularAutomatas.FiniteStateTransducer.scanr_reduce_drop._proof_1_2",
   "List.drop",
   "Neg.neg",
   "Nat.ToInt.finVal",
   "Lean.Grind.nestedProof",
   "CellularAutomatas.FiniteStateTransducer.scanr_get'_eq1._proof_1",
   "Decidable.byContradiction",
   "eq_false",
   "Fin.val_lt_of_le",
   "Classical.byContradiction",
   "id",
   "Lean.Grind.Order.eq_trans_true",
   "Fin.getElem_fin",
   "List.length",
   "Int.Linear.norm_le",
   "Eq.substr",
   "Nat.cast",
   "Eq.mp",
   "CellularAutomatas.FiniteStateTransducer.Q",
   "GetElem.getElem",
   "CellularAutomatas.FiniteStateTransducer.scanr_reduce",
   "congrArg",
   "Lean.Grind.Nat.lt_eq",
   "CellularAutomatas.FiniteStateTransducer.scanr_reduce_drop._proof_1_1",
   "Lean.Grind.ToInt.toInt",
   "Lean.Grind.ToInt.le_upper'",
   "CellularAutomatas.FiniteStateTransducer.δ",
   "Not",
   "CellularAutomatas.Word",
   "Nat.ToInt.add_congr",
   "Lean.Grind.Order.le_eq_true_of_le_k",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "LT.lt",
   "Nat.ToInt.le_eq",
   "of_eq_true",
   "LE.le",
   "Lean.Grind.CommRing.le_norm_expr",
   "Fin.isLt",
   "Lean.Grind.Order.eq_mp"],
  "name":
  "CellularAutomatas.FiniteStateTransducer.scanr_reduce_drop._proof_1_3",
  "constType":
  "∀ {α β : Type} {M : CellularAutomatas.FiniteStateTransducer α β} (w : CellularAutomatas.Word α)\n  (i : Fin (List.length w)), M.δ (M.scanr_reduce w⟦↑i + 1..*⟧) w[↑i] = M.δ (M.scanr_reduce w⟦↑i + 1..*⟧) w[i]",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "Int.toNat",
   "OfNat.ofNat",
   "CellularAutomatas.FiniteStateTransducer.scanr_get'_eq1._proof_1",
   "Eq.mpr_prop",
   "HAdd.hAdd",
   "LT.lt",
   "Lean.Grind.Nat.lt_eq",
   "Decidable.byContradiction",
   "Fin.val_lt_of_le",
   "LE.le",
   "id",
   "List.length"],
  "name": "CellularAutomatas.FiniteStateTransducer.scanr_get'_eq._proof_1_4",
  "constType":
  "∀ {α : Type} (w : List α) (i : ℤ) (h_nat_lt : i.toNat + 1 ≤ w.length), ↑⟨i.toNat, ⋯⟩ < w.length",
  "constCategory": "Theorem"},
 {"references": ["sorryAx", "OfNat.ofNat"],
  "name": "CellularAutomatas.CArtTransducer.compose",
  "constType":
  "{α β γ : Type} →\n  [inst : CellularAutomatas.Alphabet α] →\n    [inst_1 : CellularAutomatas.Alphabet β] →\n      [inst_2 : CellularAutomatas.Alphabet γ] →\n        CellularAutomatas.CArtTransducer β γ →\n          CellularAutomatas.CArtTransducer α β → CellularAutomatas.CArtTransducer α γ",
  "constCategory": "Definition"},
 {"references":
  ["SetLike.coe", "Finset.mem_coe", "Set", "Membership.mem", "propext"],
  "name": "_private.Mathlib.Data.Finset.Image.0.Finset.coe_image._simp_1_1",
  "constType": "∀ {α : Type u_1} {a : α} {s : Finset α}, (a ∈ ↑s) = (a ∈ s)",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "Eq.trans",
   "and_imp._simp_1",
   "congrArg",
   "Lean.Grind.AC.Var",
   "Bool.and",
   "congr",
   "Lean.Grind.AC.superpose_ac_idempotent_cert",
   "Eq.symm",
   "Lean.Grind.AC.Seq.denote",
   "Eq.ndrec",
   "Lean.Grind.AC.Seq.beq'_eq",
   "Lean.Grind.AC.Seq.insert",
   "Lean.Grind.AC.Seq.contains_k",
   "Bool.and'_eq_and",
   "Lean.Grind.AC.Var.denote",
   "Lean.Grind.AC.Context.op",
   "Lean.Grind.AC.Seq.denote_insert",
   "eq_self",
   "of_eq_true",
   "id",
   "Lean.Grind.AC.Seq.beq'",
   "Eq.mpr",
   "Bool.and_eq_true",
   "Bool.and'",
   "Lean.Grind.AC.Seq.denote_insert_of_contains"],
  "name": "Lean.Grind.AC.superpose_ac_idempotent",
  "constType":
  "∀ {α : Sort u_1} (ctx : Grind.AC.Context α) {inst₁ : Associative ctx.op} {inst₂ : Commutative ctx.op}\n  {inst₃ : IdempotentOp ctx.op} (x : Grind.AC.Var) (lhs₁ rhs₁ rhs : Grind.AC.Seq),\n  Grind.AC.superpose_ac_idempotent_cert x lhs₁ rhs₁ rhs = true →\n    Grind.AC.Seq.denote ctx lhs₁ = Grind.AC.Seq.denote ctx rhs₁ →\n      Grind.AC.Seq.denote ctx lhs₁ = Grind.AC.Seq.denote ctx rhs",
  "constCategory": "Theorem"},
 {"references": ["Not", "absurd", "LT.lt", "Nat.not_lt_zero", "OfNat.ofNat"],
  "name": "Nat.findX._proof_5",
  "constType": "∀ {p : ℕ → Prop}, ∀ x < 0, ¬p x",
  "constCategory": "Theorem"},
 {"references":
  ["Not", "LT.lt", "Nat.find", "Nat.find_eq_iff", "DecidablePred", "propext"],
  "name": "_private.Mathlib.Data.Nat.Find.0.Nat.find_eq_zero._simp_1_1",
  "constType":
  "∀ {m : ℕ} {p : ℕ → Prop} [inst : DecidablePred p] (h : ∃ n, p n), (Nat.find h = m) = (p m ∧ ∀ n < m, ¬p n)",
  "constCategory": "Theorem"},
 {"references": ["Units.inv_val"],
  "name": "Units.inv_mul",
  "constType": "∀ {α : Type u} [inst : Monoid α] (a : αˣ), ↑a⁻¹ * ↑a = 1",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans",
   "CellularAutomatas.tCellAutomaton.t",
   "Membership.mem",
   "congrArg",
   "CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "CellularAutomatas.tCellAutomaton.p",
   "CellularAutomatas.LcInRt.DiagonalShiftCA",
   "congr",
   "funext",
   "forall_congr",
   "HSub.hSub",
   "CellularAutomatas.CellAutomaton.Q",
   "Set",
   "CellularAutomatas.LcInRt.AdvCALc.match_1",
   "Set.mem_univ._simp_1",
   "true_and",
   "OfNat.ofNat",
   "Unit",
   "Set.univ",
   "eq_self",
   "implies_true",
   "and_self",
   "of_eq_true",
   "BEq.beq",
   "setOf"],
  "name": "CellularAutomatas.LcInRt.myCA_in_rt",
  "constType":
  "∀ {α : Type} [inst : CellularAutomatas.Alphabet α] {Γ : Type} [inst_1 : CellularAutomatas.Alphabet Γ] (c : Γ),\n  CellularAutomatas.LcInRt.AdvCALc c ∈ CellularAutomatas.CA_rt (α ⨉ Γ)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Quot.liftOn",
  "constType":
  "{α : Sort u} → {β : Sort v} → {r : α → α → Prop} → Quot r → (f : α → β) → (∀ (a b : α), r a b → f a = f b) → β",
  "constCategory": "Definition"},
 {"references":
  ["Eq.trans",
   "_private.Init.Data.Nat.Linear.0.Nat.Linear.Poly.denote_insert.match_1_1",
   "Bool.of_not_eq_true",
   "HMul.hMul",
   "Nat.Linear.Poly",
   "congrArg",
   "congr",
   "Nat.beq",
   "Nat.Linear.Poly.insert",
   "Not",
   "Nat.Linear.Context",
   "Nat.blt",
   "Nat.zero_add",
   "List.brecOn",
   "Nat.add_comm",
   "Nat.add_assoc",
   "cond",
   "Nat.eq_of_beq_eq_true",
   "Nat.Linear.Var",
   "OfNat.ofNat",
   "Unit",
   "HAdd.hAdd",
   "List.below",
   "eq_self",
   "Nat.add",
   "of_eq_true",
   "Nat.Linear.Var.denote",
   "id",
   "Nat.Linear.Poly.denote",
   "Eq.mpr",
   "Nat.right_distrib",
   "dite",
   "Nat.add_left_comm"],
  "name": "Nat.Linear.Poly.denote_insert",
  "constType":
  "∀ (ctx : Nat.Linear.Context) (k : ℕ) (v : Nat.Linear.Var) (p : Nat.Linear.Poly),\n  Nat.Linear.Poly.denote ctx (Nat.Linear.Poly.insert k v p) =\n    Nat.Linear.Poly.denote ctx p + k * Nat.Linear.Var.denote ctx v",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.CellAutomaton.δ",
   "Set",
   "Membership.mem",
   "CellularAutomatas.CellAutomaton.Q",
   "Subtype.val",
   "Set.Elem"],
  "name": "CellularAutomatas.CellAutomaton.quiescent_set",
  "constType": "(C : CellularAutomatas.CellAutomaton) → Set C.Q → Prop",
  "constCategory": "Definition"},
 {"references": ["eq_false"],
  "name": "eq_false'",
  "constType": "∀ {p : Prop}, (p → False) → p = False",
  "constCategory": "Theorem"},
 {"references": ["Not", "Classical.not_forall", "propext"],
  "name": "Classical.not_forall._simp_1",
  "constType": "∀ {α : Sort u_1} {p : α → Prop}, (¬∀ (x : α), p x) = ∃ x, ¬p x",
  "constCategory": "Theorem"},
 {"references": ["Nat.Linear.Expr.casesOn", "Nat.Linear.Var"],
  "name": "Nat.Linear.Expr.denote.match_1",
  "constType":
  "(motive : Nat.Linear.Expr → Sort u_1) →\n  (x : Nat.Linear.Expr) →\n    ((a b : Nat.Linear.Expr) → motive (a.add b)) →\n      ((k : ℕ) → motive (Nat.Linear.Expr.num k)) →\n        ((v : Nat.Linear.Var) → motive (Nat.Linear.Expr.var v)) →\n          ((k : ℕ) → (e : Nat.Linear.Expr) → motive (Nat.Linear.Expr.mulL k e)) →\n            ((e : Nat.Linear.Expr) → (k : ℕ) → motive (e.mulR k)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["HAdd.hAdd",
   "eq_self",
   "Eq.trans",
   "of_eq_true",
   "List.map",
   "OfNat.ofNat",
   "congrArg",
   "List.length"],
  "name": "List.length_map",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {as : List α} (f : α → β), (List.map f as).length = as.length",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CellularAutomatas.CArtTransducer.mk._flat_ctor",
  "constType":
  "{α Γ : Type} →\n  [inst : CellularAutomatas.Alphabet α] →\n    [inst_1 : CellularAutomatas.Alphabet Γ] →\n      (Q : Type) →\n        [alphabetQ : CellularAutomatas.Alphabet Q] →\n          (Q → Q → Q → Q) → (α → Q) → Q → (Q → Γ) → CellularAutomatas.CArtTransducer α Γ",
  "constCategory": "Definition"},
 {"references":
  ["Eq.trans",
   "HMul.hMul",
   "eq_true",
   "ite_cond_eq_true",
   "Nat.mod.inductionOn",
   "congrArg",
   "HDiv.hDiv",
   "Nat.div_eq",
   "Nat.sub_add_cancel",
   "congr",
   "HSub.hSub",
   "Eq.symm",
   "Not",
   "HMod.hMod",
   "ite",
   "And.right",
   "Nat.add_assoc",
   "ite_cond_eq_false",
   "OfNat.ofNat",
   "LT.lt",
   "HAdd.hAdd",
   "eq_self",
   "and_self",
   "Nat.mod_eq",
   "Nat.mul_succ",
   "of_eq_true",
   "eq_false",
   "LE.le",
   "id",
   "Eq.mpr"],
  "name": "Nat.mod_add_div",
  "constType": "∀ (m k : ℕ), m % k + k * (m / k) = m",
  "constCategory": "Theorem"},
 {"references":
  ["Int.add_assoc",
   "Eq.trans",
   "Int.Linear.Poly.denote",
   "HMul.hMul",
   "congrArg",
   "HAdd.hAdd",
   "eq_self",
   "Int.Linear.Var.denote",
   "Int.Linear.Context",
   "of_eq_true",
   "congr",
   "Int.add_comm",
   "Int.Linear.Poly.addConst",
   "Int.Linear.Var"],
  "name": "Int.Linear.Poly.denote_addConst",
  "constType":
  "∀ (ctx : Int.Linear.Context) (p : Int.Linear.Poly) (k : ℤ),\n  Int.Linear.Poly.denote ctx (p.addConst k) = Int.Linear.Poly.denote ctx p + k",
  "constCategory": "Theorem"},
 {"references":
  ["_private.Mathlib.Data.Finset.Image.0.Finset.coe_image._simp_1_1",
   "Eq.trans",
   "Set",
   "DecidableEq",
   "Membership.mem",
   "Finset.mem_image._simp_1",
   "congrArg",
   "implies_true",
   "Set.image",
   "SetLike.coe",
   "iff_self",
   "of_eq_true",
   "Finset.image",
   "congr",
   "funext",
   "_private.Mathlib.Data.Finset.Image.0.Finset.coe_image._simp_1_2",
   "forall_congr",
   "Set.ext"],
  "name": "Finset.coe_image",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} [inst : DecidableEq β] {f : α → β} {s : Finset α}, ↑(Finset.image f s) = f '' ↑s",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Omega.Constraint.upperBound",
   "Eq.trans",
   "Lean.Omega.Constraint.sat",
   "Int.mul_le_mul_of_nonpos_left",
   "HMul.hMul",
   "Decidable.decide.congr_simp",
   "False.elim",
   "Int.not_lt._simp_1",
   "decide_eq_true_eq",
   "And.left",
   "_private.Init.Omega.Constraint.0.Lean.Omega.Constraint.scale_sat._simp_1_2",
   "Lean.Omega.UpperBound.sat",
   "Lean.Omega.Constraint.map",
   "Int.mul_le_mul_of_nonneg_left",
   "And.right",
   "Lean.Omega.LowerBound.sat",
   "eq_false'",
   "true_and",
   "if_neg",
   "id",
   "Lean.Omega.LowerBound",
   "Eq.mpr",
   "Lean.Omega.Constraint.flip",
   "Eq.mp",
   "noConfusion_of_Nat",
   "and_true",
   "Decidable.decide",
   "congrArg",
   "Int.le_refl._simp_1",
   "Lean.Omega.Constraint.scale",
   "Int.zero_mul",
   "Lean.Omega.Constraint.casesOn",
   "congr",
   "Lean.Omega.Constraint.lowerBound",
   "Bool.ctorIdx",
   "Not",
   "ite",
   "decide_true",
   "Decidable.casesOn",
   "Lean.Omega.Constraint.isImpossible",
   "OfNat.ofNat",
   "Option.casesOn",
   "LT.lt",
   "eq_self",
   "and_self",
   "of_eq_true",
   "LE.le",
   "Int.le_of_lt",
   "Lean.Omega.UpperBound",
   "if_pos"],
  "name": "Lean.Omega.Constraint.scale_sat",
  "constType":
  "∀ {t : ℤ} {c : Omega.Constraint} (k : ℤ), c.sat t = true → (Omega.Constraint.scale k c).sat (k * t) = true",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "List.below",
   "List.brecOn",
   "List.length.match_1",
   "OfNat.ofNat",
   "Unit"],
  "name": "List.length",
  "constType": "{α : Type u_1} → List α → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["_private.Mathlib.Order.Defs.LinearOrder.0.min_eq_left._proof_1_1", "LE.le"],
  "name": "min_eq_left",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrder α] {a b : α}, a ≤ b → min a b = a",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans",
   "Eq.mp",
   "Int.Linear.Poly.denote.match_1",
   "Int.Linear.Poly.denote",
   "HMul.hMul",
   "Lean.Data.AC.Context.eq_of_norm",
   "Int.one_mul",
   "congrArg",
   "Int.Linear.Var.denote",
   "Bool.casesOn",
   "congr",
   "Eq.symm",
   "Int.beq'",
   "Int.Linear.Poly.denote'",
   "Int.Linear.Poly.denote.eq_def",
   "Eq.ndrec",
   "Int.Linear.Poly.denote'.go",
   "Int.Linear.Poly.casesOn",
   "Int.beq'_eq_beq",
   "OfNat.ofNat",
   "beq_iff_eq._simp_1",
   "HAdd.hAdd",
   "eq_self",
   "Int.Linear.Context",
   "of_eq_true",
   "id",
   "Eq.mpr",
   "Int.Linear.Poly.denote'_go_eq_denote",
   "BEq.beq",
   "Int.Linear.Var"],
  "name": "Int.Linear.Poly.denote'_eq_denote",
  "constType":
  "∀ (ctx : Int.Linear.Context) (p : Int.Linear.Poly), Int.Linear.Poly.denote' ctx p = Int.Linear.Poly.denote ctx p",
  "constCategory": "Theorem"},
 {"references": ["MulDivCancelClass.mul_div_cancel", "Ne", "OfNat.ofNat"],
  "name": "mul_div_cancel_right₀",
  "constType":
  "∀ {M₀ : Type u_1} [inst : MonoidWithZero M₀] [inst_1 : Div M₀] [MulDivCancelClass M₀] (a : M₀) {b : M₀},\n  b ≠ 0 → a * b / b = a",
  "constCategory": "Theorem"},
 {"references": ["LT.lt", "Fin.casesOn", "OfNat.ofNat"],
  "name": "Fin.elim0.match_1",
  "constType":
  "(motive : Fin 0 → Sort u_1) → (x : Fin 0) → ((val : ℕ) → (h : val < 0) → motive ⟨val, h⟩) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Int.Linear.Poly.beq'",
   "Eq.trans",
   "Int.Linear.Poly.denote'_eq_denote",
   "Eq.mp",
   "Int.Linear.Poly.denote",
   "Int.Linear.Expr.denote_norm",
   "congrArg",
   "eq_self",
   "Int.Linear.Expr.norm",
   "Int.Linear.Context",
   "of_eq_true",
   "Int.Linear.Expr.denote",
   "congr",
   "Int.Linear.Poly.beq'_eq",
   "Int.Linear.Poly.denote'"],
  "name": "Int.Linear.Expr.eq_of_norm_eq",
  "constType":
  "∀ (ctx : Int.Linear.Context) (e : Int.Linear.Expr) (p : Int.Linear.Poly),\n  e.norm.beq' p = true → Int.Linear.Expr.denote ctx e = Int.Linear.Poly.denote' ctx p",
  "constCategory": "Theorem"},
 {"references": ["Dvd.intro", "mul_one", "OfNat.ofNat"],
  "name": "dvd_refl",
  "constType": "∀ {α : Type u_1} [inst : Monoid α] (a : α), a ∣ a",
  "constCategory": "Theorem"},
 {"references":
  ["List.getElem_map",
   "CellularAutomatas.Word",
   "Eq.trans",
   "Eq.mp",
   "List.map",
   "GetElem.getElem",
   "List.length_map",
   "Prod.fst",
   "congrArg",
   "LT.lt",
   "eq_self",
   "of_eq_true",
   "CellularAutomatas.Word.fst",
   "id",
   "CellularAutomatas.Word.fst_len",
   "Eq.ndrec",
   "List.length"],
  "name": "CellularAutomatas.Word.get_fst_",
  "constType":
  "∀ {α β : Type} (w : CellularAutomatas.Word (α ⨉ β)) (t : ℕ) (h : t < List.length w.fst), w.fst[t] = w[t].1",
  "constCategory": "Theorem"},
 {"references": ["Ordering.casesOn"],
  "name": "Ordering.ctorIdx",
  "constType": "Ordering → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Grind.not_true",
   "Int.toNat",
   "CellularAutomatas.backwards_fsm.C'",
   "Nat.cast",
   "Eq.trans",
   "CellularAutomatas.backwards_fsm.Params.C",
   "CellularAutomatas.backwards_fsm.Params.inst3",
   "Membership.mem",
   "CellularAutomatas.FiniteStateTransducer.Q",
   "eagerReduce",
   "CellularAutomatas.FiniteStateTransducer.scanr_reduce",
   "Int.Linear.Expr.eq_of_norm_eq",
   "CellularAutomatas.backwards_fsm.Params.γ",
   "congrArg",
   "CellularAutomatas.LCellAutomaton.embed",
   "CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "NatCast.natCast",
   "False.casesOn",
   "congr",
   "CellularAutomatas.LCellAutomaton.embed_word",
   "CellularAutomatas.CellAutomaton.Q",
   "CellularAutomatas.Word.range",
   "CellularAutomatas.backwards_fsm.Params.α",
   "Not",
   "CellularAutomatas.Word",
   "CellularAutomatas.CArtTransducer.toLCellAutomaton",
   "CellularAutomatas.backwards_fsm.Params.β",
   "List.drop",
   "Set",
   "CellularAutomatas.backwards_fsm.Params.M",
   "CellularAutomatas.FiniteStateTransducer.scanr",
   "CellularAutomatas.backwards_fsm.Params.inst2",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "eq_self",
   "True.casesOn",
   "Classical.byContradiction",
   "id",
   "Lean.Grind.Semiring.natCast",
   "Lean.Grind.intro_with_eq",
   "Lean.Grind.Semiring.natCast_eq_ofNat",
   "CellularAutomatas.FiniteStateTransducer.f"],
  "name": "CellularAutomatas.backwards_fsm.inv._proof_1_4",
  "constType":
  "∀ (e : CellularAutomatas.backwards_fsm.Params) (w : CellularAutomatas.Word e.α) (p : ℤ),\n  (CellularAutomatas.backwards_fsm.C' e).embed_word w p = (CellularAutomatas.backwards_fsm.C' e).embed_word w p →\n    e.C.embed_word (e.M.scanr w) p = e.C.embed_word (e.M.scanr w) p →\n      e.M.scanr_reduce w⟦(p + ↑0).toNat..*⟧ = e.M.scanr_reduce w⟦(p + ↑0).toNat..*⟧ →\n        p ∈ w.range →\n          e.C.embed (e.M.f (e.M.scanr_reduce w⟦(p + ↑0).toNat..*⟧)) = e.C.embed (e.M.f (e.M.scanr_reduce w⟦p.toNat..*⟧))",
  "constCategory": "Theorem"},
 {"references": ["Lean.Omega.positivize?", "Option.getD", "Lean.Omega.Coeffs"],
  "name": "Lean.Omega.positivize",
  "constType":
  "Omega.Constraint ⨉ Omega.Coeffs → Omega.Constraint ⨉ Omega.Coeffs",
  "constCategory": "Definition"},
 {"references": ["Option.casesOn", "Option.noConfusionType", "Eq.ndrec"],
  "name": "Option.noConfusion",
  "constType":
  "{α : Type u} → {P : Sort u_1} → {x1 x2 : Option α} → x1 = x2 → Option.noConfusionType P x1 x2",
  "constCategory": "Definition"},
 {"references":
  ["LT.lt",
   "Not",
   "_private.Init.Data.Int.Order.0.Int.negSucc_lt_zero.match_1_3",
   "_private.Init.Data.Int.Order.0.Int.negSucc_lt_zero.match_1_1",
   "Nat.cast",
   "LE.le",
   "Iff.mp",
   "Int.eq_ofNat_of_zero_le",
   "Int.not_le",
   "OfNat.ofNat"],
  "name": "Int.negSucc_lt_zero",
  "constType": "∀ (n : ℕ), Int.negSucc n < 0",
  "constCategory": "Theorem"},
 {"references":
  ["Int.Linear.Var.denote",
   "Int.Linear.Poly.denote'.go",
   "Int.Linear.Context",
   "Int.beq'",
   "HMul.hMul",
   "OfNat.ofNat",
   "Int.Linear.Var"],
  "name": "Int.Linear.Poly.denote'",
  "constType": "Int.Linear.Context → Int.Linear.Poly → ℤ",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Lean.Name.mkStr2",
  "constType": "String → String → Name",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CellularAutomatas.backwards_fsm.Params.ctorIdx",
  "constType": "CellularAutomatas.backwards_fsm.Params → ℕ",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CellularAutomatas.simulation.Q1.mk",
  "constType":
  "{e : CellularAutomatas.simulation.Params} → e.C_ctl.Q → Fin 3 → CellularAutomatas.simulation.Q1 e",
  "constCategory": "Other"},
 {"references": ["List.casesOn"],
  "name": "List.append.match_1",
  "constType":
  "{α : Type u_1} →\n  (motive : List α → List α → Sort u_2) →\n    (x x_1 : List α) →\n      ((bs : List α) → motive [] bs) → ((a : α) → (as bs : List α) → motive (a :: as) bs) → motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["HAdd.hAdd",
   "LT.lt",
   "Int.add_comm",
   "id",
   "Eq.mpr",
   "Int.lt_of_add_lt_add_left",
   "congrArg"],
  "name": "Int.lt_of_add_lt_add_right",
  "constType": "∀ {a b c : ℤ}, a + b < c + b → a < c",
  "constCategory": "Theorem"},
 {"references": ["Not", "Decidable.casesOn"],
  "name": "_private.Init.Core.0.dif_pos.match_1_1",
  "constType":
  "∀ {c : Prop} (motive : Decidable c → Prop) (h : Decidable c),\n  (∀ (h : c), motive (isTrue h)) → (∀ (hnc : ¬c), motive (isFalse hnc)) → motive h",
  "constCategory": "Definition"},
 {"references": ["Nat.casesOn", "Nat.noConfusionType", "Eq.ndrec"],
  "name": "Nat.noConfusion",
  "constType":
  "{P : Sort u} → {x1 x2 : ℕ} → x1 = x2 → Nat.noConfusionType P x1 x2",
  "constCategory": "Definition"},
 {"references": ["List.casesOn"],
  "name": "_private.Init.Data.List.MapIdx.0.List.length_mapIdx_go.match_1_1",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} (motive : List α → Array β → Prop) (x : List α) (x_1 : Array β),\n  (∀ (x : Array β), motive [] x) → (∀ (a : α) (l : List α) (x : Array β), motive (a :: l) x) → motive x x_1",
  "constCategory": "Definition"},
 {"references": ["Prod.casesOn", "Lean.NameSet"],
  "name": "CellularAutomatas.collectAxiomsFromEnv.visit.match_1",
  "constType":
  "(motive : NameSet ⨉ NameSet → Sort u_1) →\n  (x : NameSet ⨉ NameSet) → ((visited axioms : NameSet) → motive (visited, axioms)) → motive x",
  "constCategory": "Definition"},
 {"references": ["Nat.cast", "congrArg"],
  "name": "Lean.Omega.Int.ofNat_congr",
  "constType": "∀ {a b : ℕ}, a = b → ↑a = ↑b",
  "constCategory": "Theorem"},
 {"references":
  ["OrderDual.toDual",
   "OrderDual",
   "Monotone.map_max",
   "Monotone",
   "Monotone.dual",
   "Function.comp",
   "DFunLike.coe",
   "OrderDual.ofDual"],
  "name": "Monotone.map_min",
  "constType":
  "∀ {α : Type u} {β : Type v} [inst : LinearOrder α] [inst_1 : LinearOrder β] {f : α → β} {a b : α},\n  Monotone f → f (min a b) = min (f a) (f b)",
  "constCategory": "Theorem"},
 {"references":
  ["Int.toNat",
   "Set",
   "Neg.neg",
   "Membership.mem",
   "HMul.hMul",
   "CellularAutomatas.LcInRt.DiagonalShiftCA_comp_p0._proof_1_2",
   "OfNat.ofNat",
   "Lean.Grind.nestedProof",
   "LT.lt",
   "HAdd.hAdd",
   "NatCast.natCast",
   "LE.le",
   "Fin.isLt",
   "setOf",
   "List.length"],
  "name": "CellularAutomatas.LcInRt.DiagonalShiftCA_comp_p0._proof_1_5",
  "constType":
  "∀ {α : Type} {t : ℕ} (w : List α) (h_1 : ↑t ∈ {i | -1 * i ≤ 0 ∧ i + -1 * ↑w.length + 1 ≤ 0}),\n  ↑⟨(↑t).toNat, ⋯⟩ < w.length",
  "constCategory": "Theorem"},
 {"references": ["Not", "Decidable.not_forall", "Classical.propDecidable"],
  "name": "Classical.not_forall",
  "constType": "∀ {α : Sort u_1} {p : α → Prop}, (¬∀ (x : α), p x) ↔ ∃ x, ¬p x",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Std.IsPreorder.le_trans",
  "constType":
  "∀ {α : Type u} {inst : LE α} [self : Std.IsPreorder α] (a b c : α), a ≤ b → b ≤ c → a ≤ c",
  "constCategory": "Theorem"},
 {"references": ["Iff.refl"],
  "name": "Iff.rfl",
  "constType": "∀ {a : Prop}, a ↔ a",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "Lean.Omega.Constraint.upperBound",
   "Eq.trans",
   "Eq.mp",
   "Lean.Omega.Constraint.sat",
   "noConfusion_of_Nat",
   "Decidable.decide",
   "Int.not_le._simp_1",
   "congrArg",
   "Decidable.decide.congr_simp",
   "False.elim",
   "Lean.Omega.Constraint.casesOn",
   "congr",
   "Lean.Omega.Constraint.lowerBound",
   "decide_eq_true_eq",
   "Bool.ctorIdx",
   "not_and._simp_1",
   "Not",
   "Int.lt_of_lt_of_le",
   "Lean.Omega.UpperBound.sat",
   "eq_false'",
   "Lean.Omega.LowerBound.sat",
   "Lean.Omega.Constraint.isImpossible",
   "Option.casesOn",
   "LT.lt",
   "LE.le",
   "Lean.Omega.UpperBound",
   "id",
   "Eq.mpr",
   "Lean.Omega.LowerBound"],
  "name": "Lean.Omega.Constraint.not_sat_of_isImpossible",
  "constType":
  "∀ {c : Omega.Constraint}, c.isImpossible = true → ∀ {t : ℤ}, ¬c.sat t = true",
  "constCategory": "Theorem"},
 {"references": ["LT.lt", "Nat.le_trans", "Nat.le_succ_of_le"],
  "name": "Nat.lt_trans",
  "constType": "∀ {n m k : ℕ}, n < m → m < k → n < k",
  "constCategory": "Theorem"},
 {"references":
  ["List.reverse",
   "Eq.symm",
   "List.head?",
   "List.getLast?",
   "List.head?_reverse"],
  "name": "_private.Init.Data.List.Lemmas.0.List.getLast?_append._simp_1_1",
  "constType": "∀ {α : Type u_1} {l : List α}, l.getLast? = l.reverse.head?",
  "constCategory": "Theorem"},
 {"references": ["Nat.ge_of_not_lt"],
  "name": "Nat.le_of_not_lt",
  "constType": "∀ {a b : ℕ}, ¬a < b → b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Eq.trans",
   "of_eq_true",
   "NatCast.natCast",
   "congr",
   "LE.le",
   "Eq.symm",
   "_private.Init.Data.Int.OfNat.0.Nat.ToInt.le_eq._simp_1_1",
   "congrArg"],
  "name": "Nat.ToInt.le_eq",
  "constType":
  "∀ {a b : ℕ} {a' b' : ℤ}, ↑a = a' → ↑b = b' → (a ≤ b) = (a' ≤ b')",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Min.min",
  "constType": "{α : Type u} → [self : Min α] → α → α → α",
  "constCategory": "Definition"},
 {"references":
  ["HAdd.hAdd",
   "Lean.Grind.Ring.intCast",
   "Nat.cast",
   "Lean.Grind.Ring.intCast_natCast",
   "id",
   "Lean.Grind.Semiring.natCast_add",
   "Eq.mpr",
   "Lean.Grind.Semiring.natCast",
   "Int.ofNat_add_ofNat",
   "Int.cast",
   "congrArg"],
  "name": "Lean.Grind.Ring.intCast_nat_add",
  "constType":
  "∀ {α : Type u} [inst : Grind.Ring α] {x y : ℕ}, ↑(↑x + ↑y) = ↑x + ↑y",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "eq_self",
   "add_left_comm",
   "Eq.trans",
   "of_eq_true",
   "Eq.ndrec",
   "congrArg"],
  "name": "Mathlib.Tactic.Ring.add_pf_add_gt",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a b₂ c : R} (b₁ : R), a + b₂ = c → a + (b₁ + b₂) = b₁ + c",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "Array.size",
   "LE.le",
   "HSub.hSub",
   "Array.foldlM.loop",
   "dite",
   "Array.forIn'._proof_2"],
  "name": "Array.foldlM",
  "constType":
  "{α : Type u} →\n  {β : Type v} →\n    {m : Type v → Type w} → [Monad m] → (β → α → m β) → β → (as : Array α) → optParam ℕ 0 → optParam ℕ as.size → m β",
  "constCategory": "Definition"},
 {"references":
  ["HAppend.hAppend",
   "CellularAutomatas.Word",
   "CellularAutomatas.FiniteStateTransducer.scanr_foldr_state",
   "Eq.trans",
   "CellularAutomatas.FiniteStateTransducer.scanr_q",
   "CellularAutomatas.FiniteStateTransducer.Q",
   "Prod.snd",
   "congrArg",
   "List.foldr",
   "Prod.fst",
   "CellularAutomatas.FiniteStateTransducer.scanr_reduce_q",
   "eq_self",
   "and_self",
   "of_eq_true",
   "List.cons.injEq",
   "congr",
   "CellularAutomatas.FiniteStateTransducer.scanr_step",
   "id",
   "Eq.mpr",
   "CellularAutomatas.FiniteStateTransducer.f",
   "CellularAutomatas.FiniteStateTransducer.δ"],
  "name": "CellularAutomatas.FiniteStateTransducer.scanr_foldr_cons",
  "constType":
  "∀ {α β : Type} {M : CellularAutomatas.FiniteStateTransducer α β} (p : CellularAutomatas.Word α) (q : M.Q)\n  (tail : List β), (List.foldr M.scanr_step (q, tail) p).2 = M.scanr_q q p ++ tail",
  "constCategory": "Theorem"},
 {"references": ["Lean.ConstantInfo.casesOn"],
  "name": "Lean.ConstantInfo.ctorIdx",
  "constType": "ConstantInfo → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["implies_congr",
   "imp_self._simp_1",
   "Eq.trans",
   "and_imp._simp_1",
   "Lean.Grind.Ring.intCast_one",
   "HMul.hMul",
   "IntCast.intCast",
   "Int.cast",
   "congrArg",
   "Bool.and",
   "Lean.Grind.CommRing.Expr.toPoly_k_eq_toPoly",
   "NatCast.natCast",
   "congr",
   "Lean.Grind.Ring.intCast_zero",
   "Eq.symm",
   "HSub.hSub",
   "Lean.Grind.CommRing.Poly.denote",
   "Eq.ndrec",
   "Lean.Grind.CommRing.Stepwise.imp_1eq_cert",
   "Lean.Grind.CommRing.Poly.beq'",
   "Lean.Grind.Ring.intCast",
   "Bool.and'_eq_and",
   "Neg.neg",
   "Lean.Grind.CommRing.Expr.toPoly_k",
   "Lean.Grind.CommRing.Poly.beq'_eq",
   "Lean.Grind.CommRing.Expr.denote",
   "HPow.hPow",
   "Lean.Grind.Semiring.one_mul",
   "_private.Init.Grind.Ring.CommSolver.0.Lean.Grind.CommRing.Stepwise.imp_1eq._simp_1_3",
   "OfNat.ofNat",
   "Lean.Grind.CommRing.denoteInt",
   "HAdd.hAdd",
   "of_eq_true",
   "Lean.Grind.CommRing.Var.denote",
   "id",
   "Lean.Grind.CommRing.Expr.denote_toPoly",
   "Eq.mpr",
   "Bool.and_eq_true",
   "Lean.Grind.Semiring.natCast",
   "Lean.Grind.CommRing.Var",
   "Bool.and'",
   "Lean.Grind.CommRing.Context",
   "Lean.Grind.CommRing.Expr.toPoly"],
  "name": "Lean.Grind.CommRing.Stepwise.imp_1eq",
  "constType":
  "∀ {α : Type u_1} [inst : Grind.CommRing α] (ctx : Grind.CommRing.Context α) (lhs rhs : Grind.CommRing.Expr)\n  (p₁ p₂ : Grind.CommRing.Poly),\n  Grind.CommRing.Stepwise.imp_1eq_cert lhs rhs p₁ p₂ = true →\n    ↑1 * Grind.CommRing.Poly.denote ctx p₁ = Grind.CommRing.Poly.denote ctx p₂ →\n      Grind.CommRing.Expr.denote ctx lhs = Grind.CommRing.Expr.denote ctx rhs",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.word_dvd_k",
   "CellularAutomatas.Word",
   "Membership.mem",
   "Language",
   "setOf"],
  "name": "CellularAutomatas.L_dvd_k",
  "constType": "{α : Type u_1} → ℕ → Language α → Language (Option α)",
  "constCategory": "Definition"},
 {"references":
  ["Nat.add_sub_cancel_left",
   "Nat.add_comm",
   "Nat.add_assoc",
   "congrArg",
   "Exists.casesOn",
   "HAdd.hAdd",
   "Nat.add_sub_cancel",
   "Nat.le.dest",
   "LE.le",
   "HSub.hSub",
   "id",
   "Eq.symm",
   "Eq.mpr"],
  "name": "Nat.add_sub_assoc",
  "constType": "∀ {m k : ℕ}, k ≤ m → ∀ (n : ℕ), n + m - k = n + (m - k)",
  "constCategory": "Theorem"},
 {"references": ["Lean.Grind.AC.Var", "Lean.Grind.AC.Expr.casesOn"],
  "name": "Lean.Grind.AC.Expr.toSeq'.match_1",
  "constType":
  "(motive : Grind.AC.Expr → Sort u_1) →\n  (e : Grind.AC.Expr) →\n    ((x : Grind.AC.Var) → motive (Grind.AC.Expr.var x)) → ((a b : Grind.AC.Expr) → motive (a.op b)) → motive e",
  "constCategory": "Definition"},
 {"references":
  ["Int.Linear.norm_le",
   "Eq.trans",
   "Set",
   "Neg.neg",
   "Membership.mem",
   "eagerReduce",
   "HMul.hMul",
   "Lean.Grind.Int.lt_eq",
   "OfNat.ofNat",
   "Eq.mpr_prop",
   "congrArg",
   "HAdd.hAdd",
   "LT.lt",
   "NatCast.natCast",
   "congr",
   "funext",
   "LE.le",
   "id",
   "setOf",
   "List.length"],
  "name": "CellularAutomatas.scan_temporal_in_F_pos._proof_1_4",
  "constType":
  "∀ {α : Type} {w : List α}, ∀ j ∈ {i | -1 * i ≤ 0 ∧ i + -1 * ↑w.length + 1 ≤ 0}, j ∈ {i | 0 ≤ i ∧ i < ↑w.length}",
  "constCategory": "Theorem"},
 {"references": ["Lean.Omega.Coeffs", "Prod.snd", "Lean.Omega.normalize"],
  "name": "Lean.Omega.normalizeCoeffs",
  "constType": "Omega.Constraint → Omega.Coeffs → Omega.Coeffs",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Lean.Grind.AddCommMonoid.add_comm",
  "constType":
  "∀ {M : Type u} [self : Grind.AddCommMonoid M] (a b : M), a + b = b + a",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.le.below.casesOn", "eq_of_heq", "LE.le", "Eq.symm", "Eq.ndrec"],
  "name": "_private.Init.Prelude.0.Nat.le_trans.match_1_6",
  "constType":
  "∀ {n m : ℕ} (funType_1 : {k : ℕ} → n ≤ m → m ≤ k → Prop)\n  (motive :\n    (k : ℕ) → n ≤ m → (x : m ≤ k) → Nat.le.below (motive := fun {k} x => ∀ (x_1 : n ≤ m), funType_1 x_1 x) x → Prop)\n  (k : ℕ) (x : n ≤ m) (x_1 : m ≤ k)\n  (below : Nat.le.below (motive := fun {k} x => ∀ (x_2 : n ≤ m), funType_1 x_2 x) x_1),\n  (∀ (h : n ≤ m), motive m h ⋯ ⋯) →\n    (∀ (h₁ : n ≤ m) (m_1 : ℕ) (h₂ : m.le m_1)\n        (ih : Nat.le.below (motive := fun {k} x => ∀ (x_2 : n ≤ m), funType_1 x_2 x) h₂)\n        (a_ih : ∀ (x : n ≤ m), funType_1 x h₂), motive m_1.succ h₁ ⋯ ⋯) →\n      motive k x x_1 below",
  "constCategory": "Definition"},
 {"references":
  ["CellularAutomatas.CA_2n",
   "CellularAutomatas.ℒ",
   "sorryAx",
   "Set",
   "CellularAutomatas.CA_lt",
   "Language",
   "OfNat.ofNat"],
  "name": "CellularAutomatas.results_unproven.ca_linear_time_eq_2n",
  "constType":
  "∀ {α : Type} [CellularAutomatas.Alphabet α],\n  CellularAutomatas.ℒ (CellularAutomatas.CA_lt α) = CellularAutomatas.ℒ (CellularAutomatas.CA_2n α)",
  "constCategory": "Theorem"},
 {"references":
  ["Set.mem_singleton_iff",
   "Set",
   "Singleton.singleton",
   "Membership.mem",
   "propext"],
  "name": "CellularAutomatas.CellAutomaton.quiescent_of_dead._simp_1_1",
  "constType": "∀ {α : Type u} {a b : α}, (a ∈ {b}) = (a = b)",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Grind.AC.Seq.contains_k",
   "Eq.trans",
   "Nat.beq_eq",
   "congrArg",
   "beq_iff_eq._simp_1",
   "Lean.Grind.AC.Var",
   "iff_self",
   "Bool.eq_iff_iff",
   "of_eq_true",
   "Nat.beq",
   "congr",
   "id",
   "Eq.mpr",
   "BEq.beq",
   "propext"],
  "name": "Lean.Grind.AC.Seq.contains_k_var",
  "constType":
  "∀ (y x : Grind.AC.Var), (Grind.AC.Seq.var y).contains_k x = (x == y)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CellularAutomatas.composition.Params.C_adv",
  "constType":
  "(self : CellularAutomatas.composition.Params) → CellularAutomatas.CArtTransducer self.α self.β",
  "constCategory": "Definition"},
 {"references": ["LocallyFiniteOrder.finset_mem_Icc"],
  "name": "Finset.mem_Icc",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] [inst_1 : LocallyFiniteOrder α] {a b x : α}, x ∈ Finset.Icc a b ↔ a ≤ x ∧ x ≤ b",
  "constCategory": "Theorem"},
 {"references": ["Bool.casesOn", "Unit.unit", "Unit"],
  "name": "Bool.and.match_1",
  "constType":
  "(motive : Bool → Sort u_1) → (x : Bool) → (Unit → motive false) → (Unit → motive true) → motive x",
  "constCategory": "Definition"},
 {"references": ["NatCast.natCast", "OfNat.ofNat"],
  "name": "Nat.ToInt.natCast_ofNat",
  "constType": "∀ (n : ℕ), ↑(OfNat.ofNat n) = OfNat.ofNat n",
  "constCategory": "Theorem"},
 {"references":
  ["rfl",
   "Not",
   "False.elim",
   "Decidable.decide",
   "_private.Init.Core.0.decide_false.match_1_1"],
  "name": "decide_false",
  "constType": "∀ (h : Decidable False), decide False = false",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.PrettyPrinter.UnexpandM",
   "Lean.TSyntax.raw",
   "EStateM",
   "Lean.Syntax.isOfKind",
   "Lean.MonadQuotation.getCurrMacroScope",
   "Lean.MacroScope",
   "Lean.Syntax.matchesNull",
   "Lean.MonadRef.mkInfoFromRefPos",
   "Lean.MonadQuotation.getContext",
   "Lean.Name.mkStr2",
   "Unit.unit",
   "MonadExcept.throw",
   "Lean.Name.mkStr4",
   "Bind.bind",
   "Lean.SyntaxNodeKind",
   "Lean.Name.mkStr1",
   "ite",
   "Bool.or",
   "Lean.Syntax.node3",
   "cond",
   "OfNat.ofNat",
   "Unit",
   "Lean.Syntax.getArg",
   "Pure.pure",
   "Lean.withRef"],
  "name": "CellularAutomatas._aux_CellularAutomatas_defs___unexpand_Prod_1",
  "constType": "PrettyPrinter.Unexpander",
  "constCategory": "Definition"},
 {"references":
  ["Eq.trans",
   "le_of_le_of_eq",
   "Lean.Omega.LinearCombo.coordinate_eval_0",
   "Lean.Omega.Constraint.combine_sat'",
   "Decidable.decide",
   "Lean.Omega.Coeffs.ofList",
   "Lean.Omega.tidy_sat",
   "HSub.hSub",
   "Eq.symm",
   "Lean.Omega.LinearCombo.add_eval",
   "Lean.Omega.Int.lt_of_not_le",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "Int.add_one_le_of_lt",
   "of_decide_eq_true",
   "Not",
   "Neg.neg",
   "Lean.Omega.Constraint.addInequality_sat",
   "Lean.Omega.Int.add_congr",
   "Lean.Omega.Constraint.isImpossible",
   "Lean.Omega.LinearCombo.coordinate",
   "OfNat.ofNat",
   "Int.sub_nonneg_of_le",
   "Lean.Omega.LinearCombo.coordinate_eval_1",
   "HAdd.hAdd",
   "Lean.Omega.LinearCombo.sub_eval",
   "LE.le",
   "id",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.Int.sub_congr"],
  "name":
  "_private.Init.Grind.Order.0.Lean.Grind.Order.le_eq_true_of_le_k._proof_1_1",
  "constType": "∀ {k₁ k₂ : ℤ}, k₁ ≤ k₂ → ¬0 ≤ k₂ - k₁ → False",
  "constCategory": "Theorem"},
 {"references": ["Max.max", "Int.max_le", "LE.le", "propext"],
  "name":
  "_private.Init.Omega.Constraint.0.Lean.Omega.Constraint.combine_sat._simp_1_4",
  "constType": "∀ {a b c : ℤ}, (max a b ≤ c) = (a ≤ c ∧ b ≤ c)",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.propIntro",
   "eq_of_heq",
   "Eq.symm",
   "Eq.ndrec",
   "Eq.casesOn",
   "CellularAutomatas.tCellAutomatonWithAdvice.mk.noConfusion",
   "HEq.casesOn",
   "And.casesOn"],
  "name": "CellularAutomatas.tCellAutomatonWithAdvice.mk.injEq",
  "constType":
  "∀ {α : Type} (Γ : Type) [alphabetΓ : CellularAutomatas.Alphabet Γ] (adv : CellularAutomatas.Advice α Γ)\n  (C : CellularAutomatas.tCellAutomaton (α ⨉ Γ)) (Γ_1 : Type) (alphabetΓ_1 : CellularAutomatas.Alphabet Γ_1)\n  (adv_1 : CellularAutomatas.Advice α Γ_1) (C_1 : CellularAutomatas.tCellAutomaton (α ⨉ Γ_1)),\n  ({ Γ := Γ, alphabetΓ := alphabetΓ, adv := adv, C := C } =\n      { Γ := Γ_1, alphabetΓ := alphabetΓ_1, adv := adv_1, C := C_1 }) =\n    (Γ = Γ_1 ∧ alphabetΓ ≍ alphabetΓ_1 ∧ adv ≍ adv_1 ∧ C ≍ C_1)",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "eq_self",
   "of_eq_true",
   "Nat.add_succ",
   "id",
   "HSub.hSub",
   "Nat.recAux",
   "Eq.mpr",
   "Nat.sub_succ",
   "Nat.pred",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Nat.sub_sub",
  "constType": "∀ (n m k : ℕ), n - m - k = n - (m + k)",
  "constCategory": "Theorem"},
 {"references": ["String.utf8ByteSize"],
  "name": "String.rawEndPos",
  "constType": "String → String.Pos.Raw",
  "constCategory": "Definition"},
 {"references":
  ["Option.ctorIdx",
   "Lean.Omega.Constraint.casesOn",
   "Lean.Omega.UpperBound",
   "Ne",
   "Lean.Omega.LowerBound",
   "Lean.Omega.Constraint.isImpossible._sparseCasesOn_1",
   "OfNat.ofNat"],
  "name": "Lean.Omega.Constraint.isImpossible.match_1",
  "constType":
  "(motive : Omega.Constraint → Sort u_1) →\n  (x : Omega.Constraint) →\n    ((x y : ℤ) → motive { lowerBound := some x, upperBound := some y }) → ((x : Omega.Constraint) → motive x) → motive x",
  "constCategory": "Definition"},
 {"references": ["CommMagma.mul_comm"],
  "name": "mul_comm",
  "constType": "∀ {G : Type u_1} [inst : CommMagma G] (a b : G), a * b = b * a",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "Not",
   "Nat.cast",
   "Nat.sub_eq_zero_of_le",
   "Iff.mpr",
   "LE.le",
   "Iff.mp",
   "HSub.hSub",
   "Int.ofNat_eq_zero",
   "Nat.not_le",
   "OfNat.ofNat",
   "Nat.le_of_lt"],
  "name": "Lean.Omega.Int.ofNat_sub_eq_zero",
  "constType": "∀ {b a : ℕ}, ¬b ≤ a → ↑(a - b) = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans",
   "Lean.Omega.normalize_sat",
   "Lean.Omega.normalizeCoeffs",
   "Lean.Omega.Coeffs",
   "Lean.Omega.tidyCoeffs",
   "Prod.fst",
   "congrArg",
   "Lean.Omega.positivize?_eq_some",
   "Lean.Omega.positivizeConstraint",
   "Lean.Omega.positivizeCoeffs",
   "Eq.symm",
   "Eq.ndrec",
   "Lean.Omega.normalize",
   "Lean.Omega.normalizeConstraint",
   "Lean.Omega.positivize?",
   "Lean.Omega.normalize?",
   "Lean.Omega.positivize_sat",
   "Lean.Omega.tidy?.match_1",
   "_private.Init.Omega.Constraint.0.Lean.Omega.tidy?.match_1.splitter",
   "Option.getD",
   "Lean.Omega.tidyConstraint",
   "Prod.snd",
   "Unit",
   "eq_self",
   "of_eq_true",
   "Lean.Omega.normalize?_eq_some",
   "id",
   "Lean.Omega.Constraint.sat'",
   "And.casesOn"],
  "name": "Lean.Omega.tidy_sat",
  "constType":
  "∀ {s : Omega.Constraint} {x v : Omega.Coeffs},\n  s.sat' x v = true → (Omega.tidyConstraint s x).sat' (Omega.tidyCoeffs s x) v = true",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.FiniteStateTransducer.advice._proof_1",
   "CellularAutomatas.Word",
   "CellularAutomatas.FiniteStateTransducer.scanr"],
  "name": "CellularAutomatas.FiniteStateTransducer.advice",
  "constType":
  "{α β : Type} →\n  [CellularAutomatas.Alphabet α] →\n    [CellularAutomatas.Alphabet β] → CellularAutomatas.FiniteStateTransducer α β → CellularAutomatas.Advice α β",
  "constCategory": "Definition"},
 {"references": ["Not", "ite", "Option.some_eq_ite_none_left", "propext"],
  "name": "Option.some_eq_ite_none_left._simp_1",
  "constType":
  "∀ {β : Type u_1} {a : β} {p : Prop} {x : Decidable p} {b : Option β},\n  (some a = if p then none else b) = (¬p ∧ some a = b)",
  "constCategory": "Theorem"},
 {"references":
  ["rfl", "absurd", "Not", "_private.Init.Core.0.dif_neg.match_1_1", "dite"],
  "name": "dif_neg",
  "constType":
  "∀ {c : Prop} {h : Decidable c} (hnc : ¬c) {α : Sort u} {t : c → α} {e : ¬c → α}, dite c t e = e hnc",
  "constCategory": "Theorem"},
 {"references":
  ["Decidable.decide", "propext", "decide_eq_true", "of_decide_eq_true"],
  "name": "decide_eq_true_eq",
  "constType": "∀ {p : Prop} [inst : Decidable p], (decide p = true) = p",
  "constCategory": "Theorem"},
 {"references":
  ["ne_comm",
   "LT.lt",
   "Iff.trans",
   "zero_le",
   "LE.le.lt_iff_ne",
   "Ne",
   "OfNat.ofNat"],
  "name": "pos_iff_ne_zero",
  "constType":
  "∀ {α : Type u} [inst : AddZeroClass α] [inst_1 : PartialOrder α] [CanonicallyOrderedAdd α] {a : α}, 0 < a ↔ a ≠ 0",
  "constCategory": "Theorem"},
 {"references": ["of_eq_true", "Eq.mp", "Eq.mpr", "propext"],
  "name": "Lean.Grind.forall_propagator",
  "constType":
  "∀ (p : Prop) (q : p → Prop) (q' : Prop) (h₁ : p = True), q ⋯ = q' → (∀ (hp : p), q hp) = q'",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.LCellAutomaton.scan_temporal_rt",
   "CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "CellularAutomatas.Word",
   "CellularAutomatas.CArtTransducer.toLCellAutomaton",
   "CellularAutomatas.CArtTransducer.f",
   "CellularAutomatas.CellAutomaton.Q",
   "List.map",
   "CellularAutomatas.CArtTransducer.advice._proof_3"],
  "name": "CellularAutomatas.CArtTransducer.advice",
  "constType":
  "{α Γ : Type} →\n  [inst : CellularAutomatas.Alphabet α] →\n    [inst_1 : CellularAutomatas.Alphabet Γ] → CellularAutomatas.CArtTransducer α Γ → CellularAutomatas.Advice α Γ",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Dvd.dvd",
  "constType": "{α : Type u_1} → [self : Dvd α] → α → α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Not",
   "eq_self",
   "False.elim",
   "Lean.Grind.nestedDecidable",
   "Eq.trans",
   "of_eq_true",
   "id",
   "Eq.symm",
   "Eq.mpr",
   "Decidable.casesOn",
   "Eq.ndrec",
   "heq_eq_eq"],
  "name": "Lean.Grind.nestedDecidable_congr",
  "constType":
  "∀ (p q : Prop), p = q → ∀ (hp : Decidable p) (hq : Decidable q), Grind.nestedDecidable hp ≍ Grind.nestedDecidable hq",
  "constCategory": "Theorem"},
 {"references": ["Nat.casesOn", "OfNat.ofNat"],
  "name": "_private.Init.Data.Nat.Basic.0.Nat.le_add_right.match_1_1",
  "constType":
  "∀ (motive : ℕ → ℕ → Prop) (x x_1 : ℕ), (∀ (n : ℕ), motive n 0) → (∀ (n k : ℕ), motive n k.succ) → motive x x_1",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CellularAutomatas.backwards_fsm.Params.M",
  "constType":
  "(self : CellularAutomatas.backwards_fsm.Params) → CellularAutomatas.FiniteStateTransducer self.α self.β",
  "constCategory": "Definition"},
 {"references": ["congrArg"],
  "name": "congr_arg",
  "constType":
  "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Omega.IntList.mul_smul_left",
   "eq_self",
   "Eq.trans",
   "of_eq_true",
   "Lean.Omega.IntList",
   "HMul.hMul",
   "Lean.Omega.IntList.sum",
   "Lean.Omega.IntList.sum_smul",
   "congrArg"],
  "name": "Lean.Omega.IntList.dot_smul_left",
  "constType":
  "∀ (xs ys : Omega.IntList) (i : ℤ), (i * xs).dot ys = i * xs.dot ys",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.Linear.hugeFuel",
   "Nat.Linear.Poly.cancelAux",
   "Nat.Linear.Var",
   "Nat.Linear.Poly"],
  "name": "Nat.Linear.Poly.cancel",
  "constType":
  "Nat.Linear.Poly → Nat.Linear.Poly → Nat.Linear.Poly ⨉ Nat.Linear.Poly",
  "constCategory": "Definition"},
 {"references": ["And.right", "trivial", "propext"],
  "name": "true_and",
  "constType": "∀ (p : Prop), (True ∧ p) = p",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CellularAutomatas.VerificationError.details",
  "constType": "CellularAutomatas.VerificationError → List String",
  "constCategory": "Definition"},
 {"references":
  ["implies_congr",
   "Lean.Grind.AC.Seq.beq'_eq",
   "Eq.trans",
   "Lean.Grind.AC.Context.op",
   "Lean.Grind.AC.Expr.denote_toSeq",
   "Lean.Grind.AC.Seq.sort",
   "congrArg",
   "eq_self",
   "of_eq_true",
   "Lean.Grind.AC.Expr.denote",
   "id",
   "Lean.Grind.AC.Seq.denote",
   "Eq.mpr",
   "Lean.Grind.AC.Seq.beq'",
   "Eq.ndrec",
   "Lean.Grind.AC.Seq.denote_sort",
   "Lean.Grind.AC.Expr.toSeq"],
  "name": "Lean.Grind.AC.norm_ac",
  "constType":
  "∀ {α : Sort u_1} (ctx : Grind.AC.Context α) {x : Associative ctx.op} {x : Commutative ctx.op} (e : Grind.AC.Expr)\n  (s : Grind.AC.Seq), e.toSeq.sort.beq' s = true → Grind.AC.Expr.denote ctx e = Grind.AC.Seq.denote ctx s",
  "constCategory": "Theorem"},
 {"references":
  ["not_le_of_gt", "Not", "LT.lt", "imp_not_comm", "LE.le", "Iff.mp"],
  "name": "not_lt_of_ge",
  "constType": "∀ {α : Type u_1} [inst : Preorder α] {a b : α}, a ≤ b → ¬b < a",
  "constCategory": "Theorem"},
 {"references": ["Nat.mul_one", "Nat.mul_comm", "HMul.hMul", "OfNat.ofNat"],
  "name": "Nat.one_mul",
  "constType": "∀ (n : ℕ), 1 * n = n",
  "constCategory": "Theorem"},
 {"references": ["Array.emptyWithCapacity", "Array.push", "OfNat.ofNat"],
  "name": "Array.mkArray3",
  "constType": "{α : Type u} → α → α → α → Array α",
  "constCategory": "Definition"},
 {"references": ["Membership.mem", "Iff.rfl"],
  "name": "Lean.Grind.IntInterval.mem_co",
  "constType":
  "∀ (lo hi x : ℤ), x ∈ Grind.IntInterval.co lo hi ↔ lo ≤ x ∧ x < hi",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Nat.casesOn",
  "constType":
  "{motive : ℕ → Sort u} → (t : ℕ) → motive Nat.zero → ((n : ℕ) → motive n.succ) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["CellularAutomatas.TwoStageAdvice.advice",
   "Eq.trans",
   "CellularAutomatas.TwoStageAdvice.β",
   "CellularAutomatas.FiniteStateTransducer.scanr_reduce",
   "CellularAutomatas.advice_len",
   "CellularAutomatas.TwoStageAdvice.M",
   "congrArg",
   "CellularAutomatas.TwoStageAdvice.C",
   "Eq.symm",
   "CellularAutomatas.FiniteStateTransducer.advice",
   "HAppend.hAppend",
   "CellularAutomatas.Word",
   "CellularAutomatas.CArtTransducer.advice",
   "List.drop",
   "CellularAutomatas.FiniteStateTransducer.scanr_q",
   "CellularAutomatas.FiniteStateTransducer.scanr",
   "List.take_append_drop",
   "CellularAutomatas.Advice.f",
   "CellularAutomatas.rel_repr",
   "eq_self",
   "of_eq_true",
   "CellularAutomatas.FiniteStateTransducer.scanr_append_take",
   "List.take",
   "id",
   "Eq.mpr",
   "CellularAutomatas.CArtTransducer.scan_temporal_independence",
   "List.length"],
  "name": "CellularAutomatas.two_stage_rel_repr_eq",
  "constType":
  "∀ {α : Type} [inst : CellularAutomatas.Alphabet α] {Γ : Type} [inst_1 : CellularAutomatas.Alphabet Γ]\n  (adv : CellularAutomatas.TwoStageAdvice α Γ) (p s : CellularAutomatas.Word α),\n  CellularAutomatas.rel_repr CellularAutomatas.TwoStageAdvice.advice p s =\n    adv.M.scanr_q (adv.M.scanr_reduce (adv.C.advice.f (p ++ s))⟦List.length p..*⟧) (adv.C.advice.f p)",
  "constCategory": "Theorem"},
 {"references":
  ["Prod.casesOn",
   "Option.ctorIdx",
   "CellularAutomatas.CellAutomaton.Q",
   "Ne",
   "CellularAutomatas.simulation.C'._sparseCasesOn_1",
   "OfNat.ofNat",
   "CellularAutomatas.simulation.Params.C_inr"],
  "name": "CellularAutomatas.simulation.C'.match_1",
  "constType":
  "(e : CellularAutomatas.simulation.Params) →\n  (motive :\n      Option (CellularAutomatas.simulation.Q1 e ⨉ e.C_inr.Q) ⨉\n          (Option (CellularAutomatas.simulation.Q1 e ⨉ e.C_inr.Q) ⨉\n            Option (CellularAutomatas.simulation.Q1 e ⨉ e.C_inr.Q)) →\n        Sort u_1) →\n    (x :\n        Option (CellularAutomatas.simulation.Q1 e ⨉ e.C_inr.Q) ⨉\n          (Option (CellularAutomatas.simulation.Q1 e ⨉ e.C_inr.Q) ⨉\n            Option (CellularAutomatas.simulation.Q1 e ⨉ e.C_inr.Q))) →\n      ((qa : CellularAutomatas.simulation.Q1 e ⨉ e.C_inr.Q) →\n          (qb : CellularAutomatas.simulation.Q1 e) →\n            (snd : e.C_inr.Q) →\n              (qc : CellularAutomatas.simulation.Q1 e ⨉ e.C_inr.Q) → motive (some qa, some (qb, snd), some qc)) →\n        ((x :\n              Option (CellularAutomatas.simulation.Q1 e ⨉ e.C_inr.Q) ⨉\n                (Option (CellularAutomatas.simulation.Q1 e ⨉ e.C_inr.Q) ⨉\n                  Option (CellularAutomatas.simulation.Q1 e ⨉ e.C_inr.Q))) →\n            motive x) →\n          motive x",
  "constCategory": "Definition"},
 {"references":
  ["Fin.val",
   "Nat.cast",
   "CellularAutomatas.CellAutomaton.Q",
   "CellularAutomatas.Config"],
  "name": "CellularAutomatas.speedup_factor_k.to_local_config",
  "constType":
  "(k : ℕ) →\n  (C : CellularAutomatas.CellAutomaton) → CellularAutomatas.Config C.Q → CellularAutomatas.speedup_factor_k.Q' k C",
  "constCategory": "Definition"},
 {"references": ["Nat.casesOn", "OfNat.ofNat"],
  "name": "List.range'.match_1",
  "constType":
  "(motive : ℕ → ℕ → ℕ → Sort u_1) →\n  (x x_1 x_2 : ℕ) → ((x x_3 : ℕ) → motive x 0 x_3) → ((s n step : ℕ) → motive s n.succ step) → motive x x_1 x_2",
  "constCategory": "Definition"},
 {"references":
  ["Nat.Linear.Context",
   "LE.le",
   "Nat.Linear.Poly.denote",
   "Prod.snd",
   "Prod.fst",
   "Nat.Linear.Poly"],
  "name": "Nat.Linear.Poly.denote_le",
  "constType": "Nat.Linear.Context → Nat.Linear.Poly ⨉ Nat.Linear.Poly → Prop",
  "constCategory": "Definition"},
 {"references":
  ["CellularAutomatas.PrefixStableProof.t_map",
   "CellularAutomatas.PrefixStableProof.M_prod",
   "CellularAutomatas.FiniteStateTransducer.M_id",
   "CellularAutomatas.Advice.rt_closed"],
  "name": "CellularAutomatas.PrefixStableProof.ts_adv",
  "constType":
  "{α : Type} →\n  [inst : CellularAutomatas.Alphabet α] →\n    {Γ : Type} →\n      [inst_1 : CellularAutomatas.Alphabet Γ] →\n        (adv : CellularAutomatas.Advice α Γ) → adv.rt_closed → CellularAutomatas.TwoStageAdvice α Γ",
  "constCategory": "Definition"},
 {"references":
  ["Bool.and",
   "Bool.casesOn",
   "Eq.symm",
   "id",
   "Eq.ndrec",
   "Decidable.decide",
   "of_decide_eq_true"],
  "name": "Bool.and_eq_true",
  "constType": "∀ (a b : Bool), ((a && b) = true) = (a = true ∧ b = true)",
  "constCategory": "Theorem"},
 {"references": ["Eq.symm"],
  "name": "Eq.mpr",
  "constType": "{α β : Sort u} → α = β → β → α",
  "constCategory": "Definition"},
 {"references":
  ["CellularAutomatas.Advice.f",
   "CellularAutomatas.Word",
   "List.drop",
   "CellularAutomatas.Advice.shift_left_advice._proof_1",
   "List.append",
   "List.length"],
  "name": "CellularAutomatas.Advice.shift_left_advice",
  "constType":
  "{α Γ : Type} → {adv : CellularAutomatas.Advice α Γ} → CellularAutomatas.Word α → CellularAutomatas.Advice α Γ",
  "constCategory": "Definition"},
 {"references": ["Exists.casesOn", "HAdd.hAdd", "Nat.cast"],
  "name": "_private.Init.Data.Int.Order.0.Int.ofNat_le.match_1_1",
  "constType":
  "∀ {m n : ℕ} (motive : (∃ n_1, ↑m + ↑n_1 = ↑n) → Prop) (x : ∃ n_1, ↑m + ↑n_1 = ↑n),\n  (∀ (k : ℕ) (hk : ↑m + ↑k = ↑n), motive ⋯) → motive x",
  "constCategory": "Definition"},
 {"references": ["CellularAutomatas.Word", "List.map", "Prod.snd"],
  "name": "CellularAutomatas.Word.snd",
  "constType":
  "{α β : Type} → CellularAutomatas.Word (α ⨉ β) → CellularAutomatas.Word β",
  "constCategory": "Definition"},
 {"references": ["Lean.Name.mkStr1"],
  "name": "Lean.identKind",
  "constType": "SyntaxNodeKind",
  "constCategory": "Definition"},
 {"references":
  ["Eq.trans",
   "Membership.mem",
   "Classical.propDecidable",
   "HMul.hMul",
   "CellularAutomatas.middle_idx",
   "GT.gt",
   "CellularAutomatas.reachable_markers",
   "Finset.mem_Icc",
   "GE.ge",
   "CellularAutomatas.middle_reachable_card._proof_1_1",
   "HDiv.hDiv",
   "not_false_eq_true",
   "funext",
   "HSub.hSub",
   "Eq.symm",
   "CellularAutomatas.middle_reachable_card._proof_1_4",
   "Eq.ndrec",
   "Finset.filter",
   "Nat.casesAuxOn",
   "Finset.filter.congr_simp",
   "MulZeroClass.mul_zero",
   "Option.some.injEq",
   "Decidable.byContradiction",
   "HasSubset.Subset",
   "gt_iff_lt._simp_1",
   "id",
   "Eq.mpr",
   "Finset.mem_range._simp_1",
   "Eq.mp",
   "le_trans",
   "congrArg",
   "CellularAutomatas.middle_reachable_card._proof_1_2",
   "zero_le._simp_4",
   "congr",
   "ge_iff_le._simp_1",
   "propext",
   "Not",
   "Nat.card_Icc",
   "Finset.range",
   "Finset.card",
   "Finset.Icc",
   "CellularAutomatas.middle_reachable_card._proof_1_3",
   "Function.comp",
   "mul_div_cancel_left₀",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "LT.lt",
   "eq_self",
   "of_eq_true",
   "OfNat.ofNat_ne_zero._simp_1",
   "Finset.card_le_card",
   "LE.le",
   "Finset.mem_filter._simp_1"],
  "name": "CellularAutomatas.middle_reachable_card",
  "constType":
  "∀ (k : ℕ), (CellularAutomatas.reachable_markers (some ∘ CellularAutomatas.middle_idx) (2 * k)).card ≥ k",
  "constCategory": "Theorem"},
 {"references":
  ["Bind.bind",
   "Lean.MonadRef.withRef",
   "Lean.MonadRef.getRef",
   "Lean.replaceRef"],
  "name": "Lean.withRef",
  "constType":
  "{m : Type → Type} → [Monad m] → [MonadRef m] → {α : Type} → Syntax → m α → m α",
  "constCategory": "Definition"},
 {"references": ["Equiv.refl"],
  "name": "OrderDual.toDual",
  "constType": "{α : Type u_1} → α ≃ αᵒᵈ",
  "constCategory": "Definition"},
 {"references": ["HAdd.hAdd", "rfl", "OfNat.ofNat"],
  "name": "Nat.add_zero",
  "constType": "∀ (n : ℕ), n + 0 = n",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "HAdd.hAdd",
   "Lean.Grind.Nat.lt_eq",
   "Int.toNat",
   "Eq.substr",
   "Fin.val",
   "LE.le",
   "CellularAutomatas.FiniteStateTransducer.scanr_get'_eq._proof_1_2",
   "Lean.Grind.nestedProof",
   "OfNat.ofNat",
   "List.length"],
  "name": "CellularAutomatas.FiniteStateTransducer.scanr_get'_eq._proof_1_5",
  "constType":
  "∀ {α : Type} (w : List α) (i : ℤ) (h_nat_lt : i.toNat + 1 ≤ w.length), i.toNat + 1 ≤ w.length → ↑⟨i.toNat, ⋯⟩ < w.length",
  "constCategory": "Theorem"},
 {"references": ["forall_eq", "propext"],
  "name": "forall_eq._simp_1",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {a' : α}, (∀ (a : α), a = a' → p a) = p a'",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.advice_prefixes_in_L_is_two_stage_advice",
   "Set",
   "Membership.mem",
   "CellularAutomatas.CA_rt"],
  "name":
  "CellularAutomatas.results.result_advice_prefixes_in_L_is_two_stage_advice",
  "constType":
  "∀ {α : Type} [inst : CellularAutomatas.Alphabet α],\n  ∀ C ∈ CellularAutomatas.CA_rt α, (CellularAutomatas.Advice.prefixes_in_L C.L).is_two_stage_advice",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.cast",
   "Eq.trans",
   "Eq.mp",
   "Membership.mem",
   "Lean.Omega.Constraint.sat",
   "Lean.Omega.normalizeCoeffs",
   "Lean.Omega.Coeffs",
   "Lean.Omega.Constraint.impossible",
   "Prod.fst",
   "congrArg",
   "False.elim",
   "Lean.Omega.IntList",
   "congr",
   "not_true_eq_false",
   "Lean.Omega.IntList.dot",
   "Lean.Omega.Constraint.div_sat'",
   "Lean.Omega.normalizeConstraint",
   "Lean.Omega.Coeffs.gcd",
   "Lean.Omega.Constraint.div",
   "Lean.Omega.IntList.dot_eq_zero_of_left_eq_zero",
   "Not",
   "_private.Init.Omega.Constraint.0.Lean.Omega.normalize_sat._simp_1_1",
   "Lean.Omega.Constraint.trivial_say",
   "Lean.Omega.Constraint.trivial",
   "ite",
   "Option.getD",
   "Decidable.casesOn",
   "Prod.snd",
   "OfNat.ofNat",
   "eq_self",
   "of_eq_true",
   "if_neg",
   "id",
   "Eq.mpr",
   "Lean.Omega.Coeffs.dot",
   "Lean.Omega.Coeffs.sdiv",
   "Lean.Omega.Constraint.sat'",
   "if_pos"],
  "name": "Lean.Omega.normalize_sat",
  "constType":
  "∀ {s : Omega.Constraint} {x v : Omega.Coeffs},\n  s.sat' x v = true → (Omega.normalizeConstraint s x).sat' (Omega.normalizeCoeffs s x) v = true",
  "constCategory": "Theorem"},
 {"references":
  ["Int.mul_add",
   "Eq.trans",
   "Eq.mp",
   "Int.Linear.Poly.append",
   "Int.Linear.Poly.mul_k_eq_mul",
   "Int.zero_add",
   "Nat.beq_eq",
   "_private.Init.Data.Int.Linear.0.Int.Linear.Poly.denote_combine_mul_k._simp_1_2",
   "Int.Linear.Poly.denote",
   "HMul.hMul",
   "congrArg",
   "Int.Linear.Var.denote",
   "Bool.casesOn",
   "Int.zero_mul",
   "Int.Linear.Poly.mul_k",
   "Int.beq'_eq",
   "Nat.beq",
   "congr",
   "Int.mul_assoc",
   "Eq.symm",
   "Int.beq'",
   "Int.add_left_comm",
   "Eq.ndrec",
   "Int.add_assoc",
   "Nat.blt",
   "Int.Linear.Poly.denote_append",
   "Int.Linear.Poly.mul",
   "Nat.recAux",
   "Int.Linear.hugeFuel",
   "Int.Linear.Poly.casesOn",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "Int.Linear.Poly.denote_mul",
   "eq_self",
   "Int.add_mul",
   "Int.Linear.Poly.combine_mul_k",
   "Int.Linear.Context",
   "of_eq_true",
   "Int.add_comm",
   "id",
   "Eq.mpr",
   "Int.Linear.Poly.combine_mul_k'",
   "_private.Init.Data.Int.Linear.0.Int.Linear.Poly.denote_combine_mul_k._simp_1_3",
   "Int.Linear.Var"],
  "name": "Int.Linear.Poly.denote_combine_mul_k",
  "constType":
  "∀ (ctx : Int.Linear.Context) (a b : ℤ) (p₁ p₂ : Int.Linear.Poly),\n  Int.Linear.Poly.denote ctx (Int.Linear.Poly.combine_mul_k a b p₁ p₂) =\n    a * Int.Linear.Poly.denote ctx p₁ + b * Int.Linear.Poly.denote ctx p₂",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.cast",
   "Eq.trans",
   "le_of_le_of_eq",
   "Int.negSucc_eq",
   "Lean.Omega.Constraint.combine_sat'",
   "Lean.Omega.LinearCombo.coordinate_eval_0",
   "Decidable.decide",
   "Lean.Omega.LinearCombo.neg_eval",
   "Lean.Omega.Coeffs.ofList",
   "Lean.Omega.tidy_sat",
   "Eq.symm",
   "HSub.hSub",
   "Lean.Omega.LinearCombo.add_eval",
   "Lean.Omega.Int.lt_of_not_le",
   "Lean.Omega.Int.neg_congr",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "Int.add_one_le_of_lt",
   "of_decide_eq_true",
   "Not",
   "Lean.Omega.combo_sat'",
   "Neg.neg",
   "Lean.Omega.Constraint.addInequality_sat",
   "Lean.Omega.Int.add_congr",
   "Lean.Omega.Constraint.isImpossible",
   "Lean.Omega.LinearCombo.coordinate",
   "OfNat.ofNat",
   "Int.ofNat_nonneg",
   "Int.sub_nonneg_of_le",
   "Lean.Omega.LinearCombo.coordinate_eval_1",
   "HAdd.hAdd",
   "Lean.Omega.LinearCombo.sub_eval",
   "LE.le",
   "id",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.Int.sub_congr"],
  "name": "_private.Init.Data.Int.LemmasAux.0.Int.blt'_eq_true._proof_1_2",
  "constType": "∀ (a a_1 : ℕ), ¬Int.negSucc a_1 ≤ ↑a → False",
  "constCategory": "Theorem"},
 {"references": ["Membership.mem", "Set.ext", "Language"],
  "name": "Language.ext",
  "constType":
  "∀ {α : Type u_1} {l m : Language α}, (∀ (x : List α), x ∈ l ↔ x ∈ m) → l = m",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Grind.Ring.intCast",
   "Std.IsPreorder.le_refl",
   "Int.cast",
   "OfNat.ofNat",
   "congrArg",
   "HAdd.hAdd",
   "Lean.Grind.Semiring.add_zero",
   "LE.le",
   "Lean.Grind.Ring.intCast_zero",
   "id",
   "Eq.symm",
   "Eq.mpr",
   "Eq.ndrec"],
  "name": "Lean.Grind.Order.le_of_eq_1_k",
  "constType":
  "∀ {α : Type u_1} [inst : LE α] [inst_1 : LT α] [LawfulOrderLT α] [inst_3 : Std.IsPreorder α] [inst_4 : Grind.Ring α]\n  [Grind.OrderedRing α] {a b : α}, a = b → a ≤ b + ↑0",
  "constCategory": "Theorem"},
 {"references": ["Nat.casesOn", "List.casesOn", "OfNat.ofNat"],
  "name": "List.take.match_1",
  "constType":
  "{α : Type u_1} →\n  (motive : ℕ → List α → Sort u_2) →\n    (x : ℕ) →\n      (x_1 : List α) →\n        ((x : List α) → motive 0 x) →\n          ((n : ℕ) → motive n.succ []) → ((n : ℕ) → (a : α) → (as : List α) → motive n.succ (a :: as)) → motive x x_1",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Lean.Environment.checked",
  "constType": "Environment → Task Kernel.Environment",
  "constCategory": "Definition"},
 {"references":
  ["HasSubset.Subset",
   "LE.le",
   "Multiset.Nodup",
   "Quotient.mk",
   "List.Nodup.subperm",
   "Quotient.inductionOn₂",
   "Multiset",
   "Multiset.subset_of_le"],
  "name": "Multiset.le_iff_subset",
  "constType": "∀ {α : Type u_1} {s t : Multiset α}, s.Nodup → (s ≤ t ↔ s ⊆ t)",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Grind.CommRing.Mon.ofVar",
   "Lean.Grind.CommRing.Poly.ofMon",
   "Lean.Grind.CommRing.Var"],
  "name": "Lean.Grind.CommRing.Poly.ofVar",
  "constType": "Grind.CommRing.Var → Grind.CommRing.Poly",
  "constCategory": "Definition"},
 {"references":
  ["Nat.cast",
   "Eq.trans",
   "Nat.beq_eq",
   "noConfusion_of_Nat",
   "Int.casesOn",
   "eq_false'",
   "congrArg",
   "eq_self",
   "False.elim",
   "of_eq_true",
   "Nat.beq",
   "congr",
   "Int.negSucc.injEq",
   "Int.ofNat_inj._simp_1",
   "Eq.symm",
   "Int.beq'",
   "Eq.ndrec",
   "Int.noConfusion",
   "Bool.ctorIdx"],
  "name": "Int.beq'_eq",
  "constType": "∀ (a b : ℤ), (a.beq' b = true) = (a = b)",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.Word.get'",
   "Nat.cast_one",
   "Mathlib.Tactic.RingNF.add_assoc_rev",
   "Eq.trans",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "CellularAutomatas.CellAutomaton.next",
   "Membership.mem",
   "HMul.hMul",
   "CellularAutomatas.Config",
   "CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "GetElem?.getElem?",
   "funext",
   "Eq.symm",
   "CellularAutomatas.Word.range",
   "CellularAutomatas.CellAutomaton.nextt.eq_1",
   "Nat.recAux",
   "add_zero",
   "CellularAutomatas.LCellAutomaton.comp",
   "Mathlib.Tactic.Ring.atom_pf",
   "Nat.cast_zero",
   "CellularAutomatas.apply_iterated",
   "id",
   "Eq.mpr",
   "Nat.rawCast",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "List.length",
   "CellularAutomatas.Word.get'._proof_1",
   "Int.toNat",
   "Nat.cast",
   "CellularAutomatas.LcInRt.DiagonalShiftCA_comp_p0._proof_1_7",
   "CellularAutomatas.LCellAutomaton.embed",
   "congrArg",
   "pow_one",
   "CellularAutomatas.LcInRt.DiagonalShiftCA",
   "List.get",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "congr",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "CellularAutomatas.LCellAutomaton.embed_word",
   "CellularAutomatas.CellAutomaton.Q",
   "CellularAutomatas.LCellAutomaton.border",
   "Not",
   "CellularAutomatas.Word",
   "CellularAutomatas.apply_iterated.eq_1",
   "Set",
   "CellularAutomatas.CellAutomaton.nextt",
   "Mathlib.Tactic.Ring.cast_pos",
   "mul_one",
   "HPow.hPow",
   "Mathlib.Tactic.Ring.add_congr",
   "Mathlib.Tactic.RingNF.nat_rawCast_1",
   "OfNat.ofNat",
   "LT.lt",
   "HAdd.hAdd",
   "Nat.cast_add",
   "eq_self",
   "Nat.iterate",
   "of_eq_true",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "dite"],
  "name": "CellularAutomatas.LcInRt.DiagonalShiftCA_comp_p0",
  "constType":
  "∀ {α : Type} [inst : CellularAutomatas.Alphabet α] {t : ℕ} (w : CellularAutomatas.Word α),\n  (CellularAutomatas.LcInRt.DiagonalShiftCA α).comp w t 0 = w[t]?",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Nat.Linear.ExprCnstr.eq",
  "constType": "Nat.Linear.ExprCnstr → Bool",
  "constCategory": "Definition"},
 {"references": ["Bool.casesOn"],
  "name": "Bool.ctorIdx",
  "constType": "Bool → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["LT.lt",
   "Iff.mpr",
   "List.length_pos_iff",
   "Ne",
   "OfNat.ofNat",
   "List.length"],
  "name": "List.length_pos_of_ne_nil",
  "constType": "∀ {α : Type u_1} {l : List α}, l ≠ [] → 0 < l.length",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans",
   "Lean.Grind.AC.Var.denote",
   "Lean.Grind.AC.Context.op",
   "congrArg",
   "Lean.Grind.AC.Var",
   "eq_self",
   "Lean.Grind.AC.Expr.toSeq'.induct_unfolding",
   "of_eq_true",
   "congr",
   "Lean.Grind.AC.Expr.denote",
   "Lean.Grind.AC.Seq.denote",
   "Lean.Grind.AC.Expr.toSeq'",
   "Std.Associative.assoc"],
  "name": "Lean.Grind.AC.Expr.denote_toSeq'",
  "constType":
  "∀ {α : Sort u_1} (ctx : Grind.AC.Context α) {x : Associative ctx.op} (e : Grind.AC.Expr) (s : Grind.AC.Seq),\n  Grind.AC.Seq.denote ctx (e.toSeq' s) = ctx.op (Grind.AC.Expr.denote ctx e) (Grind.AC.Seq.denote ctx s)",
  "constCategory": "Theorem"},
 {"references":
  ["Quotient",
   "_private.Mathlib.Data.Multiset.Defs.0.Multiset.leInductionOn.match_1_1",
   "Setoid.r",
   "Quot.sound",
   "LE.le",
   "Quotient.mk",
   "Multiset.ofList",
   "Quotient.inductionOn₂",
   "Multiset"],
  "name": "Multiset.leInductionOn",
  "constType":
  "∀ {α : Type u_1} {C : Multiset α → Multiset α → Prop} {s t : Multiset α},\n  s ≤ t → (∀ {l₁ l₂ : List α}, l₁.Sublist l₂ → C ↑l₁ ↑l₂) → C s t",
  "constCategory": "Theorem"},
 {"references": ["Nat.casesOn", "Unit.unit", "OfNat.ofNat", "Unit"],
  "name": "_private.Init.Data.List.Range.0.List.length_range'.match_1_1",
  "constType":
  "∀ (motive : ℕ → Prop) (x : ℕ), (∀ (a : Unit), motive 0) → (∀ (n : ℕ), motive n.succ) → motive x",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Lean.Kernel.Environment.constants",
  "constType": "Kernel.Environment → ConstMap",
  "constCategory": "Definition"},
 {"references": ["Iff.rfl", "GE.ge"],
  "name": "ge_iff_le",
  "constType": "∀ {α : Type u_1} [inst : LE α] {x y : α}, x ≥ y ↔ y ≤ x",
  "constCategory": "Theorem"},
 {"references": ["Int.Linear.Poly.casesOn", "Int.Linear.Var"],
  "name": "Int.Linear.Poly.ctorIdx",
  "constType": "Int.Linear.Poly → ℕ",
  "constCategory": "Definition"},
 {"references": ["Nat.Linear.Expr.toPoly", "Nat.Linear.Poly.norm"],
  "name": "Nat.Linear.Expr.toNormPoly",
  "constType": "Nat.Linear.Expr → Nat.Linear.Poly",
  "constCategory": "Definition"},
 {"references":
  ["LT.lt",
   "_private.Init.Prelude.0.Nat.lt_or_ge.match_1_1",
   "Nat.le_succ_of_le",
   "Nat.below",
   "Nat.eq_or_lt_of_le",
   "Nat.zero_le",
   "Nat.le_refl",
   "Nat.brecOn",
   "_private.Init.Prelude.0.Nat.lt_or_ge.match_1_5",
   "GE.ge",
   "_private.Init.Prelude.0.Nat.lt_or_ge.match_1_3",
   "Unit"],
  "name": "Nat.lt_or_ge",
  "constType": "∀ (n m : ℕ), n < m ∨ n ≥ m",
  "constCategory": "Theorem"},
 {"references":
  ["sorryAx",
   "CellularAutomatas.Advice.is_two_stage_advice",
   "OfNat.ofNat",
   "CellularAutomatas.Advice.prefix_stable",
   "CellularAutomatas.Advice.rt_closed"],
  "name": "CellularAutomatas.results_unproven.prefix_stable_of_rt_closed",
  "constType":
  "∀ {α : Type} [inst : CellularAutomatas.Alphabet α] {Γ : Type} [inst_1 : CellularAutomatas.Alphabet Γ]\n  (adv : CellularAutomatas.Advice α Γ), adv.rt_closed → CellularAutomatas.Advice.prefix_stable → adv.is_two_stage_advice",
  "constCategory": "Theorem"},
 {"references": ["OfNat.ofNat_ne_zero", "eq_false", "OfNat.ofNat"],
  "name": "OfNat.ofNat_ne_zero._simp_1",
  "constType":
  "∀ {R : Type u_1} [inst : AddMonoidWithOne R] [CharZero R] (n : ℕ) [inst_2 : n.AtLeastTwo], (OfNat.ofNat n = 0) = False",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CellularAutomatas.simulation.Q1.state",
  "constType":
  "{e : CellularAutomatas.simulation.Params} → CellularAutomatas.simulation.Q1 e → e.C_ctl.Q",
  "constCategory": "Definition"},
 {"references": ["Not", "imp_false", "propext"],
  "name": "imp_false._simp_1",
  "constType": "∀ {a : Prop}, (a → False) = ¬a",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Lean.Grind.CommRing.Var",
  "constType": "Type",
  "constCategory": "Definition"},
 {"references":
  ["List.ctorIdx", "Ne", "OfNat.ofNat", "List.beq._sparseCasesOn_2"],
  "name": "List.zipWith.match_1",
  "constType":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    (motive : List α → List β → Sort u_3) →\n      (x : List α) →\n        (x_1 : List β) →\n          ((x : α) → (xs : List α) → (y : β) → (ys : List β) → motive (x :: xs) (y :: ys)) →\n            ((x : List α) → (x_2 : List β) → motive x x_2) → motive x x_1",
  "constCategory": "Definition"},
 {"references": [],
  "name": "LocallyFiniteOrder.finsetIcc",
  "constType":
  "{α : Type u_1} → {inst : Preorder α} → [self : LocallyFiniteOrder α] → α → α → Finset α",
  "constCategory": "Definition"},
 {"references": ["HAdd.hAdd", "Int.add_mul", "Eq.symm", "HMul.hMul"],
  "name":
  "_private.Init.Data.Int.Linear.0.Int.Linear.Poly.denote_combine_mul_k._simp_1_3",
  "constType": "∀ (a b c : ℤ), a * c + b * c = (a + b) * c",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.FiniteStateTransducer.compose_spec2",
   "eq_self",
   "CellularAutomatas.Word",
   "CellularAutomatas.FiniteStateTransducer.comp",
   "CellularAutomatas.FiniteStateTransducer.M_map_scanr",
   "Eq.trans",
   "of_eq_true",
   "CellularAutomatas.FiniteStateTransducer.M_map",
   "CellularAutomatas.FiniteStateTransducer.scanr",
   "List.map",
   "Function.comp",
   "congrArg"],
  "name": "CellularAutomatas.FiniteStateTransducer.map_output_spec",
  "constType":
  "∀ {α β γ : Type} [inst : CellularAutomatas.Alphabet α] [inst_1 : CellularAutomatas.Alphabet β]\n  [inst_2 : CellularAutomatas.Alphabet γ] {M : CellularAutomatas.FiniteStateTransducer α β} {g : β → γ},\n  (M.map_output g).scanr = List.map g ∘ M.scanr",
  "constCategory": "Theorem"},
 {"references": ["LE.le"],
  "name": "le_of_le_of_eq",
  "constType":
  "∀ {α : Type u_1} {a b c : α} [inst : LE α], a ≤ b → b = c → a ≤ c",
  "constCategory": "Theorem"},
 {"references":
  ["List.range'",
   "GetElem.getElem.congr_simp",
   "Eq.trans",
   "Nat.zero_add",
   "HMul.hMul",
   "List.range_eq_range'",
   "GetElem.getElem",
   "OfNat.ofNat",
   "congrArg",
   "LT.lt",
   "List.range",
   "HAdd.hAdd",
   "eq_self",
   "Nat.one_mul",
   "of_eq_true",
   "List.getElem_range'",
   "Eq.ndrec",
   "List.length"],
  "name": "List.getElem_range",
  "constType":
  "∀ {j n : ℕ} (h : j < (List.range n).length), (List.range n)[j] = j",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Lean.SMap.map₁",
  "constType":
  "{α : Type u} → {β : Type v} → [inst : BEq α] → [inst_1 : Hashable α] → SMap α β → HashMap α β",
  "constCategory": "Definition"},
 {"references": ["iff_iff_eq", "Iff.symm"],
  "name": "eq_iff_iff",
  "constType": "∀ {a b : Prop}, a = b ↔ (a ↔ b)",
  "constCategory": "Theorem"},
 {"references": ["List.below", "List.brecOn", "List.getLast?.match_1", "Unit"],
  "name": "List.foldr",
  "constType": "{α : Type u} → {β : Type v} → (α → β → β) → β → List α → β",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Kernel.Environment.header",
   "_private.Lean.Environment.0.Lean.VisibilityMap.private",
   "_private.Lean.Environment.0.Lean.Environment.base"],
  "name": "Lean.Environment.header",
  "constType": "Environment → EnvironmentHeader",
  "constCategory": "Definition"},
 {"references":
  ["absurd",
   "Not",
   "_private.Init.Core.0.Decidable.not_and_iff_or_not.match_1_3",
   "_private.Init.Core.0.Decidable.not_and_iff_or_not.match_1_1",
   "_private.Init.Core.0.Decidable.not_and_iff_or_not.match_1_5"],
  "name": "Decidable.not_and_iff_or_not",
  "constType":
  "∀ {p q : Prop} [d₁ : Decidable p] [d₂ : Decidable q], ¬(p ∧ q) ↔ ¬p ∨ ¬q",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "ReaderT",
  "constType": "Type u → (Type u → Type v) → Type u → Type (max u v)",
  "constCategory": "Definition"},
 {"references":
  ["Not",
   "Eq.trans",
   "Eq.mp",
   "id",
   "iff_true",
   "Eq.mpr",
   "eq_iff_iff._simp_1",
   "iff_false"],
  "name": "Lean.Grind.eq_false_of_imp_eq_true",
  "constType": "∀ {a b : Prop}, (a → b) = True → b = False → a = False",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.cast",
   "Eq.trans",
   "Int.ofNat_le._simp_1",
   "noConfusion_of_Nat",
   "Nat.ble_eq",
   "Int.not_le._simp_1",
   "true_iff",
   "congrArg",
   "False.elim",
   "congr",
   "Eq.symm",
   "Eq.ndrec",
   "Nat.ble",
   "Bool.ctorIdx",
   "_private.Init.Data.Int.LemmasAux.0.Int.ble'_eq_true._proof_1_2",
   "Not",
   "Int.casesOn",
   "eq_false'",
   "eq_iff_iff._simp_1",
   "Int.ble'",
   "LT.lt",
   "eq_self",
   "Decidable.byContradiction",
   "of_eq_true",
   "false_iff",
   "LE.le",
   "id",
   "Eq.mpr",
   "_private.Init.Data.Int.LemmasAux.0.Int.ble'_eq_true._proof_1_4",
   "_private.Init.Data.Int.LemmasAux.0.Int.ble'_eq_true._proof_1_3"],
  "name": "Int.ble'_eq_true",
  "constType": "∀ (a b : ℤ), (a.ble' b = true) = (a ≤ b)",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "CellularAutomatas.TwoStageAdvice.advice",
   "CellularAutomatas.PrefixStableProof.f",
   "Eq.trans",
   "of_eq_true",
   "id",
   "CellularAutomatas.PrefixStableProof.ts_adv",
   "CellularAutomatas.Advice.is_two_stage_advice",
   "CellularAutomatas.Advice.prefix_stable",
   "congrArg",
   "CellularAutomatas.Advice.rt_closed"],
  "name": "CellularAutomatas.is_two_stage_of_rt_closed_and_prefix_stable",
  "constType":
  "∀ {α : Type} [inst : CellularAutomatas.Alphabet α] {Γ : Type} [inst_1 : CellularAutomatas.Alphabet Γ]\n  (adv : CellularAutomatas.Advice α Γ), adv.rt_closed → CellularAutomatas.Advice.prefix_stable → adv.is_two_stage_advice",
  "constCategory": "Theorem"},
 {"references":
  ["beq_iff_eq._simp_1",
   "iff_self",
   "Eq.trans",
   "of_eq_true",
   "Bool.eq_iff_iff",
   "congr",
   "id",
   "Eq.mpr",
   "BEq.beq",
   "propext",
   "congrArg"],
  "name": "beq_eq_beq",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} [inst : BEq α] [LawfulBEq α] [inst_2 : BEq β] [LawfulBEq β] {a₁ a₂ : α} {b₁ b₂ : β},\n  (a₁ == a₂) = (b₁ == b₂) ↔ (a₁ = a₂ ↔ b₁ = b₂)",
  "constCategory": "Theorem"},
 {"references":
  ["Cardinal.toENatAux_zero",
   "Cardinal.toENat._proof_4",
   "Cardinal.toENat._proof_2",
   "ENat",
   "Cardinal.toENat._proof_3",
   "Cardinal.toENatAux",
   "Cardinal.toENat._proof_1",
   "Cardinal"],
  "name": "Cardinal.toENat",
  "constType": "Cardinal.{u} →+*o ℕ∞",
  "constCategory": "Definition"},
 {"references":
  ["Option.ctorIdx", "Ne", "Nat.ne_of_beq_eq_false", "OfNat.ofNat"],
  "name": "CellularAutomatas.simulation.C'._sparseCasesOn_1",
  "constType":
  "{α : Type u} →\n  {motive : Option α → Sort u_1} →\n    (t : Option α) → ((val : α) → motive (some val)) → (t.ctorIdx ≠ 1 → motive t) → motive t",
  "constCategory": "Definition"},
 {"references": ["Void"],
  "name": "EST",
  "constType": "Type → Type → Type → Type",
  "constCategory": "Definition"},
 {"references": [],
  "name": "And.left",
  "constType": "∀ {a b : Prop}, a ∧ b → a",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.Word",
   "List.extract",
   "Eq.trans",
   "DecidablePred",
   "List.map",
   "List.length_map",
   "Language",
   "Decidable.decide",
   "OfNat.ofNat",
   "congrArg",
   "HAdd.hAdd",
   "List.range",
   "implies_true",
   "eq_self",
   "List.length_range",
   "of_eq_true",
   "List.take",
   "forall_congr",
   "List.length"],
  "name": "CellularAutomatas.Advice.prefixes_in_L._proof_1",
  "constType":
  "∀ {α : Type} (L : Language α) [h : DecidablePred L] (a : CellularAutomatas.Word α),\n  (List.map (fun i => decide (L (List.take (i + 1) a))) (List.range (List.length a))).length = List.length a",
  "constCategory": "Theorem"},
 {"references": ["rfl", "id"],
  "name": "id_eq",
  "constType": "∀ {α : Sort u_1} (a : α), id a = a",
  "constCategory": "Theorem"},
 {"references": ["CellularAutomatas.VerificationError._sizeOf_1"],
  "name": "CellularAutomatas.VerificationError._sizeOf_inst",
  "constType": "SizeOf CellularAutomatas.VerificationError",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Grind.Ring.intCast",
   "Std.IsPreorder.le_refl",
   "Int.cast",
   "OfNat.ofNat",
   "congrArg",
   "HAdd.hAdd",
   "Lean.Grind.Semiring.add_zero",
   "LE.le",
   "Lean.Grind.Ring.intCast_zero",
   "id",
   "Eq.symm",
   "Eq.mpr",
   "Eq.ndrec"],
  "name": "Lean.Grind.Order.le_of_eq_2_k",
  "constType":
  "∀ {α : Type u_1} [inst : LE α] [inst_1 : LT α] [LawfulOrderLT α] [inst_3 : Std.IsPreorder α] [inst_4 : Grind.Ring α]\n  [Grind.OrderedRing α] {a b : α}, a = b → b ≤ a + ↑0",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans",
   "_private.Init.Grind.Ring.CommSolver.0.Lean.Grind.CommRing.Power.denote.match_1.eq_3",
   "HMul.hMul",
   "Lean.Grind.CommRing.Power.denote.match_1",
   "Lean.Grind.CommRing.Power.casesOn",
   "congrArg",
   "Lean.Grind.CommRing.Power.denote",
   "Eq.symm",
   "Eq.ndrec",
   "_private.Init.Grind.Ring.CommSolver.0.Lean.Grind.CommRing.Power.denote.match_1.splitter",
   "Lean.Grind.CommRing.Power.k",
   "Lean.Grind.Semiring.pow_zero",
   "HPow.hPow",
   "Lean.Grind.Semiring.one_mul",
   "OfNat.ofNat",
   "Unit",
   "Lean.Grind.CommRing.Power.x",
   "HAdd.hAdd",
   "eq_self",
   "of_eq_true",
   "Lean.Grind.Semiring.pow_succ",
   "id",
   "Lean.Grind.CommRing.Var.denote",
   "Eq.mpr",
   "Lean.Grind.CommRing.Var",
   "Lean.Grind.CommRing.Context"],
  "name": "Lean.Grind.CommRing.Power.denote_eq",
  "constType":
  "∀ {α : Type u_1} [inst : Grind.Semiring α] (ctx : Grind.CommRing.Context α) (p : Grind.CommRing.Power),\n  Grind.CommRing.Power.denote ctx p = Grind.CommRing.Var.denote ctx p.x ^ p.k",
  "constCategory": "Theorem"},
 {"references": ["Iff.mpr", "trivial", "propext"],
  "name": "iff_true",
  "constType": "∀ (p : Prop), (p ↔ True) = p",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.simulation.Params.C_ctl",
   "id",
   "CellularAutomatas.CellAutomaton.Q",
   "CellularAutomatas.simulation.Q1.noConfusion",
   "OfNat.ofNat"],
  "name": "CellularAutomatas.simulation.Q1.mk.noConfusion",
  "constType":
  "{e : CellularAutomatas.simulation.Params} →\n  (P : Sort u) →\n    (state : e.C_ctl.Q) →\n      (counter : Fin 3) →\n        (state' : e.C_ctl.Q) →\n          (counter' : Fin 3) →\n            { state := state, counter := counter } = { state := state', counter := counter' } →\n              (state = state' → counter = counter' → P) → P",
  "constCategory": "Definition"},
 {"references": ["forall_eq", "propext"],
  "name": "CellularAutomatas.CellAutomaton.quiescent_of_dead._simp_1_3",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {a' : α}, (∀ (a : α), a = a' → p a) = p a'",
  "constCategory": "Theorem"},
 {"references": ["Prod.casesOn", "Nat.Linear.Poly"],
  "name": "Nat.Linear.PolyCnstr.norm.match_1",
  "constType":
  "(motive : Nat.Linear.Poly ⨉ Nat.Linear.Poly → Sort u_1) →\n  (x : Nat.Linear.Poly ⨉ Nat.Linear.Poly) → ((lhs rhs : Nat.Linear.Poly) → motive (lhs, rhs)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["HAdd.hAdd",
   "Lean.Grind.AddCommGroup.neg_add",
   "Lean.Grind.AddCommGroup.neg_neg",
   "Neg.neg",
   "id",
   "HSub.hSub",
   "Lean.Grind.AddCommMonoid.add_comm",
   "Eq.mpr",
   "Lean.Grind.AddCommGroup.sub_eq_add_neg",
   "congrArg"],
  "name": "Lean.Grind.AddCommGroup.neg_sub",
  "constType":
  "∀ {M : Type u} [inst : Grind.AddCommGroup M] (a b : M), -(a - b) = b - a",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "eq_self",
   "Eq.trans",
   "of_eq_true",
   "Neg.neg",
   "Int.zero_add",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Int.zero_sub",
  "constType": "∀ (a : ℤ), 0 - a = -a",
  "constCategory": "Theorem"},
 {"references": ["sorryAx", "OfNat.ofNat"],
  "name": "CellularAutomatas.compress_by_3.C'",
  "constType":
  "{α : Type} → CellularAutomatas.LCellAutomaton α → CellularAutomatas.LCellAutomaton α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CellularAutomatas.tCellAutomaton.mk._flat_ctor",
  "constType":
  "{α : Type} →\n  (Q : Type) →\n    [alphabetQ : CellularAutomatas.Alphabet Q] →\n      (Q → Q → Q → Q) → (α → Q) → Q → (ℕ → ℕ) → (ℕ → ℕ) → (Q → Bool) → CellularAutomatas.tCellAutomaton α",
  "constCategory": "Definition"},
 {"references": ["List.zipWith"],
  "name": "CellularAutomatas.zip_words",
  "constType":
  "{α : Type u_1} → {β : Type u_2} → List α → List β → List (α ⨉ β)",
  "constCategory": "Definition"},
 {"references":
  ["Finset.univ",
   "Finset.map",
   "And.right",
   "Membership.mem",
   "Fintype.ofBijective.match_1",
   "Finset.mem_univ",
   "Function.Bijective",
   "Finset.mem_map_of_mem",
   "Function.Surjective",
   "Function.Injective",
   "And.left"],
  "name": "Fintype.ofBijective._proof_2",
  "constType":
  "∀ {α : Type u_2} {β : Type u_1} [inst : Fintype α] (f : α → β) (H : Function.Bijective f) (b : β),\n  b ∈ Finset.map { toFun := f, inj' := ⋯ } Finset.univ",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.propIntro",
   "Lean.Grind.CommRing.Poly.add.noConfusion",
   "Eq.symm",
   "Eq.ndrec",
   "Eq.casesOn",
   "And.casesOn"],
  "name": "Lean.Grind.CommRing.Poly.add.injEq",
  "constType":
  "∀ (k : ℤ) (v : Grind.CommRing.Mon) (p : Grind.CommRing.Poly) (k_1 : ℤ) (v_1 : Grind.CommRing.Mon)\n  (p_1 : Grind.CommRing.Poly),\n  (Grind.CommRing.Poly.add k v p = Grind.CommRing.Poly.add k_1 v_1 p_1) = (k = k_1 ∧ v = v_1 ∧ p = p_1)",
  "constCategory": "Theorem"},
 {"references":
  ["Int.toNat",
   "CellularAutomatas.FiniteStateTransducer.scanr_len",
   "Eq.mp",
   "Lean.Grind.Order.of_nat_eq",
   "eagerReduce",
   "eq_true",
   "IntCast.intCast",
   "Nat.ToInt.natCast_ofNat",
   "NatCast.natCast",
   "Neg.neg",
   "Lean.Grind.Order.eq_trans_true'",
   "CellularAutomatas.FiniteStateTransducer.scanr",
   "Lean.Grind.Order.le_of_eq_2_k",
   "Nat.ToInt.add_congr",
   "Lean.Grind.Order.le_eq_true_of_le_k",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "Nat.ToInt.le_eq",
   "of_eq_true",
   "LE.le",
   "id",
   "Lean.Grind.Order.le_trans_k",
   "CellularAutomatas.FiniteStateTransducer.scanr_get'_eq._proof_1_6",
   "Lean.Grind.Order.eq_trans_true",
   "Lean.Grind.CommRing.le_norm_expr",
   "List.length",
   "Lean.Grind.Order.eq_mp"],
  "name": "CellularAutomatas.FiniteStateTransducer.scanr_get'_eq._proof_1_7",
  "constType":
  "∀ {α β : Type} {M : CellularAutomatas.FiniteStateTransducer α β} (w : List α) (i : ℤ)\n  (h_nat_lt : i.toNat + 1 ≤ w.length), ↑⟨i.toNat, ⋯⟩ < List.length (M.scanr w)",
  "constCategory": "Theorem"},
 {"references":
  ["Set",
   "Membership.mem",
   "CellularAutomatas.Word.range",
   "CellularAutomatas.backwards_fsm.Params.α",
   "Eq.mpr_prop"],
  "name": "CellularAutomatas.backwards_fsm.inv._proof_1_2",
  "constType":
  "∀ (e : CellularAutomatas.backwards_fsm.Params) (w : List e.α),\n  ∀ p ∈ CellularAutomatas.Word.range w, p ∈ CellularAutomatas.Word.range w",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.propIntro",
   "CellularAutomatas.VerificationError.mk.noConfusion",
   "Eq.symm",
   "Eq.ndrec",
   "Eq.casesOn",
   "And.casesOn"],
  "name": "CellularAutomatas.VerificationError.mk.injEq",
  "constType":
  "∀ (module : Name) (message : String) (details : List String) (module_1 : Name) (message_1 : String)\n  (details_1 : List String),\n  ({ module := module, message := message, details := details } =\n      { module := module_1, message := message_1, details := details_1 }) =\n    (module = module_1 ∧ message = message_1 ∧ details = details_1)",
  "constCategory": "Theorem"},
 {"references": ["Nat.le_of_succ_le"],
  "name": "Nat.le_of_lt",
  "constType": "∀ {n m : ℕ}, n < m → n ≤ m",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.Advice.f",
   "CellularAutomatas.CArtTransducer.compose",
   "CellularAutomatas.Word",
   "CellularAutomatas.CArtTransducer.advice",
   "sorryAx",
   "Function.comp",
   "OfNat.ofNat"],
  "name": "CellularAutomatas.CArtTransducer.compose_spec",
  "constType":
  "∀ {α β γ : Type} [inst : CellularAutomatas.Alphabet α] [inst_1 : CellularAutomatas.Alphabet β]\n  [inst_2 : CellularAutomatas.Alphabet γ] {t1 : CellularAutomatas.CArtTransducer β γ}\n  {t2 : CellularAutomatas.CArtTransducer α β}, (t1.compose t2).advice.f = t1.advice.f ∘ t2.advice.f",
  "constCategory": "Definition"},
 {"references": [],
  "name": "OrderDual",
  "constType": "Type u_5 → Type u_5",
  "constCategory": "Definition"},
 {"references":
  ["Not",
   "Eq.trans",
   "Classical.propDecidable",
   "eq_true",
   "and_true",
   "or_true",
   "congrArg",
   "eq_self",
   "or_false",
   "and_self",
   "or_self",
   "not_false_eq_true",
   "of_eq_true",
   "congr",
   "eq_false",
   "and_false",
   "not_true_eq_false",
   "dite"],
  "name": "Lean.Grind.not_and",
  "constType": "∀ (p q : Prop), (¬(p ∧ q)) = (¬p ∨ ¬q)",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.Advice.f",
   "CellularAutomatas.Word",
   "CellularAutomatas.zip_words"],
  "name": "CellularAutomatas.Advice.annotate",
  "constType":
  "{α Γ : Type} → {adv : CellularAutomatas.Advice α Γ} → CellularAutomatas.Word α → CellularAutomatas.Word (α ⨉ Γ)",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CellularAutomatas.Advice",
  "constType": "Type → Type → Type",
  "constCategory": "Other"},
 {"references":
  ["Not",
   "LT.lt",
   "Decidable.byContradiction",
   "List.length_zipWith",
   "Min.min",
   "Eq.mp",
   "List.zipWith",
   "_private.Init.Data.List.Nat.TakeDrop.0.List.lt_length_left_of_zipWith._proof_1_1",
   "congrArg",
   "List.length"],
  "name": "List.lt_length_left_of_zipWith",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} {f : α → β → γ} {i : ℕ} {l : List α} {l' : List β},\n  i < (List.zipWith f l l').length → i < l.length",
  "constCategory": "Theorem"},
 {"references":
  ["Int.Linear.Poly.brecOn",
   "Int.Linear.Poly.denote.match_1",
   "Int.Linear.Poly.insert",
   "Int.Linear.Var",
   "Int.Linear.Poly.below"],
  "name": "Int.Linear.Poly.norm",
  "constType": "Int.Linear.Poly → Int.Linear.Poly",
  "constCategory": "Definition"},
 {"references":
  ["Int.sub_self", "id", "HSub.hSub", "Eq.mpr", "OfNat.ofNat", "congrArg"],
  "name": "Int.sub_eq_zero_of_eq",
  "constType": "∀ {a b : ℤ}, a = b → a - b = 0",
  "constCategory": "Theorem"},
 {"references": ["List.ctorIdx", "Ne", "Nat.ne_of_beq_eq_false", "OfNat.ofNat"],
  "name": "List.beq._sparseCasesOn_2",
  "constType":
  "{α : Type u} →\n  {motive : List α → Sort u_1} →\n    (t : List α) → ((head : α) → (tail : List α) → motive (head :: tail)) → (t.ctorIdx ≠ 1 → motive t) → motive t",
  "constCategory": "Definition"},
 {"references": ["List.noConfusion", "id"],
  "name": "List.cons.noConfusion",
  "constType":
  "{α : Type u} →\n  (P : Sort u_1) →\n    (head : α) →\n      (tail : List α) →\n        (head' : α) → (tail' : List α) → head :: tail = head' :: tail' → (head = head' → tail = tail' → P) → P",
  "constCategory": "Definition"},
 {"references":
  ["Nat.not_le_of_gt",
   "HAdd.hAdd",
   "Not",
   "Nat.gt_of_not_le",
   "Eq.propIntro",
   "LE.le",
   "OfNat.ofNat"],
  "name": "Nat.not_le_eq",
  "constType": "∀ (a b : ℕ), (¬a ≤ b) = (b + 1 ≤ a)",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.cast",
   "Eq.trans",
   "le_of_le_of_eq",
   "HMul.hMul",
   "Lean.Omega.LinearCombo.coordinate_eval_0",
   "Lean.Omega.Constraint.combine_sat'",
   "Decidable.decide",
   "Lean.Omega.Int.ofNat_le_of_le",
   "Lean.Omega.Coeffs.ofList",
   "Eq.symm",
   "Lean.Omega.tidy_sat",
   "HSub.hSub",
   "Lean.Omega.LinearCombo.add_eval",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "And.left",
   "of_decide_eq_true",
   "Not",
   "Lean.Omega.combo_sat'",
   "Neg.neg",
   "Lean.Omega.Constraint.addInequality_sat",
   "Lean.Omega.Int.add_congr",
   "Lean.Omega.Constraint.isImpossible",
   "Lean.Omega.LinearCombo.coordinate",
   "Int.sub_nonneg_of_le",
   "OfNat.ofNat",
   "Int.ofNat_nonneg",
   "LT.lt",
   "HAdd.hAdd",
   "Lean.Omega.LinearCombo.coordinate_eval_1",
   "Nat.le_of_not_lt",
   "Lean.Omega.LinearCombo.sub_eval",
   "LE.le",
   "Int.natCast_add",
   "id",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.Int.sub_congr"],
  "name": "CellularAutomatas.middle_reachable_card._proof_1_2",
  "constType":
  "∀ (k' : ℕ) ⦃pos : ℕ⦄, k' + 1 ≤ pos ∧ pos ≤ 2 * (k' + 1) → ¬0 < pos → False",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "Eq.propIntro",
   "CellularAutomatas.CArtTransducer.toLCellAutomaton",
   "eq_of_heq",
   "Eq.symm",
   "CellularAutomatas.CellAutomaton.Q",
   "Eq.ndrec",
   "Eq.casesOn",
   "HEq.casesOn",
   "And.casesOn",
   "CellularAutomatas.composition.Params.mk.noConfusion"],
  "name": "CellularAutomatas.composition.Params.mk.injEq",
  "constType":
  "∀ (α β : Type) [_inst_α : CellularAutomatas.Alphabet α] [_inst_β : CellularAutomatas.Alphabet β]\n  (C : CellularAutomatas.LCellAutomaton β) (C_adv : CellularAutomatas.CArtTransducer α β) (f : C_adv.Q → Option C.Q)\n  (α_1 β_1 : Type) (_inst_α_1 : CellularAutomatas.Alphabet α_1) (_inst_β_1 : CellularAutomatas.Alphabet β_1)\n  (C_1 : CellularAutomatas.LCellAutomaton β_1) (C_adv_1 : CellularAutomatas.CArtTransducer α_1 β_1)\n  (f_1 : C_adv_1.Q → Option C_1.Q),\n  ({ α := α, β := β, _inst_α := _inst_α, _inst_β := _inst_β, C := C, C_adv := C_adv, f := f } =\n      { α := α_1, β := β_1, _inst_α := _inst_α_1, _inst_β := _inst_β_1, C := C_1, C_adv := C_adv_1, f := f_1 }) =\n    (α = α_1 ∧ β = β_1 ∧ _inst_α ≍ _inst_α_1 ∧ _inst_β ≍ _inst_β_1 ∧ C ≍ C_1 ∧ C_adv ≍ C_adv_1 ∧ f ≍ f_1)",
  "constCategory": "Theorem"},
 {"references": ["Lean.Omega.positivize", "Lean.Omega.Coeffs", "Prod.snd"],
  "name": "Lean.Omega.positivizeCoeffs",
  "constType": "Omega.Constraint → Omega.Coeffs → Omega.Coeffs",
  "constCategory": "Definition"},
 {"references":
  ["HAdd.hAdd",
   "List.below",
   "Nat.blt",
   "Nat.Linear.Poly.denote.match_1",
   "Nat.beq",
   "List.brecOn",
   "cond",
   "Nat.Linear.Var",
   "Unit",
   "Nat.Linear.Poly"],
  "name": "Nat.Linear.Poly.insert",
  "constType": "ℕ → Nat.Linear.Var → Nat.Linear.Poly → Nat.Linear.Poly",
  "constCategory": "Definition"},
 {"references":
  ["Classical.choose_spec",
   "Units.val",
   "Eq.symm",
   "IsUnit",
   "Classical.choose"],
  "name": "IsUnit.unit._proof_1",
  "constType":
  "∀ {M : Type u_1} [inst : Monoid M] {a : M} (h : IsUnit a), a = ↑(Classical.choose h)",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.cast",
   "_private.Init.Grind.Ring.CommSolver.0.Lean.Grind.CommRing.Expr.toPoly.match_4.congr_eq_1",
   "_private.Init.Grind.Ring.CommSolver.0.Lean.Grind.CommRing.Expr.toPoly.match_1.congr_eq_3",
   "_private.Init.Grind.Ring.CommSolver.0.Lean.Grind.CommRing.Expr.toPoly.match_4.congr_eq_8",
   "_private.Init.Grind.Ring.CommSolver.0.Lean.Grind.CommRing.Expr.toPoly.match_1.congr_eq_1",
   "Lean.Grind.CommRing.Poly.mul",
   "_private.Init.Grind.Ring.CommSolver.0.Lean.Grind.CommRing.Expr.toPoly.match_4.congr_eq_2",
   "Lean.Grind.CommRing.Poly.ofMon",
   "Lean.Grind.CommRing.Expr.toPoly.match_4",
   "Lean.Grind.CommRing.Expr.brecOn",
   "_private.Init.Grind.Ring.CommSolver.0.Lean.Grind.CommRing.Expr.toPoly.match_1.congr_eq_4",
   "congrArg",
   "Lean.Grind.CommRing.Poly.ofVar",
   "eq_of_heq",
   "_private.Init.Grind.Ring.CommSolver.0.Lean.Grind.CommRing.Expr.toPoly.match_4.congr_eq_9",
   "Lean.Grind.CommRing.Expr.below",
   "Eq.ndrec",
   "_private.Init.Grind.Ring.CommSolver.0.Lean.Grind.CommRing.Expr.toPoly.match_4.congr_eq_3",
   "_private.Init.Grind.Ring.CommSolver.0.Lean.Grind.CommRing.Expr.toPoly.match_4.splitter",
   "Lean.Grind.CommRing.Poly.pow",
   "Lean.Grind.CommRing.Poly.combine",
   "_private.Init.Grind.Ring.CommSolver.0.Lean.Grind.CommRing.Expr.toPoly.match_1.splitter",
   "Neg.neg",
   "Lean.Grind.CommRing.Expr.toPoly.match_1",
   "_private.Init.Grind.Ring.CommSolver.0.Lean.Grind.CommRing.Expr.toPoly.match_4.congr_eq_4",
   "HPow.hPow",
   "cond",
   "Bool.dcond",
   "OfNat.ofNat",
   "_private.Init.Grind.Ring.CommSolver.0.Lean.Grind.CommRing.Expr.toPoly.match_4.congr_eq_5",
   "_private.Init.Grind.Ring.CommSolver.0.Lean.Grind.CommRing.Expr.toPoly.match_1.congr_eq_5",
   "Bool.cond_neg",
   "id",
   "Lean.Grind.CommRing.Expr.toPoly.eq_def",
   "Bool.cond_pos",
   "_private.Init.Grind.Ring.CommSolver.0.Lean.Grind.CommRing.Expr.toPoly.match_1.congr_eq_2",
   "Eq.mpr",
   "_private.Init.Grind.Ring.CommSolver.0.Lean.Grind.CommRing.Expr.toPoly.match_4.congr_eq_7",
   "_private.Init.Grind.Ring.CommSolver.0.Lean.Grind.CommRing.Expr.toPoly.match_4.congr_eq_6",
   "BEq.beq",
   "Lean.Grind.CommRing.Var",
   "Lean.Grind.CommRing.Poly.mulConst",
   "Lean.Grind.CommRing.Expr.toPoly"],
  "name": "Lean.Grind.CommRing.Expr.toPoly.induct_unfolding",
  "constType":
  "∀ (motive : Grind.CommRing.Expr → Grind.CommRing.Poly → Prop),\n  (∀ (k : ℤ), motive (Grind.CommRing.Expr.num k) (Grind.CommRing.Poly.num k)) →\n    (∀ (k : ℤ), motive (Grind.CommRing.Expr.intCast k) (Grind.CommRing.Poly.num k)) →\n      (∀ (k : ℕ), motive (Grind.CommRing.Expr.natCast k) (Grind.CommRing.Poly.num ↑k)) →\n        (∀ (x : Grind.CommRing.Var), motive (Grind.CommRing.Expr.var x) (Grind.CommRing.Poly.ofVar x)) →\n          (∀ (a b : Grind.CommRing.Expr),\n              motive a a.toPoly → motive b b.toPoly → motive (a.add b) (a.toPoly.combine b.toPoly)) →\n            (∀ (a b : Grind.CommRing.Expr),\n                motive a a.toPoly → motive b b.toPoly → motive (a.mul b) (a.toPoly.mul b.toPoly)) →\n              (∀ (a : Grind.CommRing.Expr),\n                  motive a a.toPoly → motive a.neg (Grind.CommRing.Poly.mulConst (-1) a.toPoly)) →\n                (∀ (a b : Grind.CommRing.Expr),\n                    motive a a.toPoly →\n                      motive b b.toPoly →\n                        motive (a.sub b) (a.toPoly.combine (Grind.CommRing.Poly.mulConst (-1) b.toPoly))) →\n                  (∀ (a : Grind.CommRing.Expr) (k : ℕ),\n                      (k == 0) = true → motive (a.pow k) (Grind.CommRing.Poly.num 1)) →\n                    (∀ (k : ℕ),\n                        (k == 0) = false →\n                          ∀ (n : ℤ), motive ((Grind.CommRing.Expr.num n).pow k) (Grind.CommRing.Poly.num (n ^ k))) →\n                      (∀ (k : ℕ),\n                          (k == 0) = false →\n                            ∀ (n : ℤ),\n                              motive ((Grind.CommRing.Expr.intCast n).pow k) (Grind.CommRing.Poly.num (n ^ k))) →\n                        (∀ (k : ℕ),\n                            (k == 0) = false →\n                              ∀ (n : ℕ),\n                                motive ((Grind.CommRing.Expr.natCast n).pow k) (Grind.CommRing.Poly.num (↑n ^ k))) →\n                          (∀ (k : ℕ),\n                              (k == 0) = false →\n                                ∀ (x : Grind.CommRing.Var),\n                                  motive ((Grind.CommRing.Expr.var x).pow k)\n                                    (Grind.CommRing.Poly.ofMon\n                                      (Grind.CommRing.Mon.mult { x := x, k := k } Grind.CommRing.Mon.unit))) →\n                            (∀ (a : Grind.CommRing.Expr) (k : ℕ),\n                                (k == 0) = false →\n                                  (∀ (n : ℤ), a = Grind.CommRing.Expr.num n → False) →\n                                    (∀ (n : ℤ), a = Grind.CommRing.Expr.intCast n → False) →\n                                      (∀ (n : ℕ), a = Grind.CommRing.Expr.natCast n → False) →\n                                        (∀ (x : Grind.CommRing.Var), a = Grind.CommRing.Expr.var x → False) →\n                                          motive a a.toPoly → motive (a.pow k) (a.toPoly.pow k)) →\n                              ∀ (a : Grind.CommRing.Expr), motive a a.toPoly",
  "constCategory": "Theorem"},
 {"references": ["HAdd.hAdd", "LE.le"],
  "name": "AddLeftReflectLE",
  "constType": "(M : Type u_1) → [Add M] → [LE M] → Prop",
  "constCategory": "Definition"},
 {"references":
  ["rfl",
   "List.getElem?_eq_getElem",
   "List.getLast_eq_getElem._proof_3",
   "List.getLast",
   "List.getLast_eq_getElem",
   "List.getLast?_eq_some_getLast",
   "GetElem.getElem",
   "List.getLast?",
   "OfNat.ofNat",
   "congrArg",
   "Unit",
   "LT.lt",
   "GetElem?.getElem?",
   "_private.Init.Data.List.Lemmas.0.List.getLast?_eq_getElem?.match_1_3",
   "HSub.hSub",
   "id",
   "Eq.mpr",
   "_private.Init.Data.List.Lemmas.0.List.getLast?_eq_getElem?.match_1_1",
   "List.length"],
  "name": "List.getLast?_eq_getElem?",
  "constType": "∀ {α : Type u_1} {l : List α}, l.getLast? = l[l.length - 1]?",
  "constCategory": "Theorem"},
 {"references": ["Int.casesOn", "Int.noConfusionType", "Eq.ndrec"],
  "name": "Int.noConfusion",
  "constType":
  "{P : Sort u} → {x1 x2 : ℤ} → x1 = x2 → Int.noConfusionType P x1 x2",
  "constCategory": "Definition"},
 {"references": ["HAdd.hAdd", "LE.le", "Nat.le_add_right"],
  "name": "Nat.le.intro",
  "constType": "∀ {n m k : ℕ}, n + k = m → n ≤ m",
  "constCategory": "Theorem"},
 {"references": ["Bool.and", "Bool.casesOn", "Eq.symm", "Eq.ndrec"],
  "name": "Bool.false_and",
  "constType": "∀ (b : Bool), (false && b) = false",
  "constCategory": "Theorem"},
 {"references": ["Nat.min_comm", "Min.min", "LE.le", "Nat.min_eq_left"],
  "name": "Nat.min_eq_right",
  "constType": "∀ {a b : ℕ}, b ≤ a → min a b = b",
  "constCategory": "Theorem"},
 {"references": ["Lean.Grind.AC.Var", "Bool.or'", "Nat.beq"],
  "name": "Lean.Grind.AC.Seq.contains_k",
  "constType": "Grind.AC.Seq → Grind.AC.Var → Bool",
  "constCategory": "Definition"},
 {"references":
  ["CellularAutomatas.Word",
   "CellularAutomatas.TwoStageAdvice.advice",
   "Set",
   "Membership.mem",
   "Subtype.val",
   "Set.Elem",
   "CellularAutomatas.Advice.prefixes_in_L",
   "CellularAutomatas.Advice.f",
   "CellularAutomatas.CA_rt_to_TwoStage_eq",
   "CellularAutomatas.CA_rt_to_TwoStage",
   "CellularAutomatas.CA_rt",
   "Eq.ndrec",
   "CellularAutomatas.tCellAutomaton.L",
   "List.length",
   "CellularAutomatas.advice_prefixes_in_L_is_two_stage_advice.match_1_1"],
  "name": "CellularAutomatas.advice_prefixes_in_L_is_two_stage_advice",
  "constType":
  "∀ {α : Type} [inst : CellularAutomatas.Alphabet α] (C : ↑(CellularAutomatas.CA_rt α)),\n  (CellularAutomatas.Advice.prefixes_in_L (↑C).L).is_two_stage_advice",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd", "LE.le", "AddLeftReflectLE", "ContravariantClass.elim"],
  "name": "le_of_add_le_add_left",
  "constType":
  "∀ {α : Type u_1} [inst : Add α] [inst_1 : LE α] [AddLeftReflectLE α] {a b c : α}, a + b ≤ a + c → b ≤ c",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans",
   "Singleton.singleton",
   "Membership.mem",
   "Classical.propDecidable",
   "eq_true",
   "CellularAutomatas.scan_temporal_length",
   "CellularAutomatas.CArtTransducer.f",
   "ite_cond_eq_true",
   "CellularAutomatas.advice_len",
   "CellularAutomatas.TwoStageAdvice.M",
   "List.getLast?",
   "CellularAutomatas.tCellAutomaton.toLCellAutomaton",
   "Inhabited.default",
   "CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "CellularAutomatas.FiniteStateTransducer.M_id_advice_eq",
   "CellularAutomatas.LCellAutomaton.scan_temporal_rt",
   "GetElem?.getElem?",
   "CellularAutomatas.TwoStageAdvice.C",
   "not_false_eq_true",
   "funext",
   "Eq.symm",
   "CellularAutomatas.FiniteStateTransducer.advice",
   "Finset.filter",
   "CellularAutomatas.ProdCA.scan_temporal",
   "CellularAutomatas.CArtTransducer.toLCellAutomaton",
   "CellularAutomatas.CArtTransducer.advice",
   "CellularAutomatas.PrefixStableProof.f._proof_1_6",
   "getElem?_pos",
   "Finset.filter.congr_simp",
   "CellularAutomatas.PrefixStableProof.M_prod",
   "List.map",
   "CellularAutomatas.ProdCA.zipMany_get?",
   "Option.getD",
   "Language",
   "ite_cond_eq_false",
   "Finset.toList",
   "Option.some.injEq",
   "eq_false",
   "CellularAutomatas.L_c",
   "CellularAutomatas.LCellAutomaton.scan_temporal_rt.eq_1",
   "id",
   "CellularAutomatas.PrefixStableProof.ts_adv",
   "Eq.mpr",
   "CellularAutomatas.tCellAutomaton.L",
   "getElem?_neg",
   "List.length",
   "List.getElem?_eq_getElem",
   "CellularAutomatas.scan_temporal_in_F_pos",
   "CellularAutomatas.TwoStageAdvice.advice",
   "CellularAutomatas.PrefixStableProof.t_map",
   "CellularAutomatas.ProdCA.zipMany",
   "List.getD",
   "CellularAutomatas.CALc",
   "CellularAutomatas.LCellAutomaton.scan_temporal",
   "CellularAutomatas.ProdCA",
   "CellularAutomatas.PrefixStableProof.f._proof_1_5",
   "CellularAutomatas.TwoStageAdvice.β",
   "GetElem.getElem",
   "CellularAutomatas.Advice.prefix_stable",
   "congrArg",
   "CellularAutomatas.CALc_spec_2",
   "CellularAutomatas.Advice.len",
   "congr",
   "CellularAutomatas.CellAutomaton.Q",
   "Finset.toList_singleton",
   "Option.map",
   "List.head?",
   "propext",
   "Option.map_if",
   "CellularAutomatas.Advice.rt_closed",
   "Not",
   "Finset.univ",
   "CellularAutomatas.Word",
   "ite",
   "CellularAutomatas.CArtTransducer.advice._proof_3",
   "CellularAutomatas.CALc_spec_1",
   "OfNat.ofNat",
   "List.getElem?_map",
   "CellularAutomatas.FiniteStateTransducer.M_id",
   "ite_congr",
   "HAdd.hAdd",
   "CellularAutomatas.Advice.f",
   "List.ext_getElem?",
   "LT.lt",
   "eq_self",
   "List.getD_eq_getElem?_getD",
   "CellularAutomatas.PrefixStableProof.getLastOfTake",
   "of_eq_true",
   "CellularAutomatas.Advice.ext",
   "List.take",
   "CellularAutomatas.tCellAutomaton.F_pos",
   "dite"],
  "name": "CellularAutomatas.PrefixStableProof.f",
  "constType":
  "∀ {α : Type} [inst : CellularAutomatas.Alphabet α] {Γ : Type} [inst_1 : CellularAutomatas.Alphabet Γ]\n  (adv : CellularAutomatas.Advice α Γ) (h1 : adv.rt_closed),\n  CellularAutomatas.Advice.prefix_stable → CellularAutomatas.TwoStageAdvice.advice = adv",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.cast",
   "Eq.trans",
   "congrArg",
   "HAdd.hAdd",
   "Int.le.intro",
   "Nat.le.dest",
   "LE.le",
   "Eq.symm",
   "id",
   "Int.natCast_add",
   "Eq.mpr",
   "Int.le.dest",
   "_private.Init.Data.Int.Order.0.Int.ofNat_le.match_1_1",
   "Int.ofNat.inj",
   "_private.Init.Data.Int.Order.0.Int.ofNat_le.match_1_3",
   "Nat.le.intro"],
  "name": "Int.ofNat_le",
  "constType": "∀ {m n : ℕ}, ↑m ≤ ↑n ↔ m ≤ n",
  "constCategory": "Theorem"},
 {"references":
  ["Multiset.map",
   "Multiset.Nodup.dedup",
   "SetLike.coe",
   "Finset.val",
   "Set.InjOn",
   "DecidableEq",
   "Finset.nodup",
   "Multiset.Nodup.map_on"],
  "name": "Finset.image_val_of_injOn",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} [inst : DecidableEq β] {f : α → β} {s : Finset α},\n  Set.InjOn f ↑s → (Finset.image f s).val = Multiset.map f s.val",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.Linear.Poly.norm.go", "Nat.Linear.Var", "Nat.Linear.Poly"],
  "name": "Nat.Linear.Poly.norm",
  "constType": "Nat.Linear.Poly → Nat.Linear.Poly",
  "constCategory": "Definition"},
 {"references":
  ["CellularAutomatas.Word",
   "id",
   "CellularAutomatas.Advice.noConfusion",
   "List.length"],
  "name": "CellularAutomatas.Advice.mk.noConfusion",
  "constType":
  "{α Γ : Type} →\n  (P : Sort u) →\n    (f : CellularAutomatas.Word α → CellularAutomatas.Word Γ) →\n      (len : ∀ (w : CellularAutomatas.Word α), List.length (f w) = List.length w) →\n        (f' : CellularAutomatas.Word α → CellularAutomatas.Word Γ) →\n          (len' : ∀ (w : CellularAutomatas.Word α), List.length (f' w) = List.length w) →\n            { f := f, len := len } = { f := f', len := len' } → (f = f' → P) → P",
  "constCategory": "Definition"},
 {"references":
  ["HAdd.hAdd",
   "eq_self",
   "Eq.trans",
   "of_eq_true",
   "NatCast.natCast",
   "congr",
   "congrArg"],
  "name": "Nat.ToInt.add_congr",
  "constType":
  "∀ {a b : ℕ} {a' b' : ℤ}, ↑a = a' → ↑b = b' → ↑(a + b) = a' + b'",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "CellularAutomatas.Word",
   "Eq.trans",
   "of_eq_true",
   "Set",
   "CellularAutomatas.FiniteStateTransducer.scanr_q",
   "CellularAutomatas.Word.range",
   "CellularAutomatas.FiniteStateTransducer.range_of_scanr_q",
   "CellularAutomatas.FiniteStateTransducer.q0",
   "congrArg"],
  "name": "CellularAutomatas.FiniteStateTransducer.range_of_scanr",
  "constType":
  "∀ {α β : Type} {M : CellularAutomatas.FiniteStateTransducer α β} {w : CellularAutomatas.Word α},\n  (M.scanr w).range = w.range",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "CellularAutomatas.Word",
   "CellularAutomatas.Word.cone_prop'._proof_1_2",
   "Nat.cast",
   "Set",
   "Neg.neg",
   "Membership.mem",
   "CellularAutomatas.Word.cone",
   "neg_add_rev",
   "OfNat.ofNat",
   "congrArg",
   "HAdd.hAdd",
   "LT.lt",
   "Decidable.byContradiction",
   "funext",
   "LE.le",
   "id",
   "Int.natAbs",
   "Eq.mpr",
   "setOf",
   "List.length"],
  "name": "CellularAutomatas.Word.cone_prop'",
  "constType":
  "∀ {α : Type u_1} {w : CellularAutomatas.Word α} {t : ℕ} {i d : ℤ}, i + d ∈ w.cone t → d.natAbs ≤ 1 → i ∈ w.cone (t + 1)",
  "constCategory": "Theorem"},
 {"references": ["forall_const", "propext"],
  "name": "forall_const._simp_1",
  "constType":
  "∀ {b : Prop} (α : Sort u_1) [i : Nonempty α], (∀ (a : α), b) = b",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "CellularAutomatas.PrefixStableProof.getLastOfTake._proof_1_28",
   "List.length"],
  "name": "CellularAutomatas.PrefixStableProof.getLastOfTake",
  "constType":
  "∀ {i : ℕ} {α : Type u_1} {w : List α}, i < w.length → (List.take (i + 1) w).getLast? = w[i]?",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Grind.Preorder.le_of_lt",
   "Eq.mp",
   "Std.le_refl",
   "Lean.Grind.OrderedRing.zero_lt_one",
   "Nat.recAux",
   "GE.ge",
   "OfNat.ofNat",
   "congrArg",
   "LT.lt",
   "HAdd.hAdd",
   "Lean.Grind.AddCommMonoid.zero_add",
   "LE.le",
   "Lean.Grind.Preorder.lt_of_lt_of_le",
   "id",
   "Eq.mpr",
   "Lean.Grind.OrderedAdd.add_le_left",
   "ge_iff_le._simp_1",
   "Lean.Grind.Semiring.ofNat_succ"],
  "name": "Lean.Grind.OrderedRing.ofNat_nonneg",
  "constType":
  "∀ {R : Type u} [inst : Grind.Ring R] [inst_1 : LE R] [inst_2 : LT R] [LawfulOrderLT R] [inst_4 : Std.IsPreorder R]\n  [Grind.OrderedRing R] (x : ℕ), OfNat.ofNat x ≥ 0",
  "constCategory": "Theorem"},
 {"references":
  ["Multiset.map", "Membership.mem", "Multiset.mem_map", "Multiset", "propext"],
  "name": "_private.Mathlib.Data.Finset.Image.0.Finset.mem_image._simp_1_3",
  "constType":
  "∀ {α : Type u_1} {β : Type v} {f : α → β} {b : β} {s : Multiset α}, (b ∈ Multiset.map f s) = ∃ a ∈ s, f a = b",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "Lean.Omega.LinearCombo.coeffs",
   "Lean.Omega.Coeffs",
   "Lean.Omega.LinearCombo.const",
   "Lean.Omega.Coeffs.dot"],
  "name": "Lean.Omega.LinearCombo.eval",
  "constType": "Omega.LinearCombo → Omega.Coeffs → ℤ",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Grind.Semiring.ofNat_eq_natCast",
   "Nat.cast",
   "Eq.trans",
   "Eq.mp",
   "Lean.Grind.Ring.intCast_natCast",
   "Int.blt'",
   "Int.cast",
   "Int.eq_natAbs_of_nonneg",
   "congrArg",
   "Bool.casesOn",
   "Int.blt'_eq_true",
   "Int.not_lt._simp_1",
   "Eq.symm",
   "Int.natAbs",
   "Int.blt'_eq_false",
   "Eq.ndrec",
   "Not",
   "Lean.Grind.Ring.intCast",
   "Neg.neg",
   "Lean.Grind.Ring.intCast_neg",
   "OfNat.ofNat",
   "Lean.Grind.CommRing.denoteInt",
   "LT.lt",
   "Int.eq_neg_natAbs_of_nonpos",
   "Int.le_of_lt",
   "LE.le",
   "id",
   "Eq.mpr",
   "Lean.Grind.Semiring.natCast"],
  "name": "Lean.Grind.CommRing.denoteInt_eq",
  "constType":
  "∀ {α : Type u_1} [inst : Grind.Ring α] (k : ℤ), Grind.CommRing.denoteInt k = ↑k",
  "constCategory": "Theorem"},
 {"references":
  ["Int.add_le_add_right",
   "HAdd.hAdd",
   "Int.add_le_add_left",
   "LE.le",
   "Int.le_trans"],
  "name": "Int.add_le_add",
  "constType": "∀ {a b c d : ℤ}, a ≤ b → c ≤ d → a + c ≤ b + d",
  "constCategory": "Theorem"},
 {"references": ["eq_of_heq", "heq_of_eq", "propext"],
  "name": "heq_eq_eq",
  "constType": "∀ {α : Sort u_1} (a b : α), (a ≍ b) = (a = b)",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.CellAutomaton.δ", "CellularAutomatas.CellAutomaton.Q"],
  "name": "CellularAutomatas.CellAutomaton.left_independent",
  "constType": "CellularAutomatas.CellAutomaton → Prop",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Array.emptyWithCapacity",
  "constType": "{α : Type u} → ℕ → Array α",
  "constCategory": "Definition"},
 {"references":
  ["nonpos_iff_eq_zero",
   "Iff.rfl",
   "add_zero",
   "tsub_le_iff_left",
   "OfNat.ofNat",
   "congrArg",
   "HAdd.hAdd",
   "LE.le",
   "HSub.hSub",
   "id",
   "Eq.symm",
   "Eq.mpr",
   "propext"],
  "name": "tsub_eq_zero_iff_le",
  "constType":
  "∀ {α : Type u_1} [inst : AddCommMonoid α] [inst_1 : PartialOrder α] [CanonicallyOrderedAdd α] [inst_3 : Sub α]\n  [OrderedSub α] {a b : α}, a - b = 0 ↔ a ≤ b",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "Lean.Omega.IntList",
   "Option.getD",
   "HMul.hMul",
   "List.zipWithAll",
   "OfNat.ofNat"],
  "name": "Lean.Omega.IntList.combo",
  "constType": "ℤ → Omega.IntList → ℤ → Omega.IntList → Omega.IntList",
  "constCategory": "Definition"},
 {"references":
  ["rfl",
   "HAdd.hAdd",
   "LT.lt",
   "_private.Init.GetElem.0.List.getElem_cons_drop.match_1_1",
   "List.below",
   "List.drop",
   "List.brecOn",
   "Iff.mp",
   "GetElem.getElem",
   "OfNat.ofNat",
   "Nat.add_one_lt_add_one_iff",
   "List.length"],
  "name": "List.getElem_cons_drop",
  "constType":
  "∀ {α : Type u_1} {as : List α} {i : ℕ} (h : i < as.length), as[i] :: as⟦i + 1..*⟧ = as⟦i..*⟧",
  "constCategory": "Theorem"},
 {"references": ["LT.lt", "Fin.val", "Fin.is_lt", "eq_true"],
  "name": "Fin.is_lt._simp_1",
  "constType": "∀ {n : ℕ} (a : Fin n), (↑a < n) = True",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Lean.MacroScopesView.ctx",
  "constType": "MacroScopesView → Name",
  "constCategory": "Definition"},
 {"references":
  ["CellularAutomatas.FiniteStateTransducer.comp",
   "CellularAutomatas.FiniteStateTransducer.M_map"],
  "name": "CellularAutomatas.FiniteStateTransducer.map_output",
  "constType":
  "{α β γ : Type} →\n  [CellularAutomatas.Alphabet α] →\n    [CellularAutomatas.Alphabet β] →\n      [CellularAutomatas.Alphabet γ] →\n        CellularAutomatas.FiniteStateTransducer α β → (β → γ) → CellularAutomatas.FiniteStateTransducer α γ",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Omega.Constraint.upperBound",
   "Lean.Omega.UpperBound.sat",
   "Lean.Omega.Constraint.lowerBound",
   "Lean.Omega.LowerBound.sat",
   "Decidable.decide"],
  "name": "Lean.Omega.Constraint.sat",
  "constType": "Omega.Constraint → ℤ → Bool",
  "constCategory": "Definition"},
 {"references": [],
  "name": "WithTop",
  "constType": "Type u_2 → Type u_2",
  "constCategory": "Definition"},
 {"references":
  ["rfl",
   "Nat.zero_sub",
   "Trans.trans",
   "List.drop",
   "_private.Init.Data.List.TakeDrop.0.List.length_drop.match_1_1",
   "Nat.brecOn",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "Nat.below",
   "HSub.hSub",
   "Eq.symm",
   "Nat.succ_sub_succ_eq_sub",
   "List.length"],
  "name": "List.length_drop",
  "constType":
  "∀ {α : Type u_1} {i : ℕ} {l : List α}, l⟦i..*⟧.length = l.length - i",
  "constCategory": "Theorem"},
 {"references":
  ["List.getElem?_cons",
   "Nat.not_lt_zero._simp_1",
   "GetElem.getElem.congr_simp",
   "Eq.trans",
   "exists_const._simp_1",
   "noConfusion_of_Nat",
   "GetElem.getElem",
   "not_exists._simp_1",
   "congrArg",
   "GetElem?.getElem?",
   "Option.ctorIdx",
   "not_false_eq_true",
   "False.elim",
   "iff_self",
   "congr",
   "HSub.hSub",
   "Eq.ndrec",
   "_private.Init.Data.List.Lemmas.0.List.getElem?_eq_some_iff.match_1_3",
   "_private.Init.Data.List.Lemmas.0.List.getElem?_eq_some_iff.match_1_1",
   "propext",
   "Not",
   "ite",
   "Nat.lt_of_succ_lt_succ",
   "eq_false'",
   "Decidable.casesOn",
   "Nat.brecOn",
   "OfNat.ofNat",
   "Unit",
   "exists_prop_congr",
   "Option.some.injEq",
   "_private.Init.Data.List.Lemmas.0.List.getElem?_eq_some_iff._simp_1_5",
   "HAdd.hAdd",
   "LT.lt",
   "if_neg",
   "Iff.of_eq",
   "of_eq_true",
   "forall_false",
   "false_iff",
   "Iff.mpr",
   "Nat.below",
   "id",
   "Eq.mpr",
   "Nat.zero_lt_succ._simp_1",
   "getElem?_neg",
   "if_pos",
   "List.length"],
  "name": "List.getElem?_eq_some_iff",
  "constType":
  "∀ {α : Type u_1} {i : ℕ} {a : α} {l : List α}, l[i]? = some a ↔ ∃ (h : i < l.length), l[i] = a",
  "constCategory": "Theorem"},
 {"references": ["Set", "Membership.mem"],
  "name": "Set.Elem",
  "constType": "{α : Type u} → Set α → Type u",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Inhabited.default",
  "constType": "{α : Sort u} → [self : Inhabited α] → α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CellularAutomatas.VerificationError.message",
  "constType": "CellularAutomatas.VerificationError → String",
  "constCategory": "Definition"},
 {"references": ["Subsingleton.elim", "Eq.ndrec", "Decidable.decide"],
  "name": "Decidable.decide.congr_simp",
  "constType":
  "∀ (p p_1 : Prop), p = p_1 → ∀ {h : Decidable p} [h_1 : Decidable p_1], decide p = decide p_1",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Grind.AC.Var",
   "Lean.Grind.AC.Seq.insert",
   "Nat.blt",
   "Lean.Grind.AC.Seq.concat"],
  "name": "Lean.Grind.AC.Seq.unionFuel_k",
  "constType": "ℕ → Grind.AC.Seq → Grind.AC.Seq → Grind.AC.Seq",
  "constCategory": "Definition"},
 {"references": [],
  "name": "False.elim",
  "constType": "{C : Sort u} → False → C",
  "constCategory": "Definition"},
 {"references": ["List.reverseAux"],
  "name": "List.reverse",
  "constType": "{α : Type u} → List α → List α",
  "constCategory": "Definition"},
 {"references":
  ["CellularAutomatas.Word.get'",
   "implies_congr",
   "Eq.trans",
   "Lean.Grind.Order.eq_trans_false",
   "CellularAutomatas.scan_temporal_in_F_pos._proof_1_4",
   "Membership.mem",
   "HMul.hMul",
   "eagerReduce",
   "eq_true",
   "Lean.Grind.intro_with_eq'",
   "IntCast.intCast",
   "GE.ge",
   "Nat.ToInt.natCast_ofNat",
   "CellularAutomatas.tCellAutomaton.toLCellAutomaton",
   "CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "NatCast.natCast",
   "funext",
   "Lean.Grind.eq_false_of_imp_eq_true",
   "Eq.symm",
   "Neg.neg",
   "Lean.Grind.eq_true_of_and_eq_true_right",
   "Lean.Grind.Int.lt_eq",
   "Lean.Grind.nestedProof",
   "Classical.byContradiction",
   "id",
   "Lean.Grind.Order.le_trans_k",
   "Lean.Grind.Order.le_eq_false_of_le_k",
   "List.length",
   "setOf",
   "Int.Linear.norm_le",
   "Nat.cast",
   "CellularAutomatas.tCellAutomaton.t",
   "Eq.mp",
   "Lean.Grind.and_eq_of_eq_true_right",
   "CellularAutomatas.LCellAutomaton.embed",
   "congrArg",
   "Lean.Grind.imp_eq_of_eq_true_left",
   "Lean.Grind.Nat.lt_eq",
   "congr",
   "CellularAutomatas.CellAutomaton.Q",
   "CellularAutomatas.LCellAutomaton.border",
   "Not",
   "CellularAutomatas.Word",
   "Set.mem_setOf_eq",
   "Lean.Grind.Order.eq_trans_true'",
   "Set",
   "Nat.ToInt.add_congr",
   "OfNat.ofNat",
   "Eq.mpr_prop",
   "LT.lt",
   "HAdd.hAdd",
   "Nat.ToInt.le_eq",
   "of_eq_true",
   "Min.min",
   "LE.le",
   "Lean.Grind.intro_with_eq",
   "Lean.Grind.CommRing.le_norm_expr",
   "Lean.Grind.Order.eq_mp",
   "And.casesOn"],
  "name": "CellularAutomatas.scan_temporal_in_F_pos._proof_1_5",
  "constType":
  "∀ {α : Type} {C : CellularAutomatas.tCellAutomaton α} {w : CellularAutomatas.Word α},\n  ∀ i < List.length w,\n    i < List.length w →\n      ∀ (j : ℤ) (h1 : j ∈ {i | i ≥ 0 ∧ i < ↑(List.length w)}),\n        i < List.length w →\n          i + 1 ≤ List.length w →\n            C.t (min (i + 1) (List.length w)) = i →\n              -↑i ≤ j ∧ j ≤ ↑i → (0 ≤ j → j < ↑i + 1 → ↑(List.length w) ≤ j) → C.embed (w.get' j h1) = C.border",
  "constCategory": "Theorem"},
 {"references":
  ["rfl",
   "HAdd.hAdd",
   "Int.toNat",
   "Nat.cast",
   "LE.le",
   "Int.eq_ofNat_of_zero_le",
   "_private.Init.Data.Int.Order.0.Int.toNat_add.match_1_1",
   "OfNat.ofNat"],
  "name": "Int.toNat_add",
  "constType": "∀ {a b : ℤ}, 0 ≤ a → 0 ≤ b → (a + b).toNat = a.toNat + b.toNat",
  "constCategory": "Theorem"},
 {"references":
  ["Or.elim",
   "Lean.Omega.LinearCombo.coordinate_eval_2",
   "Nat.cast",
   "Eq.trans",
   "le_of_le_of_eq",
   "Lean.Omega.LinearCombo.coordinate_eval_3",
   "CellularAutomatas.Advice.annotate",
   "Lean.Omega.LinearCombo.coordinate_eval_0",
   "Lean.Omega.Constraint.combine_sat'",
   "Int.sub_eq_zero_of_eq",
   "Decidable.decide",
   "Lean.Omega.Int.ofNat_le_of_le",
   "Lean.Omega.Coeffs.ofList",
   "Lean.Omega.Int.ofNat_sub_dichotomy",
   "HSub.hSub",
   "Lean.Omega.tidy_sat",
   "Eq.symm",
   "Lean.Omega.LinearCombo.add_eval",
   "Int.add_one_le_of_lt",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "And.left",
   "of_decide_eq_true",
   "Not",
   "Lean.Omega.combo_sat'",
   "Neg.neg",
   "And.right",
   "Lean.Omega.Constraint.addInequality_sat",
   "Lean.Omega.Int.ofNat_congr",
   "Lean.Omega.Int.add_congr",
   "Lean.Omega.Constraint.isImpossible",
   "Lean.Omega.LinearCombo.coordinate",
   "Int.ofNat_nonneg",
   "Int.sub_nonneg_of_le",
   "OfNat.ofNat",
   "Lean.Omega.LinearCombo.coordinate_eval_1",
   "LT.lt",
   "HAdd.hAdd",
   "Nat.le_of_not_lt",
   "Lean.Omega.Int.ofNat_lt_of_lt",
   "Lean.Omega.LinearCombo.sub_eval",
   "LE.le",
   "Int.natCast_add",
   "id",
   "Lean.Omega.Constraint.addEquality_sat",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.Int.sub_congr",
   "List.length"],
  "name": "CellularAutomatas.LcInRt.O_L_eq_L_c._proof_1_5",
  "constType":
  "∀ {α Γ : Type} (adv : CellularAutomatas.Advice α Γ) (w : List α),\n  List.length (CellularAutomatas.Advice.annotate w) = w.length →\n    ∀ (n : ℕ),\n      w.length = n + 1 →\n        ¬List.length (CellularAutomatas.Advice.annotate w) - 1 < List.length (CellularAutomatas.Advice.annotate w) →\n          False",
  "constCategory": "Theorem"},
 {"references": ["Lean.Omega.normalize?", "Option.getD", "Lean.Omega.Coeffs"],
  "name": "Lean.Omega.normalize",
  "constType":
  "Omega.Constraint ⨉ Omega.Coeffs → Omega.Constraint ⨉ Omega.Coeffs",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Unit.unit",
  "constType": "Unit",
  "constCategory": "Definition"},
 {"references": ["Nat.cast"],
  "name": "Mathlib.Meta.NormNum.IsNat.casesOn",
  "constType":
  "{α : Type u} →\n  [inst : AddMonoidWithOne α] →\n    {a : α} →\n      {n : ℕ} →\n        {motive : Mathlib.Meta.NormNum.IsNat a n → Sort u_1} →\n          (t : Mathlib.Meta.NormNum.IsNat a n) → ((out : a = ↑n) → motive ⋯) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["Nat.cast",
   "Eq.trans",
   "le_of_le_of_eq",
   "Int.negSucc_eq",
   "Lean.Omega.Constraint.combine_sat'",
   "Lean.Omega.LinearCombo.coordinate_eval_0",
   "Decidable.decide",
   "Lean.Omega.LinearCombo.neg_eval",
   "Lean.Omega.Coeffs.ofList",
   "Eq.symm",
   "Lean.Omega.tidy_sat",
   "HSub.hSub",
   "Lean.Omega.LinearCombo.add_eval",
   "Lean.Omega.Int.neg_congr",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "Int.add_one_le_of_lt",
   "of_decide_eq_true",
   "Neg.neg",
   "Lean.Omega.Constraint.addInequality_sat",
   "Lean.Omega.Int.add_congr",
   "Lean.Omega.Constraint.isImpossible",
   "Lean.Omega.LinearCombo.coordinate",
   "OfNat.ofNat",
   "Int.ofNat_nonneg",
   "Int.sub_nonneg_of_le",
   "LT.lt",
   "HAdd.hAdd",
   "Lean.Omega.LinearCombo.sub_eval",
   "id",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.Int.sub_congr"],
  "name":
  "_private.Init.Grind.Ordered.Ring.0.Lean.Grind.OrderedRing.pos_intCast_of_pos._proof_1_1",
  "constType": "∀ (a : ℕ), 0 < Int.negSucc a → False",
  "constCategory": "Theorem"},
 {"references": ["Nat.casesOn"],
  "name": "Nat.ctorIdx",
  "constType": "ℕ → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["HAdd.hAdd",
   "Nat.casesOn",
   "List.casesOn",
   "LE.le",
   "OfNat.ofNat",
   "List.length"],
  "name": "_private.Init.Data.List.Basic.0.List.drop_eq_nil_of_le.match_1_1",
  "constType":
  "∀ {α : Type u_1} (motive : (as : List α) → (i : ℕ) → as.length ≤ i → Prop) (as : List α) (i : ℕ) (h : as.length ≤ i),\n  (∀ (i : ℕ) (h : [].length ≤ i), motive [] i h) →\n    (∀ (head : α) (tail : List α) (h : (head :: tail).length ≤ 0), motive (head :: tail) 0 h) →\n      (∀ (head : α) (as : List α) (i : ℕ) (h : (head :: as).length ≤ i + 1), motive (head :: as) i.succ h) →\n        motive as i h",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Iff.refl",
  "constType": "∀ (a : Prop), a ↔ a",
  "constCategory": "Theorem"},
 {"references": ["Lean.Name.below", "Lean.Name.brecOn.go"],
  "name": "Lean.Name.brecOn",
  "constType":
  "{motive : Name → Sort u} → (t : Name) → ((t : Name) → Name.below t → motive t) → motive t",
  "constCategory": "Definition"},
 {"references": ["HAdd.hAdd", "OfNat.ofNat"],
  "name": "Nat.recAux",
  "constType":
  "{motive : ℕ → Sort u} → motive 0 → ((n : ℕ) → motive n → motive (n + 1)) → (t : ℕ) → motive t",
  "constCategory": "Definition"},
 {"references": ["Nat.brecOn.go", "Nat.below"],
  "name": "Nat.brecOn",
  "constType":
  "{motive : ℕ → Sort u} → (t : ℕ) → ((t : ℕ) → Nat.below t → motive t) → motive t",
  "constCategory": "Definition"},
 {"references": ["Std.TreeSet.ofList", "Lean.Name.quickCmp"],
  "name": "Lean.NameSet.ofList",
  "constType": "List Name → NameSet",
  "constCategory": "Definition"},
 {"references":
  ["Int.Linear.norm_le",
   "CellularAutomatas.Word.get'._proof_1",
   "Int.toNat",
   "Eq.trans",
   "Set",
   "Neg.neg",
   "Membership.mem",
   "eagerReduce",
   "HMul.hMul",
   "Int.Linear.Expr.eq_of_norm_eq",
   "Lean.Grind.Int.lt_eq",
   "OfNat.ofNat",
   "congrArg",
   "Eq.mpr_prop",
   "HAdd.hAdd",
   "LT.lt",
   "NatCast.natCast",
   "congr",
   "funext",
   "LE.le",
   "id",
   "setOf",
   "List.length"],
  "name": "CellularAutomatas.LcInRt.DiagonalShiftCA_comp_p0._proof_1_2",
  "constType":
  "∀ {α : Type} {t : ℕ} (w : List α), ↑t ∈ {i | -1 * i ≤ 0 ∧ i + -1 * ↑w.length + 1 ≤ 0} → (↑t).toNat < w.length",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "CellularAutomatas.Word",
   "CellularAutomatas.CellAutomaton.nextt",
   "CellularAutomatas.LCellAutomaton.embed_word"],
  "name": "CellularAutomatas.LCellAutomaton.comp",
  "constType":
  "{α : Type} → (C : CellularAutomatas.LCellAutomaton α) → CellularAutomatas.Word α → ℕ → CellularAutomatas.Config C.Q",
  "constCategory": "Definition"},
 {"references":
  ["CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "CellularAutomatas.CArtTransducer.casesOn",
   "CellularAutomatas.CellAutomaton.Q",
   "CellularAutomatas.CArtTransducer.noConfusionType",
   "Eq.ndrec"],
  "name": "CellularAutomatas.CArtTransducer.noConfusion",
  "constType":
  "{α Γ : Type} →\n  [inst : CellularAutomatas.Alphabet α] →\n    [inst_1 : CellularAutomatas.Alphabet Γ] →\n      {P : Sort u} →\n        {x1 x2 : CellularAutomatas.CArtTransducer α Γ} →\n          x1 = x2 → CellularAutomatas.CArtTransducer.noConfusionType P x1 x2",
  "constCategory": "Definition"},
 {"references": ["Lean.PersistentHashMap.root"],
  "name": "Lean.PersistentHashMap.foldlM",
  "constType":
  "{m : Type w → Type w'} →\n  [Monad m] →\n    {σ : Type w} →\n      {α : Type u_1} →\n        {β : Type u_2} → {x : BEq α} → {x_1 : Hashable α} → PersistentHashMap α β → (σ → α → β → m σ) → σ → m σ",
  "constCategory": "Definition"},
 {"references":
  ["CellularAutomatas.VerificationError.noConfusionType",
   "CellularAutomatas.VerificationError.casesOn",
   "Eq.ndrec"],
  "name": "CellularAutomatas.VerificationError.noConfusion",
  "constType":
  "{P : Sort u} →\n  {x1 x2 : CellularAutomatas.VerificationError} → x1 = x2 → CellularAutomatas.VerificationError.noConfusionType P x1 x2",
  "constCategory": "Definition"},
 {"references":
  ["Int.mul_add",
   "Eq.trans",
   "Int.Linear.Poly.mul'",
   "Int.Linear.Poly.denote",
   "HMul.hMul",
   "congrArg",
   "Int.Linear.Var.denote",
   "Int.zero_mul",
   "Int.mul_assoc",
   "Not",
   "ite",
   "Int.Linear.Poly.mul",
   "Decidable.casesOn",
   "OfNat.ofNat",
   "ite_congr",
   "beq_iff_eq._simp_1",
   "HAdd.hAdd",
   "eq_self",
   "Int.Linear.Context",
   "if_neg",
   "of_eq_true",
   "id",
   "Eq.mpr",
   "BEq.beq",
   "Int.Linear.Var",
   "if_pos"],
  "name": "Int.Linear.Poly.denote_mul",
  "constType":
  "∀ (ctx : Int.Linear.Context) (p : Int.Linear.Poly) (k : ℤ),\n  Int.Linear.Poly.denote ctx (p.mul k) = k * Int.Linear.Poly.denote ctx p",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CellularAutomatas.tCellAutomatonWithAdvice.rec",
  "constType":
  "{α : Type} →\n  {motive : CellularAutomatas.tCellAutomatonWithAdvice α → Sort u} →\n    ((Γ : Type) →\n        [alphabetΓ : CellularAutomatas.Alphabet Γ] →\n          (adv : CellularAutomatas.Advice α Γ) →\n            (C : CellularAutomatas.tCellAutomaton (α ⨉ Γ)) →\n              motive { Γ := Γ, alphabetΓ := alphabetΓ, adv := adv, C := C }) →\n      (t : CellularAutomatas.tCellAutomatonWithAdvice α) → motive t",
  "constCategory": "Other"},
 {"references":
  ["CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "CellularAutomatas.CArtTransducer.toLCellAutomaton",
   "CellularAutomatas.backwards_fsm.Params.C",
   "CellularAutomatas.backwards_fsm.Params.β",
   "CellularAutomatas.backwards_fsm.Params.inst3",
   "CellularAutomatas.backwards_fsm.Params.M",
   "CellularAutomatas.FiniteStateTransducer.Q",
   "CellularAutomatas.CellAutomaton.Q",
   "CellularAutomatas.backwards_fsm.Params.inst2",
   "CellularAutomatas.backwards_fsm.Params.α",
   "CellularAutomatas.backwards_fsm.Params.γ",
   "CellularAutomatas.backwards_fsm.M'"],
  "name": "CellularAutomatas.backwards_fsm.M'.eq_1",
  "constType":
  "∀ (e : CellularAutomatas.backwards_fsm.Params),\n  CellularAutomatas.backwards_fsm.M' e =\n    CellularAutomatas.FiniteStateTransducer.M_map e.C.f ⊚ CellularAutomatas.backwards_fsm.M_join e.M.M_projQ",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Grind.Ring.intCast",
   "Lean.Grind.OrderedAdd.add_le_left_iff",
   "Eq.trans",
   "Eq.mp",
   "Lean.Grind.Order.le_trans",
   "Iff.mp",
   "eq_true",
   "_private.Init.Grind.Order.0.Lean.Grind.Order.le_trans_k._simp_1_1",
   "Int.cast",
   "congrArg",
   "beq_iff_eq._simp_1",
   "HAdd.hAdd",
   "Lean.Grind.Ring.intCast_add",
   "of_eq_true",
   "LE.le",
   "Eq.symm",
   "BEq.beq",
   "Eq.ndrec"],
  "name": "Lean.Grind.Order.le_trans_k",
  "constType":
  "∀ {α : Type u_1} [inst : LE α] [inst_1 : LT α] [LawfulOrderLT α] [inst_3 : Std.IsPreorder α] [inst_4 : Grind.Ring α]\n  [Grind.OrderedRing α] {a b c : α} {k₁ k₂ : ℤ} (k : ℤ), a ≤ b + ↑k₁ → b ≤ c + ↑k₂ → (k == k₂ + k₁) = true → a ≤ c + ↑k",
  "constCategory": "Theorem"},
 {"references": ["Option.casesOn", "Lean.ModuleIdx", "Unit.unit", "Unit"],
  "name": "CellularAutomatas.getModuleConstants.match_1",
  "constType":
  "(motive : Option ModuleIdx → Sort u_1) →\n  (moduleIdx : Option ModuleIdx) → ((idx : ModuleIdx) → motive (some idx)) → (Unit → motive none) → motive moduleIdx",
  "constCategory": "Definition"},
 {"references": ["And.comm"],
  "name": "and_comm",
  "constType": "∀ {a b : Prop}, a ∧ b ↔ b ∧ a",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "setOf",
  "constType": "{α : Type u} → (α → Prop) → Set α",
  "constCategory": "Definition"},
 {"references": ["cond.match_1", "Unit"],
  "name": "Bool.not",
  "constType": "Bool → Bool",
  "constCategory": "Definition"},
 {"references":
  ["AddLeftMono", "Nat.strictMono_cast", "Nat.cast", "StrictMono.lt_iff_lt"],
  "name": "Nat.cast_lt",
  "constType":
  "∀ {α : Type u_1} [inst : AddMonoidWithOne α] [inst_1 : PartialOrder α] [AddLeftMono α] [ZeroLEOneClass α] [CharZero α]\n  {m n : ℕ}, ↑m < ↑n ↔ m < n",
  "constCategory": "Theorem"},
 {"references": ["DecidableEq"],
  "name": "CellularAutomatas.instAlphabetOfDecidableEqOfFintypeOfInhabited",
  "constType":
  "(α : Type) → [DecidableEq α] → [Fintype α] → [Inhabited α] → CellularAutomatas.Alphabet α",
  "constCategory": "Definition"},
 {"references":
  ["List.range'",
   "Eq.trans",
   "Nat.succ_lt_succ_iff",
   "getElem?_pos",
   "Iff.mp",
   "HMul.hMul",
   "Nat.add_comm",
   "GetElem.getElem",
   "Nat.brecOn",
   "Nat.add_assoc",
   "OfNat.ofNat",
   "congrArg",
   "LT.lt",
   "HAdd.hAdd",
   "eq_self",
   "GetElem?.getElem?",
   "_private.Init.Data.List.Range.0.List.getElem?_range'.match_1_1",
   "List.length_range'",
   "of_eq_true",
   "congr",
   "Nat.below",
   "id",
   "Nat.zero_lt_succ._simp_1",
   "List.length"],
  "name": "List.getElem?_range'",
  "constType":
  "∀ {s step i n : ℕ}, i < n → (List.range' s n step)[i]? = some (s + step * i)",
  "constCategory": "Theorem"},
 {"references": ["Nat.beq_refl", "Nat.beq", "Nat.eq_of_beq_eq_true", "propext"],
  "name": "Nat.beq_eq",
  "constType": "∀ {x y : ℕ}, (x.beq y = true) = (x = y)",
  "constCategory": "Theorem"},
 {"references": ["Lean.Name.mkStr1"],
  "name": "Lean.nullKind",
  "constType": "SyntaxNodeKind",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Grind.AC.Expr.denote_toSeq'",
   "Eq.trans",
   "Lean.Grind.AC.Var.denote",
   "Lean.Grind.AC.Context.op",
   "congrArg",
   "Lean.Grind.AC.Var",
   "eq_self",
   "of_eq_true",
   "Lean.Grind.AC.Expr.denote",
   "Lean.Grind.AC.Seq.denote",
   "Lean.Grind.AC.Expr.toSeq.induct_unfolding",
   "Lean.Grind.AC.Expr.toSeq'",
   "Lean.Grind.AC.Expr.toSeq"],
  "name": "Lean.Grind.AC.Expr.denote_toSeq",
  "constType":
  "∀ {α : Sort u_1} (ctx : Grind.AC.Context α) {x : Associative ctx.op} (e : Grind.AC.Expr),\n  Grind.AC.Seq.denote ctx e.toSeq = Grind.AC.Expr.denote ctx e",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CellularAutomatas.tCellAutomaton.ctorIdx",
  "constType": "{α : Type} → CellularAutomatas.tCellAutomaton α → ℕ",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Lean.MacroScopesView.name",
  "constType": "MacroScopesView → Name",
  "constCategory": "Definition"},
 {"references":
  ["Fin.is_lt._simp_1",
   "GetElem.getElem.congr_simp",
   "CellularAutomatas.FiniteStateTransducer.scanr_len",
   "Eq.trans",
   "CellularAutomatas.FiniteStateTransducer.scanr_get'_eq1.match_1_1",
   "GetElem.getElem",
   "CellularAutomatas.FiniteStateTransducer.scanr_reduce",
   "congrArg",
   "Fin.val",
   "Eq.ndrec",
   "CellularAutomatas.FiniteStateTransducer.δ",
   "Not",
   "CellularAutomatas.Word",
   "List.drop",
   "Nat.lt_of_succ_lt_succ",
   "CellularAutomatas.FiniteStateTransducer.scanr",
   "OfNat.ofNat",
   "CellularAutomatas.FiniteStateTransducer.scanr_get'_eq1._proof_1",
   "LT.lt",
   "HAdd.hAdd",
   "Decidable.byContradiction",
   "of_eq_true",
   "Fin.val_lt_of_le",
   "LE.le",
   "id",
   "Eq.mpr",
   "CellularAutomatas.FiniteStateTransducer.scanr_cons",
   "CellularAutomatas.FiniteStateTransducer.f",
   "List.length",
   "Fin.elim0"],
  "name": "CellularAutomatas.FiniteStateTransducer.scanr_get'_eq1",
  "constType":
  "∀ {α β : Type} {M : CellularAutomatas.FiniteStateTransducer α β} (w : CellularAutomatas.Word α)\n  (i : Fin (List.length w)), (M.scanr w)[i] = M.f (M.δ (M.scanr_reduce w⟦↑i + 1..*⟧) w[i])",
  "constCategory": "Theorem"},
 {"references":
  ["_private.Init.Core.0.beq_of_eq.match_1_1", "BEq.rfl", "BEq.beq", "Unit"],
  "name": "beq_of_eq",
  "constType":
  "∀ {α : Type u_1} [inst : BEq α] [ReflBEq α] {a b : α}, a = b → (a == b) = true",
  "constCategory": "Theorem"},
 {"references":
  ["List.replicate",
   "HAppend.hAppend",
   "CellularAutomatas.Word",
   "CellularAutomatas.word_dvd_k_ext",
   "List.map",
   "List.length"],
  "name": "CellularAutomatas.word_dvd_k",
  "constType":
  "{α : Type u_1} → ℕ → CellularAutomatas.Word α → CellularAutomatas.Word (Option α)",
  "constCategory": "Definition"},
 {"references": ["HAdd.hAdd", "SizeOf.sizeOf", "OfNat.ofNat"],
  "name": "CellularAutomatas.VerificationError._sizeOf_1",
  "constType": "CellularAutomatas.VerificationError → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Int.add_left_cancel",
   "Nat.cast",
   "_private.Init.Data.Int.Order.0.Int.lt_irrefl.match_1_1",
   "Int.add_zero",
   "OfNat.ofNat",
   "congrArg",
   "LT.lt",
   "HAdd.hAdd",
   "Int.lt.dest",
   "Nat.succ_ne_zero",
   "id",
   "Eq.mpr",
   "Int.ofNat.inj"],
  "name": "Int.lt_irrefl",
  "constType": "∀ (a : ℤ), ¬a < a",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Grind.AC.Var", "Lean.Grind.AC.Var.denote", "Lean.Grind.AC.Context.op"],
  "name": "Lean.Grind.AC.Seq.denote",
  "constType": "{α : Sort u_1} → Grind.AC.Context α → Grind.AC.Seq → α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CellularAutomatas.LCellAutomaton.ctorIdx",
  "constType": "{α : Type} → CellularAutomatas.LCellAutomaton α → ℕ",
  "constCategory": "Definition"},
 {"references": ["Lean.Omega.Coeffs"],
  "name": "Lean.Omega.LinearCombo.casesOn",
  "constType":
  "{motive : Omega.LinearCombo → Sort u} →\n  (t : Omega.LinearCombo) →\n    ((const : ℤ) → (coeffs : Omega.Coeffs) → motive { const := const, coeffs := coeffs }) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["Not",
   "LT.lt",
   "Or.elim",
   "Nat.lt_or_eq_of_le",
   "LE.le",
   "id",
   "Eq.mpr",
   "congrArg"],
  "name": "Nat.findX._proof_2",
  "constType":
  "∀ {p : ℕ → Prop} (m : ℕ), (∀ n < m, ¬p n) → ¬p m → ∀ n ≤ m, ¬p n",
  "constCategory": "Theorem"},
 {"references": ["Nat.le_trans"],
  "name": "Nat.lt_of_lt_of_le",
  "constType": "∀ {n m k : ℕ}, n < m → m ≤ k → n < k",
  "constCategory": "Theorem"},
 {"references": ["Array.emptyWithCapacity", "Array.push", "OfNat.ofNat"],
  "name": "Array.mkArray2",
  "constType": "{α : Type u} → α → α → Array α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "List.toArray",
  "constType": "{α : Type u_1} → List α → Array α",
  "constCategory": "Definition"},
 {"references": ["List.casesOn"],
  "name": "List.mapIdx.go.match_1",
  "constType":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    (motive : List α → Array β → Sort u_3) →\n      (x : List α) →\n        (x_1 : Array β) →\n          ((acc : Array β) → motive [] acc) →\n            ((a : α) → (as : List α) → (acc : Array β) → motive (a :: as) acc) → motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["HAdd.hAdd",
   "_private.Init.Data.Nat.Basic.0.Nat.add_comm.match_1_1",
   "Nat.succ_add",
   "Nat.zero_add",
   "Nat.below",
   "id",
   "Eq.symm",
   "Eq.mpr",
   "Nat.brecOn",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Nat.add_comm",
  "constType": "∀ (n m : ℕ), n + m = m + n",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "Eq.trans",
   "Eq.mp",
   "Lean.Grind.Semiring.add_assoc",
   "Int.cast",
   "congrArg",
   "Lean.Grind.Ring.intCast_add",
   "_private.Init.Grind.Order.0.Lean.Grind.Order.le_eq_true_of_le_k._proof_1_1",
   "Lean.Grind.Semiring.add_zero",
   "Eq.symm",
   "Int.ble'_eq_true",
   "HSub.hSub",
   "Lean.Grind.OrderedRing.nonneg_intCast_of_nonneg",
   "Int.sub_eq_add_neg",
   "Lean.Grind.AddCommGroup.add_neg_cancel",
   "Lean.Grind.Semiring.add_comm",
   "Not",
   "Lean.Grind.Ring.intCast",
   "Lean.Grind.OrderedAdd.add_le_add",
   "Neg.neg",
   "Lean.Grind.Ring.intCast_neg",
   "iff_true",
   "eq_iff_iff._simp_1",
   "Int.ble'",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "Decidable.byContradiction",
   "Int.add_comm",
   "LE.le",
   "id",
   "Eq.mpr"],
  "name": "Lean.Grind.Order.le_eq_true_of_le_k",
  "constType":
  "∀ {α : Type u_1} [inst : LE α] [inst_1 : LT α] [LawfulOrderLT α] [inst_3 : Std.IsPreorder α] [inst_4 : Grind.Ring α]\n  [Grind.OrderedRing α] {a b : α} {k₁ k₂ : ℤ}, k₁.ble' k₂ = true → a ≤ b + ↑k₁ → (a ≤ b + ↑k₂) = True",
  "constCategory": "Theorem"},
 {"references":
  ["_private.Init.Data.List.Lemmas.0.List.getElem?_map.match_1_1",
   "rfl",
   "Eq.trans",
   "getElem?_pos",
   "List.brecOn",
   "List.map",
   "GetElem.getElem",
   "List.length_map",
   "OfNat.ofNat",
   "congrArg",
   "HAdd.hAdd",
   "LT.lt",
   "eq_self",
   "GetElem?.getElem?",
   "List.below",
   "of_eq_true",
   "congr",
   "Option.map",
   "Nat.zero_lt_succ._simp_1",
   "List.length"],
  "name": "List.getElem?_map",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {f : α → β} {l : List α} {i : ℕ}, (List.map f l)[i]? = Option.map f l[i]?",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.FiniteStateTransducer.Q",
   "CellularAutomatas.FiniteStateTransducer.q0",
   "CellularAutomatas.FiniteStateTransducer.f",
   "CellularAutomatas.FiniteStateTransducer.δ"],
  "name": "CellularAutomatas.FiniteStateTransducer.map_input",
  "constType":
  "{α β : Type} →\n  CellularAutomatas.FiniteStateTransducer α β → {γ : Type} → (γ → α) → CellularAutomatas.FiniteStateTransducer γ β",
  "constCategory": "Definition"},
 {"references":
  ["HAdd.hAdd",
   "eq_self",
   "Int.mul_add",
   "Eq.trans",
   "of_eq_true",
   "congr",
   "Int.mul_comm",
   "HMul.hMul",
   "congrArg"],
  "name": "Int.add_mul",
  "constType": "∀ (a b c : ℤ), (a + b) * c = a * c + b * c",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.Linear.Context",
   "Nat.Linear.Poly.denote_eq",
   "Nat.Linear.Poly.cancel",
   "Nat.Linear.Poly.denote_eq_cancel",
   "propext",
   "Nat.Linear.Poly.of_denote_eq_cancel",
   "Nat.Linear.Poly"],
  "name": "Nat.Linear.Poly.denote_eq_cancel_eq",
  "constType":
  "∀ (ctx : Nat.Linear.Context) (m₁ m₂ : Nat.Linear.Poly),\n  Nat.Linear.Poly.denote_eq ctx (m₁.cancel m₂) = Nat.Linear.Poly.denote_eq ctx (m₁, m₂)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Max.max",
  "constType": "{α : Type u} → [self : Max α] → α → α → α",
  "constCategory": "Definition"},
 {"references":
  ["implies_congr",
   "Eq.trans",
   "Lean.Grind.Order.of_nat_eq",
   "eagerReduce",
   "eq_true",
   "HMul.hMul",
   "ite_cond_eq_true",
   "IntCast.intCast",
   "List.getLast?_append",
   "Nat.ToInt.natCast_ofNat",
   "List.getLast?",
   "Lean.Grind.Order.int_lt",
   "GetElem?.getElem?",
   "False.elim",
   "NatCast.natCast",
   "Lean.Grind.eq_false_of_imp_eq_true",
   "Eq.symm",
   "HSub.hSub",
   "forall_prop_domain_congr",
   "Lean.Grind.forall_propagator",
   "HAppend.hAppend",
   "of_eq_false",
   "List.drop",
   "getElem?_pos",
   "Neg.neg",
   "Lean.Grind.Order.le_of_eq_2_k",
   "Lean.Grind.Order.le_of_offset_eq_1_k",
   "List.take_add",
   "List.length_append",
   "Lean.Grind.nestedProof",
   "CellularAutomatas.PrefixStableProof.getLastOfTake._proof_1_7",
   "eq_false",
   "Lean.Grind.CommRing.lt_norm_expr",
   "id",
   "Lean.Grind.Order.le_trans_k",
   "Lean.Grind.Order.eq_trans_false'",
   "Lean.Grind.Order.lt_eq_true_of_le_k",
   "Lean.Grind.Order.eq_trans_true",
   "getElem?_neg",
   "List.length",
   "Int.Linear.norm_le",
   "Eq.substr",
   "Option.some_or",
   "Int.Linear.natCast_sub",
   "Eq.mp",
   "noConfusion_of_Nat",
   "GetElem.getElem",
   "Nat.Linear.ExprCnstr.eq_of_toNormPoly_eq",
   "List.length_take",
   "Int.Linear.Expr.eq_of_norm_eq",
   "min_def",
   "congrArg",
   "Option.or",
   "Lean.Grind.Nat.lt_eq",
   "Nat.not_le_eq",
   "Lean.Grind.nestedDecidable",
   "CellularAutomatas.PrefixStableProof.getLastOfTake._proof_1_3",
   "List.getLast?_eq_getElem?",
   "Lean.Grind.Order.lt_of_not_le_k",
   "cast",
   "Not",
   "Nat.ToInt.lt_eq",
   "ite",
   "Lean.Grind.Order.le_eq_true_of_le_k",
   "Nat.ToInt.add_congr",
   "Lean.Grind.Order.eq_mp_not",
   "OfNat.ofNat",
   "ite_congr",
   "HAdd.hAdd",
   "LT.lt",
   "Nat.ToInt.le_eq",
   "of_eq_true",
   "Min.min",
   "Lean.Grind.CommRing.Expr.eq_of_toPoly_eq",
   "List.take",
   "LE.le",
   "Lean.Grind.Semiring.natCast",
   "CellularAutomatas.PrefixStableProof.getLastOfTake._proof_1_5",
   "Lean.Grind.CommRing.le_norm_expr",
   "Lean.Grind.Semiring.natCast_eq_ofNat"],
  "name": "CellularAutomatas.PrefixStableProof.getLastOfTake._proof_1_15",
  "constType":
  "∀ {i : ℕ} {α : Type u_1} {w : List α},\n  i + 1 ≤ w.length →\n    -1 * ↑(List.take 1 w⟦i..*⟧).length + 1 ≤ 0 →\n      (List.take (i + 1) w).length - 1 <\n        (List.take (List.take i w).length w ++\n            List.take (List.take 1 w⟦i..*⟧).length w⟦(List.take i w).length..*⟧).length",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Pure.pure",
  "constType":
  "{f : Type u → Type v} → [self : Pure f] → {α : Type u} → α → f α",
  "constCategory": "Definition"},
 {"references":
  ["Not",
   "LT.lt",
   "Eq.trans",
   "LE.le",
   "Int.negSucc_lt_zero",
   "id",
   "Eq.mpr",
   "iff_false",
   "Int.not_le._simp_1",
   "OfNat.ofNat"],
  "name": "Int.negSucc_not_nonneg",
  "constType": "∀ (n : ℕ), 0 ≤ Int.negSucc n ↔ False",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "CellularAutomatas.CellAutomaton.δ",
   "CellularAutomatas.nextt_congr._proof_1_9",
   "CellularAutomatas.nextt_congr._proof_1_6",
   "Nat.cast",
   "CellularAutomatas.nextt_congr._proof_1_4",
   "CellularAutomatas.CellAutomaton.next",
   "CellularAutomatas.CellAutomaton.nextt",
   "Nat.recAux",
   "CellularAutomatas.Config",
   "OfNat.ofNat",
   "CellularAutomatas.nextt_congr._proof_1_10",
   "HAdd.hAdd",
   "CellularAutomatas.nextt_congr._proof_1_5",
   "Decidable.byContradiction",
   "CellularAutomatas.nextt_congr._proof_1_3",
   "CellularAutomatas.nextt_congr._proof_1_7",
   "LE.le",
   "HSub.hSub",
   "id",
   "CellularAutomatas.CellAutomaton.Q",
   "CellularAutomatas.nextt_congr._proof_1_8"],
  "name": "CellularAutomatas.nextt_congr",
  "constType":
  "∀ (C : CellularAutomatas.CellAutomaton) (c1 c2 : CellularAutomatas.Config C.Q) (t : ℕ) (i : ℤ),\n  (∀ (j : ℤ), i - ↑t ≤ j ∧ j ≤ i + ↑t → c1 j = c2 j) → C.nextt c1 t i = C.nextt c2 t i",
  "constCategory": "Theorem"},
 {"references": ["Nat.not_succ_le_self"],
  "name": "Nat.lt_irrefl",
  "constType": "∀ (n : ℕ), ¬n < n",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.Advice.f",
   "CellularAutomatas.Word",
   "CellularAutomatas.Advice.casesOn",
   "List.length"],
  "name":
  "CellularAutomatas.advice_prefixes_in_L_is_two_stage_advice.match_1_1",
  "constType":
  "∀ {α : Type} (motive : (x x_1 : CellularAutomatas.Advice α Bool) → x.f = x_1.f → Prop)\n  (x x_1 : CellularAutomatas.Advice α Bool) (h_eq : x.f = x_1.f),\n  (∀ (f1 : CellularAutomatas.Word α → CellularAutomatas.Word Bool)\n      (l1 : ∀ (w : CellularAutomatas.Word α), List.length (f1 w) = List.length w)\n      (f2 : CellularAutomatas.Word α → CellularAutomatas.Word Bool)\n      (l2 : ∀ (w : CellularAutomatas.Word α), List.length (f2 w) = List.length w)\n      (h : { f := f1, len := l1 }.f = { f := f2, len := l2 }.f),\n      motive { f := f1, len := l1 } { f := f2, len := l2 } h) →\n    motive x x_1 h_eq",
  "constCategory": "Definition"},
 {"references": ["LT.lt", "AddLeftMono", "Nat.cast_lt", "Nat.cast", "propext"],
  "name": "Nat.cast_lt._simp_1",
  "constType":
  "∀ {α : Type u_1} [inst : AddMonoidWithOne α] [inst_1 : PartialOrder α] [AddLeftMono α] [ZeroLEOneClass α] [CharZero α]\n  {m n : ℕ}, (↑m < ↑n) = (m < n)",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Omega.LinearCombo.mul_eval_of_const_left",
   "Or.casesOn",
   "Lean.Omega.LinearCombo.mul_eval_of_const_right",
   "Lean.Omega.LinearCombo.mul",
   "Lean.Omega.Coeffs.isZero",
   "Lean.Omega.LinearCombo.coeffs",
   "id",
   "HMul.hMul",
   "Lean.Omega.Coeffs",
   "Eq.mpr",
   "Lean.Omega.LinearCombo.eval",
   "congrArg"],
  "name": "Lean.Omega.LinearCombo.mul_eval",
  "constType":
  "∀ (l₁ l₂ : Omega.LinearCombo) (v : Omega.Coeffs),\n  l₁.coeffs.isZero ∨ l₂.coeffs.isZero → (l₁.mul l₂).eval v = l₁.eval v * l₂.eval v",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Omega.Constraint.upperBound",
   "Eq.trans",
   "Eq.mp",
   "Lean.Omega.Constraint.sat",
   "and_true",
   "Decidable.decide",
   "congrArg",
   "Decidable.decide.congr_simp",
   "Lean.Omega.Constraint.casesOn",
   "congr",
   "Lean.Omega.Constraint.lowerBound",
   "decide_eq_true_eq",
   "And.left",
   "Lean.Omega.UpperBound.sat",
   "And.right",
   "Lean.Omega.LowerBound.sat",
   "decide_true",
   "true_and",
   "Lean.Omega.Constraint.add",
   "Option.casesOn",
   "HAdd.hAdd",
   "eq_self",
   "and_self",
   "of_eq_true",
   "LE.le",
   "Lean.Omega.UpperBound",
   "id",
   "Lean.Omega.LowerBound",
   "Eq.mpr",
   "Int.add_le_add"],
  "name": "Lean.Omega.Constraint.add_sat",
  "constType":
  "∀ {c₁ c₂ : Omega.Constraint} {x₁ x₂ : ℤ}, c₁.sat x₁ = true → c₂.sat x₂ = true → (c₁.add c₂).sat (x₁ + x₂) = true",
  "constCategory": "Theorem"},
 {"references": ["Not", "Decidable.casesOn"],
  "name": "_private.Init.Core.0.if_pos.match_1_1",
  "constType":
  "∀ {c : Prop} (motive : Decidable c → Prop) (h : Decidable c),\n  (∀ (h : c), motive (isTrue h)) → (∀ (hnc : ¬c), motive (isFalse hnc)) → motive h",
  "constCategory": "Definition"},
 {"references":
  ["Lean.NameSet.insert", "EmptyCollection.emptyCollection", "Lean.NameSet"],
  "name": "Lean.Expr.getUsedConstantsAsSet",
  "constType": "Expr → NameSet",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Nat.le.casesOn",
  "constType":
  "∀ {n : ℕ} {motive : (a : ℕ) → n.le a → Prop} {a : ℕ} (t : n.le a),\n  motive n ⋯ → (∀ {m : ℕ} (a : n.le m), motive m.succ ⋯) → motive a t",
  "constCategory": "Definition"},
 {"references": ["eq_self", "Eq.trans", "of_eq_true", "congr", "congrArg"],
  "name": "Lean.Grind.eq_congr",
  "constType":
  "∀ {α : Sort u} {a₁ b₁ a₂ b₂ : α}, a₁ = a₂ → b₁ = b₂ → (a₁ = b₁) = (a₂ = b₂)",
  "constCategory": "Theorem"},
 {"references": ["Array.emptyWithCapacity", "Array.push", "OfNat.ofNat"],
  "name": "Array.mkArray4",
  "constType": "{α : Type u} → α → α → α → α → Array α",
  "constCategory": "Definition"},
 {"references":
  ["Set", "Membership.mem", "CellularAutomatas.DefinesLanguage.L", "Language"],
  "name": "CellularAutomatas.ℒ",
  "constType":
  "{α : Type} → {CA : Type u_1} → [d : CellularAutomatas.DefinesLanguage CA α] → Set CA → Set (Language α)",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CellularAutomatas.TwoStageAdvice.C",
  "constType":
  "{α Γ : Type} →\n  [inst : CellularAutomatas.Alphabet α] →\n    [inst_1 : CellularAutomatas.Alphabet Γ] →\n      (self : CellularAutomatas.TwoStageAdvice α Γ) → CellularAutomatas.CArtTransducer α self.β",
  "constCategory": "Definition"},
 {"references": ["Lean.Omega.positivize", "Lean.Omega.Coeffs", "Prod.fst"],
  "name": "Lean.Omega.positivizeConstraint",
  "constType": "Omega.Constraint → Omega.Coeffs → Omega.Constraint",
  "constCategory": "Definition"},
 {"references":
  ["LT.lt",
   "Nat.casesOn",
   "False.elim",
   "Nat.ctorIdx",
   "List.casesOn",
   "noConfusion_of_Nat",
   "Fin.casesOn",
   "Nat.le.casesOn",
   "OfNat.ofNat",
   "List.length"],
  "name": "List.get.match_1",
  "constType":
  "{α : Type u_1} →\n  (motive : (x : List α) → Fin x.length → Sort u_2) →\n    (x : List α) →\n      (x_1 : Fin x.length) →\n        ((a : α) → (tail : List α) → (isLt : 0 < (a :: tail).length) → motive (a :: tail) ⟨0, isLt⟩) →\n          ((head : α) →\n              (as : List α) → (i : ℕ) → (h : i.succ < (head :: as).length) → motive (head :: as) ⟨i.succ, h⟩) →\n            motive x x_1",
  "constCategory": "Definition"},
 {"references": ["CellularAutomatas.CellAutomaton.casesOn"],
  "name": "CellularAutomatas.CellAutomaton.noConfusionType",
  "constType":
  "Sort u → CellularAutomatas.CellAutomaton → CellularAutomatas.CellAutomaton → Sort u",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Omega.LinearCombo.coordinate_eval_2",
   "Nat.cast",
   "Eq.trans",
   "le_of_le_of_eq",
   "Lean.Omega.LinearCombo.coordinate_eval_0",
   "Lean.Omega.Constraint.combine_sat'",
   "Decidable.decide",
   "Lean.Omega.Coeffs.ofList",
   "HSub.hSub",
   "Lean.Omega.tidy_sat",
   "Eq.symm",
   "Lean.Omega.LinearCombo.add_eval",
   "Lean.Omega.Int.lt_of_not_le",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "Int.add_one_le_of_lt",
   "And.left",
   "of_decide_eq_true",
   "Not",
   "Neg.neg",
   "Lean.Omega.Constraint.addInequality_sat",
   "Lean.Omega.Int.add_congr",
   "Lean.Omega.Constraint.isImpossible",
   "Lean.Omega.LinearCombo.coordinate",
   "OfNat.ofNat",
   "Int.sub_nonneg_of_le",
   "Lean.Omega.LinearCombo.coordinate_eval_1",
   "HAdd.hAdd",
   "Lean.Omega.LinearCombo.sub_eval",
   "LE.le",
   "Int.natCast_add",
   "id",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.Int.sub_congr"],
  "name": "CellularAutomatas.nextt_congr._proof_1_7",
  "constType":
  "∀ (t : ℕ) (i j : ℤ), i - ↑t ≤ j ∧ j ≤ i + ↑t → ¬i - ↑(t + 1) ≤ j → False",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "HAdd.hAdd",
   "Lean.Grind.Nat.lt_eq",
   "List.take",
   "LE.le",
   "HSub.hSub",
   "OfNat.ofNat",
   "Eq.mpr_prop",
   "List.length"],
  "name": "CellularAutomatas.PrefixStableProof.getLastOfTake._proof_1_19",
  "constType":
  "∀ {i : ℕ} {α : Type u_1} {w : List α},\n  (List.take (i + 1) w).length - 1 + 1 ≤ (List.take i w).length →\n    (List.take (i + 1) w).length - 1 < (List.take i w).length",
  "constCategory": "Theorem"},
 {"references": ["Quot.sound", "id", "Quot.liftOn", "congrArg"],
  "name": "funext",
  "constType":
  "∀ {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x}, (∀ (x : α), f x = g x) → f = g",
  "constCategory": "Theorem"},
 {"references":
  ["List.filter",
   "Setoid.r",
   "Quot.sound",
   "DecidablePred",
   "List.Perm.filter",
   "Decidable.decide"],
  "name": "Multiset.filter._proof_1",
  "constType":
  "∀ {α : Type u_1} (p : α → Prop) [inst : DecidablePred p] (_l₁ _l₂ : List α),\n  (List.isSetoid α) _l₁ _l₂ →\n    Quot.mk (⇑(List.isSetoid α)) (List.filter (fun b => decide (p b)) _l₁) =\n      Quot.mk (⇑(List.isSetoid α)) (List.filter (fun b => decide (p b)) _l₂)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CellularAutomatas.backwards_fsm.Params.α",
  "constType": "CellularAutomatas.backwards_fsm.Params → Type",
  "constCategory": "Definition"},
 {"references": ["Set", "CellularAutomatas.CA_rt"],
  "name": "CellularAutomatas.CA_rt.eq_1",
  "constType":
  "∀ (α : Type), CellularAutomatas.CA_rt α = CellularAutomatas.t_rt α (CellularAutomatas.CA α)",
  "constCategory": "Theorem"},
 {"references":
  ["List.getElem_map",
   "CellularAutomatas.Word",
   "CellularAutomatas.Word.snd_len",
   "Eq.trans",
   "Eq.mp",
   "List.map",
   "GetElem.getElem",
   "Prod.snd",
   "List.length_map",
   "congrArg",
   "LT.lt",
   "eq_self",
   "of_eq_true",
   "id",
   "Eq.ndrec",
   "CellularAutomatas.Word.snd",
   "List.length"],
  "name": "CellularAutomatas.Word.get_snd_",
  "constType":
  "∀ {α β : Type} (w : CellularAutomatas.Word (α ⨉ β)) (t : ℕ) (h : t < List.length w.snd), w.snd[t] = w[t].2",
  "constCategory": "Theorem"},
 {"references": ["outParam"],
  "name": "HMod.hMod",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → [self : HMod α β γ] → α → β → γ",
  "constCategory": "Definition"},
 {"references":
  ["LT.lt",
   "LE.le.trans_lt",
   "Max.max",
   "le_sup_right",
   "And.right",
   "sup_ind",
   "le_sup_left",
   "And.left"],
  "name": "sup_lt_iff",
  "constType":
  "∀ {α : Type u} [inst : LinearOrder α] {a b c : α}, max b c < a ↔ b < a ∧ c < a",
  "constCategory": "Theorem"},
 {"references":
  ["rfl",
   "List.getLast",
   "List.getLast_eq_getElem._proof_3",
   "GetElem.getElem.congr_simp",
   "Eq.trans",
   "List.brecOn",
   "GetElem.getElem",
   "OfNat.ofNat",
   "congrArg",
   "HAdd.hAdd",
   "List.getLast._proof_2",
   "LT.lt",
   "eq_self",
   "List.below",
   "_private.Init.Data.List.Lemmas.0.List.getLast_eq_getElem.match_1_1",
   "of_eq_true",
   "congr",
   "HSub.hSub",
   "Ne",
   "Nat.succ_sub_succ",
   "Eq.ndrec",
   "List.length"],
  "name": "List.getLast_eq_getElem",
  "constType":
  "∀ {α : Type u_1} {l : List α} (h : l ≠ []), l.getLast h = l[l.length - 1]",
  "constCategory": "Theorem"},
 {"references": ["Membership.mem", "Iff.rfl"],
  "name": "Lean.Grind.IntInterval.mem_io",
  "constType": "∀ (hi x : ℤ), x ∈ Grind.IntInterval.io hi ↔ x < hi",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Grind.AC.Var", "Lean.Grind.AC.Context.vars", "Lean.RArray.get"],
  "name": "Lean.Grind.AC.Var.denote",
  "constType": "{α : Sort u} → Grind.AC.Context α → Grind.AC.Var → α",
  "constCategory": "Definition"},
 {"references":
  ["implies_congr",
   "Eq.trans",
   "noConfusion_of_Nat",
   "eq_iff_iff",
   "Bool.coe_iff_coe._simp_1",
   "Bool.false_eq_true",
   "congrArg",
   "_private.Init.Grind.Ring.CommSolver.0.Lean.Grind.CommRing.Poly.beq'_eq._simp_1_2",
   "Bool.and",
   "False.elim",
   "Int.beq'_eq",
   "congr",
   "funext",
   "Eq.symm",
   "and_congr_right_iff._simp_1",
   "Int.beq'",
   "Eq.ndrec",
   "Lean.Grind.CommRing.Poly.beq'",
   "propext",
   "Lean.Grind.CommRing.Mon.beq'_eq",
   "Bool.and'_eq_and",
   "Lean.Grind.CommRing.Poly.ctorIdx",
   "eq_false'",
   "eq_iff_iff._simp_1",
   "Lean.Grind.CommRing.Mon.beq'",
   "eq_self",
   "of_eq_true",
   "Lean.Grind.CommRing.Poly.casesOn",
   "id",
   "Lean.Grind.CommRing.Poly.add.injEq",
   "Eq.mpr",
   "Bool.and_eq_true",
   "Lean.Grind.CommRing.Poly.num.injEq",
   "Bool.and'"],
  "name": "Lean.Grind.CommRing.Poly.beq'_eq",
  "constType":
  "∀ (p₁ p₂ : Grind.CommRing.Poly), (p₁.beq' p₂ = true) = (p₁ = p₂)",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "CellularAutomatas.Word",
   "CellularAutomatas.ProdCA.zipMany",
   "List.getD",
   "Eq.trans",
   "ite",
   "CellularAutomatas.ProdCA.zipMany_get?._proof_1_4",
   "List.map",
   "Option.getD",
   "List.getElem?_map",
   "ite_congr",
   "congrArg",
   "Inhabited.default",
   "LT.lt",
   "List.range",
   "List.getD_eq_getElem?_getD",
   "GetElem?.getElem?",
   "congr",
   "funext",
   "id",
   "Eq.mpr",
   "Option.map",
   "List.length"],
  "name": "CellularAutomatas.ProdCA.zipMany_get?",
  "constType":
  "∀ {β : Type} [inst : CellularAutomatas.Alphabet β] {γ : β → Type v} [inst_1 : (b : β) → Inhabited (γ b)]\n  (f : (b : β) → CellularAutomatas.Word (γ b)) (i : ℕ),\n  (CellularAutomatas.ProdCA.zipMany f)[i]? =\n    if i < List.length (f default) then some fun b => List.getD (f b) i default else none",
  "constCategory": "Theorem"},
 {"references": ["cond.match_1", "Unit"],
  "name": "cond",
  "constType": "{α : Sort u} → Bool → α → α → α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Nat.Linear.Var",
  "constType": "Type",
  "constCategory": "Definition"},
 {"references":
  ["Nat.cast",
   "Eq.trans",
   "le_of_le_of_eq",
   "Lean.Omega.LinearCombo.coordinate_eval_0",
   "Decidable.decide",
   "Lean.Omega.Coeffs.ofList",
   "Eq.symm",
   "Lean.Omega.tidy_sat",
   "HSub.hSub",
   "Lean.Omega.LinearCombo.add_eval",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "Int.add_one_le_of_lt",
   "of_decide_eq_true",
   "Not",
   "CellularAutomatas.Word",
   "Neg.neg",
   "Lean.Omega.Constraint.addInequality_sat",
   "Lean.Omega.Int.add_congr",
   "Lean.Omega.Constraint.isImpossible",
   "Lean.Omega.LinearCombo.coordinate",
   "OfNat.ofNat",
   "Int.sub_nonneg_of_le",
   "HAdd.hAdd",
   "Lean.Omega.LinearCombo.sub_eval",
   "Lean.Omega.Int.ofNat_lt_of_lt",
   "LE.le",
   "Nat.lt_of_not_le",
   "id",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.Int.sub_congr",
   "List.length"],
  "name": "CellularAutomatas.FiniteStateTransducer.scanr_get'_eq1._proof_1",
  "constType":
  "∀ {α : Type} (w : CellularAutomatas.Word α), ¬List.length w ≤ List.length w → False",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CellularAutomatas.CellAutomaton.alphabetQ",
  "constType":
  "(self : CellularAutomatas.CellAutomaton) → CellularAutomatas.Alphabet self.Q",
  "constCategory": "Definition"},
 {"references": ["Int.le_min", "Min.min", "LE.le", "propext"],
  "name":
  "_private.Init.Omega.Constraint.0.Lean.Omega.Constraint.combine_sat._simp_1_3",
  "constType": "∀ {a b c : ℤ}, (a ≤ min b c) = (a ≤ b ∧ a ≤ c)",
  "constCategory": "Theorem"},
 {"references":
  ["rfl", "absurd", "Not", "_private.Init.Core.0.if_neg.match_1_1", "ite"],
  "name": "if_neg",
  "constType":
  "∀ {c : Prop} {h : Decidable c}, ¬c → ∀ {α : Sort u} {t e : α}, (if c then t else e) = e",
  "constCategory": "Theorem"},
 {"references": ["Lean.Grind.IntInterval.casesOn", "Unit.unit", "Unit"],
  "name": "Lean.Grind.IntInterval.lo?.match_1",
  "constType":
  "(motive : Grind.IntInterval → Sort u_1) →\n  (i : Grind.IntInterval) →\n    ((lo hi : ℤ) → motive (Grind.IntInterval.co lo hi)) →\n      ((lo : ℤ) → motive (Grind.IntInterval.ci lo)) →\n        ((hi : ℤ) → motive (Grind.IntInterval.io hi)) → (Unit → motive Grind.IntInterval.ii) → motive i",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Iff.mpr",
  "constType": "∀ {a b : Prop}, (a ↔ b) → b → a",
  "constCategory": "Theorem"},
 {"references":
  ["Set",
   "Singleton.singleton",
   "CellularAutomatas.CellAutomaton.Q",
   "CellularAutomatas.CellAutomaton.quiescent_set"],
  "name": "CellularAutomatas.CellAutomaton.quiescent",
  "constType": "(C : CellularAutomatas.CellAutomaton) → C.Q → Prop",
  "constCategory": "Definition"},
 {"references":
  ["implies_congr",
   "_private.Init.Data.Int.Linear.0.Int.Linear.Poly.beq'_eq._simp_1_2",
   "Int.Linear.Poly.beq'",
   "Eq.trans",
   "Int.Linear.Poly.add.injEq",
   "Nat.beq_eq",
   "noConfusion_of_Nat",
   "eq_iff_iff",
   "Bool.coe_iff_coe._simp_1",
   "Bool.false_eq_true",
   "congrArg",
   "Bool.and",
   "False.elim",
   "Int.beq'_eq",
   "congr",
   "Nat.beq",
   "funext",
   "Eq.symm",
   "and_congr_right_iff._simp_1",
   "Int.beq'",
   "Eq.ndrec",
   "propext",
   "Int.Linear.Poly.num.injEq",
   "Bool.and'_eq_and",
   "eq_false'",
   "eq_iff_iff._simp_1",
   "Int.Linear.Poly.casesOn",
   "Int.Linear.Poly.ctorIdx",
   "eq_self",
   "of_eq_true",
   "id",
   "Bool.and_eq_true",
   "Eq.mpr",
   "Bool.and'",
   "Int.Linear.Var"],
  "name": "Int.Linear.Poly.beq'_eq",
  "constType": "∀ (p₁ p₂ : Int.Linear.Poly), (p₁.beq' p₂ = true) = (p₁ = p₂)",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "id",
   "CellularAutomatas.CellAutomaton.Q",
   "CellularAutomatas.tCellAutomaton.noConfusion"],
  "name": "CellularAutomatas.tCellAutomaton.mk.noConfusion",
  "constType":
  "{α : Type} →\n  (P : Sort u) →\n    (toLCellAutomaton : CellularAutomatas.LCellAutomaton α) →\n      (t p : ℕ → ℕ) →\n        (F_pos : toLCellAutomaton.Q → Bool) →\n          (toLCellAutomaton' : CellularAutomatas.LCellAutomaton α) →\n            (t' p' : ℕ → ℕ) →\n              (F_pos' : toLCellAutomaton'.Q → Bool) →\n                { toLCellAutomaton := toLCellAutomaton, t := t, p := p, F_pos := F_pos } =\n                    { toLCellAutomaton := toLCellAutomaton', t := t', p := p', F_pos := F_pos' } →\n                  (toLCellAutomaton = toLCellAutomaton' → t = t' → p = p' → F_pos ≍ F_pos' → P) → P",
  "constCategory": "Definition"},
 {"references": ["CellularAutomatas.FiniteStateTransducer._sizeOf_1"],
  "name": "CellularAutomatas.FiniteStateTransducer._sizeOf_inst",
  "constType":
  "(α β : Type) → [SizeOf α] → [SizeOf β] → SizeOf (CellularAutomatas.FiniteStateTransducer α β)",
  "constCategory": "Definition"},
 {"references":
  ["LT.lt",
   "List.range",
   "eq_true_of_decide",
   "List.range'",
   "Eq.trans",
   "of_eq_true",
   "optParam",
   "_private.Init.Data.List.Nat.Range.0.List.nodup_range._simp_1_1",
   "List.range_eq_range'",
   "List.Nodup",
   "OfNat.ofNat",
   "congrArg"],
  "name": "List.nodup_range",
  "constType": "∀ {n : ℕ}, (List.range n).Nodup",
  "constCategory": "Theorem"},
 {"references": ["Nat.cast", "Eq.symm"],
  "name": "Mathlib.Meta.NormNum.isNat_ofNat",
  "constType":
  "∀ (α : Type u) [inst : AddMonoidWithOne α] {a : α} {n : ℕ}, ↑n = a → Mathlib.Meta.NormNum.IsNat a n",
  "constCategory": "Theorem"},
 {"references": ["LT.lt", "Nat.zero_lt_succ", "eq_true", "OfNat.ofNat"],
  "name": "Nat.zero_lt_succ._simp_1",
  "constType": "∀ (n : ℕ), (0 < n.succ) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Grind.CommRing.Poly.pow",
   "Lean.Grind.CommRing.Poly.combine",
   "Nat.cast",
   "Neg.neg",
   "Lean.Grind.CommRing.Expr.toPoly.match_1",
   "Lean.Grind.CommRing.Poly.mul",
   "Lean.Grind.CommRing.Poly.ofMon",
   "Lean.Grind.CommRing.Expr.toPoly.match_4",
   "HPow.hPow",
   "Lean.Grind.CommRing.Expr.brecOn",
   "cond",
   "OfNat.ofNat",
   "Lean.Grind.CommRing.Poly.ofVar",
   "Lean.Grind.CommRing.Expr.below",
   "Lean.Grind.CommRing.Var",
   "BEq.beq",
   "Lean.Grind.CommRing.Poly.mulConst"],
  "name": "Lean.Grind.CommRing.Expr.toPoly",
  "constType": "Grind.CommRing.Expr → Grind.CommRing.Poly",
  "constCategory": "Definition"},
 {"references":
  ["Eq.trans",
   "CellularAutomatas.backwards_fsm.Params.inst3",
   "eagerReduce",
   "CellularAutomatas.Config",
   "CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "NatCast.natCast",
   "funext",
   "HSub.hSub",
   "CellularAutomatas.Word.get'?",
   "CellularAutomatas.backwards_fsm.Params.α",
   "CellularAutomatas.CellAutomaton.δ",
   "CellularAutomatas.CArtTransducer.toLCellAutomaton",
   "List.drop",
   "CellularAutomatas.backwards_fsm.Params.β",
   "Neg.neg",
   "CellularAutomatas.backwards_fsm.Params.M",
   "CellularAutomatas.FiniteStateTransducer.scanr",
   "Prod.snd",
   "CellularAutomatas.backwards_fsm.Params.inst2",
   "CellularAutomatas.LCellAutomaton.comp",
   "Classical.byContradiction",
   "id",
   "Int.toNat",
   "Lean.Grind.not_true",
   "Nat.cast",
   "CellularAutomatas.backwards_fsm.C'",
   "CellularAutomatas.backwards_fsm.Params.C",
   "CellularAutomatas.FiniteStateTransducer.Q",
   "CellularAutomatas.FiniteStateTransducer.δ?",
   "CellularAutomatas.FiniteStateTransducer.scanr_reduce",
   "CellularAutomatas.backwards_fsm.Params.γ",
   "Int.Linear.Expr.eq_of_norm_eq",
   "Prod.fst",
   "congrArg",
   "congr",
   "False.casesOn",
   "CellularAutomatas.CellAutomaton.Q",
   "Lean.Grind.forall_and",
   "Not",
   "CellularAutomatas.Word",
   "Lean.Grind.Semiring.natCast_add",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "eq_self",
   "True.casesOn",
   "Lean.Grind.intro_with_eq",
   "Lean.Grind.Semiring.natCast",
   "Lean.Grind.Semiring.natCast_eq_ofNat",
   "And.casesOn"],
  "name": "CellularAutomatas.backwards_fsm.inv._proof_1_7",
  "constType":
  "∀ (e : CellularAutomatas.backwards_fsm.Params) (w : CellularAutomatas.Word e.α) (t : ℕ) (p : ℤ),\n  (∀ (p : ℤ),\n      let c' := (CellularAutomatas.backwards_fsm.C' e).comp w t p;\n      let q := e.M.scanr_reduce w⟦(p + ↑t).toNat..*⟧;\n      c'.2 q = e.C.comp (e.M.scanr w) t p ∧ c'.1 = w.get'? (p + ↑t)) →\n    (CellularAutomatas.backwards_fsm.C' e).comp w t = (CellularAutomatas.backwards_fsm.C' e).comp w t →\n      (CellularAutomatas.backwards_fsm.C' e).comp w t (p - 1) =\n          (CellularAutomatas.backwards_fsm.C' e).comp w t (p - 1) →\n        (CellularAutomatas.backwards_fsm.C' e).comp w t p = (CellularAutomatas.backwards_fsm.C' e).comp w t p →\n          (CellularAutomatas.backwards_fsm.C' e).comp w (t + 1) p =\n              (((CellularAutomatas.backwards_fsm.C' e).comp w t (p + 1)).1, fun q =>\n                e.C.δ\n                  (((CellularAutomatas.backwards_fsm.C' e).comp w t (p - 1)).2\n                    (e.M.δ? (e.M.δ? q ((CellularAutomatas.backwards_fsm.C' e).comp w t p).1)\n                      ((CellularAutomatas.backwards_fsm.C' e).comp w t (p - 1)).1))\n                  (((CellularAutomatas.backwards_fsm.C' e).comp w t p).2\n                    (e.M.δ? q ((CellularAutomatas.backwards_fsm.C' e).comp w t p).1))\n                  (((CellularAutomatas.backwards_fsm.C' e).comp w t (p + 1)).2 q)) →\n            (CellularAutomatas.backwards_fsm.C' e).comp w t (p + 1) =\n                (CellularAutomatas.backwards_fsm.C' e).comp w t (p + 1) →\n              e.M.scanr_reduce w⟦(p + ↑(t + 1)).toNat..*⟧ = e.M.scanr_reduce w⟦(p + ↑(t + 1)).toNat..*⟧ →\n                (((CellularAutomatas.backwards_fsm.C' e).comp w (t + 1) p).2\n                      (e.M.scanr_reduce w⟦(p + ↑(t + 1)).toNat..*⟧) =\n                    let q_right :=\n                      e.M.δ? (e.M.scanr_reduce w⟦(p + ↑(t + 1)).toNat..*⟧)\n                        ((CellularAutomatas.backwards_fsm.C' e).comp w t p).1;\n                    let q_center := e.M.δ? q_right ((CellularAutomatas.backwards_fsm.C' e).comp w t (p - 1)).1;\n                    e.C.δ (((CellularAutomatas.backwards_fsm.C' e).comp w t (p - 1)).2 q_center)\n                      (((CellularAutomatas.backwards_fsm.C' e).comp w t p).2 q_right)\n                      (((CellularAutomatas.backwards_fsm.C' e).comp w t (p + 1)).2\n                        (e.M.scanr_reduce w⟦(p + ↑(t + 1)).toNat..*⟧))) →\n                  (let c' := (CellularAutomatas.backwards_fsm.C' e).comp w t (p + 1);\n                    let q := e.M.scanr_reduce w⟦(p + 1 + ↑t).toNat..*⟧;\n                    c'.2 q = e.C.comp (e.M.scanr w) t (p + 1) ∧ c'.1 = w.get'? (p + 1 + ↑t)) →\n                    ((CellularAutomatas.backwards_fsm.C' e).comp w t (p + 1)).2\n                            (e.M.scanr_reduce w⟦(p + ↑(t + 1)).toNat..*⟧) =\n                          e.C.comp (e.M.scanr w) t (p + 1) ∧\n                        ((CellularAutomatas.backwards_fsm.C' e).comp w t (p + 1)).1 = w.get'? (p + ↑t + 1) →\n                      ((CellularAutomatas.backwards_fsm.C' e).comp w t p).1 = w.get'? (p + ↑t) →\n                        e.M.δ? (e.M.scanr_reduce w⟦(p + (↑t + 1)).toNat..*⟧) (w.get'? (p + ↑t)) =\n                          e.M.δ? (e.M.scanr_reduce w⟦(p + ↑t + 1).toNat..*⟧) (w.get'? (p + ↑t))",
  "constCategory": "Theorem"},
 {"references": ["rfl", "Fin.val", "GetElem.getElem"],
  "name": "Fin.getElem_fin",
  "constType":
  "∀ {Cont : Type u_1} {Elem : Type u_2} {Dom : Cont → ℕ → Prop} {n : ℕ} [inst : GetElem Cont ℕ Elem Dom] (a : Cont)\n  (i : Fin n) (h : Dom a ↑i), a[i] = a[↑i]",
  "constCategory": "Theorem"},
 {"references": ["List.Perm.length_eq", "Setoid.r", "List.length"],
  "name": "Multiset.card",
  "constType": "{α : Type u_1} → Multiset α → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "Eq.trans",
   "of_eq_true",
   "List.zipWith_nil_right",
   "List.zipWith",
   "congrArg"],
  "name": "List.zip_nil_right",
  "constType": "∀ {α : Type u} {β : Type v} {l : List α}, l.zip [] = []",
  "constCategory": "Theorem"},
 {"references":
  ["Bool.not",
   "Bool.not_true",
   "Eq.trans",
   "noConfusion_of_Nat",
   "eq_false'",
   "congrArg",
   "eq_self",
   "Bool.casesOn",
   "False.elim",
   "of_eq_true",
   "iff_self",
   "congr",
   "Eq.symm",
   "Eq.ndrec",
   "Bool.not_false",
   "Bool.ctorIdx"],
  "name": "Bool.not_eq_eq_eq_not",
  "constType": "∀ {a b : Bool}, (!a) = b ↔ a = !b",
  "constCategory": "Theorem"},
 {"references":
  ["List.range",
   "CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "CellularAutomatas.Word",
   "CellularAutomatas.CellAutomaton.Q",
   "List.map",
   "CellularAutomatas.LCellAutomaton.comp"],
  "name": "CellularAutomatas.LCellAutomaton.scan_temporal",
  "constType":
  "{α : Type} → (C : CellularAutomatas.LCellAutomaton α) → ℕ → ℤ → CellularAutomatas.Word α → CellularAutomatas.Word C.Q",
  "constCategory": "Definition"},
 {"references":
  ["Eq.trans",
   "le_of_le_of_eq",
   "Membership.mem",
   "Subtype.val",
   "Lean.Omega.Int.ofNat_le_of_le",
   "CellularAutomatas.tCellAutomaton.toLCellAutomaton",
   "Set.Elem",
   "CellularAutomatas.LCellAutomaton.scan_temporal_rt",
   "CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "Lean.Omega.tidy_sat",
   "HSub.hSub",
   "Eq.symm",
   "Lean.Omega.LinearCombo.add_eval",
   "CellularAutomatas.CArtTransducer.advice",
   "Lean.Omega.combo_sat'",
   "Neg.neg",
   "Lean.Omega.Constraint.addInequality_sat",
   "List.map",
   "Lean.Omega.LinearCombo.coordinate",
   "id",
   "Lean.Omega.Constraint.addEquality_sat",
   "CellularAutomatas.tCellAutomaton.L",
   "Lean.Omega.Int.sub_congr",
   "List.length",
   "Lean.Omega.LinearCombo.coordinate_eval_7",
   "Nat.cast",
   "CellularAutomatas.tCellAutomaton.t",
   "Int.sub_eq_zero_of_eq",
   "Decidable.decide",
   "Lean.Omega.Coeffs.ofList",
   "CellularAutomatas.CellAutomaton.Q",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "of_decide_eq_true",
   "Not",
   "CellularAutomatas.Word",
   "List.extract",
   "Set",
   "Lean.Omega.Int.ofNat_congr",
   "Lean.Omega.Int.add_congr",
   "Function.comp",
   "Lean.Omega.Constraint.isImpossible",
   "Int.sub_nonneg_of_le",
   "OfNat.ofNat",
   "LT.lt",
   "HAdd.hAdd",
   "CellularAutomatas.Advice.f",
   "List.range",
   "Lean.Omega.LinearCombo.coordinate_eval_1",
   "Nat.le_of_not_lt",
   "Lean.Omega.LinearCombo.coordinate_eval_6",
   "Lean.Omega.LinearCombo.sub_eval",
   "List.take",
   "Int.natCast_add",
   "CellularAutomatas.CA_rt",
   "Lean.Omega.LinearCombo.eval",
   "CellularAutomatas.tCellAutomaton.F_pos",
   "Lean.Omega.LinearCombo.coordinate_eval_5"],
  "name": "CellularAutomatas.CA_rt_to_TwoStage_eq._proof_1_8",
  "constType":
  "∀ {α : Type} [CellularAutomatas.Alphabet α] (C : ↑(CellularAutomatas.CA_rt α)) (w : CellularAutomatas.Word α) (i : ℕ),\n  (List.take (i + 1) w).length = i + 1 →\n    (↑C).t (i + 1) = i →\n      List.length ((↑C).scan_temporal_rt (List.take (i + 1) w)) = i + 1 →\n        ¬i < List.length ((↑C).scan_temporal_rt (List.take (i + 1) w)) → False",
  "constCategory": "Theorem"},
 {"references": ["Exists.casesOn"],
  "name": "_private.Init.PropLemmas.0.exists_prop_congr.match_1_1",
  "constType":
  "∀ {p : Prop} {q : p → Prop} (motive : Exists q → Prop) (x : Exists q), (∀ (w : p) (h : q w), motive ⋯) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Nat.below", "List.range.loop.match_1", "Nat.brecOn", "OfNat.ofNat"],
  "name": "List.range.loop",
  "constType": "ℕ → List ℕ → List ℕ",
  "constCategory": "Definition"},
 {"references":
  ["implies_congr",
   "Int.Linear.Poly.beq'",
   "Eq.trans",
   "Int.Linear.Poly.denote'_eq_denote",
   "Int.Linear.Poly.denote",
   "HMul.hMul",
   "Int.Linear.Poly.denote_combine_mul_k",
   "Int.add_zero",
   "congrArg",
   "congr",
   "Eq.symm",
   "Int.Linear.Poly.denote'",
   "Eq.ndrec",
   "Neg.neg",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "Int.mul_zero",
   "eq_self",
   "Int.Linear.eq_eq_subst'_cert",
   "Int.Linear.Poly.combine_mul_k",
   "Int.Linear.Context",
   "of_eq_true",
   "Int.Linear.Poly.beq'_eq",
   "id",
   "Eq.mpr"],
  "name": "Int.Linear.eq_eq_subst'",
  "constType":
  "∀ (ctx : Int.Linear.Context) (a b : ℤ) (p₁ p₂ p₃ : Int.Linear.Poly),\n  Int.Linear.eq_eq_subst'_cert a b p₁ p₂ p₃ = true →\n    Int.Linear.Poly.denote' ctx p₁ = 0 → Int.Linear.Poly.denote' ctx p₂ = 0 → Int.Linear.Poly.denote' ctx p₃ = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Grind.AC.Var",
   "Lean.Grind.AC.Seq.insert",
   "Lean.Grind.AC.Seq.unionFuel.match_3",
   "Nat.blt",
   "Lean.Grind.AC.Seq.unionFuel.match_1",
   "ite",
   "Nat.below",
   "Lean.Grind.AC.Seq.concat",
   "Nat.brecOn",
   "OfNat.ofNat",
   "Unit"],
  "name": "Lean.Grind.AC.Seq.unionFuel",
  "constType": "ℕ → Grind.AC.Seq → Grind.AC.Seq → Grind.AC.Seq",
  "constCategory": "Definition"},
 {"references": ["List.casesOn", "Ne"],
  "name": "_private.Init.Data.List.Lemmas.0.List.getLast_eq_getElem.match_1",
  "constType":
  "∀ {α : Type u_1} (motive : (l : List α) → l ≠ [] → Prop) (l : List α) (h : l ≠ []),\n  (∀ (h : [] ≠ []), motive [] h) → (∀ (a : α) (l : List α) (h : a :: l ≠ []), motive (a :: l) h) → motive l h",
  "constCategory": "Definition"},
 {"references":
  ["HMod.hMod", "Fin.val", "Nat.cast", "sorryAx", "Fin.intCast", "OfNat.ofNat"],
  "name": "CellularAutomatas.speedup_factor_k.intCastEq",
  "constType":
  "∀ {k : ℕ} [inst : NeZero k] (p : ℤ), ↑↑(Fin.intCast p) = p % ↑k",
  "constCategory": "Theorem"},
 {"references": ["And.casesOn"],
  "name": "_private.Init.PropLemmas.0.forall_and.match_1_1",
  "constType":
  "∀ {α : Sort u_1} {p q : α → Prop} (motive : ((∀ (x : α), p x) ∧ ∀ (x : α), q x) → Prop)\n  (x : (∀ (x : α), p x) ∧ ∀ (x : α), q x), (∀ (h₁ : ∀ (x : α), p x) (h₂ : ∀ (x : α), q x), motive ⋯) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Ne",
   "Nat.ne_of_beq_eq_false",
   "OfNat.ofNat",
   "Int.Linear.Poly.ctorIdx",
   "Int.Linear.Var"],
  "name": "Int.Linear.instBEqPoly.beq._sparseCasesOn_1",
  "constType":
  "{motive : Int.Linear.Poly → Sort u} →\n  (t : Int.Linear.Poly) → ((k : ℤ) → motive (Int.Linear.Poly.num k)) → (t.ctorIdx ≠ 0 → motive t) → motive t",
  "constCategory": "Definition"},
 {"references": [],
  "name": "namedPattern",
  "constType": "{α : Sort u} → (x a : α) → x = a → α",
  "constCategory": "Definition"},
 {"references":
  ["HAdd.hAdd",
   "id",
   "Lean.Grind.AddCommMonoid.add_comm",
   "Lean.Grind.AddCommMonoid.add_zero",
   "Eq.mpr",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Lean.Grind.AddCommMonoid.zero_add",
  "constType":
  "∀ {M : Type u} [inst : Grind.AddCommMonoid M] (a : M), 0 + a = a",
  "constCategory": "Theorem"},
 {"references":
  ["HAppend.hAppend",
   "List.reverse",
   "List.reverseAux_eq_append",
   "Eq.symm",
   "id",
   "Eq.mpr",
   "List.reverseAux",
   "congrArg"],
  "name": "List.reverse_cons",
  "constType":
  "∀ {α : Type u} {a : α} {as : List α}, (a :: as).reverse = as.reverse ++ [a]",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.propIntro",
   "Int.negSucc.noConfusion",
   "Eq.symm",
   "Eq.ndrec",
   "Eq.casesOn"],
  "name": "Int.negSucc.injEq",
  "constType": "∀ (a a_1 : ℕ), (Int.negSucc a = Int.negSucc a_1) = (a = a_1)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CellularAutomatas.CArtTransducer.rec",
  "constType":
  "{α Γ : Type} →\n  [inst : CellularAutomatas.Alphabet α] →\n    [inst_1 : CellularAutomatas.Alphabet Γ] →\n      {motive : CellularAutomatas.CArtTransducer α Γ → Sort u} →\n        ((toLCellAutomaton : CellularAutomatas.LCellAutomaton α) →\n            (f : toLCellAutomaton.Q → Γ) → motive { toLCellAutomaton := toLCellAutomaton, f := f }) →\n          (t : CellularAutomatas.CArtTransducer α Γ) → motive t",
  "constCategory": "Other"},
 {"references":
  ["Not",
   "CellularAutomatas.Word.get'",
   "CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "CellularAutomatas.Word",
   "Set",
   "Membership.mem",
   "CellularAutomatas.Word.range",
   "CellularAutomatas.CellAutomaton.Q",
   "CellularAutomatas.LCellAutomaton.border",
   "dite",
   "CellularAutomatas.LCellAutomaton.embed"],
  "name": "CellularAutomatas.LCellAutomaton.embed_word",
  "constType":
  "{α : Type} → (C : CellularAutomatas.LCellAutomaton α) → CellularAutomatas.Word α → CellularAutomatas.Config C.Q",
  "constCategory": "Definition"},
 {"references": ["Lean.Grind.AC.Var", "Lean.Grind.AC.Seq.casesOn"],
  "name": "Lean.Grind.AC.Seq.erase0.match_1",
  "constType":
  "(motive : Grind.AC.Seq → Sort u_1) →\n  (s : Grind.AC.Seq) →\n    ((x : Grind.AC.Var) → motive (Grind.AC.Seq.var x)) →\n      ((x : Grind.AC.Var) → (s : Grind.AC.Seq) → motive (Grind.AC.Seq.cons x s)) → motive s",
  "constCategory": "Definition"},
 {"references": ["Int.neg.match_1"],
  "name": "Int.natAbs",
  "constType": "ℤ → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Eq.trans",
   "true_or",
   "Membership.mem",
   "eq_true",
   "or_true",
   "congrArg",
   "Unit",
   "eq_self",
   "List.cons.noConfusion",
   "of_eq_true",
   "List.Mem.casesOn",
   "Eq.ndrec",
   "_private.Init.Data.List.Lemmas.0.List.mem_cons.match_1_1"],
  "name": "List.mem_cons",
  "constType":
  "∀ {α : Type u_1} {b : α} {l : List α} {a : α}, a ∈ b :: l ↔ a = b ∨ a ∈ l",
  "constCategory": "Theorem"},
 {"references":
  ["Neg.neg",
   "Lean.Omega.Constraint.neg",
   "ite",
   "LE.le",
   "Lean.Omega.Coeffs.smul",
   "Lean.Omega.Coeffs",
   "Lean.Omega.Coeffs.leading",
   "Lean.Omega.normalize?.match_1",
   "OfNat.ofNat"],
  "name": "Lean.Omega.positivize?",
  "constType":
  "Omega.Constraint ⨉ Omega.Coeffs → Option (Omega.Constraint ⨉ Omega.Coeffs)",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Bind.bind",
  "constType":
  "{m : Type u → Type v} → [self : Bind m] → {α β : Type u} → m α → (α → m β) → m β",
  "constCategory": "Definition"},
 {"references":
  ["LT.lt",
   "List.length_mapIdx",
   "Eq.mp",
   "List.mapIdx",
   "congrArg",
   "List.length"],
  "name": "List.getElem_mapIdx._proof_1",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {l : List α} {f : ℕ → α → β} {i : ℕ} {h : i < (List.mapIdx f l).length}, i < l.length",
  "constCategory": "Theorem"},
 {"references":
  ["Not", "LT.lt", "Iff.mpr", "LE.le", "Iff.mp", "Int.le_trans", "Int.not_le"],
  "name": "Int.lt_of_lt_of_le",
  "constType": "∀ {a b c : ℤ}, a < b → b ≤ c → a < c",
  "constCategory": "Theorem"},
 {"references":
  ["not_lt._simp_1",
   "Nat.cast",
   "Eq.trans",
   "Membership.mem",
   "eq_true",
   "EmptyCollection.emptyCollection",
   "GE.ge",
   "congrArg",
   "congr",
   "funext",
   "CellularAutomatas.Word.range",
   "ge_iff_le._simp_1",
   "Not",
   "not_and._simp_1",
   "Set",
   "iff_false",
   "OfNat.ofNat",
   "LT.lt",
   "implies_true",
   "of_eq_true",
   "LE.le",
   "id",
   "Set.mem_empty_iff_false._simp_1",
   "Set.ext",
   "implies_congr_ctx",
   "List.length",
   "setOf"],
  "name": "CellularAutomatas.empty_word_range",
  "constType": "∀ {α : Type u_1}, CellularAutomatas.Word.range [] = ∅",
  "constCategory": "Theorem"},
 {"references": ["Set", "Singleton.singleton", "Membership.mem", "Iff.rfl"],
  "name": "Set.mem_singleton_iff",
  "constType": "∀ {α : Type u} {a b : α}, a ∈ {b} ↔ a = b",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "LT.lt",
   "List.drop",
   "HSub.hSub",
   "id",
   "Nat.add_lt_of_lt_sub",
   "Nat.add_comm",
   "Eq.mpr",
   "List.length_drop",
   "congrArg",
   "List.length"],
  "name": "List.getElem_drop._proof_1",
  "constType":
  "∀ {α : Type u_1} {xs : List α} {i j : ℕ} {h : j < xs⟦i..*⟧.length}, i + j < xs.length",
  "constCategory": "Theorem"},
 {"references":
  ["Or.elim",
   "Lean.Omega.LinearCombo.coordinate_eval_2",
   "Nat.cast",
   "Eq.trans",
   "Lean.Omega.LinearCombo.coordinate_eval_3",
   "le_of_le_of_eq",
   "Lean.Omega.LinearCombo.coordinate_eval_0",
   "Lean.Omega.Constraint.combine_sat'",
   "Int.sub_eq_zero_of_eq",
   "Decidable.decide",
   "Lean.Omega.Int.ofNat_le_of_le",
   "Lean.Omega.Coeffs.ofList",
   "Lean.Omega.tidy_sat",
   "Eq.symm",
   "HSub.hSub",
   "Lean.Omega.Int.lt_of_not_le",
   "Lean.Omega.LinearCombo.add_eval",
   "Lean.Omega.ite_disjunction",
   "Int.add_one_le_of_lt",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "And.left",
   "of_decide_eq_true",
   "Not",
   "Lean.Omega.combo_sat'",
   "Int.min_def",
   "Neg.neg",
   "ite",
   "And.right",
   "Lean.Omega.Constraint.addInequality_sat",
   "Lean.Omega.Int.add_congr",
   "Lean.Omega.Constraint.isImpossible",
   "Lean.Omega.LinearCombo.coordinate",
   "OfNat.ofNat",
   "Int.sub_nonneg_of_le",
   "HAdd.hAdd",
   "Lean.Omega.LinearCombo.coordinate_eval_1",
   "LT.lt",
   "Nat.le_of_not_lt",
   "Lean.Omega.Int.ofNat_lt_of_lt",
   "Lean.Omega.LinearCombo.sub_eval",
   "Min.min",
   "LE.le",
   "Lean.Omega.Constraint.addEquality_sat",
   "id",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.Int.ofNat_min",
   "Lean.Omega.Int.sub_congr",
   "List.length"],
  "name":
  "_private.Init.Data.List.Nat.TakeDrop.0.List.lt_length_left_of_zipWith._proof_1_1",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {i : ℕ} {l : List α} {l' : List β}, i < min l.length l'.length → ¬i < l.length → False",
  "constCategory": "Theorem"},
 {"references": ["HAdd.hAdd"],
  "name": "Int.ofNat_nonneg",
  "constType": "∀ (n : ℕ), 0 ≤ ↑n",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.propIntro",
   "CellularAutomatas.simulation.Params.C_ctl",
   "Eq.symm",
   "CellularAutomatas.CellAutomaton.Q",
   "CellularAutomatas.simulation.Q1.mk.noConfusion",
   "Eq.ndrec",
   "Eq.casesOn",
   "OfNat.ofNat",
   "And.casesOn"],
  "name": "CellularAutomatas.simulation.Q1.mk.injEq",
  "constType":
  "∀ {e : CellularAutomatas.simulation.Params} (state : e.C_ctl.Q) (counter : Fin 3) (state_1 : e.C_ctl.Q)\n  (counter_1 : Fin 3),\n  ({ state := state, counter := counter } = { state := state_1, counter := counter_1 }) =\n    (state = state_1 ∧ counter = counter_1)",
  "constCategory": "Theorem"},
 {"references": ["beq_iff_eq", "BEq.beq", "propext"],
  "name": "beq_iff_eq._simp_1",
  "constType":
  "∀ {α : Type u_1} [inst : BEq α] [LawfulBEq α] {a b : α}, ((a == b) = true) = (a = b)",
  "constCategory": "Theorem"},
 {"references": ["Or.casesOn", "Not"],
  "name": "Classical.propDecidable.match_1",
  "constType":
  "∀ (a : Prop) (motive : a ∨ ¬a → Prop) (x : a ∨ ¬a), (∀ (h : a), motive ⋯) → (∀ (h : ¬a), motive ⋯) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["SetLike.mem_coe", "SetLike.coe", "Set", "Membership.mem", "propext"],
  "name": "SetLike.mem_coe._simp_1",
  "constType":
  "∀ {A : Type u_1} {B : Type u_2} [i : SetLike A B] {p : A} {x : B}, (x ∈ ↑p) = (x ∈ p)",
  "constCategory": "Theorem"},
 {"references": ["Nat.pred_le_pred"],
  "name": "Nat.le_of_succ_le_succ",
  "constType": "∀ {n m : ℕ}, n.succ ≤ m.succ → n ≤ m",
  "constCategory": "Theorem"},
 {"references": ["CellularAutomatas.CArtTransducer._sizeOf_1"],
  "name": "CellularAutomatas.CArtTransducer._sizeOf_inst",
  "constType":
  "(α Γ : Type) →\n  {inst : CellularAutomatas.Alphabet α} →\n    {inst_1 : CellularAutomatas.Alphabet Γ} → [SizeOf α] → [SizeOf Γ] → SizeOf (CellularAutomatas.CArtTransducer α Γ)",
  "constCategory": "Definition"},
 {"references":
  ["Multiset.map", "Finset.val", "DecidableEq", "Multiset.toFinset"],
  "name": "Finset.image",
  "constType":
  "{α : Type u_1} → {β : Type u_2} → [DecidableEq β] → (α → β) → Finset α → Finset β",
  "constCategory": "Definition"},
 {"references": [],
  "name": "BEq.beq",
  "constType": "{α : Type u} → [self : BEq α] → α → α → Bool",
  "constCategory": "Definition"},
 {"references":
  ["Nat.cast",
   "Eq.trans",
   "le_of_le_of_eq",
   "Int.negSucc_eq",
   "Lean.Omega.Constraint.combine_sat'",
   "Lean.Omega.LinearCombo.coordinate_eval_0",
   "Decidable.decide",
   "Lean.Omega.LinearCombo.neg_eval",
   "Lean.Omega.Coeffs.ofList",
   "Lean.Omega.tidy_sat",
   "Eq.symm",
   "HSub.hSub",
   "Lean.Omega.LinearCombo.add_eval",
   "Lean.Omega.Int.lt_of_not_le",
   "Lean.Omega.Int.neg_congr",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "Int.add_one_le_of_lt",
   "of_decide_eq_true",
   "Not",
   "Lean.Omega.combo_sat'",
   "Neg.neg",
   "Lean.Omega.Constraint.addInequality_sat",
   "Lean.Omega.Int.add_congr",
   "Lean.Omega.Constraint.isImpossible",
   "Lean.Omega.LinearCombo.coordinate",
   "OfNat.ofNat",
   "Int.ofNat_nonneg",
   "Int.sub_nonneg_of_le",
   "Lean.Omega.LinearCombo.coordinate_eval_1",
   "HAdd.hAdd",
   "Lean.Omega.LinearCombo.sub_eval",
   "LE.le",
   "id",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.Int.sub_congr"],
  "name": "_private.Init.Data.Int.LemmasAux.0.Int.ble'_eq_true._proof_1_3",
  "constType": "∀ (a a_1 : ℕ), ¬Int.negSucc a ≤ ↑a_1 → False",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Monoid.npow_succ",
  "constType":
  "∀ {M : Type u} [self : Monoid M] (n : ℕ) (x : M), Monoid.npow (n + 1) x = Monoid.npow n x * x",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "Nat.add",
   "Nat.le_succ_of_le",
   "_private.Init.Data.Nat.Basic.0.Nat.le_add_right.match_1_1",
   "Nat.below",
   "LE.le",
   "Nat.le_refl",
   "Nat.brecOn",
   "OfNat.ofNat"],
  "name": "Nat.le_add_right",
  "constType": "∀ (n k : ℕ), n ≤ n + k",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "Int.Linear.Poly.beq'",
   "Nat.cast",
   "Eq.trans",
   "Int.Linear.Poly.denote'_eq_denote",
   "Int.Linear.Poly.denote",
   "HMul.hMul",
   "Int.Linear.Poly.denote_combine_mul_k",
   "Int.add_zero",
   "congrArg",
   "Int.zero_mul",
   "Int.Linear.Poly.leadCoeff",
   "Eq.symm",
   "Int.Linear.Poly.denote'",
   "Int.natAbs",
   "Eq.ndrec",
   "Int.Linear.le_combine_cert",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "Int.natCast_nonneg._simp_1",
   "of_eq_true",
   "Int.Linear.Poly.combine_mul_k",
   "Int.Linear.Context",
   "LE.le",
   "Int.add_comm",
   "Int.mul_le_mul_of_nonpos_right",
   "id",
   "Int.Linear.Poly.beq'_eq",
   "Eq.mpr",
   "Int.add_le_add"],
  "name": "Int.Linear.le_combine",
  "constType":
  "∀ (ctx : Int.Linear.Context) (p₁ p₂ p₃ : Int.Linear.Poly),\n  Int.Linear.le_combine_cert p₁ p₂ p₃ = true →\n    Int.Linear.Poly.denote' ctx p₁ ≤ 0 → Int.Linear.Poly.denote' ctx p₂ ≤ 0 → Int.Linear.Poly.denote' ctx p₃ ≤ 0",
  "constCategory": "Theorem"},
 {"references": ["Prod.casesOn", "Option.casesOn", "Unit.unit", "Unit"],
  "name": "CellularAutomatas.analyzeAndVerify.match_3",
  "constType":
  "(motive : Option (Name ⨉ List Name) → Sort u_1) →\n  (x : Option (Name ⨉ List Name)) →\n    ((fst : Name) → (allowedAxioms : List Name) → motive (some (fst, allowedAxioms))) → (Unit → motive none) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Or.elim",
   "Lean.Omega.LinearCombo.coordinate_eval_2",
   "Nat.cast",
   "Eq.trans",
   "Lean.Omega.LinearCombo.coordinate_eval_3",
   "le_of_le_of_eq",
   "Lean.Omega.LinearCombo.coordinate_eval_0",
   "Lean.Omega.Constraint.combine_sat'",
   "Int.sub_eq_zero_of_eq",
   "Decidable.decide",
   "Lean.Omega.Int.ofNat_le_of_le",
   "Lean.Omega.Coeffs.ofList",
   "Eq.symm",
   "Lean.Omega.tidy_sat",
   "HSub.hSub",
   "Lean.Omega.LinearCombo.add_eval",
   "Lean.Omega.ite_disjunction",
   "Int.add_one_le_of_lt",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "And.left",
   "of_decide_eq_true",
   "Not",
   "Lean.Omega.combo_sat'",
   "Int.min_def",
   "Neg.neg",
   "ite",
   "And.right",
   "Lean.Omega.Constraint.addInequality_sat",
   "Lean.Omega.Int.add_congr",
   "Lean.Omega.Constraint.isImpossible",
   "Lean.Omega.LinearCombo.coordinate",
   "OfNat.ofNat",
   "Int.sub_nonneg_of_le",
   "HAdd.hAdd",
   "Lean.Omega.LinearCombo.coordinate_eval_1",
   "LT.lt",
   "Nat.le_of_not_lt",
   "Lean.Omega.Int.ofNat_lt_of_lt",
   "Lean.Omega.LinearCombo.sub_eval",
   "Min.min",
   "LE.le",
   "Lean.Omega.Constraint.addEquality_sat",
   "id",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.Int.ofNat_min",
   "Lean.Omega.Int.sub_congr",
   "List.length"],
  "name":
  "_private.Init.Data.List.Nat.TakeDrop.0.List.lt_length_right_of_zipWith._proof_1_1",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {i : ℕ} {l : List α} {l' : List β}, i < min l.length l'.length → ¬i < l'.length → False",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.Word.get'._proof_1",
   "Int.toNat",
   "CellularAutomatas.Word",
   "List.get",
   "Set",
   "Membership.mem",
   "CellularAutomatas.Word.range",
   "List.length"],
  "name": "CellularAutomatas.Word.get'",
  "constType":
  "{α : Type u} → (w : CellularAutomatas.Word α) → (i : ℤ) → i ∈ w.range → α",
  "constCategory": "Definition"},
 {"references":
  ["Not",
   "Int.lt_iff_le_and_ne",
   "Int.le_refl",
   "_private.Init.Data.Int.Order.0.Int.lt_iff_le_not_le.match_1_3",
   "congrArg",
   "LT.lt",
   "Int.le_antisymm",
   "Not.imp",
   "_private.Init.Data.Int.Order.0.Int.lt_iff_le_not_le.match_1_1",
   "LE.le",
   "id",
   "Eq.mpr",
   "Ne",
   "Eq.ndrec",
   "propext"],
  "name": "Int.lt_iff_le_not_le",
  "constType": "∀ {a b : ℤ}, a < b ↔ a ≤ b ∧ ¬b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["Int.Linear.Poly.brecOn",
   "Int.Linear.Poly.denote.match_1",
   "HMul.hMul",
   "Int.Linear.Var",
   "Int.Linear.Poly.below"],
  "name": "Int.Linear.Poly.mul'",
  "constType": "Int.Linear.Poly → ℤ → Int.Linear.Poly",
  "constCategory": "Definition"},
 {"references":
  ["rfl",
   "List.range'",
   "Nat.brecOn",
   "Nat.add_assoc",
   "List.range.loop",
   "OfNat.ofNat",
   "congrArg",
   "HAdd.hAdd",
   "Nat.add_right_comm",
   "Nat.below",
   "id",
   "Eq.symm",
   "Eq.mpr",
   "_private.Init.Data.List.Range.0.List.range_loop_range'.match_1_1"],
  "name": "List.range_loop_range'",
  "constType":
  "∀ (s n : ℕ), List.range.loop s (List.range' s n) = List.range' 0 (n + s)",
  "constCategory": "Theorem"},
 {"references": ["Lean.SyntaxNodeKind"],
  "name": "Lean.SyntaxNodeKinds",
  "constType": "Type",
  "constCategory": "Definition"},
 {"references": ["rfl", "HAdd.hAdd", "Not", "LE.le", "OfNat.ofNat"],
  "name": "Nat.findX._proof_3",
  "constType":
  "∀ {p : ℕ → Prop} (m : ℕ), (∀ n ≤ m, ¬p n) → m + 1 = m + 1 ∧ ∀ k ≤ m, ¬p k",
  "constCategory": "Theorem"},
 {"references":
  ["Not", "eq_self", "Eq.trans", "of_eq_true", "ite", "ite_congr", "congrArg"],
  "name": "ite_cond_eq_true",
  "constType":
  "∀ {α : Sort u} {c : Prop} {x : Decidable c} (a b : α), c = True → (if c then a else b) = a",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.simulation.C'",
   "sorryAx",
   "CellularAutomatas.CellAutomaton.Q",
   "OfNat.ofNat",
   "CellularAutomatas.simulation.Params.C_inr"],
  "name": "CellularAutomatas.simulation.to_CinrQ",
  "constType":
  "(e : CellularAutomatas.simulation.Params) → (CellularAutomatas.simulation.C' e).Q → e.C_inr.Q",
  "constCategory": "Definition"},
 {"references": ["Not", "not_exists", "propext"],
  "name": "not_exists._simp_1",
  "constType": "∀ {α : Sort u_1} {p : α → Prop}, (¬∃ x, p x) = ∀ (x : α), ¬p x",
  "constCategory": "Theorem"},
 {"references": ["LE.le", "And.casesOn"],
  "name": "_private.Init.Data.Int.Order.0.Int.eq_iff_le_and_ge.match_1_1",
  "constType":
  "∀ {x y : ℤ} (motive : x ≤ y ∧ y ≤ x → Prop) (h : x ≤ y ∧ y ≤ x), (∀ (h₁ : x ≤ y) (h₂ : y ≤ x), motive ⋯) → motive h",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CellularAutomatas.composition.Params._inst_α",
  "constType":
  "(self : CellularAutomatas.composition.Params) → CellularAutomatas.Alphabet self.α",
  "constCategory": "Definition"},
 {"references": ["Nat.casesOn", "Unit.unit", "Unit"],
  "name": "Nat.beq.match_1",
  "constType":
  "(motive : ℕ → ℕ → Sort u_1) →\n  (x x_1 : ℕ) →\n    (Unit → motive Nat.zero Nat.zero) →\n      ((n : ℕ) → motive Nat.zero n.succ) →\n        ((n : ℕ) → motive n.succ Nat.zero) → ((n m : ℕ) → motive n.succ m.succ) → motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["HMul.hMul", "Int.mul_ne_zero_iff", "Ne", "OfNat.ofNat", "propext"],
  "name": "Int.mul_ne_zero_iff._simp_1",
  "constType": "∀ {a b : ℤ}, (a * b ≠ 0) = (a ≠ 0 ∧ b ≠ 0)",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "False.elim",
   "Eq.trans",
   "of_eq_true",
   "noConfusion_of_Nat",
   "eq_false'",
   "Bool.ctorIdx",
   "congrArg"],
  "name": "Bool.true_eq_false",
  "constType": "(true = false) = False",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans",
   "CellularAutomatas.CellAutomaton.nextt",
   "CellularAutomatas.uniform_config",
   "CellularAutomatas.δδt",
   "CellularAutomatas.LCellAutomaton.empty_word_config_eq_uniform_border",
   "Function.comp",
   "CellularAutomatas.Config",
   "congrArg",
   "CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "eq_self",
   "of_eq_true",
   "CellularAutomatas.LCellAutomaton.uniform_state_eq",
   "CellularAutomatas.LCellAutomaton.embed_word",
   "CellularAutomatas.CellAutomaton.Q",
   "CellularAutomatas.LCellAutomaton.border"],
  "name": "CellularAutomatas.LCellAutomaton.comp_empty_eq_uniform",
  "constType":
  "∀ {α : Type} {C : CellularAutomatas.LCellAutomaton α},\n  C.comp [] = CellularAutomatas.uniform_config ∘ CellularAutomatas.δδt C.border",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.Word",
   "CellularAutomatas.FiniteStateTransducer.scanr_foldr_state",
   "CellularAutomatas.FiniteStateTransducer.comp",
   "Eq.trans",
   "CellularAutomatas.FiniteStateTransducer.scanr_q",
   "CellularAutomatas.FiniteStateTransducer.Q",
   "and_true",
   "Prod.snd",
   "List.foldr",
   "Prod.fst",
   "congrArg",
   "CellularAutomatas.FiniteStateTransducer.scanr_reduce_q",
   "eq_self",
   "of_eq_true",
   "List.cons.injEq",
   "CellularAutomatas.FiniteStateTransducer.scanr_step",
   "id",
   "CellularAutomatas.FiniteStateTransducer.scanr_reduce_q_empty",
   "Eq.mpr",
   "CellularAutomatas.FiniteStateTransducer.f",
   "CellularAutomatas.FiniteStateTransducer.δ"],
  "name": "CellularAutomatas.FiniteStateTransducer.comp_scanr_reduce_q",
  "constType":
  "∀ {α β γ : Type} [CellularAutomatas.Alphabet α] [CellularAutomatas.Alphabet β] [CellularAutomatas.Alphabet γ]\n  {M2 : CellularAutomatas.FiniteStateTransducer β γ} {M1 : CellularAutomatas.FiniteStateTransducer α β} (q1 : M1.Q)\n  (q2 : M2.Q) (w : CellularAutomatas.Word α),\n  (M2 ⊚ M1).scanr_reduce_q (q1, q2) w = (M1.scanr_reduce_q q1 w, M2.scanr_reduce_q q2 (M1.scanr_q q1 w))",
  "constCategory": "Theorem"},
 {"references": ["Int.Linear.Context", "Lean.RArray.get", "Int.Linear.Var"],
  "name": "Int.Linear.Var.denote",
  "constType": "Int.Linear.Context → Int.Linear.Var → ℤ",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Name.brecOn", "Lean.Name.below", "Lean.Name.appendCore.match_1"],
  "name": "Lean.Name.appendCore",
  "constType": "Name → Name → Name",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CellularAutomatas.ProductAlphabet",
  "constType":
  "{α β : Type} → [CellularAutomatas.Alphabet α] → [CellularAutomatas.Alphabet β] → CellularAutomatas.Alphabet (α ⨉ β)",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "List.ctorIdx",
   "False.elim",
   "Eq.trans",
   "of_eq_true",
   "List.zipWith.eq_2",
   "noConfusion_of_Nat",
   "List.zipWith",
   "congrArg"],
  "name": "List.zipWith_nil_right",
  "constType":
  "∀ {α : Type u} {β : Type v} {γ : Type w} {l : List α} {f : α → β → γ}, List.zipWith f l [] = []",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CellularAutomatas.simulation.Params.mk",
  "constType":
  "(C_inr C_ctl : CellularAutomatas.CellAutomaton) → (C_ctl.Q → Option C_inr.Q) → CellularAutomatas.simulation.Params",
  "constCategory": "Other"},
 {"references":
  ["Not",
   "CellularAutomatas.simulation.instDecidableEqQ1.decEq._proof_3",
   "CellularAutomatas.simulation.instDecidableEqQ1.decEq._proof_1",
   "CellularAutomatas.simulation.Params.C_ctl",
   "CellularAutomatas.CellAutomaton.Q",
   "CellularAutomatas.simulation.instDecidableEqQ1.decEq.match_1",
   "CellularAutomatas.simulation.instDecidableEqQ1.decEq._proof_2",
   "Eq.ndrec",
   "dite",
   "OfNat.ofNat"],
  "name": "CellularAutomatas.simulation.instDecidableEqQ1.decEq",
  "constType":
  "{e : CellularAutomatas.simulation.Params} → (x x_1 : CellularAutomatas.simulation.Q1 e) → Decidable (x = x_1)",
  "constCategory": "Definition"},
 {"references":
  ["LT.lt",
   "Int.sub_pos_of_lt",
   "Eq.mp",
   "Int.lt_of_sub_pos",
   "Int.mul_pos",
   "HSub.hSub",
   "HMul.hMul",
   "Int.mul_sub",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Int.mul_lt_mul_of_pos_left",
  "constType": "∀ {a b c : ℤ}, a < b → 0 < c → c * a < c * b",
  "constCategory": "Theorem"},
 {"references":
  ["Bind.bind",
   "Lean.NameMap.find?",
   "_private.Lean.Environment.0.Lean.Environment.allRealizations",
   "Bool.not",
   "Bool.and",
   "Lean.NameMap",
   "ite",
   "_private.Lean.Environment.0.Lean.AsyncConsts.add.match_1",
   "Pure.pure",
   "Task.get",
   "_private.Lean.Environment.0.Lean.Environment.asyncConsts",
   "_private.Lean.Environment.0.Lean.AsyncConsts.find?"],
  "name": "_private.Lean.Environment.0.Lean.Environment.findAsyncConst?",
  "constType":
  "Environment → Name → optParam Bool false → Option Lean.AsyncConst✝",
  "constCategory": "Definition"},
 {"references": ["Ne"],
  "name": "Ne.eq_1",
  "constType": "∀ {α : Sort u} (a b : α), (a ≠ b) = ¬a = b",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.CellAutomaton.δ", "CellularAutomatas.CellAutomaton.Q"],
  "name": "CellularAutomatas.CellAutomaton.right_independent",
  "constType": "CellularAutomatas.CellAutomaton → Prop",
  "constCategory": "Definition"},
 {"references": ["NeZero.out"],
  "name": "NeZero.ne",
  "constType": "∀ {R : Type u_1} [inst : Zero R] (n : R) [h : NeZero n], n ≠ 0",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "HAdd.hAdd",
   "Lean.Grind.Nat.lt_eq",
   "Eq.substr",
   "List.take",
   "LE.le",
   "HSub.hSub",
   "OfNat.ofNat",
   "List.length"],
  "name": "CellularAutomatas.PrefixStableProof.getLastOfTake._proof_1_8",
  "constType":
  "∀ {i : ℕ} {α : Type u_1} {w : List α},\n  (List.take (i + 1) w).length - 1 + 1 ≤ w.length → (List.take (i + 1) w).length - 1 < w.length",
  "constCategory": "Theorem"},
 {"references": ["Neg.neg", "OfNat.ofNat", "propext", "Int.neg_eq_zero"],
  "name": "Int.neg_eq_zero._simp_1",
  "constType": "∀ {a : ℤ}, (-a = 0) = (a = 0)",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "Lean.Grind.AC.Seq.union_k",
   "Eq.trans",
   "Eq.mp",
   "and_imp._simp_1",
   "Lean.Grind.AC.Seq.denote_union",
   "congrArg",
   "Lean.Grind.AC.Seq.union",
   "Bool.and",
   "congr",
   "Eq.symm",
   "Lean.Grind.AC.Seq.denote",
   "Lean.Grind.AC.Seq.union_k_eq_union",
   "Eq.ndrec",
   "Lean.Grind.AC.Seq.beq'_eq",
   "Bool.and'_eq_and",
   "Lean.Grind.AC.Context.op",
   "Lean.Grind.AC.simp_ac_cert",
   "eq_self",
   "of_eq_true",
   "id",
   "Lean.Grind.AC.Seq.beq'",
   "Eq.mpr",
   "Bool.and_eq_true",
   "Bool.and'"],
  "name": "Lean.Grind.AC.eq_simp_rhs_ac",
  "constType":
  "∀ {α : Sort u_1} (ctx : Grind.AC.Context α) {inst₁ : Associative ctx.op} {inst₂ : Commutative ctx.op}\n  (c lhs₁ rhs₁ lhs₂ rhs₂ rhs₂' : Grind.AC.Seq),\n  Grind.AC.simp_ac_cert c lhs₁ rhs₁ rhs₂ rhs₂' = true →\n    Grind.AC.Seq.denote ctx lhs₁ = Grind.AC.Seq.denote ctx rhs₁ →\n      Grind.AC.Seq.denote ctx lhs₂ = Grind.AC.Seq.denote ctx rhs₂ →\n        Grind.AC.Seq.denote ctx lhs₂ = Grind.AC.Seq.denote ctx rhs₂'",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Std.Associative.assoc",
  "constType":
  "∀ {α : Sort u} {op : α → α → α} [self : Associative op] (a b c : α), op (op a b) c = op a (op b c)",
  "constCategory": "Theorem"},
 {"references":
  ["Int.neg_le_neg_iff",
   "Neg.neg",
   "LE.le",
   "Eq.symm",
   "id",
   "Int.neg_zero",
   "Eq.mpr",
   "Iff.rfl",
   "propext",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Int.neg_le_zero_iff",
  "constType": "∀ {a : ℤ}, -a ≤ 0 ↔ 0 ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.cast",
   "Eq.mp",
   "Int.ofNat_eq_natCast",
   "Lean.Grind.Ring.intCast_natCast",
   "Int.cast",
   "congrArg",
   "False.elim",
   "Eq.symm",
   "Eq.ndrec",
   "Nat.casesAuxOn",
   "Not",
   "Lean.Grind.Ring.intCast",
   "_private.Init.Grind.Ordered.Ring.0.Lean.Grind.OrderedRing.pos_intCast_of_pos._proof_1_1",
   "Lean.Grind.OrderedRing.pos_natCast_of_pos",
   "Int.casesOn",
   "OfNat.ofNat",
   "Int.lt_irrefl._simp_1",
   "HAdd.hAdd",
   "LT.lt",
   "of_eq_true",
   "Classical.byContradiction",
   "id",
   "Eq.mpr",
   "Lean.Grind.Semiring.natCast",
   "Nat.zero_lt_succ._simp_1"],
  "name": "Lean.Grind.OrderedRing.pos_intCast_of_pos",
  "constType":
  "∀ {R : Type u} [inst : Grind.Ring R] [inst_1 : LE R] [inst_2 : LT R] [LawfulOrderLT R] [inst_4 : Std.IsPreorder R]\n  [Grind.OrderedRing R] (a : ℤ), 0 < a → 0 < ↑a",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "SizeOf.sizeOf",
   "CellularAutomatas.CellAutomaton.Q",
   "OfNat.ofNat"],
  "name": "CellularAutomatas.simulation.Params._sizeOf_1",
  "constType": "CellularAutomatas.simulation.Params → ℕ",
  "constCategory": "Definition"},
 {"references": ["Or.casesOn", "LT.lt"],
  "name": "_private.Init.Prelude.0.Nat.lt_or_ge.match_1_1",
  "constType":
  "∀ (n m : ℕ) (motive : m = n ∨ m < n → Prop) (x : m = n ∨ m < n),\n  (∀ (h1 : m = n), motive ⋯) → (∀ (h1 : m < n), motive ⋯) → motive x",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CellularAutomatas.backwards_fsm.Params.β",
  "constType": "CellularAutomatas.backwards_fsm.Params → Type",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Name.mkStr4",
   "Bind.bind",
   "Lean.SyntaxNodeKind",
   "Lean.Name.mkStr1",
   "ite",
   "Lean.TSyntax.raw",
   "EStateM",
   "String.toRawSubstring'",
   "Lean.Syntax.isOfKind",
   "Lean.MonadQuotation.getCurrMacroScope",
   "Lean.MacroScope",
   "OfNat.ofNat",
   "Lean.MonadRef.mkInfoFromRefPos",
   "Pure.pure",
   "Lean.Syntax.getArg",
   "Lean.addMacroScope",
   "Lean.MonadQuotation.getContext",
   "Lean.MacroM",
   "Lean.Name.mkStr2",
   "MonadExcept.throw",
   "Lean.Syntax.node2"],
  "name":
  "CellularAutomatas.«_aux_CellularAutomatas_defs___macroRules_CellularAutomatas_term_⊗__1»",
  "constType": "Macro",
  "constCategory": "Definition"},
 {"references": ["Int.casesOn"],
  "name": "_private.Init.Data.Int.Order.0.Int.toNat_eq_max.match_1_1",
  "constType":
  "∀ (motive : ℤ → Prop) (x : ℤ), (∀ (n : ℕ), motive (Int.ofNat n)) → (∀ (n : ℕ), motive (Int.negSucc n)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["HAdd.hAdd",
   "CellularAutomatas.CellAutomaton.delta_closed_set",
   "Set",
   "CellularAutomatas.CellAutomaton.next",
   "Membership.mem",
   "HSub.hSub",
   "id",
   "CellularAutomatas.CellAutomaton.Q",
   "CellularAutomatas.Config",
   "OfNat.ofNat"],
  "name": "CellularAutomatas.CellAutomaton.next_state_of_closed_set_state",
  "constType":
  "∀ {C : CellularAutomatas.CellAutomaton} {S : Set C.Q} {c : CellularAutomatas.Config C.Q} {i : ℤ},\n  C.delta_closed_set S → c i ∈ S → C.next c i ∈ S",
  "constCategory": "Theorem"},
 {"references": ["Set.image", "Set", "Membership.mem", "Iff.rfl"],
  "name": "Set.mem_image",
  "constType":
  "∀ {α : Type u} {β : Type v} (f : α → β) (s : Set α) (y : β), y ∈ f '' s ↔ ∃ x ∈ s, f x = y",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons_ne_nil",
   "List.getElem_map",
   "GetElem.getElem.congr_simp",
   "Eq.trans",
   "Eq.mp",
   "GetElem.getElem",
   "List.getElem_cons_length._proof_1",
   "congrArg",
   "False.elim",
   "Eq.symm",
   "not_true_eq_false",
   "Eq.ndrec",
   "Not",
   "rfl",
   "List.getLast",
   "List.casesOn",
   "List.map",
   "List.length_map",
   "List.getElem_cons_length",
   "LT.lt",
   "eq_self",
   "of_eq_true",
   "id",
   "List.head_map._proof_1",
   "Ne",
   "Eq.mpr",
   "List.length"],
  "name": "List.getLast_map",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {f : α → β} {l : List α} (h : List.map f l ≠ []),\n  (List.map f l).getLast h = f (l.getLast ⋯)",
  "constCategory": "Theorem"},
 {"references": ["Lean.Omega.Coeffs.set", "OfNat.ofNat"],
  "name": "Lean.Omega.LinearCombo.coordinate",
  "constType": "ℕ → Omega.LinearCombo",
  "constCategory": "Definition"},
 {"references": [],
  "name": "AddZeroClass.zero_add",
  "constType": "∀ {M : Type u} [self : AddZeroClass M] (a : M), 0 + a = a",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "Not",
   "HAppend.hAppend",
   "LT.lt",
   "Eq.mp",
   "LE.le",
   "Nat.sub_lt_left_of_lt_add",
   "Nat.not_lt._simp_1",
   "List.length_append",
   "congrArg",
   "List.length"],
  "name": "List.getElem_append._proof_1",
  "constType":
  "∀ {α : Type u_1} {l₁ l₂ : List α} {i : ℕ}, i < (l₁ ++ l₂).length → ¬i < l₁.length → i - l₁.length < l₂.length",
  "constCategory": "Theorem"},
 {"references": ["LT.lt", "HAdd.hAdd", "Function.swap"],
  "name": "AddRightReflectLT",
  "constType": "(M : Type u_1) → [Add M] → [LT M] → Prop",
  "constCategory": "Definition"},
 {"references": ["HAdd.hAdd", "LT.lt", "add_pos_iff", "OfNat.ofNat", "propext"],
  "name": "add_pos_iff._simp_4",
  "constType":
  "∀ {α : Type u} [inst : AddCommMonoid α] [inst_1 : PartialOrder α] [CanonicallyOrderedAdd α] {a b : α},\n  (0 < a + b) = (0 < a ∨ 0 < b)",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Name.hasMacroScopes",
   "_private.Init.Prelude.0.Lean.extractMacroScopesAux",
   "cond.match_1",
   "Lean.MacroScope",
   "Unit"],
  "name": "Lean.extractMacroScopes",
  "constType": "Name → MacroScopesView",
  "constCategory": "Definition"},
 {"references":
  ["CellularAutomatas.LCellAutomaton.scan_temporal_rt",
   "CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "CellularAutomatas.Word",
   "CellularAutomatas.CellAutomaton.Q"],
  "name": "CellularAutomatas.LCellAutomaton.scan_temporal_rt.eq_1",
  "constType":
  "∀ {α : Type} (C : CellularAutomatas.LCellAutomaton α) (w : CellularAutomatas.Word α),\n  C.scan_temporal_rt w = C.scan_temporal (List.length w) 0 w",
  "constCategory": "Theorem"},
 {"references": ["List.foldl.match_1", "List.below", "List.brecOn"],
  "name": "List.foldl",
  "constType": "{α : Type u} → {β : Type v} → (α → β → α) → α → List β → α",
  "constCategory": "Definition"},
 {"references":
  ["LT.lt",
   "HAdd.hAdd",
   "Lean.Grind.Nat.lt_eq",
   "Eq.substr",
   "List.drop",
   "List.take",
   "LE.le",
   "HSub.hSub",
   "OfNat.ofNat",
   "List.length"],
  "name": "CellularAutomatas.PrefixStableProof.getLastOfTake._proof_1_21",
  "constType":
  "∀ {i : ℕ} {α : Type u_1} {w : List α},\n  (List.take (List.take 1 w⟦i..*⟧).length w⟦(List.take i w).length..*⟧).length - 1 + 1 ≤\n      w⟦(List.take i w).length..*⟧.length →\n    (List.take (List.take 1 w⟦i..*⟧).length w⟦(List.take i w).length..*⟧).length - 1 <\n      w⟦(List.take i w).length..*⟧.length",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.PrettyPrinter.UnexpandM",
   "Lean.TSyntax.raw",
   "EStateM",
   "Lean.Syntax.isOfKind",
   "Lean.MonadQuotation.getCurrMacroScope",
   "Lean.MacroScope",
   "Lean.Syntax.matchesNull",
   "Lean.MonadRef.mkInfoFromRefPos",
   "Lean.MonadQuotation.getContext",
   "Lean.Name.mkStr2",
   "Unit.unit",
   "MonadExcept.throw",
   "Lean.Name.mkStr4",
   "Bind.bind",
   "Lean.SyntaxNodeKind",
   "Lean.Name.mkStr1",
   "ite",
   "Bool.or",
   "Lean.Syntax.node3",
   "cond",
   "OfNat.ofNat",
   "Unit",
   "Lean.Syntax.getArg",
   "Pure.pure",
   "Lean.withRef"],
  "name":
  "CellularAutomatas._aux_CellularAutomatas_defs___unexpand_CellularAutomatas_zip_words_1",
  "constType": "PrettyPrinter.Unexpander",
  "constCategory": "Definition"},
 {"references": ["CellularAutomatas.CellAutomaton.Q"],
  "name": "CellularAutomatas.simulation.Params.mk._flat_ctor",
  "constType":
  "(C_inr C_ctl : CellularAutomatas.CellAutomaton) → (C_ctl.Q → Option C_inr.Q) → CellularAutomatas.simulation.Params",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CellularAutomatas.backwards_fsm.Params.C",
  "constType":
  "(self : CellularAutomatas.backwards_fsm.Params) → CellularAutomatas.CArtTransducer self.β self.γ",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CellularAutomatas.Alphabet.rec",
  "constType":
  "{α : Type} →\n  {motive : CellularAutomatas.Alphabet α → Sort u} →\n    ([dec : DecidableEq α] → [fin : Fintype α] → [inh : Inhabited α] → motive { dec := dec, fin := fin, inh := inh }) →\n      (t : CellularAutomatas.Alphabet α) → motive t",
  "constCategory": "Other"},
 {"references": ["NonemptyType.type"],
  "name": "Void",
  "constType": "Type → Type",
  "constCategory": "Definition"},
 {"references":
  ["HAdd.hAdd",
   "LT.lt",
   "Nat.casesOn",
   "Fin.casesOn",
   "OfNat.ofNat",
   "List.length"],
  "name": "CellularAutomatas.FiniteStateTransducer.scanr_get'_eq1.match_1_1",
  "constType":
  "∀ {α : Type} (a : α) (w : List α) (motive : Fin (a :: w).length → Prop) (i : Fin (a :: w).length),\n  (∀ (isLt : 0 < (a :: w).length), motive ⟨0, isLt⟩) →\n    (∀ (n : ℕ) (h : n + 1 < (a :: w).length), motive ⟨n.succ, h⟩) → motive i",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CellularAutomatas.tCellAutomatonWithAdvice.mk._flat_ctor",
  "constType":
  "{α : Type} →\n  (Γ : Type) →\n    [alphabetΓ : CellularAutomatas.Alphabet Γ] →\n      CellularAutomatas.Advice α Γ →\n        CellularAutomatas.tCellAutomaton (α ⨉ Γ) → CellularAutomatas.tCellAutomatonWithAdvice α",
  "constCategory": "Definition"},
 {"references": ["WithTop"],
  "name": "ENat",
  "constType": "Type",
  "constCategory": "Definition"},
 {"references":
  ["Eq.trans",
   "Lean.Grind.AC.eq_norm_ac",
   "Lean.Grind.Order.of_nat_eq",
   "eq_true",
   "eagerReduce",
   "HMul.hMul",
   "ite_cond_eq_true",
   "List.length_drop",
   "IntCast.intCast",
   "Nat.ToInt.natCast_ofNat",
   "Lean.Grind.AC.eq_simp_lhs_exact",
   "Lean.Grind.AC.refl",
   "NatCast.natCast",
   "HSub.hSub",
   "Eq.symm",
   "Lean.Grind.AC.eq_simp_rhs_ac",
   "CellularAutomatas.PrefixStableProof.getLastOfTake._proof_1_10",
   "Lean.Grind.AC.superpose_ac_idempotent",
   "List.drop",
   "Neg.neg",
   "Lean.Grind.Order.le_of_eq_2_k",
   "Lean.Grind.Order.le_of_offset_eq_1_k",
   "Lean.Grind.AC.norm_ac",
   "id",
   "Lean.Grind.Order.le_trans_k",
   "Lean.Grind.AC.eq_orient",
   "Lean.Grind.Order.eq_trans_true",
   "List.length",
   "Int.Linear.norm_le",
   "Int.Linear.natCast_sub",
   "Eq.mp",
   "Lean.Grind.Order.le_of_eq_1_k",
   "Int.Linear.Expr.eq_of_norm_eq",
   "List.length_take",
   "min_def",
   "congrArg",
   "Lean.Grind.nestedDecidable",
   "Lean.Grind.Order.eq_of_le_of_le_0",
   "Not",
   "Lean.Grind.Order.eq_trans_true'",
   "ite",
   "Lean.Grind.Order.le_eq_true_of_le_k",
   "Nat.ToInt.add_congr",
   "OfNat.ofNat",
   "Lean.Grind.AC.eq_simp_rhs_exact",
   "ite_congr",
   "Lean.Grind.AC.imp_eq",
   "HAdd.hAdd",
   "Nat.ToInt.le_eq",
   "of_eq_true",
   "Lean.Grind.CommRing.Expr.eq_of_toPoly_eq",
   "Min.min",
   "List.take",
   "LE.le",
   "Lean.Grind.AC.eq_expr_seq_seq",
   "Lean.Grind.Semiring.natCast",
   "Lean.Grind.CommRing.le_norm_expr",
   "Lean.Grind.Semiring.natCast_eq_ofNat",
   "Lean.Grind.Order.eq_mp"],
  "name": "CellularAutomatas.PrefixStableProof.getLastOfTake._proof_1_11",
  "constType":
  "∀ {i : ℕ} {α : Type u_1} {w : List α},\n  i + 1 ≤ w.length →\n    -1 * ↑(List.take 1 w⟦i..*⟧).length + 1 ≤ 0 →\n      (List.take (List.take 1 w⟦i..*⟧).length w⟦(List.take i w).length..*⟧).length - 1 <\n        (List.take (List.take 1 w⟦i..*⟧).length w⟦(List.take i w).length..*⟧).length",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Nat.Linear.ExprCnstr.casesOn",
  "constType":
  "{motive : Nat.Linear.ExprCnstr → Sort u} →\n  (t : Nat.Linear.ExprCnstr) →\n    ((eq : Bool) → (lhs rhs : Nat.Linear.Expr) → motive { eq := eq, lhs := lhs, rhs := rhs }) → motive t",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Lean.Grind.Semiring.add_assoc",
  "constType":
  "∀ {α : Type u} [self : Grind.Semiring α] (a b c : α), a + b + c = a + (b + c)",
  "constCategory": "Theorem"},
 {"references": ["beq_of_eq", "LawfulBEq.eq_of_beq", "BEq.beq"],
  "name": "beq_iff_eq",
  "constType":
  "∀ {α : Type u_1} [inst : BEq α] [LawfulBEq α] {a b : α}, (a == b) = true ↔ a = b",
  "constCategory": "Theorem"},
 {"references":
  ["HAppend.hAppend",
   "CellularAutomatas.Word",
   "List.drop",
   "Eq.trans",
   "List.length_drop",
   "List.length_append",
   "congrArg",
   "CellularAutomatas.Advice.f",
   "HAdd.hAdd",
   "implies_true",
   "eq_self",
   "Nat.add_sub_cancel",
   "of_eq_true",
   "CellularAutomatas.Advice.len",
   "forall_congr",
   "HSub.hSub",
   "List.length"],
  "name": "CellularAutomatas.Advice.shift_left_advice._proof_1",
  "constType":
  "∀ {α Γ : Type} {adv : CellularAutomatas.Advice α Γ} (extension a : CellularAutomatas.Word α),\n  (adv.f (a ++ extension))⟦List.length extension..*⟧.length = List.length a",
  "constCategory": "Theorem"},
 {"references": ["IsUnit.unit", "IsUnit", "Int.units_natAbs"],
  "name": "Int.natAbs_of_isUnit",
  "constType": "∀ {u : ℤ}, IsUnit u → u.natAbs = 1",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "pow_succ",
   "id",
   "HMul.hMul",
   "Eq.mpr",
   "HPow.hPow",
   "one_mul",
   "pow_zero",
   "OfNat.ofNat",
   "congrArg"],
  "name": "pow_one",
  "constType": "∀ {M : Type u_2} [inst : Monoid M] (a : M), a ^ 1 = a",
  "constCategory": "Theorem"},
 {"references": ["Prod.casesOn", "CellularAutomatas.FiniteStateTransducer.Q"],
  "name": "CellularAutomatas.FiniteStateTransducer.comp.match_1",
  "constType":
  "{β γ α : Type} →\n  (M2 : CellularAutomatas.FiniteStateTransducer β γ) →\n    (M1 : CellularAutomatas.FiniteStateTransducer α β) →\n      (motive : M1.Q ⨉ M2.Q → Sort u_1) → (x : M1.Q ⨉ M2.Q) → ((q1 : M1.Q) → (q2 : M2.Q) → motive (q1, q2)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Int.Linear.norm_eq_cert",
   "Int.Linear.Context",
   "Eq.mp",
   "Int.Linear.Expr.denote",
   "Int.Linear.norm_eq",
   "Int.Linear.Poly.denote'",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Int.Linear.eq_norm_expr",
  "constType":
  "∀ (ctx : Int.Linear.Context) (lhs rhs : Int.Linear.Expr) (p : Int.Linear.Poly),\n  Int.Linear.norm_eq_cert lhs rhs p = true →\n    Int.Linear.Expr.denote ctx lhs = Int.Linear.Expr.denote ctx rhs → Int.Linear.Poly.denote' ctx p = 0",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CellularAutomatas.TwoStageAdvice.mk._flat_ctor",
  "constType":
  "{α Γ : Type} →\n  [inst : CellularAutomatas.Alphabet α] →\n    [inst_1 : CellularAutomatas.Alphabet Γ] →\n      (β : Type) →\n        [alphabetβ : CellularAutomatas.Alphabet β] →\n          CellularAutomatas.CArtTransducer α β →\n            CellularAutomatas.FiniteStateTransducer β Γ → CellularAutomatas.TwoStageAdvice α Γ",
  "constCategory": "Definition"},
 {"references": ["Fintype.complete"],
  "name": "Finset.mem_univ",
  "constType": "∀ {α : Type u_1} [inst : Fintype α] (x : α), x ∈ Finset.univ",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Bool.casesOn",
   "Eq.trans",
   "of_eq_true",
   "ite",
   "Eq.symm",
   "ite_cond_eq_true",
   "Eq.ndrec",
   "cond",
   "Bool.false_eq_true",
   "ite_cond_eq_false",
   "congrArg"],
  "name": "Bool.cond_eq_ite",
  "constType":
  "∀ {α : Sort u_1} (b : Bool) (t e : α), (bif b then t else e) = if b = true then t else e",
  "constCategory": "Theorem"},
 {"references": ["OfNat.ofNat", "Array.findIdx?.loop"],
  "name": "Array.findIdx?",
  "constType": "{α : Type u} → (α → Bool) → Array α → Option ℕ",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CellularAutomatas.FiniteStateTransducer.mk._flat_ctor",
  "constType":
  "{α β : Type} →\n  (Q : Type) →\n    [alphabetQ : CellularAutomatas.Alphabet Q] → (Q → α → Q) → Q → (Q → β) → CellularAutomatas.FiniteStateTransducer α β",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Lean.Environment.isExporting",
  "constType": "Environment → Bool",
  "constCategory": "Definition"},
 {"references": ["List.getLast?.match_1", "Unit"],
  "name": "List.head?",
  "constType": "{α : Type u} → List α → Option α",
  "constCategory": "Definition"},
 {"references":
  ["CellularAutomatas.CellAutomaton.casesOn",
   "CellularAutomatas.CellAutomaton.noConfusionType",
   "Eq.ndrec"],
  "name": "CellularAutomatas.CellAutomaton.noConfusion",
  "constType":
  "{P : Sort u} →\n  {x1 x2 : CellularAutomatas.CellAutomaton} → x1 = x2 → CellularAutomatas.CellAutomaton.noConfusionType P x1 x2",
  "constCategory": "Definition"},
 {"references":
  ["implies_congr",
   "Eq.trans",
   "and_imp._simp_1",
   "Membership.mem",
   "noConfusion_of_Nat",
   "GE.ge",
   "Lean.Grind.IntInterval.hi?",
   "Option.ctorIdx",
   "False.elim",
   "Lean.Grind.IntInterval.casesOn",
   "Lean.Grind.ToInt.toInt_mem",
   "Eq.symm",
   "false_implies",
   "Lean.Grind.ToInt.toInt",
   "Eq.ndrec",
   "Int.add_one_le_of_lt",
   "Lean.Grind.IntInterval.mem_ii._simp_1",
   "ge_iff_le._simp_1",
   "outParam",
   "Lean.Grind.IntInterval.mem_ci._simp_1",
   "Lean.Grind.IntInterval.mem_co._simp_1",
   "eq_false'",
   "OfNat.ofNat",
   "LT.lt",
   "HAdd.hAdd",
   "Option.some.injEq",
   "forall_const._simp_1",
   "of_eq_true",
   "LE.le",
   "id",
   "Eq.mpr",
   "Lean.Grind.IntInterval.mem_io._simp_1"],
  "name": "Lean.Grind.ToInt.le_upper'",
  "constType":
  "∀ {α : Type u_1} {i : Grind.IntInterval} [inst : Grind.ToInt α i] (hi : ℤ), i.hi? = some hi → ∀ (a : α), ↑a + 1 ≤ hi",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CellularAutomatas.FiniteStateTransducer.δ",
  "constType":
  "{α β : Type} → (self : CellularAutomatas.FiniteStateTransducer α β) → self.Q → α → self.Q",
  "constCategory": "Definition"},
 {"references":
  ["CellularAutomatas.CellAutomaton.next",
   "CellularAutomatas.apply_iterated",
   "CellularAutomatas.CellAutomaton.Q",
   "CellularAutomatas.Config"],
  "name": "CellularAutomatas.CellAutomaton.nextt",
  "constType":
  "(C : CellularAutomatas.CellAutomaton) → CellularAutomatas.Config C.Q → ℕ → CellularAutomatas.Config C.Q",
  "constCategory": "Definition"},
 {"references": ["HAdd.hAdd", "Nat.le_of_succ_le_succ", "OfNat.ofNat"],
  "name": "Nat.lt_of_succ_lt_succ",
  "constType": "∀ {n m : ℕ}, n.succ < m.succ → n < m",
  "constCategory": "Theorem"},
 {"references": ["CellularAutomatas.LcInRt.AdvCALc"],
  "name": "CellularAutomatas.LcInRt.O",
  "constType":
  "{α : Type} →\n  [CellularAutomatas.Alphabet α] →\n    {Γ : Type} →\n      [CellularAutomatas.Alphabet Γ] → CellularAutomatas.Advice α Γ → Γ → CellularAutomatas.tCellAutomatonWithAdvice α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Lean.Grind.CommRing.Power.k",
  "constType": "Grind.CommRing.Power → ℕ",
  "constCategory": "Definition"},
 {"references": ["MulOneClass.mul_one"],
  "name": "mul_one",
  "constType": "∀ {M : Type u} [inst : MulOneClass M] (a : M), a * 1 = a",
  "constCategory": "Theorem"},
 {"references":
  ["HDiv.hDiv",
   "mul_div_cancel_right₀",
   "mul_comm",
   "id",
   "HMul.hMul",
   "Eq.mpr",
   "Ne",
   "OfNat.ofNat",
   "congrArg"],
  "name": "mul_div_cancel_left₀",
  "constType":
  "∀ {M₀ : Type u_1} [inst : CommMonoidWithZero M₀] [inst_1 : Div M₀] [MulDivCancelClass M₀] (b : M₀) {a : M₀},\n  a ≠ 0 → a * b / a = b",
  "constCategory": "Theorem"},
 {"references":
  ["rfl",
   "HAppend.hAppend",
   "List.append_inj_right",
   "congrArg",
   "List.length"],
  "name": "List.append_right_inj",
  "constType":
  "∀ {α : Type u_1} {t₁ t₂ : List α} (s : List α), s ++ t₁ = s ++ t₂ ↔ t₁ = t₂",
  "constCategory": "Theorem"},
 {"references": ["OfNat.ofNat", "Int.Linear.Expr.toPoly'.go"],
  "name": "Int.Linear.Expr.toPoly'",
  "constType": "Int.Linear.Expr → Int.Linear.Poly",
  "constCategory": "Definition"},
 {"references":
  ["Eq.trans",
   "Lean.Omega.IntList.get",
   "Lean.Omega.LinearCombo.coordinate",
   "OfNat.ofNat",
   "congrArg",
   "HAdd.hAdd",
   "eq_self",
   "Lean.Omega.LinearCombo.coordinate_eval",
   "of_eq_true",
   "Lean.Omega.Coeffs.ofList",
   "Lean.Omega.IntList.get_cons_succ",
   "Lean.Omega.Coeffs.get",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.IntList.get_cons_zero"],
  "name": "Lean.Omega.LinearCombo.coordinate_eval_1",
  "constType":
  "∀ {a0 a1 : ℤ} {t : List ℤ}, (Omega.LinearCombo.coordinate 1).eval (Omega.Coeffs.ofList (a0 :: a1 :: t)) = a1",
  "constCategory": "Theorem"},
 {"references":
  ["Int.Linear.instBEqPoly.beq._sparseCasesOn_2",
   "Ne",
   "OfNat.ofNat",
   "Int.Linear.Poly.ctorIdx",
   "Int.Linear.Var"],
  "name": "Int.Linear.Poly.leadCoeff.match_1",
  "constType":
  "(motive : Int.Linear.Poly → Sort u_1) →\n  (p : Int.Linear.Poly) →\n    ((a : ℤ) → (v : Int.Linear.Var) → (p : Int.Linear.Poly) → motive (Int.Linear.Poly.add a v p)) →\n      ((x : Int.Linear.Poly) → motive x) → motive p",
  "constCategory": "Definition"},
 {"references": ["propext", "And.left"],
  "name": "and_self",
  "constType": "∀ (p : Prop), (p ∧ p) = p",
  "constCategory": "Theorem"},
 {"references": ["List.casesOn", "Ne"],
  "name": "List.getLast.match_1",
  "constType":
  "{α : Type u_1} →\n  (motive : (x : List α) → x ≠ [] → Sort u_2) →\n    (x : List α) →\n      (x_1 : x ≠ []) →\n        ((h : [] ≠ []) → motive [] h) →\n          ((a : α) → (x : [a] ≠ []) → motive [a] x) →\n            ((head b : α) → (as : List α) → (x : head :: b :: as ≠ []) → motive (head :: b :: as) x) → motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["CellularAutomatas.Word.get'",
   "CellularAutomatas.Word.get'._proof_1",
   "Int.toNat",
   "Fin.is_lt._simp_1",
   "Nat.cast",
   "CellularAutomatas.FiniteStateTransducer.scanr_len",
   "Eq.trans",
   "Eq.mp",
   "Membership.mem",
   "eq_true",
   "GetElem.getElem",
   "CellularAutomatas.FiniteStateTransducer.scanr_reduce",
   "GE.ge",
   "congrArg",
   "Fin.val",
   "List.get",
   "funext",
   "Eq.symm",
   "CellularAutomatas.Word.range",
   "CellularAutomatas.FiniteStateTransducer.scanr_get'_eq2",
   "ge_iff_le._simp_1",
   "CellularAutomatas.Word",
   "List.drop",
   "Set",
   "CellularAutomatas.FiniteStateTransducer.scanr",
   "Int.toNat_lt._simp_1",
   "OfNat.ofNat",
   "CellularAutomatas.Word.get'.eq_1",
   "LT.lt",
   "eq_self",
   "CellularAutomatas.FiniteStateTransducer.range_of_scanr",
   "of_eq_true",
   "LE.le",
   "id",
   "Eq.mpr",
   "Fin.isLt",
   "setOf",
   "CellularAutomatas.FiniteStateTransducer.f",
   "List.length"],
  "name": "CellularAutomatas.backwards_fsm.scanr_get'_eq2",
  "constType":
  "∀ {α β : Type} {M : CellularAutomatas.FiniteStateTransducer α β} (w : CellularAutomatas.Word α) (i : ℤ)\n  (h : i ∈ w.range), (M.scanr w).get' i ⋯ = M.f (M.scanr_reduce w⟦i.toNat..*⟧)",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.propIntro",
   "eq_of_heq",
   "Eq.symm",
   "Eq.ndrec",
   "Eq.casesOn",
   "HEq.casesOn",
   "CellularAutomatas.CellAutomaton.mk.noConfusion",
   "And.casesOn"],
  "name": "CellularAutomatas.CellAutomaton.mk.injEq",
  "constType":
  "∀ (Q : Type) [alphabetQ : CellularAutomatas.Alphabet Q] (δ : Q → Q → Q → Q) (Q_1 : Type)\n  (alphabetQ_1 : CellularAutomatas.Alphabet Q_1) (δ_1 : Q_1 → Q_1 → Q_1 → Q_1),\n  ({ Q := Q, alphabetQ := alphabetQ, δ := δ } = { Q := Q_1, alphabetQ := alphabetQ_1, δ := δ_1 }) =\n    (Q = Q_1 ∧ alphabetQ ≍ alphabetQ_1 ∧ δ ≍ δ_1)",
  "constCategory": "Theorem"},
 {"references":
  ["Set",
   "Membership.mem",
   "CellularAutomatas.CA_rt",
   "CellularAutomatas.tCellAutomaton.F_pos",
   "Subtype.val",
   "CellularAutomatas.tCellAutomaton.toLCellAutomaton",
   "Set.Elem",
   "CellularAutomatas.FiniteStateTransducer.M_id"],
  "name": "CellularAutomatas.CA_rt_to_TwoStage",
  "constType":
  "{α : Type} →\n  [inst : CellularAutomatas.Alphabet α] → ↑(CellularAutomatas.CA_rt α) → CellularAutomatas.TwoStageAdvice α Bool",
  "constCategory": "Definition"},
 {"references":
  ["CellularAutomatas.simulation.C'",
   "sorryAx",
   "CellularAutomatas.simulation.to_C'Q",
   "CellularAutomatas.simulation.Params.C_ctl",
   "CellularAutomatas.CellAutomaton.nextt",
   "HMul.hMul",
   "Function.comp",
   "CellularAutomatas.simulation.to_CinrQ",
   "CellularAutomatas.Config",
   "OfNat.ofNat",
   "CellularAutomatas.simulation.Params.C_inr",
   "HAdd.hAdd",
   "CellularAutomatas.CellAutomaton.Q"],
  "name": "CellularAutomatas.simulation.spec",
  "constType":
  "∀ (e : CellularAutomatas.simulation.Params) (c_ctl : CellularAutomatas.Config e.C_ctl.Q)\n  (c_inr : CellularAutomatas.Config e.C_inr.Q) (t : ℕ) (p : ℤ),\n  have c' := CellularAutomatas.simulation.to_C'Q e ∘ c_ctl;\n  have proj := CellularAutomatas.simulation.to_CinrQ e;\n  let C' := CellularAutomatas.simulation.C' e;\n  proj (C'.nextt c' (3 + 3 * t) 0) = e.C_inr.nextt c_inr t 0",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans",
   "List.getElem_range",
   "Lean.Grind.Order.of_nat_eq",
   "eq_true",
   "eagerReduce",
   "Option.getD_some",
   "IntCast.intCast",
   "Nat.ToInt.natCast_ofNat",
   "Inhabited.default",
   "CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "GetElem?.getElem?",
   "NatCast.natCast",
   "Eq.symm",
   "CellularAutomatas.ProdCA.scan_temporal._proof_1_3",
   "forall_prop_domain_congr",
   "Lean.Grind.forall_propagator",
   "getElem?_pos",
   "Neg.neg",
   "Option.map_some",
   "Lean.Grind.Order.le_of_eq_2_k",
   "Option.getD",
   "CellularAutomatas.LCellAutomaton.comp",
   "Lean.Grind.nestedProof",
   "eq_false",
   "Classical.byContradiction",
   "id",
   "Lean.Grind.Order.le_trans_k",
   "Lean.Grind.Order.eq_trans_true",
   "List.length",
   "Eq.substr",
   "Eq.mp",
   "GetElem.getElem",
   "CellularAutomatas.ProdCA.scan_temporal._proof_1_2",
   "congrArg",
   "Lean.Grind.Nat.lt_eq",
   "List.length_range",
   "CellularAutomatas.CellAutomaton.Q",
   "Option.map",
   "Not",
   "CellularAutomatas.Word",
   "Lean.Grind.Order.eq_trans_true'",
   "Nat.ToInt.add_congr",
   "Lean.Grind.Order.le_eq_true_of_le_k",
   "OfNat.ofNat",
   "List.range",
   "LT.lt",
   "HAdd.hAdd",
   "Nat.ToInt.le_eq",
   "of_eq_true",
   "LE.le",
   "Lean.Grind.intro_with_eq",
   "Lean.Grind.CommRing.le_norm_expr",
   "Lean.Grind.Order.eq_mp"],
  "name": "CellularAutomatas.ProdCA.scan_temporal._proof_1_4",
  "constType":
  "∀ {α β : Type} {t : ℕ} {p : ℤ} (f : β → CellularAutomatas.LCellAutomaton α) (w : CellularAutomatas.Word α),\n  ∀ t_1 < t,\n    ∀ (b : β),\n      (fun b => (f b).comp w t_1 p) b = (Option.map (fun x => (f b).comp w x p) (List.range t)[t_1]?).getD default",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "Int.Linear.Poly.brecOn",
   "Int.Linear.Poly.denote.match_1",
   "Int.Linear.Var",
   "Int.Linear.Poly.below"],
  "name": "Int.Linear.Poly.addConst",
  "constType": "Int.Linear.Poly → ℤ → Int.Linear.Poly",
  "constCategory": "Definition"},
 {"references": ["HAdd.hAdd", "SizeOf.sizeOf", "OfNat.ofNat"],
  "name": "CellularAutomatas.FiniteStateTransducer._sizeOf_1",
  "constType":
  "{α β : Type} → [SizeOf α] → [SizeOf β] → CellularAutomatas.FiniteStateTransducer α β → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Eq.trans",
   "getElem?_pos",
   "ite",
   "Nat.noConfusion",
   "eq_false'",
   "ite_cond_eq_true",
   "GetElem.getElem",
   "ite_cond_eq_false",
   "OfNat.ofNat",
   "congrArg",
   "HAdd.hAdd",
   "LT.lt",
   "eq_self",
   "GetElem?.getElem?",
   "of_eq_true",
   "congr",
   "Eq.symm",
   "HSub.hSub",
   "Eq.ndrec",
   "Nat.zero_lt_succ._simp_1",
   "Nat.casesAuxOn",
   "List.length"],
  "name": "List.getElem?_cons",
  "constType":
  "∀ {α : outParam (Type u_1)} {a : α} {l : List α} {i : ℕ}, (a :: l)[i]? = if i = 0 then some a else l[i - 1]?",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans",
   "Membership.mem",
   "Iff.mp",
   "CellularAutomatas.advice_len",
   "or_true",
   "GT.gt",
   "CellularAutomatas.tCellAutomatonWithAdvice.L",
   "List.getLast?",
   "CellularAutomatas.tCellAutomaton.toLCellAutomaton",
   "CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "GetElem?.getElem?",
   "False.elim",
   "not_false_eq_true",
   "iff_self",
   "List.zipWith_nil_right",
   "Eq.symm",
   "HSub.hSub",
   "lt_self_iff_false._simp_1",
   "Eq.ndrec",
   "CellularAutomatas.LcInRt.O_L_eq_L_c._proof_1_5",
   "Nat.casesAuxOn",
   "List.getLast",
   "List.length_zipWith",
   "List.getLast_eq_getElem",
   "lt_add_iff_pos_left._simp_4",
   "List.getLast?_eq_some_getLast",
   "eq_false'",
   "Prod.snd",
   "Language",
   "CellularAutomatas.LCellAutomaton.comp",
   "add_pos_iff._simp_4",
   "Unit",
   "Option.some.injEq",
   "Decidable.byContradiction",
   "List.length_pos_iff_ne_nil",
   "CellularAutomatas.L_c",
   "gt_iff_lt._simp_1",
   "id",
   "min_self",
   "List.zipWith",
   "Eq.mpr",
   "CellularAutomatas.tCellAutomatonWithAdvice.adv",
   "CellularAutomatas.tCellAutomaton.L",
   "getElem?_neg",
   "CellularAutomatas.tCellAutomatonWithAdvice.Γ",
   "setOf",
   "List.length",
   "List.getElem?_eq_getElem",
   "List.getLast_eq_getElem._proof_3",
   "GetElem.getElem.congr_simp",
   "Eq.mp",
   "CellularAutomatas.tCellAutomaton.t",
   "CellularAutomatas.Advice.annotate",
   "List.lt_length_left_of_zipWith",
   "noConfusion_of_Nat",
   "GetElem.getElem",
   "Language.ext",
   "Bool.false_eq_true",
   "congrArg",
   "Option.ctorIdx",
   "CellularAutomatas.LcInRt.DiagonalShiftCA",
   "CellularAutomatas.LcInRt.AdvCALc",
   "congr",
   "CellularAutomatas.Advice.len",
   "CellularAutomatas.tCellAutomatonWithAdvice.C",
   "CellularAutomatas.LcInRt.DiagonalShiftCA_comp_p0",
   "CellularAutomatas.CellAutomaton.Q",
   "propext",
   "zero_lt_one._simp_1",
   "List.lt_length_right_of_zipWith",
   "Not",
   "CellularAutomatas.Word",
   "CellularAutomatas.adv_empty",
   "List.getElem_zipWith",
   "CellularAutomatas.LcInRt.O",
   "CellularAutomatas.LcInRt.AdvCALc.match_1",
   "OfNat.ofNat",
   "beq_iff_eq._simp_1",
   "HAdd.hAdd",
   "CellularAutomatas.Advice.f",
   "LT.lt",
   "eq_self",
   "List.length_eq_zero_iff",
   "zero_tsub",
   "of_eq_true",
   "Min.min",
   "LE.le",
   "Ne",
   "CellularAutomatas.tCellAutomaton.F_pos",
   "BEq.beq",
   "Fin.isLt"],
  "name": "CellularAutomatas.LcInRt.O_L_eq_L_c",
  "constType":
  "∀ {α : Type} [inst : CellularAutomatas.Alphabet α] {Γ : Type} [inst_1 : CellularAutomatas.Alphabet Γ]\n  (adv : CellularAutomatas.Advice α Γ) (c : Γ), (CellularAutomatas.LcInRt.O adv c).L = CellularAutomatas.L_c adv c",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "Neg.neg",
   "Int.add_comm",
   "LE.le",
   "id",
   "Eq.mpr",
   "Iff.rfl",
   "Lean.Omega.Int.add_le_zero_iff_le_neg",
   "propext",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Lean.Omega.Int.add_le_zero_iff_le_neg'",
  "constType": "∀ {a b : ℤ}, a + b ≤ 0 ↔ b ≤ -a",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Lean.Grind.Semiring.ofNat_eq_natCast",
  "constType":
  "∀ {α : Type u} [self : Grind.Semiring α] (n : ℕ), OfNat.ofNat n = ↑n",
  "constCategory": "Theorem"},
 {"references": ["CellularAutomatas.backwards_fsm.Params._sizeOf_1"],
  "name": "CellularAutomatas.backwards_fsm.Params._sizeOf_inst",
  "constType": "SizeOf CellularAutomatas.backwards_fsm.Params",
  "constCategory": "Definition"},
 {"references": ["NonemptyType.type"],
  "name": "IO.RealWorld",
  "constType": "Type",
  "constCategory": "Definition"},
 {"references":
  ["Eq.trans",
   "le_of_le_of_eq",
   "Lean.Omega.Constraint.combine_sat'",
   "Lean.Omega.LinearCombo.coordinate_eval_0",
   "Decidable.decide",
   "Lean.Omega.Coeffs.ofList",
   "Eq.symm",
   "Lean.Omega.tidy_sat",
   "HSub.hSub",
   "Lean.Omega.LinearCombo.add_eval",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "Int.add_one_le_of_lt",
   "of_decide_eq_true",
   "Neg.neg",
   "Lean.Omega.Constraint.addInequality_sat",
   "Lean.Omega.Int.add_congr",
   "Lean.Omega.Constraint.isImpossible",
   "Lean.Omega.LinearCombo.coordinate",
   "OfNat.ofNat",
   "Int.sub_nonneg_of_le",
   "LT.lt",
   "HAdd.hAdd",
   "Lean.Omega.LinearCombo.sub_eval",
   "LE.le",
   "id",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.Int.sub_congr"],
  "name": "_private.Init.Grind.Order.0.Lean.Grind.Order.le_unsat_k._proof_1_1",
  "constType": "∀ {k : ℤ}, k < 0 → 0 ≤ k → False",
  "constCategory": "Theorem"},
 {"references":
  ["absurd", "rfl", "Not", "_private.Init.Core.0.dif_pos.match_1_1", "dite"],
  "name": "dif_pos",
  "constType":
  "∀ {c : Prop} {h : Decidable c} (hc : c) {α : Sort u} {t : c → α} {e : ¬c → α}, dite c t e = t hc",
  "constCategory": "Theorem"},
 {"references":
  ["Int.neg_le_neg",
   "Eq.mp",
   "Neg.neg",
   "congr",
   "LE.le",
   "Int.neg_neg",
   "congrArg"],
  "name": "Int.neg_le_neg_iff",
  "constType": "∀ {a b : ℤ}, -a ≤ -b ↔ b ≤ a",
  "constCategory": "Theorem"},
 {"references": ["LE.le"],
  "name": "Monotone",
  "constType":
  "{α : Type u} → {β : Type v} → [Preorder α] → [Preorder β] → (α → β) → Prop",
  "constCategory": "Definition"},
 {"references": ["Not", "False.elim", "eq_true"],
  "name": "not_false_eq_true",
  "constType": "(¬False) = True",
  "constCategory": "Theorem"},
 {"references": ["Lean.Omega.Coeffs", "Lean.Omega.IntList.get"],
  "name": "Lean.Omega.Coeffs.get",
  "constType": "Omega.Coeffs → ℕ → ℤ",
  "constCategory": "Definition"},
 {"references":
  ["not_or_intro",
   "Not",
   "Eq.trans",
   "Int.le_total",
   "ite",
   "eq_true",
   "ite_cond_eq_true",
   "ite_cond_eq_false",
   "congrArg",
   "eq_self",
   "Int.le_antisymm",
   "Max.max",
   "of_eq_true",
   "False.casesOn",
   "eq_false",
   "congr",
   "LE.le",
   "id",
   "Eq.mpr",
   "dite"],
  "name": "Int.max_comm",
  "constType": "∀ (a b : ℤ), max a b = max b a",
  "constCategory": "Theorem"},
 {"references": ["HMod.hMod", "Fin.ofNat._proof_1"],
  "name": "Fin.ofNat",
  "constType": "(n : ℕ) → [NeZero n] → ℕ → Fin n",
  "constCategory": "Definition"},
 {"references": ["Quotient.out", "Multiset"],
  "name": "Multiset.toList",
  "constType": "{α : Type u_1} → Multiset α → List α",
  "constCategory": "Definition"},
 {"references": ["outParam"],
  "name": "MonadExcept.throw",
  "constType":
  "{ε : outParam (Type u)} → {m : Type v → Type w} → [self : MonadExcept ε m] → {α : Type v} → ε → m α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CellularAutomatas.TwoStageAdvice",
  "constType":
  "(α Γ : Type) → [CellularAutomatas.Alphabet α] → [CellularAutomatas.Alphabet Γ] → Type 1",
  "constCategory": "Other"},
 {"references":
  ["iff_self",
   "Eq.trans",
   "of_eq_true",
   "Set",
   "Membership.mem",
   "CellularAutomatas.set_iff._simp_1_1",
   "congrArg",
   "setOf"],
  "name": "CellularAutomatas.set_iff",
  "constType":
  "∀ {α : Type u_1} (p1 p2 : α → Prop), {w | p1 w} = {w | p2 w} ↔ ∀ (w : α), p1 w ↔ p2 w",
  "constCategory": "Theorem"},
 {"references": ["outParam"],
  "name": "ForIn.forIn",
  "constType":
  "{m : Type u₁ → Type u₂} →\n  {ρ : Type u} →\n    {α : outParam (Type v)} → [self : ForIn m ρ α] → {β : Type u₁} → [Monad m] → ρ → β → (α → β → m (ForInStep β)) → m β",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Lean.ConstantVal.name",
  "constType": "ConstantVal → Name",
  "constCategory": "Definition"},
 {"references":
  ["CellularAutomatas.FiniteStateTransducer.scanr_reduce_q",
   "CellularAutomatas.FiniteStateTransducer.Q"],
  "name": "CellularAutomatas.FiniteStateTransducer.scanr_reduce_q.eq_2",
  "constType":
  "∀ {α β : Type} (M : CellularAutomatas.FiniteStateTransducer α β) (q : M.Q) (c : α) (cs : List α),\n  M.scanr_reduce_q q (c :: cs) = M.δ (M.scanr_reduce_q q cs) c",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans",
   "Lean.Omega.Decidable.or_not_not_of_not_and",
   "Lean.Omega.LinearCombo.coordinate_eval_3",
   "le_of_le_of_eq",
   "Classical.propDecidable",
   "Lean.Omega.LinearCombo.coordinate_eval_4",
   "Lean.Omega.Int.ofNat_le_of_le",
   "Lean.Omega.LinearCombo.neg_eval",
   "Lean.Omega.tidy_sat",
   "HSub.hSub",
   "Eq.symm",
   "Lean.Omega.ite_disjunction",
   "Lean.Omega.LinearCombo.add_eval",
   "Lean.Omega.Int.lt_of_not_le",
   "Lean.Omega.Int.neg_congr",
   "Int.add_one_le_of_lt",
   "And.left",
   "Lean.Omega.combo_sat'",
   "Neg.neg",
   "And.right",
   "Lean.Omega.Constraint.addInequality_sat",
   "Lean.Omega.Int.le_of_not_lt",
   "Lean.Omega.LinearCombo.coordinate",
   "Lean.Omega.Constraint.addEquality_sat",
   "id",
   "Lean.Omega.Int.sub_congr",
   "Lean.Omega.Int.ofNat_natAbs",
   "List.length",
   "Or.elim",
   "Nat.cast",
   "Lean.Omega.LinearCombo.coordinate_eval_2",
   "Lean.Omega.Constraint.combine_sat'",
   "Lean.Omega.LinearCombo.coordinate_eval_0",
   "Int.sub_eq_zero_of_eq",
   "Decidable.decide",
   "Lean.Omega.Coeffs.ofList",
   "Int.natAbs",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "of_decide_eq_true",
   "Not",
   "CellularAutomatas.Word",
   "ite",
   "Lean.Omega.Int.add_congr",
   "Lean.Omega.Constraint.isImpossible",
   "OfNat.ofNat",
   "Int.sub_nonneg_of_le",
   "HAdd.hAdd",
   "LT.lt",
   "Lean.Omega.LinearCombo.coordinate_eval_1",
   "Lean.Omega.LinearCombo.sub_eval",
   "LE.le",
   "Lean.Omega.LinearCombo.eval"],
  "name": "CellularAutomatas.Word.cone_prop'._proof_1_2",
  "constType":
  "∀ {α : Type u_1} {w : CellularAutomatas.Word α} {t : ℕ} {i d : ℤ},\n  -↑t ≤ i + d ∧ i + d < ↑(List.length w) + ↑t → d.natAbs ≤ 1 → ¬(-1 + -↑t ≤ i ∧ i < ↑(List.length w) + (↑t + 1)) → False",
  "constCategory": "Theorem"},
 {"references":
  ["Option.all", "LE.le", "Lean.Omega.UpperBound", "Decidable.decide"],
  "name": "Lean.Omega.UpperBound.sat",
  "constType": "Omega.UpperBound → ℤ → Bool",
  "constCategory": "Definition"},
 {"references": ["eq_of_heq", "GetElem.getElem", "Eq.ndrec"],
  "name": "GetElem.getElem.hcongr_8",
  "constType":
  "∀ (coll coll' : Type u),\n  coll = coll' →\n    ∀ (idx idx' : Type v),\n      idx = idx' →\n        ∀ (elem elem' : Type w),\n          elem = elem' →\n            ∀ (valid : coll → idx → Prop) (valid' : coll' → idx' → Prop),\n              valid ≍ valid' →\n                ∀ (self : GetElem coll idx elem valid) (self' : GetElem coll' idx' elem' valid'),\n                  self ≍ self' →\n                    ∀ (xs : coll) (xs' : coll'),\n                      xs ≍ xs' →\n                        ∀ (i : idx) (i' : idx'),\n                          i ≍ i' → ∀ (h : valid xs i) (h' : valid' xs' i'), h ≍ h' → xs[i] ≍ xs'[i']",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "And.right",
  "constType": "∀ {a b : Prop}, a ∧ b → b",
  "constCategory": "Theorem"},
 {"references":
  ["Set",
   "Membership.mem",
   "Eq.symm",
   "Set.ext",
   "Iff.rfl",
   "Eq.ndrec",
   "Eq.casesOn"],
  "name": "Set.ext_iff",
  "constType": "∀ {α : Type u} {a b : Set α}, a = b ↔ ∀ (x : α), x ∈ a ↔ x ∈ b",
  "constCategory": "Theorem"},
 {"references": ["Nat.succ_lt_succ_iff"],
  "name": "Nat.add_one_lt_add_one_iff",
  "constType": "∀ {a b : ℕ}, a + 1 < b + 1 ↔ a < b",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Unit",
  "constType": "Type",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Lean.MonadRef.withRef",
  "constType":
  "{m : Type → Type} → [self : MonadRef m] → {α : Type} → Syntax → m α → m α",
  "constCategory": "Definition"},
 {"references":
  ["Nat.cast_one",
   "Nat.cast",
   "Eq.trans",
   "HMul.hMul",
   "mul_one",
   "HPow.hPow",
   "add_zero",
   "OfNat.ofNat",
   "congrArg",
   "HAdd.hAdd",
   "pow_one",
   "eq_self",
   "of_eq_true",
   "congr"],
  "name": "Mathlib.Tactic.Ring.atom_pf",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] (a : R), a = a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Lean.Grind.CommRing.Poly.casesOn",
  "constType":
  "{motive : Grind.CommRing.Poly → Sort u} →\n  (t : Grind.CommRing.Poly) →\n    ((k : ℤ) → motive (Grind.CommRing.Poly.num k)) →\n      ((k : ℤ) → (v : Grind.CommRing.Mon) → (p : Grind.CommRing.Poly) → motive (Grind.CommRing.Poly.add k v p)) →\n        motive t",
  "constCategory": "Definition"},
 {"references": ["Lean.Grind.ToInt.toInt"],
  "name": "Lean.Grind.ToInt.toInt.eq_1",
  "constType":
  "∀ (α : Type u) {range : Grind.IntInterval} [self : Grind.ToInt α range], Grind.ToInt.toInt = self.1",
  "constCategory": "Theorem"},
 {"references": ["Eq.mp", "NatCast.natCast", "congrArg"],
  "name": "Nat.ToInt.of_eq",
  "constType": "∀ {a b : ℕ} {a' b' : ℤ}, ↑a = a' → ↑b = b' → a = b → a' = b'",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans",
   "Lean.Omega.IntList.get",
   "Lean.Omega.LinearCombo.coordinate",
   "OfNat.ofNat",
   "congrArg",
   "HAdd.hAdd",
   "eq_self",
   "Lean.Omega.LinearCombo.coordinate_eval",
   "of_eq_true",
   "Lean.Omega.Coeffs.ofList",
   "Lean.Omega.IntList.get_cons_succ",
   "Lean.Omega.Coeffs.get",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.IntList.get_cons_zero"],
  "name": "Lean.Omega.LinearCombo.coordinate_eval_7",
  "constType":
  "∀ {a0 a1 a2 a3 a4 a5 a6 a7 : ℤ} {t : List ℤ},\n  (Omega.LinearCombo.coordinate 7).eval (Omega.Coeffs.ofList (a0 :: a1 :: a2 :: a3 :: a4 :: a5 :: a6 :: a7 :: t)) = a7",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.cast",
   "Eq.trans",
   "le_of_le_of_eq",
   "Int.negSucc_eq",
   "Lean.Omega.Constraint.combine_sat'",
   "Lean.Omega.LinearCombo.coordinate_eval_0",
   "Decidable.decide",
   "Lean.Omega.LinearCombo.neg_eval",
   "Lean.Omega.Coeffs.ofList",
   "Lean.Omega.tidy_sat",
   "Eq.symm",
   "HSub.hSub",
   "Lean.Omega.LinearCombo.add_eval",
   "Lean.Omega.Int.neg_congr",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "of_decide_eq_true",
   "Not",
   "Lean.Omega.combo_sat'",
   "Neg.neg",
   "Lean.Omega.Constraint.addInequality_sat",
   "Lean.Omega.Int.add_congr",
   "Lean.Omega.Constraint.isImpossible",
   "Lean.Omega.Int.le_of_not_lt",
   "Lean.Omega.LinearCombo.coordinate",
   "OfNat.ofNat",
   "Int.ofNat_nonneg",
   "Int.sub_nonneg_of_le",
   "Lean.Omega.LinearCombo.coordinate_eval_1",
   "HAdd.hAdd",
   "LT.lt",
   "Lean.Omega.LinearCombo.sub_eval",
   "id",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.Int.sub_congr"],
  "name": "_private.Init.Data.Int.LemmasAux.0.Int.blt'_eq_true._proof_1_3",
  "constType": "∀ (a a_1 : ℕ), ¬Int.negSucc a < ↑a_1 → False",
  "constCategory": "Theorem"},
 {"references": ["Multiset.mem_range"],
  "name": "Finset.mem_range",
  "constType": "∀ {n m : ℕ}, m ∈ Finset.range n ↔ m < n",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Lean.Name.mkStr3",
  "constType": "String → String → String → Name",
  "constCategory": "Definition"},
 {"references":
  ["HAdd.hAdd",
   "LT.lt",
   "Eq.trans",
   "of_eq_true",
   "Nat.lt_add_one._simp_1",
   "OfNat.ofNat",
   "congrArg",
   "List.length"],
  "name": "List.getElem_cons_length._proof_1",
  "constType":
  "∀ {α : Type u_1} {xs : List α} {i : ℕ}, i = xs.length → i < xs.length + 1",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Function.swap",
  "constType":
  "{α : Sort u₁} → {β : Sort u₂} → {φ : α → β → Sort u₃} → ((x : α) → (y : β) → φ x y) → (y : β) → (x : α) → φ x y",
  "constCategory": "Definition"},
 {"references":
  ["Eq.trans",
   "Lean.Omega.LinearCombo.coordinate_eval_3",
   "le_of_le_of_eq",
   "Lean.Omega.LinearCombo.coordinate_eval_4",
   "GT.gt",
   "Lean.Omega.Int.ofNat_le_of_le",
   "Lean.Omega.tidy_sat",
   "HSub.hSub",
   "Eq.symm",
   "Lean.Omega.Int.lt_of_not_le",
   "Lean.Omega.ite_disjunction",
   "Lean.Omega.LinearCombo.add_eval",
   "Int.add_one_le_of_lt",
   "And.left",
   "Lean.Omega.combo_sat'",
   "Neg.neg",
   "And.right",
   "Lean.Omega.Constraint.addInequality_sat",
   "Lean.Omega.LinearCombo.coordinate",
   "Lean.Omega.Constraint.addEquality_sat",
   "id",
   "Lean.Omega.Int.sub_congr",
   "List.length",
   "Lean.Omega.LinearCombo.coordinate_eval_7",
   "Or.elim",
   "Lean.Omega.LinearCombo.coordinate_eval_2",
   "Nat.cast",
   "Lean.Omega.Constraint.combine_sat'",
   "Lean.Omega.LinearCombo.coordinate_eval_0",
   "Int.sub_eq_zero_of_eq",
   "Decidable.decide",
   "Nat.lt_or_gt_of_ne",
   "Lean.Omega.Coeffs.ofList",
   "Lean.Omega.Int.ofNat_sub_dichotomy",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "of_decide_eq_true",
   "Not",
   "ite",
   "Int.min_def",
   "Lean.Omega.Int.add_congr",
   "Lean.Omega.Constraint.isImpossible",
   "Int.ofNat_nonneg",
   "OfNat.ofNat",
   "Int.sub_nonneg_of_le",
   "HAdd.hAdd",
   "LT.lt",
   "Lean.Omega.LinearCombo.coordinate_eval_1",
   "Lean.Omega.LinearCombo.coordinate_eval_6",
   "Lean.Omega.LinearCombo.sub_eval",
   "Lean.Omega.Int.ofNat_lt_of_lt",
   "Min.min",
   "LE.le",
   "Int.natCast_add",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.Int.ofNat_min",
   "Lean.Omega.LinearCombo.coordinate_eval_5"],
  "name": "_private.Init.Data.List.Nat.TakeDrop.0.List.take_add._proof_1_1",
  "constType":
  "∀ {α : Type u_1} {l : List α} {i j : ℕ}, ¬min (i + j - min i l.length) (l.length - i) = min j (l.length - i) → False",
  "constCategory": "Theorem"},
 {"references": ["Int.casesOn"],
  "name": "_private.Init.Data.Int.Order.0.Int.ofNat_toNat.match_1_1",
  "constType":
  "∀ (motive : ℤ → Prop) (a : ℤ), (∀ (n : ℕ), motive (Int.ofNat n)) → (∀ (n : ℕ), motive (Int.negSucc n)) → motive a",
  "constCategory": "Definition"},
 {"references": ["Lean.Syntax.casesOn", "Lean.SyntaxNodeKind"],
  "name": "_private.Init.Prelude.0.Lean.Syntax.setKind.match_1",
  "constType":
  "(motive : Syntax → Sort u_1) →\n  (stx : Syntax) →\n    ((info : SourceInfo) → (kind : SyntaxNodeKind) → (args : Array Syntax) → motive (Syntax.node info kind args)) →\n      ((x : Syntax) → motive x) → motive stx",
  "constCategory": "Definition"},
 {"references": ["Nat.casesOn", "Unit.unit", "Unit"],
  "name": "_private.Init.Prelude.0.Nat.zero_le.match_1_1",
  "constType":
  "∀ (motive : ℕ → Prop) (x : ℕ), (∀ (a : Unit), motive Nat.zero) → (∀ (n : ℕ), motive n.succ) → motive x",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CellularAutomatas.simulation.Params.C_inr",
  "constType":
  "CellularAutomatas.simulation.Params → CellularAutomatas.CellAutomaton",
  "constCategory": "Definition"},
 {"references":
  ["Multiset.map",
   "Multiset.toFinset_card_le",
   "Multiset.card",
   "Finset.val",
   "Eq.mp",
   "DecidableEq",
   "Finset.card",
   "LE.le",
   "Multiset.toFinset",
   "Multiset.card_map",
   "congrArg"],
  "name": "Finset.card_image_le",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {s : Finset α} {f : α → β} [inst : DecidableEq β], (Finset.image f s).card ≤ s.card",
  "constCategory": "Theorem"},
 {"references": ["Int.Linear.Poly.casesOn", "Int.Linear.Var"],
  "name": "Int.Linear.Poly.coeff.match_1",
  "constType":
  "(motive : Int.Linear.Poly → Sort u_1) →\n  (p : Int.Linear.Poly) →\n    ((a : ℤ) → (y : Int.Linear.Var) → (p : Int.Linear.Poly) → motive (Int.Linear.Poly.add a y p)) →\n      ((k : ℤ) → motive (Int.Linear.Poly.num k)) → motive p",
  "constCategory": "Definition"},
 {"references":
  ["Lean.DefinitionVal.casesOn",
   "_private.Lean.Declaration.0.Lean.ConstantInfo.value?._sparseCasesOn_1",
   "Lean.TheoremVal.casesOn",
   "Lean.OpaqueVal.casesOn",
   "Ne",
   "OfNat.ofNat",
   "Lean.ConstantInfo.ctorIdx",
   "Lean.ConstantVal.casesOn"],
  "name": "_private.Lean.Declaration.0.Lean.ConstantInfo.value?.match_1",
  "constType":
  "(motive : ConstantInfo → Sort u_1) →\n  (info : ConstantInfo) →\n    ((name : Name) →\n        (levelParams : List Name) →\n          (type value : Expr) →\n            (hints : ReducibilityHints) →\n              (safety : DefinitionSafety) →\n                (all : List Name) →\n                  motive\n                    (ConstantInfo.defnInfo\n                      { name := name, levelParams := levelParams, type := type, value := value, hints := hints,\n                        safety := safety, all := all })) →\n      ((name : Name) →\n          (levelParams : List Name) →\n            (type value : Expr) →\n              (all : List Name) →\n                motive\n                  (ConstantInfo.thmInfo\n                    { name := name, levelParams := levelParams, type := type, value := value, all := all })) →\n        ((name : Name) →\n            (levelParams : List Name) →\n              (type value : Expr) →\n                (isUnsafe : Bool) →\n                  (all : List Name) →\n                    motive\n                      (ConstantInfo.opaqueInfo\n                        { name := name, levelParams := levelParams, type := type, value := value, isUnsafe := isUnsafe,\n                          all := all })) →\n          ((x : ConstantInfo) → motive x) → motive info",
  "constCategory": "Definition"},
 {"references": ["DecidableEq"],
  "name": "CellularAutomatas.Alphabet.mk._flat_ctor",
  "constType":
  "{α : Type} → [dec : DecidableEq α] → [fin : Fintype α] → [inh : Inhabited α] → CellularAutomatas.Alphabet α",
  "constCategory": "Definition"},
 {"references":
  ["Not",
   "eq_self",
   "of_eq_false",
   "Eq.trans",
   "of_eq_true",
   "Eq.mpr_not",
   "dite",
   "not_false",
   "dite_congr",
   "congrArg",
   "Eq.mpr_prop"],
  "name": "dite_cond_eq_false",
  "constType":
  "∀ {α : Sort u} {c : Prop} {x : Decidable c} {t : c → α} {e : ¬c → α} (h : c = False), dite c t e = e ⋯",
  "constCategory": "Theorem"},
 {"references":
  ["Int.max_eq_left",
   "Max.max",
   "Nat.cast",
   "Int.natCast_nonneg",
   "id",
   "Eq.mpr",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Int.ofNat_max_zero",
  "constType": "∀ (n : ℕ), max (↑n) 0 = ↑n",
  "constCategory": "Theorem"},
 {"references": ["LE.le", "eq_true", "Nat.le_refl"],
  "name": "Nat.le_refl._simp_1",
  "constType": "∀ (n : ℕ), (n ≤ n) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Bool.true_and",
   "eq_self",
   "Bool.and",
   "Bool.casesOn",
   "Eq.trans",
   "of_eq_true",
   "Eq.symm",
   "Eq.ndrec",
   "Bool.and'",
   "Bool.false_and",
   "congrArg"],
  "name": "Bool.and'_eq_and",
  "constType": "∀ (a b : Bool), a.and' b = (a && b)",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "Nat.cast",
   "Eq.trans",
   "Eq.mp",
   "Lean.Grind.OrderedAdd.add_lt_add",
   "congrArg",
   "Lean.Grind.Semiring.add_zero",
   "Eq.symm",
   "false_implies",
   "Eq.ndrec",
   "Nat.casesAuxOn",
   "Nat.lt_irrefl._simp_1",
   "Nat.zero_add",
   "Lean.Grind.OrderedRing.zero_lt_one",
   "Nat.recAux",
   "Lean.Grind.Semiring.natCast_add",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "LT.lt",
   "forall_const._simp_1",
   "of_eq_true",
   "id",
   "Eq.mpr",
   "Lean.Grind.Semiring.natCast",
   "Nat.zero_lt_succ._simp_1",
   "Lean.Grind.Semiring.natCast_one"],
  "name": "Lean.Grind.OrderedRing.pos_natCast_of_pos",
  "constType":
  "∀ {R : Type u} [inst : Grind.Ring R] [inst_1 : LE R] [inst_2 : LT R] [LawfulOrderLT R] [inst_4 : Std.IsPreorder R]\n  [Grind.OrderedRing R] (a : ℕ), 0 < a → 0 < ↑a",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "Std.le_trans",
   "LE.le",
   "Lean.Grind.OrderedAdd.add_le_left",
   "Lean.Grind.OrderedAdd.add_le_right"],
  "name": "Lean.Grind.OrderedAdd.add_le_add",
  "constType":
  "∀ {M : Type u} [inst : LE M] [inst_1 : Std.IsPreorder M] [inst_2 : Grind.AddCommMonoid M] [Grind.OrderedAdd M]\n  {a b c d : M}, a ≤ b → c ≤ d → a + c ≤ b + d",
  "constCategory": "Theorem"},
 {"references":
  ["id",
   "CellularAutomatas.CellAutomaton.Q",
   "CellularAutomatas.simulation.Params.noConfusion"],
  "name": "CellularAutomatas.simulation.Params.mk.noConfusion",
  "constType":
  "(P : Sort u) →\n  (C_inr C_ctl : CellularAutomatas.CellAutomaton) →\n    (f : C_ctl.Q → Option C_inr.Q) →\n      (C_inr' C_ctl' : CellularAutomatas.CellAutomaton) →\n        (f' : C_ctl'.Q → Option C_inr'.Q) →\n          { C_inr := C_inr, C_ctl := C_ctl, f := f } = { C_inr := C_inr', C_ctl := C_ctl', f := f' } →\n            (C_inr = C_inr' → C_ctl = C_ctl' → f ≍ f' → P) → P",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Function.comp",
  "constType":
  "{α : Sort u} → {β : Sort v} → {δ : Sort w} → (β → δ) → (α → β) → α → δ",
  "constCategory": "Definition"},
 {"references":
  ["_private.Init.Data.List.Nat.TakeDrop.0.List.length_take_le._simp_1_1",
   "Eq.trans",
   "of_eq_true",
   "Min.min",
   "List.take",
   "LE.le",
   "List.length_take",
   "congrArg",
   "List.length"],
  "name": "List.length_take_le",
  "constType":
  "∀ {α : Type u_1} (i : ℕ) (l : List α), (List.take i l).length ≤ i",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.Linear.Context",
   "Nat.Linear.Expr.denote",
   "LE.le",
   "Nat.Linear.ExprCnstr.lhs",
   "cond",
   "Nat.Linear.ExprCnstr.eq",
   "Nat.Linear.ExprCnstr.rhs"],
  "name": "Nat.Linear.ExprCnstr.denote",
  "constType": "Nat.Linear.Context → Nat.Linear.ExprCnstr → Prop",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CellularAutomatas.tCellAutomatonWithAdvice",
  "constType": "Type → Type 1",
  "constCategory": "Other"},
 {"references":
  ["Lean.Grind.AC.Seq.union_k", "Lean.Grind.AC.Seq.beq'", "Bool.and'"],
  "name": "Lean.Grind.AC.simp_ac_cert",
  "constType":
  "Grind.AC.Seq → Grind.AC.Seq → Grind.AC.Seq → Grind.AC.Seq → Grind.AC.Seq → Bool",
  "constCategory": "Definition"},
 {"references": ["Nat.casesOn", "Unit.unit", "OfNat.ofNat", "Unit"],
  "name": "Nat.pow.match_1",
  "constType":
  "(motive : ℕ → Sort u_1) → (x : ℕ) → (Unit → motive 0) → ((n : ℕ) → motive n.succ) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "Set",
   "Membership.mem",
   "CellularAutomatas.CellAutomaton.right_independent",
   "CellularAutomatas.tCellAutomaton.toLCellAutomaton",
   "CellularAutomatas.CAr",
   "setOf"],
  "name": "CellularAutomatas.OCAr",
  "constType": "(α : Type) → Set (CellularAutomatas.tCellAutomaton α)",
  "constCategory": "Definition"},
 {"references": ["id"],
  "name": "CellularAutomatas.VerificationError.details._default",
  "constType": "List String",
  "constCategory": "Definition"},
 {"references":
  ["Max.max",
   "Int.max_eq_right",
   "LE.le",
   "Eq.symm",
   "id",
   "Eq.mpr",
   "Int.max_comm",
   "congrArg"],
  "name": "Int.max_eq_left",
  "constType": "∀ {a b : ℤ}, b ≤ a → max a b = a",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans",
   "Int.zero_add",
   "Lean.Omega.Coeffs",
   "HMul.hMul",
   "Lean.Omega.IntList.get",
   "Lean.Omega.IntList.set",
   "Int.one_mul",
   "OfNat.ofNat",
   "congrArg",
   "HAdd.hAdd",
   "eq_self",
   "of_eq_true",
   "Lean.Omega.Coeffs.get",
   "HSub.hSub",
   "Lean.Omega.IntList.dot",
   "Int.sub_zero",
   "Lean.Omega.IntList.dot_set_left"],
  "name": "Lean.Omega.LinearCombo.coordinate_eval",
  "constType":
  "∀ (i : ℕ) (v : Omega.Coeffs), (Omega.LinearCombo.coordinate i).eval v = v.get i",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Bool.true_eq_false",
   "Bool.casesOn",
   "Eq.trans",
   "of_eq_true",
   "congr",
   "Eq.symm",
   "Eq.ndrec",
   "Bool.false_eq_true",
   "congrArg"],
  "name": "Bool.true_eq",
  "constType": "∀ (b : Bool), (true = b) = (b = true)",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "HAdd.hAdd",
   "LT.lt",
   "LE.le",
   "Nat.below",
   "HSub.hSub",
   "Nat.div.go.match_1",
   "Nat.brecOn",
   "dite",
   "Nat.div_rec_fuel_lemma",
   "OfNat.ofNat"],
  "name": "Nat.div.go",
  "constType": "(y : ℕ) → 0 < y → (fuel x : ℕ) → x < fuel → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["HAdd.hAdd",
   "eq_self",
   "Eq.trans",
   "of_eq_true",
   "add_zero",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Mathlib.Tactic.Ring.add_pf_add_zero",
  "constType": "∀ {R : Type u_1} [inst : CommSemiring R] (a : R), a + 0 = a",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "CellularAutomatas.CArtTransducer.toLCellAutomaton",
   "CellularAutomatas.CellAutomaton.Q"],
  "name": "CellularAutomatas.composition.Params.casesOn",
  "constType":
  "{motive : CellularAutomatas.composition.Params → Sort u} →\n  (t : CellularAutomatas.composition.Params) →\n    ((α β : Type) →\n        [_inst_α : CellularAutomatas.Alphabet α] →\n          [_inst_β : CellularAutomatas.Alphabet β] →\n            (C : CellularAutomatas.LCellAutomaton β) →\n              (C_adv : CellularAutomatas.CArtTransducer α β) →\n                (f : C_adv.Q → Option C.Q) →\n                  motive { α := α, β := β, _inst_α := _inst_α, _inst_β := _inst_β, C := C, C_adv := C_adv, f := f }) →\n      motive t",
  "constCategory": "Definition"},
 {"references": ["CellularAutomatas.Word", "List.length"],
  "name": "CellularAutomatas.Advice.casesOn",
  "constType":
  "{α Γ : Type} →\n  {motive : CellularAutomatas.Advice α Γ → Sort u} →\n    (t : CellularAutomatas.Advice α Γ) →\n      ((f : CellularAutomatas.Word α → CellularAutomatas.Word Γ) →\n          (len : ∀ (w : CellularAutomatas.Word α), List.length (f w) = List.length w) → motive { f := f, len := len }) →\n        motive t",
  "constCategory": "Definition"},
 {"references": ["eq_false", "And.right"],
  "name": "and_false",
  "constType": "∀ (p : Prop), (p ∧ False) = False",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.simulation.Params.C_ctl",
   "CellularAutomatas.CellAutomaton.Q",
   "OfNat.ofNat"],
  "name": "CellularAutomatas.simulation.Q1.casesOn",
  "constType":
  "{e : CellularAutomatas.simulation.Params} →\n  {motive : CellularAutomatas.simulation.Q1 e → Sort u} →\n    (t : CellularAutomatas.simulation.Q1 e) →\n      ((state : e.C_ctl.Q) → (counter : Fin 3) → motive { state := state, counter := counter }) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["Nat.lt_of_lt_of_le",
   "Eq.mp",
   "GetElem.getElem",
   "List.length_take",
   "List.length_take_le'",
   "congrArg",
   "LT.lt",
   "Nat.lt_min",
   "Min.min",
   "List.take",
   "Iff.mpr",
   "id",
   "Eq.symm",
   "Eq.mpr",
   "List.getElem_take'",
   "propext",
   "List.length",
   "And.left"],
  "name": "List.getElem_take",
  "constType":
  "∀ {α : Type u_1} {xs : List α} {j i : ℕ} {h : i < (List.take j xs).length}, (List.take j xs)[i] = xs[i]",
  "constCategory": "Theorem"},
 {"references": ["_private.Init.Data.List.Lemmas.0.List.cons_ne_nil.match_1_1"],
  "name": "List.cons_ne_nil",
  "constType": "∀ {α : Type u_1} (a : α) (l : List α), a :: l ≠ []",
  "constCategory": "Theorem"},
 {"references":
  ["Int.Linear.instBEqPoly.beq._sparseCasesOn_1",
   "Int.Linear.Poly.isUnsatEq.match_1",
   "False.elim",
   "id",
   "Ne",
   "Int.Linear.Poly.casesOn",
   "Nat.ne_of_beq_eq_false",
   "OfNat.ofNat",
   "Int.Linear.Poly.ctorIdx",
   "Int.Linear.Var"],
  "name":
  "_private.Init.Data.Int.Linear.0.Int.Linear.Poly.isUnsatEq.match_1.eq_2",
  "constType":
  "∀ (motive : Int.Linear.Poly → Sort u_1) (x : Int.Linear.Poly) (h_1 : (k : ℤ) → motive (Int.Linear.Poly.num k))\n  (h_2 : (x : Int.Linear.Poly) → motive x),\n  (∀ (k : ℤ), x = Int.Linear.Poly.num k → False) →\n    (match x with\n      | Int.Linear.Poly.num k => h_1 k\n      | x => h_2 x) =\n      h_2 x",
  "constCategory": "Theorem"},
 {"references": ["outParam"],
  "name": "Singleton.singleton",
  "constType":
  "{α : outParam (Type u)} → {β : Type v} → [self : Singleton α β] → α → β",
  "constCategory": "Definition"},
 {"references": ["Not", "Eq.symm"],
  "name": "Eq.mpr_not",
  "constType": "∀ {p q : Prop}, p = q → ¬q → ¬p",
  "constCategory": "Theorem"},
 {"references": ["id", "Inhabited.default"],
  "name": "CellularAutomatas.ca_id",
  "constType":
  "(α : Type) → [inst : CellularAutomatas.Alphabet α] → CellularAutomatas.CArtTransducer α α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "eagerReduce",
  "constType": "{α : Sort u} → α → α",
  "constCategory": "Definition"},
 {"references": ["Classical.indefiniteDescription", "Subtype.val"],
  "name": "Classical.choose",
  "constType": "{α : Sort u} → {p : α → Prop} → (∃ x, p x) → α",
  "constCategory": "Definition"},
 {"references": ["Std.DTreeMap.empty"],
  "name": "Std.TreeMap.empty",
  "constType":
  "{α : Type u} → {β : Type v} → {cmp : α → α → Ordering} → TreeMap α β cmp",
  "constCategory": "Definition"},
 {"references": ["LT.lt", "GetElem?.getElem?", "List.casesOn", "List.length"],
  "name": "_private.Init.Data.List.Lemmas.0.List.ext_getElem?.match_1_1",
  "constType":
  "∀ {α : Type u_1} (motive : (l₁ l₂ : List α) → (∀ (i : ℕ), l₁[i]? = l₂[i]?) → Prop) (l₁ l₂ : List α)\n  (h : ∀ (i : ℕ), l₁[i]? = l₂[i]?),\n  (∀ (x : ∀ (i : ℕ), [][i]? = [][i]?), motive [] [] x) →\n    (∀ (head : α) (tail : List α) (h : ∀ (i : ℕ), (head :: tail)[i]? = [][i]?), motive (head :: tail) [] h) →\n      (∀ (head : α) (tail : List α) (h : ∀ (i : ℕ), [][i]? = (head :: tail)[i]?), motive [] (head :: tail) h) →\n        (∀ (a : α) (l₁ : List α) (a' : α) (l₂ : List α) (h : ∀ (i : ℕ), (a :: l₁)[i]? = (a' :: l₂)[i]?),\n            motive (a :: l₁) (a' :: l₂) h) →\n          motive l₁ l₂ h",
  "constCategory": "Definition"},
 {"references":
  ["LT.lt",
   "List.range",
   "HAdd.hAdd",
   "Lean.Grind.Nat.lt_eq",
   "Eq.substr",
   "LE.le",
   "OfNat.ofNat",
   "Inhabited.default",
   "List.length"],
  "name": "CellularAutomatas.ProdCA.zipMany_get?._proof_1_2",
  "constType":
  "∀ {β : Type} [inst : CellularAutomatas.Alphabet β] {γ : β → Type u_1} (f : (b : β) → List (γ b)) (i : ℕ),\n  i + 1 ≤ (List.range (f default).length).length → i < (List.range (f default).length).length",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CellularAutomatas.FiniteStateTransducer.ctorIdx",
  "constType": "{α β : Type} → CellularAutomatas.FiniteStateTransducer α β → ℕ",
  "constCategory": "Definition"},
 {"references": ["Prod.snd", "EmptyCollection.emptyCollection", "Lean.NameSet"],
  "name": "CellularAutomatas.collectAxiomsFromEnv",
  "constType": "Environment → Name → NameSet",
  "constCategory": "Definition"},
 {"references": ["rfl", "Lean.Grind.AC.Seq.denote"],
  "name": "Lean.Grind.AC.refl",
  "constType":
  "∀ {α : Sort u_1} (ctx : Grind.AC.Context α) (s : Grind.AC.Seq), Grind.AC.Seq.denote ctx s = Grind.AC.Seq.denote ctx s",
  "constCategory": "Theorem"},
 {"references": ["exists_false", "eq_false"],
  "name": "exists_false._simp_1",
  "constType": "∀ {α : Sort u_1}, (∃ _a, False) = False",
  "constCategory": "Theorem"},
 {"references": ["LT.lt"],
  "name": "Nat.succ_le_of_lt",
  "constType": "∀ {n m : ℕ}, n < m → n.succ ≤ m",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans",
   "Eq.mp",
   "Int.Linear.Poly.denote'_eq_denote",
   "Int.Linear.Poly.denote",
   "Iff.rfl",
   "eq_iff_iff._simp_1",
   "Int.Linear.Expr.denote_norm",
   "OfNat.ofNat",
   "congrArg",
   "Int.Linear.norm_eq_cert",
   "Int.Linear.Expr.norm",
   "Int.Linear.Context",
   "Int.Linear.Expr.denote",
   "Int.Linear.Poly.beq'_eq",
   "Eq.symm",
   "HSub.hSub",
   "id",
   "Int.sub_eq_zero",
   "Int.Linear.Poly.denote'",
   "Eq.mpr",
   "Eq.ndrec",
   "propext"],
  "name": "Int.Linear.norm_eq",
  "constType":
  "∀ (ctx : Int.Linear.Context) (lhs rhs : Int.Linear.Expr) (p : Int.Linear.Poly),\n  Int.Linear.norm_eq_cert lhs rhs p = true →\n    (Int.Linear.Expr.denote ctx lhs = Int.Linear.Expr.denote ctx rhs) = (Int.Linear.Poly.denote' ctx p = 0)",
  "constCategory": "Theorem"},
 {"references": ["Or.casesOn", "LT.lt", "GE.ge"],
  "name": "_private.Init.Data.Nat.Basic.0.Nat.not_le_of_gt.match_1_1",
  "constType":
  "∀ {n m : ℕ} (motive : n < m ∨ n ≥ m → Prop) (x : n < m ∨ n ≥ m),\n  (∀ (h₂ : n < m), motive ⋯) → (∀ (h₂ : n ≥ m), motive ⋯) → motive x",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CellularAutomatas.composition.Params.f",
  "constType":
  "(self : CellularAutomatas.composition.Params) → self.C_adv.Q → Option self.C.Q",
  "constCategory": "Definition"},
 {"references": ["Units.val", "Eq.symm", "Eq.ndrec", "Eq.casesOn", "Units.ext"],
  "name": "Units.ext_iff",
  "constType": "∀ {α : Type u} [inst : Monoid α] {u v : αˣ}, u = v ↔ ↑u = ↑v",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "Nat.le_sub_of_add_le",
   "Nat.add_le_of_le_sub",
   "LE.le",
   "HSub.hSub"],
  "name": "Nat.le_sub_iff_add_le",
  "constType": "∀ {k m n : ℕ}, k ≤ m → (n ≤ m - k ↔ n + k ≤ m)",
  "constCategory": "Theorem"},
 {"references": ["Min.min", "Nat.min_le_left", "LE.le", "eq_true"],
  "name":
  "_private.Init.Data.List.Nat.TakeDrop.0.List.length_take_le._simp_1_1",
  "constType": "∀ (a b : ℕ), (min a b ≤ a) = True",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.Word",
   "sorryAx",
   "Nat.cast",
   "ite",
   "HMul.hMul",
   "CellularAutomatas.LCellAutomaton.comp",
   "GE.ge",
   "OfNat.ofNat",
   "CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "HAdd.hAdd",
   "CellularAutomatas.compress_by_3.C'",
   "CellularAutomatas.compress_by_3.f",
   "CellularAutomatas.CellAutomaton.Q",
   "Int.natAbs"],
  "name": "CellularAutomatas.compress_by_3.compression1",
  "constType":
  "∀ {α : Type} [CellularAutomatas.Alphabet α] (C : CellularAutomatas.LCellAutomaton α) (w : CellularAutomatas.Word α)\n  (t : ℕ) (p : ℤ),\n  CellularAutomatas.compress_by_3.f ((CellularAutomatas.compress_by_3.C' C).comp w t p) =\n    if p ≥ 0 ∧ ↑t = 2 * p + 3 then\n      have i := (3 * p).natAbs;\n      some (C.comp w i 0, C.comp w (i + 1) 0, C.comp w (i + 2) 0)\n    else none",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Omega.Constraint.sat'.eq_1",
   "Lean.Omega.Coeffs.dot_smul_left",
   "Lean.Omega.Constraint.sat",
   "Lean.Omega.Coeffs.combo",
   "Lean.Omega.Coeffs",
   "HMul.hMul",
   "Lean.Omega.Coeffs.combo_eq_smul_add_smul",
   "Lean.Omega.Constraint.combo",
   "congrArg",
   "HAdd.hAdd",
   "Lean.Omega.Constraint.combo_sat",
   "Lean.Omega.IntList",
   "Lean.Omega.Coeffs.dot_distrib_left",
   "id",
   "Eq.mpr",
   "Lean.Omega.Coeffs.dot",
   "Lean.Omega.Constraint.sat'"],
  "name": "Lean.Omega.combo_sat'",
  "constType":
  "∀ (s t : Omega.Constraint) (a : ℤ) (x : Omega.Coeffs) (b : ℤ) (y v : Omega.Coeffs),\n  s.sat' x v = true → t.sat' y v = true → (Omega.Constraint.combo a s b t).sat' (Omega.Coeffs.combo a x b y) v = true",
  "constCategory": "Theorem"},
 {"references": ["Nat.casesOn"],
  "name": "Nat.noConfusionType",
  "constType": "Sort u → ℕ → ℕ → Sort u",
  "constCategory": "Definition"},
 {"references":
  ["CellularAutomatas.CALc",
   "CellularAutomatas.ProdCA",
   "CellularAutomatas.tCellAutomaton.toLCellAutomaton",
   "CellularAutomatas.Advice.rt_closed"],
  "name": "CellularAutomatas.PrefixStableProof.M_prod",
  "constType":
  "{α : Type} →\n  [inst : CellularAutomatas.Alphabet α] →\n    {Γ : Type} →\n      [inst_1 : CellularAutomatas.Alphabet Γ] →\n        (adv : CellularAutomatas.Advice α Γ) → adv.rt_closed → CellularAutomatas.LCellAutomaton α",
  "constCategory": "Definition"},
 {"references": ["List.map", "List.map_eq_nil_iff", "propext"],
  "name": "List.map_eq_nil_iff._simp_1",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {f : α → β} {l : List α}, (List.map f l = []) = (l = [])",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "CellularAutomatas.CA",
   "Set",
   "Membership.mem",
   "CellularAutomatas.tCellAutomaton.toLCellAutomaton",
   "CellularAutomatas.CellAutomaton.left_independent",
   "setOf"],
  "name": "CellularAutomatas.OCA",
  "constType": "(α : Type) → Set (CellularAutomatas.tCellAutomaton α)",
  "constCategory": "Definition"},
 {"references":
  ["implies_congr",
   "Int.Linear.Poly.coeff",
   "Int.Linear.Poly.beq'",
   "Bool.not",
   "Eq.trans",
   "Int.Linear.Poly.denote'_eq_denote",
   "and_imp._simp_1",
   "Int.zero_add",
   "Int.Linear.Poly.denote",
   "Int.Linear.Poly.denote_combine_mul_k",
   "HMul.hMul",
   "congrArg",
   "Int.mul_ne_zero_iff._simp_1",
   "Bool.and",
   "not_false_eq_true",
   "congr",
   "Eq.symm",
   "Int.Linear.Poly.denote'",
   "Int.beq'",
   "Eq.ndrec",
   "Int.neg_eq_zero._simp_1",
   "Not",
   "Int.beq'_ne",
   "Bool.not_true",
   "Bool.and'_eq_and",
   "Bool.not_eq_eq_eq_not._simp_1",
   "Neg.neg",
   "OfNat.ofNat",
   "Int.Linear.diseq_eq_subst_cert",
   "Int.mul_zero",
   "HAdd.hAdd",
   "and_self",
   "of_eq_true",
   "Int.Linear.Poly.combine_mul_k",
   "Int.Linear.Context",
   "eq_false",
   "Int.Linear.Poly.beq'_eq",
   "id",
   "Ne",
   "Eq.mpr",
   "Bool.and_eq_true",
   "Bool.and'",
   "Int.Linear.Var"],
  "name": "Int.Linear.eq_diseq_subst",
  "constType":
  "∀ (ctx : Int.Linear.Context) (x : Int.Linear.Var) (p₁ p₂ p₃ : Int.Linear.Poly),\n  Int.Linear.diseq_eq_subst_cert x p₁ p₂ p₃ = true →\n    Int.Linear.Poly.denote' ctx p₁ = 0 → Int.Linear.Poly.denote' ctx p₂ ≠ 0 → Int.Linear.Poly.denote' ctx p₃ ≠ 0",
  "constCategory": "Theorem"},
 {"references": ["Mathlib.Meta.NormNum.IsNat.casesOn", "Nat.cast"],
  "name":
  "_private.Mathlib.Tactic.Ring.Basic.0.Mathlib.Tactic.Ring.cast_pos.match_1_1",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a : R} {n : ℕ} (motive : Mathlib.Meta.NormNum.IsNat a n → Prop)\n  (x : Mathlib.Meta.NormNum.IsNat a n), (∀ (e : a = ↑n), motive ⋯) → motive x",
  "constCategory": "Definition"},
 {"references": ["Set", "Membership.mem", "Set.ext_iff", "propext"],
  "name": "CellularAutomatas.set_iff._simp_1_1",
  "constType":
  "∀ {α : Type u} {a b : Set α}, (a = b) = ∀ (x : α), x ∈ a ↔ x ∈ b",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.Word.get'",
   "CellularAutomatas.Word",
   "Set",
   "Membership.mem",
   "CellularAutomatas.Word.range"],
  "name": "CellularAutomatas.Word.get'.eq_1",
  "constType":
  "∀ {α : Type u} (w : CellularAutomatas.Word α) (i : ℤ) (h : i ∈ w.range), w.get' i h = List.get w ⟨i.toNat, ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "CellularAutomatas.tCellAutomaton.casesOn",
   "CellularAutomatas.CellAutomaton.Q"],
  "name": "CellularAutomatas.tCellAutomaton.noConfusionType",
  "constType":
  "{α : Type} → Sort u → CellularAutomatas.tCellAutomaton α → CellularAutomatas.tCellAutomaton α → Sort u",
  "constCategory": "Definition"},
 {"references": ["CanonicallyOrderedAdd.le_self_add"],
  "name": "le_self_add",
  "constType":
  "∀ {α : Type u} [inst : Add α] [inst_1 : LE α] [CanonicallyOrderedAdd α] {a b : α}, a ≤ a + b",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "implies_congr",
   "Int.Linear.Poly.beq'",
   "Int.Linear.Poly.denote'_eq_denote",
   "Int.Linear.Poly.denote",
   "Int.Linear.Expr.denote_norm",
   "OfNat.ofNat",
   "congrArg",
   "Int.Linear.norm_eq_cert",
   "Int.Linear.Expr.norm",
   "Int.Linear.Context",
   "Int.Linear.Expr.denote",
   "Eq.symm",
   "HSub.hSub",
   "id",
   "Int.Linear.Poly.beq'_eq",
   "Int.sub_eq_zero",
   "Int.Linear.Poly.denote'",
   "Eq.mpr",
   "Eq.ndrec",
   "propext"],
  "name": "Int.Linear.not_eq_norm_expr",
  "constType":
  "∀ (ctx : Int.Linear.Context) (lhs rhs : Int.Linear.Expr) (p : Int.Linear.Poly),\n  Int.Linear.norm_eq_cert lhs rhs p = true →\n    ¬Int.Linear.Expr.denote ctx lhs = Int.Linear.Expr.denote ctx rhs → ¬Int.Linear.Poly.denote' ctx p = 0",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CellularAutomatas.composition.Params.ctorIdx",
  "constType": "CellularAutomatas.composition.Params → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Nat.le_trans",
   "Nat.le_succ",
   "LE.le",
   "Nat.pred",
   "OfNat.ofNat",
   "_private.Init.Prelude.0.Nat.pred_le_pred.match_1_1"],
  "name": "Nat.pred_le_pred",
  "constType": "∀ {n m : ℕ}, n ≤ m → n.pred ≤ m.pred",
  "constCategory": "Theorem"},
 {"references": ["Prod.casesOn", "Lean.Omega.Coeffs"],
  "name": "Lean.Omega.normalize?.match_1",
  "constType":
  "(motive : Omega.Constraint ⨉ Omega.Coeffs → Sort u_1) →\n  (x : Omega.Constraint ⨉ Omega.Coeffs) → ((s : Omega.Constraint) → (x : Omega.Coeffs) → motive (s, x)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Not",
   "Eq.trans",
   "Nat.zero_add",
   "List.brecOn",
   "_private.Init.Data.List.MapIdx.0.List.length_mapIdx_go.match_1_1",
   "Array.size_push",
   "OfNat.ofNat",
   "congrArg",
   "List.mapIdx.go",
   "HAdd.hAdd",
   "Array.size",
   "List.below",
   "eq_self",
   "Decidable.byContradiction",
   "of_eq_true",
   "_private.Init.Data.List.MapIdx.0.List.length_mapIdx_go._proof_1_6",
   "Array.push",
   "id",
   "Eq.mpr",
   "List.length"],
  "name": "List.length_mapIdx_go",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {f : ℕ → α → β} {l : List α} {acc : Array β},\n  (List.mapIdx.go f l acc).length = l.length + acc.size",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt", "Lean.Grind.IntInterval.mem_io", "Membership.mem", "propext"],
  "name": "Lean.Grind.IntInterval.mem_io._simp_1",
  "constType": "∀ (hi x : ℤ), (x ∈ Grind.IntInterval.io hi) = (x < hi)",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans",
   "CellularAutomatas.backwards_fsm.Params.inst3",
   "eq_true",
   "eagerReduce",
   "CellularAutomatas.Config",
   "CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "NatCast.natCast",
   "funext",
   "HSub.hSub",
   "Eq.symm",
   "CellularAutomatas.Word.get'?",
   "CellularAutomatas.backwards_fsm.Params.α",
   "CellularAutomatas.CellAutomaton.δ",
   "CellularAutomatas.CArtTransducer.toLCellAutomaton",
   "List.drop",
   "CellularAutomatas.backwards_fsm.Params.β",
   "Neg.neg",
   "CellularAutomatas.backwards_fsm.Params.M",
   "CellularAutomatas.FiniteStateTransducer.scanr",
   "Prod.snd",
   "CellularAutomatas.backwards_fsm.Params.inst2",
   "CellularAutomatas.LCellAutomaton.comp",
   "eq_false",
   "Classical.byContradiction",
   "id",
   "Int.toNat",
   "Nat.cast",
   "CellularAutomatas.backwards_fsm.C'",
   "CellularAutomatas.backwards_fsm.Params.C",
   "Eq.mp",
   "CellularAutomatas.FiniteStateTransducer.Q",
   "CellularAutomatas.FiniteStateTransducer.δ?",
   "CellularAutomatas.FiniteStateTransducer.scanr_reduce",
   "CellularAutomatas.backwards_fsm.Params.γ",
   "Int.Linear.Expr.eq_of_norm_eq",
   "Prod.fst",
   "congrArg",
   "congr",
   "CellularAutomatas.CellAutomaton.Q",
   "Lean.Grind.forall_and",
   "Not",
   "CellularAutomatas.Word",
   "Lean.Grind.Semiring.natCast_add",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "eq_self",
   "True.casesOn",
   "Lean.Grind.intro_with_eq",
   "Lean.Grind.Semiring.natCast",
   "Lean.Grind.Semiring.natCast_eq_ofNat",
   "And.casesOn"],
  "name": "CellularAutomatas.backwards_fsm.inv._proof_1_9",
  "constType":
  "∀ (e : CellularAutomatas.backwards_fsm.Params) (w : CellularAutomatas.Word e.α) (t : ℕ) (p : ℤ),\n  (∀ (p : ℤ),\n      let c' := (CellularAutomatas.backwards_fsm.C' e).comp w t p;\n      let q := e.M.scanr_reduce w⟦(p + ↑t).toNat..*⟧;\n      c'.2 q = e.C.comp (e.M.scanr w) t p ∧ c'.1 = w.get'? (p + ↑t)) →\n    (CellularAutomatas.backwards_fsm.C' e).comp w t = (CellularAutomatas.backwards_fsm.C' e).comp w t →\n      (CellularAutomatas.backwards_fsm.C' e).comp w t (p - 1) =\n          (CellularAutomatas.backwards_fsm.C' e).comp w t (p - 1) →\n        (CellularAutomatas.backwards_fsm.C' e).comp w t p = (CellularAutomatas.backwards_fsm.C' e).comp w t p →\n          (CellularAutomatas.backwards_fsm.C' e).comp w (t + 1) p =\n              (((CellularAutomatas.backwards_fsm.C' e).comp w t (p + 1)).1, fun q =>\n                e.C.δ\n                  (((CellularAutomatas.backwards_fsm.C' e).comp w t (p - 1)).2\n                    (e.M.δ? (e.M.δ? q ((CellularAutomatas.backwards_fsm.C' e).comp w t p).1)\n                      ((CellularAutomatas.backwards_fsm.C' e).comp w t (p - 1)).1))\n                  (((CellularAutomatas.backwards_fsm.C' e).comp w t p).2\n                    (e.M.δ? q ((CellularAutomatas.backwards_fsm.C' e).comp w t p).1))\n                  (((CellularAutomatas.backwards_fsm.C' e).comp w t (p + 1)).2 q)) →\n            (CellularAutomatas.backwards_fsm.C' e).comp w t (p + 1) =\n                (CellularAutomatas.backwards_fsm.C' e).comp w t (p + 1) →\n              e.M.scanr_reduce w⟦(p + ↑(t + 1)).toNat..*⟧ = e.M.scanr_reduce w⟦(p + ↑(t + 1)).toNat..*⟧ →\n                (((CellularAutomatas.backwards_fsm.C' e).comp w (t + 1) p).2\n                      (e.M.scanr_reduce w⟦(p + ↑(t + 1)).toNat..*⟧) =\n                    let q_right :=\n                      e.M.δ? (e.M.scanr_reduce w⟦(p + ↑(t + 1)).toNat..*⟧)\n                        ((CellularAutomatas.backwards_fsm.C' e).comp w t p).1;\n                    let q_center := e.M.δ? q_right ((CellularAutomatas.backwards_fsm.C' e).comp w t (p - 1)).1;\n                    e.C.δ (((CellularAutomatas.backwards_fsm.C' e).comp w t (p - 1)).2 q_center)\n                      (((CellularAutomatas.backwards_fsm.C' e).comp w t p).2 q_right)\n                      (((CellularAutomatas.backwards_fsm.C' e).comp w t (p + 1)).2\n                        (e.M.scanr_reduce w⟦(p + ↑(t + 1)).toNat..*⟧))) →\n                  (let c' := (CellularAutomatas.backwards_fsm.C' e).comp w t (p + 1);\n                    let q := e.M.scanr_reduce w⟦(p + 1 + ↑t).toNat..*⟧;\n                    c'.2 q = e.C.comp (e.M.scanr w) t (p + 1) ∧ c'.1 = w.get'? (p + 1 + ↑t)) →\n                    ((CellularAutomatas.backwards_fsm.C' e).comp w t (p + 1)).2\n                            (e.M.scanr_reduce w⟦(p + ↑(t + 1)).toNat..*⟧) =\n                          e.C.comp (e.M.scanr w) t (p + 1) ∧\n                        ((CellularAutomatas.backwards_fsm.C' e).comp w t (p + 1)).1 = w.get'? (p + ↑t + 1) →\n                      ((CellularAutomatas.backwards_fsm.C' e).comp w t p).1 = w.get'? (p + ↑t) →\n                        e.M.δ? (e.M.scanr_reduce w⟦(p + ↑(t + 1)).toNat..*⟧)\n                              ((CellularAutomatas.backwards_fsm.C' e).comp w t p).1 =\n                            e.M.scanr_reduce w⟦(p + ↑t).toNat..*⟧ →\n                          ((CellularAutomatas.backwards_fsm.C' e).comp w t p).2\n                                (e.M.δ? (e.M.scanr_reduce w⟦(p + ↑(t + 1)).toNat..*⟧)\n                                  ((CellularAutomatas.backwards_fsm.C' e).comp w t p).1) =\n                              e.C.comp (e.M.scanr w) t p →\n                            ((CellularAutomatas.backwards_fsm.C' e).comp w t (p - 1)).1 = w.get'? (p + ↑t - 1) →\n                              (let c' := (CellularAutomatas.backwards_fsm.C' e).comp w t (p - 1);\n                                let q := e.M.scanr_reduce w⟦(p - 1 + ↑t).toNat..*⟧;\n                                c'.2 q = e.C.comp (e.M.scanr w) t (p - 1) ∧ c'.1 = w.get'? (p - 1 + ↑t)) →\n                                e.M.δ? (e.M.scanr_reduce w⟦(p + ↑t).toNat..*⟧)\n                                    ((CellularAutomatas.backwards_fsm.C' e).comp w t (p - 1)).1 =\n                                  e.M.δ? (e.M.scanr_reduce w⟦(p - 1 + ↑t + 1).toNat..*⟧) (w.get'? (p - 1 + ↑t))",
  "constCategory": "Theorem"},
 {"references": ["Std.TreeSet.inner", "Std.TreeMap.keysArray", "Unit"],
  "name": "Std.TreeSet.toArray",
  "constType":
  "{α : Type u} → {cmp : α → α → Ordering} → TreeSet α cmp → Array α",
  "constCategory": "Definition"},
 {"references":
  ["Not",
   "Nat.cast",
   "Eq.trans",
   "Int.natCast_nonneg",
   "ite",
   "Neg.neg",
   "ite_cond_eq_false",
   "OfNat.ofNat",
   "Int.natAbs.eq_def",
   "ite_congr",
   "congrArg",
   "HAdd.hAdd",
   "eq_self",
   "of_eq_true",
   "LE.le",
   "Eq.symm",
   "id",
   "Eq.mpr",
   "Int.natAbs",
   "_private.Init.Omega.Int.0.Int.neg.match_1.splitter",
   "Int.neg.match_1",
   "Eq.ndrec",
   "Int.negSucc_not_nonneg._simp_1",
   "if_pos"],
  "name": "Lean.Omega.Int.ofNat_natAbs",
  "constType": "∀ (a : ℤ), ↑a.natAbs = if 0 ≤ a then a else -a",
  "constCategory": "Theorem"},
 {"references": ["rfl", "Option.or"],
  "name": "Option.some_or",
  "constType":
  "∀ {α : Type u_1} {a : α} {o : Option α}, (some a).or o = some a",
  "constCategory": "Theorem"},
 {"references":
  ["EquivLike.injective",
   "Function.Surjective",
   "DFunLike.coe",
   "EquivLike.surjective",
   "Function.Injective"],
  "name": "EquivLike.bijective",
  "constType":
  "∀ {E : Sort u_1} {α : Sort u_3} {β : Sort u_4} [inst : EquivLike E α β] (e : E), Function.Bijective ⇑e",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Preorder.lt_iff_le_not_ge",
  "constType":
  "∀ {α : Type u_2} [self : Preorder α] (a b : α), a < b ↔ a ≤ b ∧ ¬b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["Neg.neg", "ite", "LE.le", "Int.natAbs", "Fin.ofNat", "OfNat.ofNat"],
  "name": "Fin.intCast",
  "constType": "{n : ℕ} → [NeZero n] → ℤ → Fin n",
  "constCategory": "Definition"},
 {"references": ["LE.le", "Std.IsPreorder.le_trans"],
  "name": "Lean.Grind.Order.le_trans",
  "constType":
  "∀ {α : Type u_1} [inst : LE α] [Std.IsPreorder α] {a b c : α}, a ≤ b → b ≤ c → a ≤ c",
  "constCategory": "Theorem"},
 {"references": ["Set"],
  "name": "Set.Mem",
  "constType": "{α : Type u} → Set α → α → Prop",
  "constCategory": "Definition"},
 {"references": ["trivial", "propext", "And.left"],
  "name": "and_true",
  "constType": "∀ (p : Prop), (p ∧ True) = p",
  "constCategory": "Theorem"},
 {"references": ["Lean.Syntax.isNodeOf", "Lean.nullKind"],
  "name": "Lean.Syntax.matchesNull",
  "constType": "Syntax → ℕ → Bool",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Grind.AC.Var",
   "Lean.Grind.AC.Seq.sort'",
   "Lean.Grind.AC.Seq.erase0.match_1"],
  "name": "Lean.Grind.AC.Seq.sort",
  "constType": "Grind.AC.Seq → Grind.AC.Seq",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Omega.positivize?",
   "eq_self",
   "and_self",
   "Eq.trans",
   "of_eq_true",
   "congr",
   "Option.getD",
   "Lean.Omega.Coeffs",
   "Prod.snd",
   "congrArg",
   "Prod.fst"],
  "name": "Lean.Omega.positivize?_eq_some",
  "constType":
  "∀ {s : Omega.Constraint} {x : Omega.Coeffs} {s' : Omega.Constraint} {x' : Omega.Coeffs},\n  Omega.positivize? (s, x) = some (s', x') → Omega.positivizeConstraint s x = s' ∧ Omega.positivizeCoeffs s x = x'",
  "constCategory": "Theorem"},
 {"references": ["HMul.hMul", "Eq.ndrec"],
  "name": "Lean.Omega.Int.mul_congr",
  "constType": "∀ {a b c d : ℤ}, a = b → c = d → a * c = b * d",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "Lean.Omega.Constraint.map",
   "ite",
   "HMul.hMul",
   "Lean.Omega.Constraint.isImpossible",
   "Lean.Omega.Constraint.flip",
   "OfNat.ofNat"],
  "name": "Lean.Omega.Constraint.scale",
  "constType": "ℤ → Omega.Constraint → Omega.Constraint",
  "constCategory": "Definition"},
 {"references": ["CellularAutomatas.FiniteStateTransducer.casesOn"],
  "name": "CellularAutomatas.FiniteStateTransducer.noConfusionType",
  "constType":
  "{α β : Type} →\n  Sort u → CellularAutomatas.FiniteStateTransducer α β → CellularAutomatas.FiniteStateTransducer α β → Sort u",
  "constCategory": "Definition"},
 {"references": ["CellularAutomatas.simulation.Params._sizeOf_1"],
  "name": "CellularAutomatas.simulation.Params._sizeOf_inst",
  "constType": "SizeOf CellularAutomatas.simulation.Params",
  "constCategory": "Definition"},
 {"references":
  ["ite", "_private.Lean.Declaration.0.Lean.ConstantInfo.value?.match_1"],
  "name": "Lean.ConstantInfo.value?",
  "constType": "ConstantInfo → optParam Bool false → Option Expr",
  "constCategory": "Definition"},
 {"references":
  ["Or.elim",
   "Lean.Omega.LinearCombo.coordinate_eval_2",
   "Nat.cast",
   "Eq.trans",
   "le_of_le_of_eq",
   "Lean.Omega.LinearCombo.coordinate_eval_3",
   "Lean.Omega.LinearCombo.coordinate_eval_0",
   "Lean.Omega.Constraint.combine_sat'",
   "Int.sub_eq_zero_of_eq",
   "GT.gt",
   "Decidable.decide",
   "Lean.Omega.Int.ofNat_le_of_le",
   "Nat.lt_or_gt_of_ne",
   "Lean.Omega.Coeffs.ofList",
   "Lean.Omega.Int.ofNat_sub_dichotomy",
   "Lean.Omega.tidy_sat",
   "HSub.hSub",
   "Eq.symm",
   "Lean.Omega.LinearCombo.add_eval",
   "Int.add_one_le_of_lt",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "And.left",
   "of_decide_eq_true",
   "Not",
   "CellularAutomatas.Word",
   "Neg.neg",
   "And.right",
   "Lean.Omega.Constraint.addInequality_sat",
   "Lean.Omega.Int.add_congr",
   "Lean.Omega.Constraint.isImpossible",
   "Lean.Omega.LinearCombo.coordinate",
   "Int.sub_nonneg_of_le",
   "OfNat.ofNat",
   "LT.lt",
   "HAdd.hAdd",
   "Lean.Omega.Int.ofNat_lt_of_lt",
   "Lean.Omega.LinearCombo.sub_eval",
   "LE.le",
   "Int.natCast_add",
   "id",
   "Lean.Omega.Constraint.addEquality_sat",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.Int.sub_congr",
   "List.length"],
  "name": "CellularAutomatas.distinct_prefixes_from_markers._proof_1_1",
  "constType":
  "∀ {α : Type} (p : CellularAutomatas.Word α) (pos n : ℕ),\n  List.length p ≤ n → ¬List.length p + (n - List.length p) = n → False",
  "constCategory": "Theorem"},
 {"references": ["Not", "id", "Decidable.decide", "of_decide_eq_true"],
  "name": "not_true_eq_false",
  "constType": "(¬True) = False",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "implies_congr",
   "Lean.Grind.Ring.intCast",
   "Eq.mp",
   "Neg.neg",
   "Lean.Grind.Ring.intCast_neg",
   "Lean.Grind.Semiring.add_assoc",
   "Int.cast",
   "OfNat.ofNat",
   "congrArg",
   "HAdd.hAdd",
   "LT.lt",
   "Lean.Grind.Semiring.add_zero",
   "Lean.Grind.Order.lt_of_not_le",
   "Lean.Grind.OrderedAdd.add_lt_left",
   "Int.beq'_eq",
   "LE.le",
   "Eq.symm",
   "id",
   "Int.beq'",
   "Eq.mpr",
   "Lean.Grind.AddCommGroup.add_neg_cancel",
   "Eq.ndrec"],
  "name": "Lean.Grind.Order.lt_of_not_le_k",
  "constType":
  "∀ {α : Type u_1} [inst : LE α] [inst_1 : LT α] [LawfulOrderLT α] [inst_3 : IsLinearPreorder α] [inst_4 : Grind.Ring α]\n  [Grind.OrderedRing α] {a b : α} {k k' : ℤ}, k'.beq' (-k) = true → ¬a ≤ b + ↑k → b < a + ↑k'",
  "constCategory": "Theorem"},
 {"references":
  ["Functor.map",
   "Bind.bind",
   "LawfulApplicative.map_pure",
   "eq_self",
   "LawfulMonad.bind_pure_comp",
   "Eq.trans",
   "of_eq_true",
   "List.foldrM_cons",
   "Pure.pure",
   "List.foldrM",
   "congrArg",
   "List.foldr"],
  "name": "List.foldrM_pure",
  "constType":
  "∀ {m : Type u_1 → Type u_2} {α : Type u_3} {β : Type u_1} [inst : Monad m] [LawfulMonad m] {f : α → β → β} {b : β}\n  {l : List α}, List.foldrM (fun x1 x2 => pure (f x1 x2)) b l = pure (List.foldr f b l)",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.Word",
   "Eq.trans",
   "Iff.mp",
   "OfNat.ofNat",
   "congrArg",
   "CellularAutomatas.Advice.f",
   "eq_self",
   "List.length_eq_zero_iff",
   "of_eq_true",
   "CellularAutomatas.Advice.len",
   "id",
   "Eq.mpr",
   "List.length"],
  "name": "CellularAutomatas.adv_empty",
  "constType":
  "∀ {α Γ : Type} (adv : CellularAutomatas.Advice α Γ), adv.f [] = []",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.below",
   "LE.le",
   "Nat.brecOn",
   "OfNat.ofNat",
   "Unit",
   "_private.Init.Prelude.0.Nat.zero_le.match_1_1"],
  "name": "Nat.zero_le",
  "constType": "∀ (n : ℕ), 0 ≤ n",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CellularAutomatas.CellAutomaton.mk._flat_ctor",
  "constType":
  "(Q : Type) → [alphabetQ : CellularAutomatas.Alphabet Q] → (Q → Q → Q → Q) → CellularAutomatas.CellAutomaton",
  "constCategory": "Definition"},
 {"references":
  ["Prod.casesOn",
   "Option.casesOn",
   "CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "CellularAutomatas.LcInRt.DiagonalShiftCA",
   "CellularAutomatas.CellAutomaton.Q",
   "Unit.unit",
   "Unit"],
  "name": "CellularAutomatas.LcInRt.AdvCALc.match_1",
  "constType":
  "{α : Type} →\n  [inst : CellularAutomatas.Alphabet α] →\n    {Γ : Type} →\n      [inst_1 : CellularAutomatas.Alphabet Γ] →\n        let __LCellAutomaton := CellularAutomatas.LcInRt.DiagonalShiftCA (α ⨉ Γ);\n        (motive : __LCellAutomaton.Q → Sort u_1) →\n          (q : __LCellAutomaton.Q) → ((fst : α) → (g : Γ) → motive (some (fst, g))) → (Unit → motive none) → motive q",
  "constCategory": "Definition"},
 {"references":
  ["HAdd.hAdd",
   "SizeOf.sizeOf",
   "CellularAutomatas.simulation.Params.C_ctl",
   "CellularAutomatas.CellAutomaton.Q",
   "OfNat.ofNat"],
  "name": "CellularAutomatas.simulation.Q1._sizeOf_1",
  "constType":
  "{e : CellularAutomatas.simulation.Params} → CellularAutomatas.simulation.Q1 e → ℕ",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Lean.Grind.Semiring.pow_zero",
  "constType": "∀ {α : Type u} [self : Grind.Semiring α] (a : α), a ^ 0 = 1",
  "constCategory": "Theorem"},
 {"references": ["Unit", "Std.TreeMap.empty"],
  "name": "Std.TreeSet.empty",
  "constType": "{α : Type u} → {cmp : α → α → Ordering} → TreeSet α cmp",
  "constCategory": "Definition"},
 {"references": ["Set", "CellularAutomatas.tCellAutomatons"],
  "name": "CellularAutomatas.tCellAutomatons.eq_1",
  "constType": "∀ (α : Type), CellularAutomatas.tCellAutomatons α = Set.univ",
  "constCategory": "Theorem"},
 {"references": ["Int.Linear.Expr.norm", "Int.Linear.Poly.beq'"],
  "name": "Int.Linear.norm_eq_cert",
  "constType": "Int.Linear.Expr → Int.Linear.Expr → Int.Linear.Poly → Bool",
  "constCategory": "Definition"},
 {"references":
  ["CellularAutomatas.Word.get'",
   "Eq.trans",
   "CellularAutomatas.backwards_fsm.Params.inst3",
   "Membership.mem",
   "eq_true",
   "eagerReduce",
   "CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "NatCast.natCast",
   "Eq.symm",
   "CellularAutomatas.Word.range",
   "CellularAutomatas.backwards_fsm.Params.α",
   "CellularAutomatas.CArtTransducer.toLCellAutomaton",
   "List.drop",
   "CellularAutomatas.backwards_fsm.Params.β",
   "CellularAutomatas.backwards_fsm.Params.M",
   "CellularAutomatas.FiniteStateTransducer.scanr",
   "Prod.snd",
   "CellularAutomatas.backwards_fsm.Params.inst2",
   "add_zero",
   "Lean.Grind.nestedProof",
   "Prod.mk.inj",
   "eq_false",
   "Classical.byContradiction",
   "id",
   "CellularAutomatas.backwards_fsm.inv._proof_1_2",
   "Int.toNat",
   "Nat.cast",
   "CellularAutomatas.backwards_fsm.C'",
   "CellularAutomatas.backwards_fsm.Params.C",
   "Eq.mp",
   "CellularAutomatas.FiniteStateTransducer.Q",
   "CellularAutomatas.FiniteStateTransducer.scanr_reduce",
   "CellularAutomatas.backwards_fsm.Params.γ",
   "Int.Linear.Expr.eq_of_norm_eq",
   "Lean.Grind.dite_cond_eq_false'",
   "Prod.fst",
   "CellularAutomatas.LCellAutomaton.embed",
   "congrArg",
   "Lean.Grind.nestedDecidable",
   "congr",
   "CellularAutomatas.LCellAutomaton.embed_word",
   "Lean.Grind.dite_cond_eq_true'",
   "CellularAutomatas.CellAutomaton.Q",
   "CellularAutomatas.LCellAutomaton.border",
   "Not",
   "CellularAutomatas.Word",
   "Lean.Grind.em",
   "Lean.Grind.alreadyNorm",
   "Set",
   "OfNat.ofNat",
   "Eq.mpr_prop",
   "Or.casesOn",
   "HAdd.hAdd",
   "eq_self",
   "True.casesOn",
   "CharP.cast_eq_zero",
   "Lean.Grind.intro_with_eq",
   "Lean.Grind.Semiring.natCast",
   "dite",
   "Lean.Grind.Semiring.natCast_eq_ofNat",
   "CellularAutomatas.FiniteStateTransducer.f"],
  "name": "CellularAutomatas.backwards_fsm.inv._proof_1_3",
  "constType":
  "∀ (e : CellularAutomatas.backwards_fsm.Params) (w : CellularAutomatas.Word e.α) (p : ℤ),\n  (CellularAutomatas.backwards_fsm.C' e).embed_word w p = (CellularAutomatas.backwards_fsm.C' e).embed_word w p →\n    e.C.embed_word (e.M.scanr w) p = e.C.embed_word (e.M.scanr w) p →\n      e.M.scanr_reduce w⟦(p + ↑0).toNat..*⟧ = e.M.scanr_reduce w⟦(p + ↑0).toNat..*⟧ →\n        (if h : p ∈ w.range then (some (w.get' p ⋯), fun q => e.C.embed (e.M.f q)) else (none, fun x => e.C.border)).1 =\n          if h : p ∈ w.range then some (w.get' p ⋯) else none",
  "constCategory": "Theorem"},
 {"references":
  ["LE.le",
   "_private.Init.Prelude.0.Nat.not_succ_le_zero.match_1_5",
   "_private.Init.Prelude.0.Nat.not_succ_le_zero.match_1_3",
   "_private.Init.Prelude.0.Nat.not_succ_le_zero.match_1_1",
   "OfNat.ofNat",
   "Unit"],
  "name": "Nat.not_succ_le_zero",
  "constType": "∀ (n : ℕ), n.succ ≤ 0 → False",
  "constCategory": "Theorem"},
 {"references":
  ["Or.elim",
   "Lean.Omega.LinearCombo.coordinate_eval_2",
   "Nat.cast",
   "Eq.trans",
   "le_of_le_of_eq",
   "Lean.Omega.LinearCombo.coordinate_eval_3",
   "Lean.Omega.LinearCombo.coordinate_eval_0",
   "Lean.Omega.Constraint.combine_sat'",
   "Int.sub_eq_zero_of_eq",
   "GT.gt",
   "Decidable.decide",
   "Lean.Omega.Int.ofNat_le_of_le",
   "Nat.lt_or_gt_of_ne",
   "Lean.Omega.Coeffs.ofList",
   "Lean.Omega.Int.ofNat_sub_dichotomy",
   "Lean.Omega.tidy_sat",
   "HSub.hSub",
   "Eq.symm",
   "Lean.Omega.LinearCombo.add_eval",
   "Int.add_one_le_of_lt",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "And.left",
   "of_decide_eq_true",
   "Not",
   "Lean.Omega.combo_sat'",
   "Neg.neg",
   "And.right",
   "Lean.Omega.Constraint.addInequality_sat",
   "Lean.Omega.Int.add_congr",
   "Lean.Omega.Constraint.isImpossible",
   "Lean.Omega.LinearCombo.coordinate",
   "Int.sub_nonneg_of_le",
   "OfNat.ofNat",
   "Lean.Omega.LinearCombo.coordinate_eval_1",
   "LT.lt",
   "HAdd.hAdd",
   "Lean.Omega.Int.ofNat_lt_of_lt",
   "Lean.Omega.LinearCombo.sub_eval",
   "LE.le",
   "Int.natCast_add",
   "id",
   "Lean.Omega.Constraint.addEquality_sat",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.Int.sub_congr",
   "List.length"],
  "name": "_private.Init.Data.List.Nat.TakeDrop.0.List.take_append._proof_1_1",
  "constType":
  "∀ {α : Type u_1} (tail : List α) (n : ℕ), ¬n - tail.length = n + 1 - (tail.length + 1) → False",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.Advice.f",
   "CellularAutomatas.Word",
   "CellularAutomatas.Advice.ext.match_1",
   "Eq.symm",
   "Eq.ndrec",
   "Eq.casesOn",
   "List.length"],
  "name": "CellularAutomatas.Advice.ext",
  "constType":
  "∀ {α Γ : Type} {x y : CellularAutomatas.Advice α Γ}, x.f = y.f → x = y",
  "constCategory": "Theorem"},
 {"references": ["CellularAutomatas.tCellAutomatonWithAdvice._sizeOf_1"],
  "name": "CellularAutomatas.tCellAutomatonWithAdvice._sizeOf_inst",
  "constType":
  "(α : Type) → [SizeOf α] → SizeOf (CellularAutomatas.tCellAutomatonWithAdvice α)",
  "constCategory": "Definition"},
 {"references": ["CellularAutomatas.TwoStageAdvice.noConfusion", "id"],
  "name": "CellularAutomatas.TwoStageAdvice.mk.noConfusion",
  "constType":
  "{α Γ : Type} →\n  [inst : CellularAutomatas.Alphabet α] →\n    [inst_1 : CellularAutomatas.Alphabet Γ] →\n      (P : Sort u) →\n        (β : Type) →\n          [alphabetβ : CellularAutomatas.Alphabet β] →\n            (C : CellularAutomatas.CArtTransducer α β) →\n              (M : CellularAutomatas.FiniteStateTransducer β Γ) →\n                (β' : Type) →\n                  (alphabetβ' : CellularAutomatas.Alphabet β') →\n                    (C' : CellularAutomatas.CArtTransducer α β') →\n                      (M' : CellularAutomatas.FiniteStateTransducer β' Γ) →\n                        { β := β, alphabetβ := alphabetβ, C := C, M := M } =\n                            { β := β', alphabetβ := alphabetβ', C := C', M := M' } →\n                          (β = β' → alphabetβ ≍ alphabetβ' → C ≍ C' → M ≍ M' → P) → P",
  "constCategory": "Definition"},
 {"references": [],
  "name": "MulOneClass.mul_one",
  "constType": "∀ {M : Type u} [self : MulOneClass M] (a : M), a * 1 = a",
  "constCategory": "Theorem"},
 {"references":
  ["Int.add",
   "Nat.blt",
   "Int.mul",
   "Int.Linear.Poly.mul",
   "Int.Linear.Poly.append",
   "Nat.beq",
   "Int.beq'",
   "OfNat.ofNat",
   "Int.Linear.Var"],
  "name": "Int.Linear.Poly.combine_mul_k'",
  "constType":
  "ℕ → ℤ → ℤ → Int.Linear.Poly → Int.Linear.Poly → Int.Linear.Poly",
  "constCategory": "Definition"},
 {"references": ["Membership.mem", "SetLike.ext"],
  "name": "Finset.ext",
  "constType":
  "∀ {α : Type u_1} {s₁ s₂ : Finset α}, (∀ (a : α), a ∈ s₁ ↔ a ∈ s₂) → s₁ = s₂",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "Lean.Grind.CommRing.norm_cnstr_cert",
   "Eq.trans",
   "Eq.mp",
   "congrArg",
   "Lean.Grind.CommRing.Expr.toPoly_k_eq_toPoly",
   "congr",
   "Lean.Grind.CommRing.Poly.denote",
   "HSub.hSub",
   "Eq.symm",
   "Lean.Grind.CommRing.Poly.beq'",
   "propext",
   "Lean.Grind.CommRing.Expr.toPoly_k",
   "Lean.Grind.CommRing.Poly.beq'_eq",
   "Lean.Grind.CommRing.Expr.denote",
   "eq_iff_iff._simp_1",
   "Iff.rfl",
   "OfNat.ofNat",
   "LE.le",
   "id",
   "Eq.mpr",
   "Lean.Grind.CommRing.Expr.denote_toPoly",
   "Lean.Grind.OrderedAdd.sub_nonneg_iff",
   "Lean.Grind.CommRing.Context",
   "Lean.Grind.CommRing.Expr.toPoly"],
  "name": "Lean.Grind.CommRing.le_norm_expr",
  "constType":
  "∀ {α : Type u_1} [inst : Grind.CommRing α] [inst_1 : LE α] [inst_2 : LT α] [inst_3 : Std.IsPreorder α]\n  [Grind.OrderedRing α] (ctx : Grind.CommRing.Context α) (lhs rhs lhs' rhs' : Grind.CommRing.Expr),\n  Grind.CommRing.norm_cnstr_cert lhs rhs lhs' rhs' = true →\n    (Grind.CommRing.Expr.denote ctx lhs ≤ Grind.CommRing.Expr.denote ctx rhs) =\n      (Grind.CommRing.Expr.denote ctx lhs' ≤ Grind.CommRing.Expr.denote ctx rhs')",
  "constCategory": "Theorem"},
 {"references": ["List.filter", "List.mem_filter", "Membership.mem", "propext"],
  "name": "List.mem_filter._simp_1",
  "constType":
  "∀ {α : Type u_1} {p : α → Bool} {as : List α} {x : α}, (x ∈ List.filter p as) = (x ∈ as ∧ p x = true)",
  "constCategory": "Theorem"},
 {"references": ["Lean.Grind.AC.Seq.below", "Lean.Grind.AC.Seq.brecOn.go"],
  "name": "Lean.Grind.AC.Seq.brecOn",
  "constType":
  "{motive : Grind.AC.Seq → Sort u} →\n  (t : Grind.AC.Seq) → ((t : Grind.AC.Seq) → Grind.AC.Seq.below t → motive t) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "Nat.iterate",
   "Eq.trans",
   "of_eq_true",
   "Function.iterate_one",
   "CellularAutomatas.CellAutomaton.next",
   "CellularAutomatas.CellAutomaton.Q",
   "CellularAutomatas.Config",
   "OfNat.ofNat",
   "congrArg"],
  "name": "CellularAutomatas.nextt1",
  "constType":
  "∀ (C : CellularAutomatas.CellAutomaton) (c : CellularAutomatas.Config C.Q), C.nextt c 1 = C.next c",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd", "LT.lt", "Int.add_lt_add_right", "Int.lt_of_add_lt_add_right"],
  "name": "Int.add_lt_add_iff_right",
  "constType": "∀ {a b : ℤ} (c : ℤ), a + c < b + c ↔ a < b",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "ToString.toString",
  "constType": "{α : Type u} → [self : ToString α] → α → String",
  "constCategory": "Definition"},
 {"references": ["id", "Decidable.decide", "of_decide_eq_true"],
  "name": "Bool.coe_iff_coe",
  "constType": "∀ {a b : Bool}, (a = true ↔ b = true) ↔ a = b",
  "constCategory": "Theorem"},
 {"references": ["Nat.blt"],
  "name": "Int.blt'",
  "constType": "ℤ → ℤ → Bool",
  "constCategory": "Definition"},
 {"references":
  ["Eq.trans",
   "Lean.Grind.Order.eq_trans_false",
   "Lean.Grind.Order.of_nat_eq",
   "HMul.hMul",
   "eagerReduce",
   "eq_true",
   "ite_cond_eq_true",
   "IntCast.intCast",
   "Lean.Grind.Order.le_of_offset_eq_2_k",
   "Nat.ToInt.natCast_ofNat",
   "Lean.Grind.Order.int_lt",
   "NatCast.natCast",
   "Eq.symm",
   "HSub.hSub",
   "CellularAutomatas.PrefixStableProof.getLastOfTake._proof_1_20",
   "of_eq_false",
   "List.drop",
   "Neg.neg",
   "Lean.Grind.Order.le_of_eq_2_k",
   "Lean.Grind.Order.le_of_offset_eq_1_k",
   "id",
   "Lean.Grind.Order.le_trans_k",
   "Lean.Grind.Order.le_eq_false_of_le_k",
   "Lean.Grind.Order.eq_trans_true",
   "List.length",
   "Int.Linear.norm_le",
   "Int.Linear.natCast_sub",
   "Eq.mp",
   "Lean.Grind.Order.le_of_eq_1_k",
   "Int.Linear.Expr.eq_of_norm_eq",
   "List.length_take",
   "min_def",
   "congrArg",
   "Lean.Grind.nestedDecidable",
   "Lean.Grind.Order.eq_of_le_of_le_0",
   "Lean.Grind.Order.lt_of_not_le_k",
   "Not",
   "ite",
   "Lean.Grind.Order.eq_trans_true'",
   "Lean.Grind.Order.le_eq_true_of_le_k",
   "Nat.ToInt.add_congr",
   "Lean.Grind.Order.eq_mp_not",
   "OfNat.ofNat",
   "ite_congr",
   "HAdd.hAdd",
   "Nat.ToInt.le_eq",
   "of_eq_true",
   "Lean.Grind.CommRing.Expr.eq_of_toPoly_eq",
   "Min.min",
   "List.take",
   "LE.le",
   "Lean.Grind.Semiring.natCast",
   "Lean.Grind.CommRing.le_norm_expr",
   "Lean.Grind.Semiring.natCast_eq_ofNat",
   "Lean.Grind.Order.eq_mp"],
  "name": "CellularAutomatas.PrefixStableProof.getLastOfTake._proof_1_26",
  "constType":
  "∀ {i : ℕ} {α : Type u_1} {w : List α},\n  i + 1 ≤ w.length →\n    -1 * ↑(List.take 1 w⟦i..*⟧).length + 1 ≤ 0 →\n      ¬-1 * ↑(List.take i w).length + 1 ≤ 0 →\n        -1 * ↑(List.take (i + 1) w).length + 1 ≤ 0 →\n          (List.take (i + 1) w).length - ((List.take i w).length + 1) < (List.take 1 w⟦i..*⟧).length",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans",
   "Lean.Omega.IntList.get",
   "Lean.Omega.LinearCombo.coordinate",
   "OfNat.ofNat",
   "congrArg",
   "HAdd.hAdd",
   "eq_self",
   "Lean.Omega.LinearCombo.coordinate_eval",
   "of_eq_true",
   "Lean.Omega.Coeffs.ofList",
   "Lean.Omega.IntList.get_cons_succ",
   "Lean.Omega.Coeffs.get",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.IntList.get_cons_zero"],
  "name": "Lean.Omega.LinearCombo.coordinate_eval_4",
  "constType":
  "∀ {a0 a1 a2 a3 a4 : ℤ} {t : List ℤ},\n  (Omega.LinearCombo.coordinate 4).eval (Omega.Coeffs.ofList (a0 :: a1 :: a2 :: a3 :: a4 :: t)) = a4",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Omega.LinearCombo.coordinate_eval_2",
   "Nat.cast",
   "Eq.trans",
   "le_of_le_of_eq",
   "Lean.Omega.LinearCombo.coordinate_eval_0",
   "Lean.Omega.Constraint.combine_sat'",
   "Int.sub_eq_zero_of_eq",
   "Decidable.decide",
   "GE.ge",
   "Lean.Omega.LinearCombo.neg_eval",
   "Lean.Omega.Coeffs.ofList",
   "HSub.hSub",
   "Lean.Omega.tidy_sat",
   "Eq.symm",
   "Lean.Omega.LinearCombo.add_eval",
   "Int.add_one_le_of_lt",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "Lean.Omega.Int.neg_congr",
   "of_decide_eq_true",
   "Not",
   "Lean.Omega.combo_sat'",
   "Neg.neg",
   "Lean.Omega.Constraint.addInequality_sat",
   "Lean.Omega.Int.add_congr",
   "Lean.Omega.Constraint.isImpossible",
   "Lean.Omega.LinearCombo.coordinate",
   "Int.sub_nonneg_of_le",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "Lean.Omega.LinearCombo.coordinate_eval_1",
   "Lean.Omega.Int.ofNat_lt_of_lt",
   "Lean.Omega.LinearCombo.sub_eval",
   "Nat.lt_of_not_le",
   "Int.natCast_add",
   "id",
   "Lean.Omega.Constraint.addEquality_sat",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.Int.sub_congr"],
  "name":
  "_private.Init.Grind.Ring.Basic.0.Lean.Grind.Ring.intCast_add._proof_1_5",
  "constType":
  "∀ (x y : ℕ), ¬x ≥ y + 1 → ↑x + -↑(y + 1) = -↑(y + 1 - x) → ¬y + 1 ≥ x → False",
  "constCategory": "Theorem"},
 {"references": ["Quotient.mk'"],
  "name": "Cardinal.mk",
  "constType": "Type u → Cardinal.{u}",
  "constCategory": "Definition"},
 {"references":
  ["Eq.propIntro",
   "eq_of_heq",
   "Eq.symm",
   "Eq.ndrec",
   "Eq.casesOn",
   "HEq.casesOn",
   "CellularAutomatas.FiniteStateTransducer.mk.noConfusion",
   "And.casesOn"],
  "name": "CellularAutomatas.FiniteStateTransducer.mk.injEq",
  "constType":
  "∀ {α β : Type} (Q : Type) [alphabetQ : CellularAutomatas.Alphabet Q] (δ : Q → α → Q) (q0 : Q) (f : Q → β) (Q_1 : Type)\n  (alphabetQ_1 : CellularAutomatas.Alphabet Q_1) (δ_1 : Q_1 → α → Q_1) (q0_1 : Q_1) (f_1 : Q_1 → β),\n  ({ Q := Q, alphabetQ := alphabetQ, δ := δ, q0 := q0, f := f } =\n      { Q := Q_1, alphabetQ := alphabetQ_1, δ := δ_1, q0 := q0_1, f := f_1 }) =\n    (Q = Q_1 ∧ alphabetQ ≍ alphabetQ_1 ∧ δ ≍ δ_1 ∧ q0 ≍ q0_1 ∧ f ≍ f_1)",
  "constCategory": "Theorem"},
 {"references": ["outParam"],
  "name": "HDiv.hDiv",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → [self : HDiv α β γ] → α → β → γ",
  "constCategory": "Definition"},
 {"references": ["HasSubset.Subset", "Set", "Membership.mem"],
  "name": "Set.Subset.trans",
  "constType": "∀ {α : Type u} {a b c : Set α}, a ⊆ b → b ⊆ c → a ⊆ c",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CellularAutomatas.tCellAutomatonWithAdvice.ctorIdx",
  "constType": "{α : Type} → CellularAutomatas.tCellAutomatonWithAdvice α → ℕ",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Fin.val",
  "constType": "{n : ℕ} → Fin n → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "List.below",
   "Eq.trans",
   "of_eq_true",
   "congr",
   "List.take",
   "List.brecOn",
   "List.map",
   "_private.Init.Data.List.TakeDrop.0.List.map_take.match_1_1",
   "List.take_nil",
   "congrArg"],
  "name": "List.map_take",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {f : α → β} {l : List α} {i : ℕ},\n  List.map f (List.take i l) = List.take i (List.map f l)",
  "constCategory": "Theorem"},
 {"references":
  ["_private.Init.Data.List.Nat.Range.0.List.mem_range._simp_1_1",
   "List.range'",
   "Eq.trans",
   "Nat.zero_add",
   "Membership.mem",
   "List.range_eq_range'",
   "true_and",
   "OfNat.ofNat",
   "List.mem_range'_1._simp_1",
   "congrArg",
   "List.range",
   "LT.lt",
   "HAdd.hAdd",
   "iff_self",
   "of_eq_true",
   "congr",
   "LE.le"],
  "name": "List.mem_range",
  "constType": "∀ {m n : ℕ}, m ∈ List.range n ↔ m < n",
  "constCategory": "Theorem"},
 {"references": ["CellularAutomatas.Word", "List.map", "Prod.fst"],
  "name": "CellularAutomatas.Word.fst",
  "constType":
  "{α β : Type} → CellularAutomatas.Word (α ⨉ β) → CellularAutomatas.Word α",
  "constCategory": "Definition"},
 {"references":
  ["Lean.SourceInfo.fromRef", "Bind.bind", "Lean.MonadRef.getRef", "Pure.pure"],
  "name": "Lean.MonadRef.mkInfoFromRefPos",
  "constType": "{m : Type → Type} → [Monad m] → [MonadRef m] → m SourceInfo",
  "constCategory": "Definition"},
 {"references":
  ["HMod.hMod",
   "Nat.mod_zero",
   "_private.Init.Data.Int.DivMod.Bootstrap.0.Int.emod_zero.match_1_1",
   "Int.natAbs",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Int.emod_zero",
  "constType": "∀ (a : ℤ), a % 0 = a",
  "constCategory": "Theorem"},
 {"references": ["NegZeroClass.neg_zero"],
  "name": "neg_zero",
  "constType": "∀ {G : Type u_1} [inst : NegZeroClass G], -0 = 0",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CellularAutomatas.composition.Params.mk",
  "constType":
  "(α β : Type) →\n  [_inst_α : CellularAutomatas.Alphabet α] →\n    [_inst_β : CellularAutomatas.Alphabet β] →\n      (C : CellularAutomatas.LCellAutomaton β) →\n        (C_adv : CellularAutomatas.CArtTransducer α β) → (C_adv.Q → Option C.Q) → CellularAutomatas.composition.Params",
  "constCategory": "Other"},
 {"references":
  ["Ne", "Nat.ne_of_beq_eq_false", "OfNat.ofNat", "Lean.ConstantInfo.ctorIdx"],
  "name": "CellularAutomatas.collectAxiomsFromEnv.visit._sparseCasesOn_3",
  "constType":
  "{motive : ConstantInfo → Sort u} →\n  (t : ConstantInfo) → ((val : AxiomVal) → motive (ConstantInfo.axiomInfo val)) → (t.ctorIdx ≠ 0 → motive t) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["HAppend.hAppend",
   "eq_self",
   "List.append_assoc",
   "List.append_nil",
   "Eq.trans",
   "of_eq_true",
   "List.reverse_cons",
   "congr",
   "List.reverse",
   "congrArg"],
  "name": "List.reverse_append",
  "constType":
  "∀ {α : Type u_1} {as bs : List α}, (as ++ bs).reverse = bs.reverse ++ as.reverse",
  "constCategory": "Theorem"},
 {"references": ["Bool.casesOn", "Unit.unit", "Unit"],
  "name": "cond.match_1",
  "constType":
  "(motive : Bool → Sort u_1) → (c : Bool) → (Unit → motive true) → (Unit → motive false) → motive c",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "Eq.trans",
   "of_eq_true",
   "Eq.mp",
   "id",
   "iff_true",
   "eq_true",
   "eq_iff_iff._simp_1",
   "congrArg"],
  "name": "Lean.Grind.eq_true_of_and_eq_true_right",
  "constType": "∀ {a b : Prop}, (a ∧ b) = True → b = True",
  "constCategory": "Theorem"},
 {"references": ["List.below", "List.brecOn", "List.length.match_1", "Unit"],
  "name": "List.map",
  "constType": "{α : Type u_1} → {β : Type u_2} → (α → β) → List α → List β",
  "constCategory": "Definition"},
 {"references": ["Int.Linear.Var"],
  "name": "Int.Linear.Poly.casesOn",
  "constType":
  "{motive : Int.Linear.Poly → Sort u} →\n  (t : Int.Linear.Poly) →\n    ((k : ℤ) → motive (Int.Linear.Poly.num k)) →\n      ((k : ℤ) → (v : Int.Linear.Var) → (p : Int.Linear.Poly) → motive (Int.Linear.Poly.add k v p)) → motive t",
  "constCategory": "Definition"},
 {"references": ["List.reverseAux.match_1", "List.below", "List.brecOn"],
  "name": "List.reverseAux",
  "constType": "{α : Type u} → List α → List α → List α",
  "constCategory": "Definition"},
 {"references":
  ["Eq.symm", "HMul.hMul", "Int.casesOn", "Eq.ndrec", "OfNat.ofNat"],
  "name": "Int.mul_zero",
  "constType": "∀ (a : ℤ), a * 0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["HMod.hMod",
   "Nat.cast",
   "Neg.neg",
   "Int.negSucc_eq",
   "HMul.hMul",
   "OfNat.ofNat",
   "congrArg",
   "Nat.mod_add_div",
   "HAdd.hAdd",
   "HDiv.hDiv",
   "Int.natCast_emod",
   "Int.add_right_comm",
   "Int.sub_sub_self",
   "Int.sub_sub",
   "HSub.hSub",
   "id",
   "Eq.symm",
   "Int.neg_neg",
   "Eq.mpr",
   "Int.natCast_ediv",
   "Int.neg_sub"],
  "name": "_private.Init.Data.Int.DivMod.Bootstrap.0.Int.emod_add_mul_ediv.aux",
  "constType":
  "∀ (m n : ℕ), ↑n - (↑m % ↑n + 1) - (↑n * (↑m / ↑n) + ↑n) = Int.negSucc m",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt", "Not", "Nat.lt_or_ge", "LE.le", "Or.resolve_right", "GE.ge"],
  "name": "Nat.lt_of_not_le",
  "constType": "∀ {a b : ℕ}, ¬a ≤ b → b < a",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CellularAutomatas.VerificationError.mk",
  "constType":
  "Name → String → List String → CellularAutomatas.VerificationError",
  "constCategory": "Other"},
 {"references":
  ["Or.elim",
   "Nat.cast",
   "Eq.trans",
   "le_of_le_of_eq",
   "Classical.propDecidable",
   "Int.negSucc_eq",
   "Lean.Omega.LinearCombo.coordinate_eval_0",
   "Lean.Omega.Constraint.combine_sat'",
   "Decidable.decide",
   "Lean.Omega.Int.ofNat_le_of_le",
   "Lean.Omega.LinearCombo.neg_eval",
   "Lean.Omega.Coeffs.ofList",
   "Eq.symm",
   "Lean.Omega.tidy_sat",
   "HSub.hSub",
   "Lean.Omega.LinearCombo.add_eval",
   "Lean.Omega.Int.lt_of_not_le",
   "Lean.Omega.Int.neg_congr",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "Int.add_one_le_of_lt",
   "And.left",
   "of_decide_eq_true",
   "Not",
   "Neg.neg",
   "And.right",
   "Lean.Omega.Constraint.addInequality_sat",
   "Lean.Omega.Int.add_congr",
   "Lean.Omega.Constraint.isImpossible",
   "Lean.Omega.LinearCombo.coordinate",
   "OfNat.ofNat",
   "Int.sub_nonneg_of_le",
   "Lean.Omega.LinearCombo.coordinate_eval_1",
   "HAdd.hAdd",
   "Lean.Omega.Int.ofNat_lt_of_lt",
   "Lean.Omega.LinearCombo.sub_eval",
   "Nat.lt_of_not_le",
   "LE.le",
   "id",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.Int.sub_congr",
   "Lean.Omega.Decidable.and_not_or_not_and_of_not_iff"],
  "name": "_private.Init.Data.Int.LemmasAux.0.Int.ble'_eq_true._proof_1_4",
  "constType":
  "∀ (a a_1 : ℕ), ¬(a_1 ≤ a ↔ Int.negSucc a ≤ Int.negSucc a_1) → False",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "Eq.trans",
   "Eq.mp",
   "Lean.Grind.Semiring.add_assoc",
   "Int.blt'",
   "Int.cast",
   "congrArg",
   "Lean.Grind.Ring.intCast_add",
   "Lean.Grind.Semiring.add_zero",
   "Int.blt'_eq_true",
   "Eq.symm",
   "HSub.hSub",
   "Int.sub_eq_add_neg",
   "Lean.Grind.AddCommGroup.add_neg_cancel",
   "Lean.Grind.Semiring.add_comm",
   "Not",
   "Lean.Grind.Ring.intCast",
   "_private.Init.Grind.Order.0.Lean.Grind.Order.lt_eq_true_of_le_k._proof_1_1",
   "Lean.Grind.OrderedRing.pos_intCast_of_pos",
   "Neg.neg",
   "Lean.Grind.Ring.intCast_neg",
   "_private.Init.Grind.Order.0.Lean.Grind.Order.add_lt_add_of_le_of_lt",
   "iff_true",
   "eq_iff_iff._simp_1",
   "OfNat.ofNat",
   "LT.lt",
   "HAdd.hAdd",
   "Decidable.byContradiction",
   "Int.add_comm",
   "LE.le",
   "id",
   "Eq.mpr"],
  "name": "Lean.Grind.Order.lt_eq_true_of_le_k",
  "constType":
  "∀ {α : Type u_1} [inst : LE α] [inst_1 : LT α] [LawfulOrderLT α] [inst_3 : Std.IsPreorder α] [inst_4 : Grind.Ring α]\n  [Grind.OrderedRing α] {a b : α} {k₁ k₂ : ℤ}, k₁.blt' k₂ = true → a ≤ b + ↑k₁ → (a < b + ↑k₂) = True",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "Lean.Grind.AddCommGroup.sub_add_cancel",
   "Lean.Grind.OrderedAdd.add_le_left_iff",
   "Lean.Grind.AddCommMonoid.zero_add",
   "LE.le",
   "id",
   "HSub.hSub",
   "Eq.mpr",
   "Iff.rfl",
   "propext",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Lean.Grind.OrderedAdd.sub_nonneg_iff",
  "constType":
  "∀ {M : Type u} [inst : LE M] [inst_1 : Std.IsPreorder M] [inst_2 : Grind.AddCommGroup M] [Grind.OrderedAdd M] {a b : M},\n  0 ≤ a - b ↔ b ≤ a",
  "constCategory": "Theorem"},
 {"references": ["Nat.zero_add"],
  "name": "Nat.mul_one",
  "constType": "∀ (n : ℕ), n * 1 = n",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "CellularAutomatas.Word",
   "Int.toNat",
   "Nat.cast",
   "Set",
   "Eq.mp",
   "Membership.mem",
   "GE.ge",
   "OfNat.ofNat",
   "congrArg",
   "LT.lt",
   "Decidable.byContradiction",
   "CellularAutomatas.Word.get'._simp_2",
   "funext",
   "LE.le",
   "CellularAutomatas.Word.range",
   "CellularAutomatas.Word.get'._proof_3",
   "setOf",
   "List.length"],
  "name": "CellularAutomatas.Word.get'._proof_1",
  "constType":
  "∀ {α : Type u_1} (w : CellularAutomatas.Word α), ∀ i ∈ w.range, i.toNat < List.length w",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.CellAutomaton.δ",
   "Eq.trans",
   "Eq.mp",
   "Set",
   "Singleton.singleton",
   "CellularAutomatas.CellAutomaton.dead",
   "Membership.mem",
   "CellularAutomatas.CellAutomaton.quiescent_of_dead._simp_1_1",
   "CellularAutomatas.CellAutomaton.quiescent_of_dead._simp_1_3",
   "Subtype.val",
   "Set.Elem",
   "congrArg",
   "eq_self",
   "of_eq_true",
   "congr",
   "forall_congr",
   "CellularAutomatas.CellAutomaton.quiescent",
   "id",
   "CellularAutomatas.CellAutomaton.Q",
   "Subtype.casesOn",
   "forall_prop_domain_congr",
   "CellularAutomatas.CellAutomaton.quiescent_of_dead._simp_1_2"],
  "name": "CellularAutomatas.CellAutomaton.quiescent_of_dead",
  "constType":
  "∀ {C : CellularAutomatas.CellAutomaton} {q : C.Q}, C.dead q → C.quiescent q",
  "constCategory": "Theorem"},
 {"references": ["IO.RealWorld", "EST"],
  "name": "EIO",
  "constType": "Type → Type → Type",
  "constCategory": "Definition"},
 {"references": ["Eq.symm"],
  "name": "Eq.substr",
  "constType": "∀ {α : Sort u} {p : α → Prop} {a b : α}, b = a → p a → p b",
  "constCategory": "Theorem"},
 {"references":
  ["absurd",
   "LT.lt",
   "HSub.hSub",
   "Ne",
   "Nat.le_refl",
   "OfNat.ofNat",
   "_private.Init.Data.List.Lemmas.0.List.getLast_eq_getElem.match_1",
   "List.length"],
  "name": "List.getLast_eq_getElem._proof_3",
  "constType":
  "∀ {α : Type u_1} {l : List α}, l ≠ [] → l.length - 1 < l.length",
  "constCategory": "Theorem"},
 {"references": ["Lean.Omega.tidy?", "Option.getD", "Lean.Omega.Coeffs"],
  "name": "Lean.Omega.tidy",
  "constType":
  "Omega.Constraint ⨉ Omega.Coeffs → Omega.Constraint ⨉ Omega.Coeffs",
  "constCategory": "Definition"},
 {"references": ["and_imp", "propext"],
  "name": "and_imp._simp_1",
  "constType": "∀ {a b c : Prop}, (a ∧ b → c) = (a → b → c)",
  "constCategory": "Theorem"},
 {"references": ["Not", "Decidable.casesOn"],
  "name": "_private.Init.Core.0.Decidable.not_and_iff_or_not.match_1_1",
  "constType":
  "∀ {p q : Prop} (motive : Decidable p → Decidable q → Prop) (d₁ : Decidable p) (d₂ : Decidable q),\n  (∀ (h₁ : p) (h₂ : q), motive (isTrue h₁) (isTrue h₂)) →\n    (∀ (x : Decidable p) (h₂ : ¬q), motive x (isFalse h₂)) →\n      (∀ (h₁ : ¬p) (x : Decidable q), motive (isFalse h₁) x) → motive d₁ d₂",
  "constCategory": "Definition"},
 {"references":
  ["CellularAutomatas.FiniteStateTransducer.δ?",
   "CellularAutomatas.FiniteStateTransducer.Q"],
  "name": "CellularAutomatas.FiniteStateTransducer.δ?.eq_1",
  "constType":
  "∀ {α β : Type} (M : CellularAutomatas.FiniteStateTransducer α β) (x : M.Q), M.δ? x none = x",
  "constCategory": "Theorem"},
 {"references": ["HAdd.hAdd", "SizeOf.sizeOf", "OfNat.ofNat"],
  "name": "CellularAutomatas.CellAutomaton.mk.sizeOf_spec",
  "constType":
  "∀ (Q : Type) [alphabetQ : CellularAutomatas.Alphabet Q] (δ : Q → Q → Q → Q),\n  sizeOf { Q := Q, alphabetQ := alphabetQ, δ := δ } = 1 + sizeOf Q + sizeOf alphabetQ",
  "constCategory": "Theorem"},
 {"references":
  ["sorryAx",
   "CellularAutomatas.Advice.exp_middle",
   "OfNat.ofNat",
   "CellularAutomatas.Advice.rt_closed"],
  "name": "CellularAutomatas.results_unproven.advice_exp_middle_rt_closed",
  "constType":
  "∀ {α : Type} [inst : CellularAutomatas.Alphabet α], (CellularAutomatas.Advice.exp_middle α).rt_closed",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.Word", "CellularAutomatas.FiniteStateTransducer.scanr"],
  "name": "CellularAutomatas.FiniteStateTransducer.scanr.eq_1",
  "constType":
  "∀ {α β : Type} (M : CellularAutomatas.FiniteStateTransducer α β) (w : CellularAutomatas.Word α),\n  M.scanr w = M.scanr_q M.q0 w",
  "constCategory": "Theorem"},
 {"references":
  ["Classical.choose_spec",
   "Set",
   "CellularAutomatas.L_c",
   "Membership.mem",
   "And.right",
   "CellularAutomatas.CA_rt",
   "CellularAutomatas.L_c_in_rt",
   "CellularAutomatas.tCellAutomaton.L",
   "Language",
   "Classical.choose",
   "CellularAutomatas.Advice.rt_closed"],
  "name": "CellularAutomatas.CALc_spec_2",
  "constType":
  "∀ {α : Type} [inst : CellularAutomatas.Alphabet α] {Γ : Type} [inst_1 : CellularAutomatas.Alphabet Γ]\n  (adv : CellularAutomatas.Advice α Γ) (h : adv.rt_closed) (c : Γ),\n  (CellularAutomatas.CALc adv h c).L = CellularAutomatas.L_c adv c",
  "constCategory": "Theorem"},
 {"references": ["SetLike.coe", "Set", "Membership.mem", "Iff.rfl"],
  "name": "Finset.mem_coe",
  "constType": "∀ {α : Type u_1} {a : α} {s : Finset α}, a ∈ ↑s ↔ a ∈ s",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.Word",
   "Eq.trans",
   "CellularAutomatas.FiniteStateTransducer.scanr",
   "List.map",
   "Prod.snd",
   "true_and",
   "congrArg",
   "List.foldr",
   "Inhabited.default",
   "eq_self",
   "List.cons.injEq",
   "CellularAutomatas.FiniteStateTransducer.M_map",
   "funext",
   "CellularAutomatas.FiniteStateTransducer.scanr_step",
   "id",
   "Eq.mpr"],
  "name": "CellularAutomatas.FiniteStateTransducer.M_map_scanr",
  "constType":
  "∀ {α β : Type} [inst : CellularAutomatas.Alphabet α] [inst_1 : CellularAutomatas.Alphabet β] (f : α → β),\n  (CellularAutomatas.FiniteStateTransducer.M_map f).scanr = List.map f",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans",
   "eq_true",
   "CellularAutomatas.advice_len",
   "OfNat.ofNat",
   "congrArg",
   "Eq.mpr_prop",
   "HAdd.hAdd",
   "LT.lt",
   "CellularAutomatas.Advice.f",
   "Lean.Grind.Nat.lt_eq",
   "of_eq_true",
   "LE.le",
   "List.length"],
  "name": "CellularAutomatas.PrefixStableProof.f._proof_1_3",
  "constType":
  "∀ {α Γ : Type} (adv : CellularAutomatas.Advice α Γ) (w : List α) (i : ℕ), i + 1 ≤ w.length → i < List.length (adv.f w)",
  "constCategory": "Theorem"},
 {"references": ["Membership.mem", "Iff.rfl"],
  "name": "Lean.Grind.IntInterval.mem_ci",
  "constType": "∀ (lo x : ℤ), x ∈ Grind.IntInterval.ci lo ↔ lo ≤ x",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "HAdd.hAdd",
   "Lean.Grind.Nat.lt_eq",
   "Eq.substr",
   "List.drop",
   "List.take",
   "LE.le",
   "HSub.hSub",
   "OfNat.ofNat",
   "List.length"],
  "name": "CellularAutomatas.PrefixStableProof.getLastOfTake._proof_1_3",
  "constType":
  "∀ {i : ℕ} {α : Type u_1} {w : List α},\n  (List.take 1 w⟦i..*⟧).length - 1 + 1 ≤ (List.take 1 w⟦i..*⟧).length →\n    (List.take 1 w⟦i..*⟧).length - 1 < (List.take 1 w⟦i..*⟧).length",
  "constCategory": "Theorem"},
 {"references": ["Max.max", "List.foldl", "List.getLast?.match_1", "Unit"],
  "name": "List.max?",
  "constType": "{α : Type u} → [Max α] → List α → Option α",
  "constCategory": "Definition"},
 {"references": ["Lean.Grind.AC.Var"],
  "name": "Lean.Grind.AC.Expr.below",
  "constType":
  "{motive : Grind.AC.Expr → Sort u} → Grind.AC.Expr → Sort (max 1 u)",
  "constCategory": "Definition"},
 {"references": ["Nat.beq"],
  "name": "Int.beq'",
  "constType": "ℤ → ℤ → Bool",
  "constCategory": "Definition"},
 {"references":
  ["Option.ctorIdx",
   "_private.Lean.Environment.0.Lean.Kernel.Environment.Diagnostics.recordUnfold._sparseCasesOn_1",
   "Ne",
   "OfNat.ofNat"],
  "name": "_private.Lean.Environment.0.Lean.Environment.addDeclCore.match_5",
  "constType":
  "(motive : Option ConstantInfo → Sort u_1) →\n  (x : Option ConstantInfo) →\n    ((info : ConstantInfo) → motive (some info)) → ((x : Option ConstantInfo) → motive x) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["LE.le",
   "id",
   "Nat.zero_le",
   "Eq.mpr",
   "Decidable.decide",
   "Nat.le_antisymm",
   "OfNat.ofNat",
   "propext",
   "of_decide_eq_true",
   "congrArg"],
  "name": "Nat.le_zero_eq",
  "constType": "∀ (a : ℕ), (a ≤ 0) = (a = 0)",
  "constCategory": "Theorem"},
 {"references": ["LT.lt", "eq_false", "Nat.lt_irrefl"],
  "name": "Nat.lt_irrefl._simp_1",
  "constType": "∀ (n : ℕ), (n < n) = False",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.cast",
   "Eq.trans",
   "Nat.add_comm",
   "_private.Init.Data.Int.Lemmas.0.Int.add_assoc.aux2",
   "Nat.add_assoc",
   "OfNat.ofNat",
   "_private.Init.Data.Int.Lemmas.0.Int.add_assoc.match_1_1",
   "congrArg",
   "HAdd.hAdd",
   "eq_self",
   "of_eq_true",
   "congr",
   "Int.add_comm",
   "id",
   "Eq.symm",
   "_private.Init.Data.Int.Lemmas.0.Int.add_assoc.aux1",
   "Eq.mpr",
   "Nat.add_left_comm"],
  "name": "Int.add_assoc",
  "constType": "∀ (a b c : ℤ), a + b + c = a + (b + c)",
  "constCategory": "Theorem"},
 {"references": ["rfl", "Set", "Membership.mem", "setOf"],
  "name": "Set.mem_setOf_eq",
  "constType": "∀ {α : Type u} {x : α} {p : α → Prop}, (x ∈ {y | p y}) = p x",
  "constCategory": "Theorem"},
 {"references": ["Lean.Grind.CommRing.Poly.casesOn"],
  "name": "Lean.Grind.CommRing.Poly.denote.match_1",
  "constType":
  "(motive : Grind.CommRing.Poly → Sort u_1) →\n  (p : Grind.CommRing.Poly) →\n    ((k : ℤ) → motive (Grind.CommRing.Poly.num k)) →\n      ((k : ℤ) → (m : Grind.CommRing.Mon) → (p : Grind.CommRing.Poly) → motive (Grind.CommRing.Poly.add k m p)) →\n        motive p",
  "constCategory": "Definition"},
 {"references": ["Bool.not", "id", "Decidable.decide", "of_decide_eq_true"],
  "name": "Bool.not_true",
  "constType": "(!true) = false",
  "constCategory": "Theorem"},
 {"references": ["Int.le.intro", "Int.add_zero"],
  "name": "Int.le_refl",
  "constType": "∀ (a : ℤ), a ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "Lean.Grind.Semiring.ofNat_eq_natCast",
   "Nat.cast",
   "Lean.Grind.Semiring.ofNat_add",
   "Eq.symm",
   "id",
   "Eq.mpr",
   "Lean.Grind.Semiring.natCast",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Lean.Grind.Semiring.natCast_add",
  "constType":
  "∀ {α : Type u} [inst : Grind.Semiring α] (a b : ℕ), ↑(a + b) = ↑a + ↑b",
  "constCategory": "Theorem"},
 {"references": ["Nat.cast", "Int.ofNat_le", "LE.le", "propext"],
  "name": "_private.Init.Data.Int.OfNat.0.Nat.ToInt.le_eq._simp_1_1",
  "constType": "∀ {m n : ℕ}, (↑m ≤ ↑n) = (m ≤ n)",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "Int.toNat",
   "Nat.cast",
   "LE.le",
   "Int.toNat_lt",
   "propext",
   "OfNat.ofNat"],
  "name": "Int.toNat_lt._simp_1",
  "constType": "∀ {n : ℕ} {z : ℤ}, 0 ≤ z → (z.toNat < n) = (z < ↑n)",
  "constCategory": "Theorem"},
 {"references":
  ["Multiset.nodup_dedup", "DecidableEq", "Multiset.dedup", "Multiset"],
  "name": "Multiset.toFinset",
  "constType": "{α : Type u_1} → [DecidableEq α] → Multiset α → Finset α",
  "constCategory": "Definition"},
 {"references":
  ["HAdd.hAdd",
   "LT.lt",
   "List.range'",
   "LE.le",
   "Membership.mem",
   "List.mem_range'_1",
   "OfNat.ofNat",
   "propext"],
  "name": "List.mem_range'_1._simp_1",
  "constType": "∀ {s n m : ℕ}, (m ∈ List.range' s n) = (s ≤ m ∧ m < s + n)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CellularAutomatas.collectAxiomsFromEnv.visit",
  "constType": "Environment → Name → NameSet → NameSet → NameSet ⨉ NameSet",
  "constCategory": "Other"},
 {"references":
  ["implies_true",
   "eq_self",
   "Eq.trans",
   "of_eq_true",
   "congr",
   "Lean.Grind.AC.Expr.denote",
   "Lean.Grind.AC.Seq.denote",
   "implies_congr_ctx",
   "congrArg"],
  "name": "Lean.Grind.AC.imp_eq",
  "constType":
  "∀ {α : Sort u_1} (ctx : Grind.AC.Context α) (lhs rhs : Grind.AC.Expr) (s : Grind.AC.Seq),\n  Grind.AC.Expr.denote ctx lhs = Grind.AC.Seq.denote ctx s →\n    Grind.AC.Expr.denote ctx rhs = Grind.AC.Seq.denote ctx s →\n      Grind.AC.Expr.denote ctx lhs = Grind.AC.Expr.denote ctx rhs",
  "constCategory": "Theorem"},
 {"references": ["HAdd.hAdd", "SizeOf.sizeOf", "OfNat.ofNat"],
  "name": "CellularAutomatas.TwoStageAdvice._sizeOf_1",
  "constType":
  "{α Γ : Type} →\n  {inst : CellularAutomatas.Alphabet α} →\n    {inst_1 : CellularAutomatas.Alphabet Γ} → [SizeOf α] → [SizeOf Γ] → CellularAutomatas.TwoStageAdvice α Γ → ℕ",
  "constCategory": "Definition"},
 {"references": ["Membership.mem", "Lean.Omega.Coeffs", "OfNat.ofNat"],
  "name": "Lean.Omega.Coeffs.isZero",
  "constType": "Omega.Coeffs → Prop",
  "constCategory": "Definition"},
 {"references":
  ["HAdd.hAdd",
   "Int.Linear.Var.denote",
   "Int.Linear.Context",
   "Neg.neg",
   "HSub.hSub",
   "HMul.hMul",
   "Int.Linear.Expr.below",
   "Int.Linear.Expr.brecOn",
   "Int.Linear.Var",
   "Int.Linear.Expr.denote.match_1"],
  "name": "Int.Linear.Expr.denote",
  "constType": "Int.Linear.Context → Int.Linear.Expr → ℤ",
  "constCategory": "Definition"},
 {"references": [],
  "name": "True.casesOn",
  "constType":
  "{motive : True → Sort u} → (t : True) → motive True.intro → motive t",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "Lean.Omega.normalize?",
   "and_self",
   "Eq.trans",
   "of_eq_true",
   "congr",
   "Option.getD",
   "Lean.Omega.Coeffs",
   "Prod.snd",
   "congrArg",
   "Prod.fst"],
  "name": "Lean.Omega.normalize?_eq_some",
  "constType":
  "∀ {s : Omega.Constraint} {x : Omega.Coeffs} {s' : Omega.Constraint} {x' : Omega.Coeffs},\n  Omega.normalize? (s, x) = some (s', x') → Omega.normalizeConstraint s x = s' ∧ Omega.normalizeCoeffs s x = x'",
  "constCategory": "Theorem"},
 {"references":
  ["Set.univ",
   "StrictMono.strictMonoOn",
   "StrictMonoOn.lt_iff_lt",
   "trivial",
   "StrictMono"],
  "name": "StrictMono.lt_iff_lt",
  "constType":
  "∀ {α : Type u} {β : Type v} [inst : LinearOrder α] [inst_1 : Preorder β] {f : α → β},\n  StrictMono f → ∀ {a b : α}, f a < f b ↔ a < b",
  "constCategory": "Theorem"},
 {"references":
  ["Int.mul_add",
   "Eq.trans",
   "Eq.mp",
   "Int.mul_comm",
   "Int.zero_add",
   "Int.Linear.Poly.denote",
   "HMul.hMul",
   "Int.Linear.Expr.toPoly'.go",
   "congrArg",
   "Int.Linear.Var.denote",
   "Int.zero_mul",
   "congr",
   "Int.Linear.Expr.toPoly'.go.induct",
   "Int.mul_assoc",
   "Eq.symm",
   "HSub.hSub",
   "Int.neg_mul",
   "Int.sub_eq_add_neg",
   "Int.mul_neg",
   "Int.add_assoc",
   "Int.mul",
   "Neg.neg",
   "cond",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "Int.mul_zero",
   "Int.Linear.Poly.denote_addConst",
   "eq_self",
   "Int.Linear.Context",
   "of_eq_true",
   "Int.Linear.Expr.denote",
   "Int.add_comm",
   "_private.Init.Data.Int.Linear.0.Int.Linear.Expr.denote_toPoly'_go._simp_1_10",
   "id",
   "LawfulBEq.eq_of_beq",
   "Int.mul_sub",
   "Eq.mpr",
   "Int.Linear.Poly.addConst",
   "BEq.beq",
   "Int.Linear.Var"],
  "name": "Int.Linear.Expr.denote_toPoly'_go",
  "constType":
  "∀ {k : ℤ} {p : Int.Linear.Poly} (ctx : Int.Linear.Context) (e : Int.Linear.Expr),\n  Int.Linear.Poly.denote ctx (Int.Linear.Expr.toPoly'.go k e p) =\n    k * Int.Linear.Expr.denote ctx e + Int.Linear.Poly.denote ctx p",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.SyntaxNodeKind",
   "Array.getD",
   "_private.Init.Prelude.0.Lean.Syntax.setKind.match_1"],
  "name": "Lean.Syntax.getArg",
  "constType": "Syntax → ℕ → Syntax",
  "constCategory": "Definition"},
 {"references":
  ["Eq.trans",
   "true_or",
   "Membership.mem",
   "List.map",
   "eq_true",
   "or_true",
   "congrArg",
   "eq_self",
   "of_eq_true",
   "List.cons.injEq",
   "id",
   "Eq.mpr",
   "List.mem_cons._simp_1"],
  "name":
  "_private.CellularAutomatas.proofs.cart_transducers.0.CellularAutomatas.list_map_congr",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {f g : α → β} {l : List α}, (∀ x ∈ l, f x = g x) → List.map f l = List.map g l",
  "constCategory": "Theorem"},
 {"references": ["id", "iff_true_intro"],
  "name": "imp_self",
  "constType": "∀ {a : Prop}, a → a ↔ True",
  "constCategory": "Theorem"},
 {"references":
  ["Set.mem_singleton_iff",
   "Set",
   "Singleton.singleton",
   "Membership.mem",
   "propext"],
  "name": "Set.mem_singleton_iff._simp_1",
  "constType": "∀ {α : Type u} {a b : α}, (a ∈ {b}) = (a = b)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "SubtractionMonoid.neg_add_rev",
  "constType":
  "∀ {G : Type u} [self : SubtractionMonoid G] (a b : G), -(a + b) = -b + -a",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "Eq.symm",
   "id",
   "Nat.add_comm",
   "Eq.mpr",
   "Nat.add_assoc",
   "congrArg"],
  "name": "Nat.add_left_comm",
  "constType": "∀ (n m k : ℕ), n + (m + k) = m + (n + k)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CellularAutomatas.Alphabet.dec",
  "constType":
  "{α : Type} → [self : CellularAutomatas.Alphabet α] → DecidableEq α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Lean.AsyncConstantInfo.constInfo",
  "constType": "AsyncConstantInfo → Task ConstantInfo",
  "constCategory": "Definition"},
 {"references": ["LT.lt", "Not", "not_lt", "LE.le", "propext"],
  "name": "not_lt._simp_1",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrder α] {a b : α}, (¬a < b) = (b ≤ a)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CellularAutomatas.simulation.Q1.ctorIdx",
  "constType":
  "{e : CellularAutomatas.simulation.Params} → CellularAutomatas.simulation.Q1 e → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["CellularAutomatas.δδ",
   "CellularAutomatas.apply_iterated",
   "CellularAutomatas.CellAutomaton.Q"],
  "name": "CellularAutomatas.δδt",
  "constType": "{C : CellularAutomatas.CellAutomaton} → C.Q → ℕ → C.Q",
  "constCategory": "Definition"},
 {"references":
  ["HAdd.hAdd",
   "CellularAutomatas.CellAutomaton.δ",
   "HSub.hSub",
   "CellularAutomatas.CellAutomaton.Q",
   "CellularAutomatas.Config",
   "OfNat.ofNat"],
  "name": "CellularAutomatas.CellAutomaton.next",
  "constType":
  "(C : CellularAutomatas.CellAutomaton) → CellularAutomatas.Config C.Q → CellularAutomatas.Config C.Q",
  "constCategory": "Definition"},
 {"references":
  ["Nat.cast",
   "Eq.trans",
   "le_of_le_of_eq",
   "Int.negSucc_eq",
   "Lean.Omega.Constraint.combine_sat'",
   "Lean.Omega.LinearCombo.coordinate_eval_0",
   "Decidable.decide",
   "Lean.Omega.LinearCombo.neg_eval",
   "Lean.Omega.Coeffs.ofList",
   "Eq.symm",
   "Lean.Omega.tidy_sat",
   "Lean.Omega.LinearCombo.add_eval",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "Lean.Omega.Int.neg_congr",
   "of_decide_eq_true",
   "Neg.neg",
   "Lean.Omega.Constraint.addInequality_sat",
   "Lean.Omega.Int.add_congr",
   "Lean.Omega.Constraint.isImpossible",
   "Lean.Omega.LinearCombo.coordinate",
   "OfNat.ofNat",
   "Int.ofNat_nonneg",
   "HAdd.hAdd",
   "LE.le",
   "id",
   "Lean.Omega.LinearCombo.eval"],
  "name":
  "_private.Init.Grind.Ordered.Ring.0.Lean.Grind.OrderedRing.nonneg_intCast_of_nonneg._proof_1_1",
  "constType": "∀ (a : ℕ), 0 ≤ Int.negSucc a → False",
  "constCategory": "Theorem"},
 {"references": ["CellularAutomatas.backwards_fsm.M_join"],
  "name": "CellularAutomatas.backwards_fsm.M_join.eq_1",
  "constType":
  "∀ {γ α β : Type} [inst : CellularAutomatas.Alphabet γ] [inst_1 : CellularAutomatas.Alphabet α]\n  [inst_2 : CellularAutomatas.Alphabet β] (M : CellularAutomatas.FiniteStateTransducer α β),\n  CellularAutomatas.backwards_fsm.M_join M =\n    (CellularAutomatas.FiniteStateTransducer.M_map fun x =>\n        match x with\n        | (a, b) => a b) ⊚\n      (CellularAutomatas.FiniteStateTransducer.M_map Prod.snd).M_prod\n        (M ⊚ CellularAutomatas.FiniteStateTransducer.M_map Prod.fst)",
  "constCategory": "Theorem"},
 {"references": ["trivial", "propext"],
  "name": "eq_true",
  "constType": "∀ {p : Prop}, p → p = True",
  "constCategory": "Theorem"},
 {"references": ["CellularAutomatas.Word", "OfNat.ofNat", "List.length"],
  "name": "CellularAutomatas.Advice.mk.sizeOf_spec",
  "constType":
  "∀ {α Γ : Type} [inst : SizeOf α] [inst_1 : SizeOf Γ] (f : CellularAutomatas.Word α → CellularAutomatas.Word Γ)\n  (len : ∀ (w : CellularAutomatas.Word α), List.length (f w) = List.length w), sizeOf { f := f, len := len } = 1",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CellularAutomatas.Config",
  "constType": "Type u_1 → Type u_1",
  "constCategory": "Definition"},
 {"references":
  ["List.getLast._proof_2", "List.getLast", "List.getLast?.match_1", "Unit"],
  "name": "List.getLast?",
  "constType": "{α : Type u} → List α → Option α",
  "constCategory": "Definition"},
 {"references":
  ["rfl",
   "Nat.cast",
   "_private.Init.Data.Int.Order.0.Int.natAbs_neg.match_1_1",
   "Neg.neg",
   "Int.natAbs",
   "OfNat.ofNat",
   "Unit"],
  "name": "Int.natAbs_neg",
  "constType": "∀ (a : ℤ), (-a).natAbs = a.natAbs",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.simulation.Params.casesOn",
   "CellularAutomatas.CellAutomaton.Q",
   "CellularAutomatas.simulation.Params.noConfusionType",
   "Eq.ndrec"],
  "name": "CellularAutomatas.simulation.Params.noConfusion",
  "constType":
  "{P : Sort u} →\n  {x1 x2 : CellularAutomatas.simulation.Params} → x1 = x2 → CellularAutomatas.simulation.Params.noConfusionType P x1 x2",
  "constCategory": "Definition"},
 {"references": ["List.noConfusion"],
  "name": "List.getLast._proof_2",
  "constType":
  "∀ {α : Type u_1} (b : α) (as : List α), b :: as = [] → List.noConfusionType False (b :: as) []",
  "constCategory": "Theorem"},
 {"references": ["Nat.casesOn", "List.casesOn", "OfNat.ofNat"],
  "name": "_private.Init.Data.List.Nat.TakeDrop.0.List.length_take.match_1_1",
  "constType":
  "∀ {α : Type u_1} (motive : ℕ → List α → Prop) (x : ℕ) (x_1 : List α),\n  (∀ (l : List α), motive 0 l) →\n    (∀ (n : ℕ), motive n.succ []) → (∀ (n : ℕ) (head : α) (l : List α), motive n.succ (head :: l)) → motive x x_1",
  "constCategory": "Definition"},
 {"references": ["absurd", "False.elim", "List.casesOn", "Ne"],
  "name": "_private.Init.Data.List.Lemmas.0.List.getLast_eq_getElem.match_1_1",
  "constType":
  "∀ {α : Type u_1} (motive : (x : List α) → x ≠ [] → Prop) (x : List α) (x_1 : x ≠ []),\n  (∀ (head : α) (x : [head] ≠ []), motive [head] x) →\n    (∀ (head head_1 : α) (tail : List α) (x : head :: head_1 :: tail ≠ []), motive (head :: head_1 :: tail) x) →\n      motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["implies_congr",
   "CellularAutomatas.LCellAutomaton.scan_temporal_rt_len",
   "Eq.trans",
   "CellularAutomatas.FiniteStateTransducer.scanr_len",
   "List.length_mapIdx",
   "CellularAutomatas.CArtTransducer.f",
   "Inhabited.default",
   "CellularAutomatas.LCellAutomaton.scan_temporal_rt",
   "CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "congrFun",
   "CellularAutomatas.FiniteStateTransducer.advice",
   "CellularAutomatas.Word.get'?",
   "Eq.ndrec",
   "rfl",
   "CellularAutomatas.CArtTransducer.toLCellAutomaton",
   "CellularAutomatas.CArtTransducer.advice",
   "CellularAutomatas.FiniteStateTransducer.comp",
   "List.length_zipWith",
   "CellularAutomatas.backwards_fsm.Params.β",
   "CellularAutomatas.backwards_fsm.Params.M",
   "Option.getD",
   "CellularAutomatas.backwards_fsm.Params.inst2",
   "Prod.snd",
   "CellularAutomatas.LCellAutomaton.comp",
   "implies_true",
   "List.ext_getElem",
   "Eq.mpr",
   "CellularAutomatas.Word.snd",
   "CellularAutomatas.backwards_fsm.C'",
   "CellularAutomatas.backwards_fsm.Params.C",
   "GetElem.getElem.congr_simp",
   "List.map_map",
   "CellularAutomatas.FiniteStateTransducer.Q",
   "GetElem.getElem",
   "CellularAutomatas.FiniteStateTransducer.scanr_reduce",
   "CellularAutomatas.backwards_fsm.Params.γ",
   "Prod.fst",
   "congr",
   "CellularAutomatas.backwards_fsm.M_join",
   "List.lt_length_right_of_zipWith",
   "List.getElem_zipWith",
   "OfNat.ofNat",
   "CellularAutomatas.Advice.f",
   "HAdd.hAdd",
   "List.range",
   "eq_self",
   "CellularAutomatas.backwards_fsm.M_join_spec",
   "List.mapIdx",
   "List.getElem_mapIdx",
   "List.getElem_map",
   "le_refl",
   "CellularAutomatas.backwards_fsm.Params.inst3",
   "List.getElem_range",
   "Membership.mem",
   "CellularAutomatas.scan_temporal_length",
   "funext",
   "forall_congr",
   "CellularAutomatas.Word.fst",
   "CellularAutomatas.backwards_fsm.Params.α",
   "And.left",
   "CellularAutomatas.FiniteStateTransducer.compose_spec2",
   "CellularAutomatas.Word.get_snd_",
   "CellularAutomatas.FiniteStateTransducer.advice._proof_1",
   "List.drop",
   "And.right",
   "CellularAutomatas.FiniteStateTransducer.scanr",
   "List.map",
   "List.length_map",
   "zero_add",
   "CellularAutomatas.Word.fst_len",
   "id",
   "List.zipWith",
   "CellularAutomatas.backwards_fsm.M'",
   "List.length",
   "Int.toNat",
   "Nat.cast",
   "CellularAutomatas.Word.snd_len",
   "Eq.mp",
   "CellularAutomatas.LCellAutomaton.scan_temporal",
   "List.lt_length_left_of_zipWith",
   "congrArg",
   "CellularAutomatas.Word.get_fst_",
   "CellularAutomatas.FiniteStateTransducer.M_map_scanr",
   "CellularAutomatas.CellAutomaton.Q",
   "inf_eq_right._simp_1",
   "CellularAutomatas.Word",
   "CellularAutomatas.FiniteStateTransducer.M_projQ_scanr2",
   "Function.comp",
   "List.map_inj_left._simp_1",
   "CellularAutomatas.backwards_fsm.Word.get'_eq",
   "LT.lt",
   "of_eq_true",
   "Min.min",
   "CellularAutomatas.FiniteStateTransducer.M_map",
   "CellularAutomatas.FiniteStateTransducer.M_projQ",
   "LE.le",
   "CellularAutomatas.backwards_fsm.inv"],
  "name": "CellularAutomatas.backwards_fsm.spec_",
  "constType":
  "∀ (e : CellularAutomatas.backwards_fsm.Params),\n  (CellularAutomatas.backwards_fsm.M' e).advice.f ∘ (CellularAutomatas.backwards_fsm.C' e).advice.f =\n    e.C.advice.f ∘ e.M.advice.f",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CellularAutomatas.Advice.ctorIdx",
  "constType": "{α Γ : Type} → CellularAutomatas.Advice α Γ → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Int.Linear.norm_le",
   "Eq.trans",
   "Set",
   "Neg.neg",
   "Membership.mem",
   "eagerReduce",
   "HMul.hMul",
   "Lean.Grind.Int.lt_eq",
   "OfNat.ofNat",
   "congrArg",
   "Eq.mpr_prop",
   "HAdd.hAdd",
   "LT.lt",
   "NatCast.natCast",
   "congr",
   "List.take",
   "funext",
   "LE.le",
   "id",
   "setOf",
   "List.length"],
  "name": "CellularAutomatas.scan_temporal_in_F_pos._proof_1_6",
  "constType":
  "∀ {α : Type} {w : List α} (i : ℕ),\n  ∀ j ∈ {i_1 | -1 * i_1 ≤ 0 ∧ i_1 + -1 * ↑(List.take (i + 1) w).length + 1 ≤ 0},\n    j ∈ {i_1 | 0 ≤ i_1 ∧ i_1 < ↑(List.take (i + 1) w).length}",
  "constCategory": "Theorem"},
 {"references":
  ["absurd", "HAdd.hAdd", "Not", "False.elim", "Nat.casesOn", "OfNat.ofNat"],
  "name":
  "_private.Init.Data.List.Lemmas.0.List.getElem?_eq_some_iff.match_1_3",
  "constType":
  "∀ (motive : (i : ℕ) → ¬i = 0 → Prop) (i : ℕ) (h : ¬i = 0), (∀ (i : ℕ) (h : ¬i + 1 = 0), motive i.succ h) → motive i h",
  "constCategory": "Definition"},
 {"references": ["List.casesOn", "Unit.unit", "Unit"],
  "name":
  "_private.Init.Data.List.Lemmas.0.List.getElem?_eq_some_iff.match_1_1",
  "constType":
  "∀ {α : Type u_1} (motive : List α → Prop) (l : List α),\n  (∀ (a : Unit), motive []) → (∀ (head : α) (l : List α), motive (head :: l)) → motive l",
  "constCategory": "Definition"},
 {"references":
  ["Eq.trans",
   "Lean.Grind.CommRing.Mon.denote_ofVar",
   "Lean.Grind.CommRing.Mon.denote",
   "Lean.Grind.CommRing.Poly.ofMon",
   "Lean.Grind.CommRing.Mon.ofVar",
   "congrArg",
   "eq_self",
   "of_eq_true",
   "Lean.Grind.CommRing.Poly.denote",
   "Lean.Grind.CommRing.Var.denote",
   "Lean.Grind.CommRing.Var",
   "Lean.Grind.CommRing.Poly.denote_ofMon",
   "Lean.Grind.CommRing.Context"],
  "name": "Lean.Grind.CommRing.Poly.denote_ofVar",
  "constType":
  "∀ {α : Type u_1} [inst : Grind.Ring α] (ctx : Grind.CommRing.Context α) (x : Grind.CommRing.Var),\n  Grind.CommRing.Poly.denote ctx (Grind.CommRing.Poly.ofVar x) = Grind.CommRing.Var.denote ctx x",
  "constCategory": "Theorem"},
 {"references":
  ["Bind.bind",
   "List.below",
   "List.brecOn",
   "Pure.pure",
   "List.foldlM.match_1"],
  "name": "List.foldlM",
  "constType":
  "{m : Type u → Type v} → [Monad m] → {s : Type u} → {α : Type w} → (s → α → m s) → s → List α → m s",
  "constCategory": "Definition"},
 {"references": ["Prod.casesOn", "CellularAutomatas.FiniteStateTransducer.Q"],
  "name": "CellularAutomatas.FiniteStateTransducer.scanr_step.match_1",
  "constType":
  "{α β : Type} →\n  (M : CellularAutomatas.FiniteStateTransducer α β) →\n    (motive : M.Q ⨉ List β → Sort u_1) → (x : M.Q ⨉ List β) → ((q : M.Q) → (w : List β) → motive (q, w)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Int.add_assoc",
   "Eq.trans",
   "Int.Linear.Poly.append",
   "Int.Linear.Poly.denote",
   "HMul.hMul",
   "congrArg",
   "HAdd.hAdd",
   "Int.Linear.Poly.denote_addConst",
   "eq_self",
   "Int.Linear.Var.denote",
   "Int.Linear.Context",
   "of_eq_true",
   "congr",
   "Int.add_comm",
   "Int.Linear.Poly.addConst",
   "Int.Linear.Var"],
  "name": "Int.Linear.Poly.denote_append",
  "constType":
  "∀ (ctx : Int.Linear.Context) (p₁ p₂ : Int.Linear.Poly),\n  Int.Linear.Poly.denote ctx (p₁.append p₂) = Int.Linear.Poly.denote ctx p₁ + Int.Linear.Poly.denote ctx p₂",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "Eq.trans",
   "Eq.mp",
   "_private.Init.Grind.Order.0.Lean.Grind.Order.lt_eq_true_of_lt_k._proof_1_1",
   "Lean.Grind.Semiring.add_assoc",
   "Int.cast",
   "congrArg",
   "Lean.Grind.Ring.intCast_add",
   "Lean.Grind.Semiring.add_zero",
   "Eq.symm",
   "Int.ble'_eq_true",
   "HSub.hSub",
   "Lean.Grind.OrderedRing.nonneg_intCast_of_nonneg",
   "Int.sub_eq_add_neg",
   "Lean.Grind.AddCommGroup.add_neg_cancel",
   "Lean.Grind.Semiring.add_comm",
   "Not",
   "Lean.Grind.Ring.intCast",
   "Neg.neg",
   "Lean.Grind.Ring.intCast_neg",
   "_private.Init.Grind.Order.0.Lean.Grind.Order.add_lt_add_of_le_of_lt",
   "iff_true",
   "eq_iff_iff._simp_1",
   "Int.ble'",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "LT.lt",
   "Decidable.byContradiction",
   "Int.add_comm",
   "LE.le",
   "id",
   "Eq.mpr"],
  "name": "Lean.Grind.Order.lt_eq_true_of_lt_k",
  "constType":
  "∀ {α : Type u_1} [inst : LE α] [inst_1 : LT α] [LawfulOrderLT α] [inst_3 : Std.IsPreorder α] [inst_4 : Grind.Ring α]\n  [Grind.OrderedRing α] {a b : α} {k₁ k₂ : ℤ}, k₁.ble' k₂ = true → a < b + ↑k₁ → (a < b + ↑k₂) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Bind.bind",
   "HAppend.hAppend",
   "List.foldlM_cons",
   "List.append_assoc",
   "Eq.trans",
   "LawfulMonad.bind_assoc",
   "List.foldlM_append",
   "congrArg",
   "eq_self",
   "of_eq_true",
   "List.reverse",
   "congr",
   "List.reverse_cons",
   "funext",
   "id",
   "List.foldrM",
   "Pure.pure",
   "bind_pure",
   "LawfulMonad.pure_bind",
   "List.foldlM"],
  "name": "List.foldrM_cons",
  "constType":
  "∀ {m : Type u_1 → Type u_2} {α : Type u_3} {β : Type u_1} [inst : Monad m] [LawfulMonad m] {a : α} {l : List α}\n  {f : α → β → m β} {b : β}, List.foldrM f b (a :: l) = List.foldrM f b l >>= f a",
  "constCategory": "Theorem"},
 {"references": ["absurd", "Not", "Or.elim", "id"],
  "name": "Or.resolve_left",
  "constType": "∀ {a b : Prop}, a ∨ b → ¬a → b",
  "constCategory": "Theorem"},
 {"references": ["Not", "Array.getInternal", "LT.lt", "Array.size", "dite"],
  "name": "Array.getD",
  "constType": "{α : Type u_1} → Array α → ℕ → α → α",
  "constCategory": "Definition"},
 {"references":
  ["Not",
   "eq_self",
   "not_false_eq_true",
   "Eq.trans",
   "of_eq_true",
   "eq_false",
   "congr",
   "Classical.propDecidable",
   "not_true_eq_false",
   "eq_true",
   "dite",
   "congrArg"],
  "name": "Lean.Grind.not_not",
  "constType": "∀ (p : Prop), (¬¬p) = p",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CellularAutomatas.DefinesLanguage",
  "constType": "Sort u_1 → outParam Type → Sort (max 1 u_1)",
  "constCategory": "Other"},
 {"references":
  ["Eq.propIntro",
   "Eq.symm",
   "Eq.ndrec",
   "Eq.casesOn",
   "Option.some.noConfusion"],
  "name": "Option.some.injEq",
  "constType":
  "∀ {α : Type u} (val val_1 : α), (some val = some val_1) = (val = val_1)",
  "constCategory": "Theorem"},
 {"references":
  ["outParam",
   "id",
   "CellularAutomatas.DefinesLanguage.noConfusion",
   "Language"],
  "name": "CellularAutomatas.DefinesLanguage.mk.noConfusion",
  "constType":
  "{CA : Sort u_1} →\n  {α : outParam Type} → (P : Sort u) → (L L' : CA → Language α) → { L := L } = { L := L' } → (L = L' → P) → P",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Setoid.r",
  "constType": "{α : Sort u} → [self : Setoid α] → α → α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Nat.le_trans",
   "Min.min",
   "Nat.min_le_left",
   "LE.le",
   "_private.Init.Data.Nat.MinMax.0.Nat.le_min.match_1_1",
   "Nat.min_le_right",
   "Nat.le_min_of_le_of_le"],
  "name": "Nat.le_min",
  "constType": "∀ {a b c : ℕ}, a ≤ min b c ↔ a ≤ b ∧ a ≤ c",
  "constCategory": "Theorem"},
 {"references":
  ["rfl",
   "Nat.succ_add",
   "_private.Init.Data.Nat.Basic.0.Nat.le.dest.match_1_3",
   "Nat.add_comm",
   "Nat.brecOn",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "absurd",
   "Nat.not_succ_le_zero",
   "Nat.le_of_succ_le_succ",
   "_private.Init.Data.Nat.Basic.0.Nat.le.dest.match_1_1",
   "LE.le",
   "Nat.below",
   "Eq.symm"],
  "name": "Nat.le.dest",
  "constType": "∀ {n m : ℕ}, n ≤ m → ∃ k, n + k = m",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.cast",
   "Int.subNatNat",
   "Int.negOfNat.match_1",
   "Int.subNatNat.eq_1",
   "OfNat.ofNat",
   "Unit",
   "congrArg",
   "Nat.sub_eq_zero_of_le",
   "LE.le",
   "HSub.hSub",
   "id",
   "Eq.mpr",
   "_private.Init.Data.Int.Lemmas.0.Int.ofNat_sub.match_1_1"],
  "name": "Int.ofNat_sub",
  "constType": "∀ {m n : ℕ}, m ≤ n → ↑(n - m) = ↑n - ↑m",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Lean.Omega.LowerBound",
  "constType": "Type",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CellularAutomatas.FiniteStateTransducer.alphabetQ",
  "constType":
  "{α β : Type} → (self : CellularAutomatas.FiniteStateTransducer α β) → CellularAutomatas.Alphabet self.Q",
  "constCategory": "Definition"},
 {"references":
  ["Int.Linear.Poly.beq'",
   "Int.Linear.Poly.coeff",
   "Int.Linear.Poly.combine_mul_k",
   "Neg.neg",
   "Int.ble'",
   "Bool.and'",
   "OfNat.ofNat",
   "Int.Linear.Var"],
  "name": "Int.Linear.eq_le_subst_nonpos_cert",
  "constType":
  "Int.Linear.Var → Int.Linear.Poly → Int.Linear.Poly → Int.Linear.Poly → Bool",
  "constCategory": "Definition"},
 {"references":
  ["eq_self", "Eq.trans", "of_eq_true", "Eq.symm", "Eq.ndrec", "congrArg"],
  "name": "Lean.Grind.Order.eq_trans_true",
  "constType": "∀ {p q : Prop}, p = q → q = True → p = True",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Name.mkStr4",
   "Bind.bind",
   "Lean.SyntaxNodeKind",
   "Lean.Name.mkStr1",
   "ite",
   "Lean.TSyntax.raw",
   "EStateM",
   "Lean.Name.mkStr3",
   "String.toRawSubstring'",
   "Lean.Syntax.isOfKind",
   "Lean.MonadQuotation.getCurrMacroScope",
   "Lean.Syntax.node3",
   "Lean.MacroScope",
   "OfNat.ofNat",
   "Lean.MonadRef.mkInfoFromRefPos",
   "Pure.pure",
   "Lean.Syntax.getArg",
   "Lean.addMacroScope",
   "Lean.MonadQuotation.getContext",
   "Lean.Name.mkStr2",
   "Lean.MacroM",
   "MonadExcept.throw",
   "Lean.Syntax.node2"],
  "name":
  "CellularAutomatas.Word.«_aux_CellularAutomatas_defs___macroRules_CellularAutomatas_Word_term_⟦_.._⟧_1»",
  "constType": "Macro",
  "constCategory": "Definition"},
 {"references": ["Prod.casesOn"],
  "name": "CellularAutomatas.backwards_fsm.M_join.match_1",
  "constType":
  "{γ β : Type} →\n  (motive : (β → γ) ⨉ β → Sort u_1) → (x : (β → γ) ⨉ β) → ((a : β → γ) → (b : β) → motive (a, b)) → motive x",
  "constCategory": "Definition"},
 {"references": ["CellularAutomatas.Word", "List.casesOn"],
  "name":
  "_private.CellularAutomatas.proofs.finite_state_transducers.0.CellularAutomatas.FiniteStateTransducer.scanr_reduce_q.match_1.splitter",
  "constType":
  "{α : Type} →\n  (motive : CellularAutomatas.Word α → Sort u_1) →\n    (x : CellularAutomatas.Word α) → motive [] → ((c : α) → (cs : List α) → motive (c :: cs)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Set.image", "Set", "Membership.mem", "Set.mem_image", "propext"],
  "name": "Set.mem_image._simp_1",
  "constType":
  "∀ {α : Type u} {β : Type v} (f : α → β) (s : Set α) (y : β), (y ∈ f '' s) = ∃ x ∈ s, f x = y",
  "constCategory": "Theorem"},
 {"references":
  ["Not", "eq_self", "Eq.trans", "of_eq_true", "not_true_eq_false", "congrArg"],
  "name": "Lean.Grind.not_true",
  "constType": "(¬True) = False",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.ctorIdx",
   "noConfusion_of_Nat",
   "GetElem.getElem",
   "Nat.le.casesOn",
   "OfNat.ofNat",
   "LT.lt",
   "HAdd.hAdd",
   "GetElem?.getElem?",
   "False.elim",
   "List.get._proof_1",
   "Eq.symm",
   "Eq.ndrec",
   "List.length",
   "Nat.casesAuxOn"],
  "name": "List.getElem?_eq_getElem",
  "constType":
  "∀ {α : Type u_1} {l : List α} {i : ℕ} (h : i < l.length), l[i]? = some l[i]",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans",
   "Lean.Omega.IntList.get",
   "Lean.Omega.LinearCombo.coordinate",
   "OfNat.ofNat",
   "congrArg",
   "HAdd.hAdd",
   "eq_self",
   "Lean.Omega.LinearCombo.coordinate_eval",
   "of_eq_true",
   "Lean.Omega.Coeffs.ofList",
   "Lean.Omega.IntList.get_cons_succ",
   "Lean.Omega.Coeffs.get",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.IntList.get_cons_zero"],
  "name": "Lean.Omega.LinearCombo.coordinate_eval_2",
  "constType":
  "∀ {a0 a1 a2 : ℤ} {t : List ℤ}, (Omega.LinearCombo.coordinate 2).eval (Omega.Coeffs.ofList (a0 :: a1 :: a2 :: t)) = a2",
  "constCategory": "Theorem"},
 {"references":
  ["not_lt._simp_1",
   "Nat.cast",
   "Eq.trans",
   "Eq.mp",
   "Membership.mem",
   "congrArg",
   "funext",
   "Int.natAbs",
   "CellularAutomatas.Word.cone_prop._proof_1_2",
   "Not",
   "not_and._simp_1",
   "CellularAutomatas.Word",
   "Neg.neg",
   "Set",
   "CellularAutomatas.Word.cone",
   "neg_add_rev",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "LT.lt",
   "Decidable.byContradiction",
   "LE.le",
   "id",
   "Eq.mpr",
   "implies_congr_ctx",
   "List.length",
   "setOf"],
  "name": "CellularAutomatas.Word.cone_prop",
  "constType":
  "∀ {α : Type u_1} {w : CellularAutomatas.Word α} {t : ℕ} {i : ℤ} (d : ℤ),\n  i ∉ w.cone (t + 1) → d.natAbs ≤ 1 → i + d ∉ w.cone t",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans",
   "le_of_le_of_eq",
   "Lean.Omega.LinearCombo.coordinate_eval_0",
   "Lean.Omega.Constraint.combine_sat'",
   "Decidable.decide",
   "Lean.Omega.Coeffs.ofList",
   "Lean.Omega.tidy_sat",
   "Eq.symm",
   "HSub.hSub",
   "Lean.Omega.LinearCombo.add_eval",
   "Lean.Omega.Int.lt_of_not_le",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "Int.add_one_le_of_lt",
   "of_decide_eq_true",
   "Not",
   "ite",
   "Neg.neg",
   "Lean.Omega.Constraint.addInequality_sat",
   "Lean.Omega.Int.add_congr",
   "Lean.Omega.Constraint.isImpossible",
   "Lean.Omega.LinearCombo.coordinate",
   "OfNat.ofNat",
   "Int.sub_nonneg_of_le",
   "HAdd.hAdd",
   "LT.lt",
   "Lean.Omega.LinearCombo.sub_eval",
   "LE.le",
   "id",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.Int.sub_congr"],
  "name": "CellularAutomatas.FiniteStateTransducer.scanr_reduce'?._proof_1_2",
  "constType": "∀ i < 0, ¬i + 1 ≤ 0 → False",
  "constCategory": "Theorem"},
 {"references": ["HAdd.hAdd", "LE.le", "Nat.add_comm", "Nat.le_add_right"],
  "name": "Nat.le_add_left",
  "constType": "∀ (n m : ℕ), n ≤ m + n",
  "constCategory": "Theorem"},
 {"references": ["eq_self", "Eq.trans", "of_eq_true", "and_true", "congrArg"],
  "name": "Lean.Grind.and_eq_of_eq_true_right",
  "constType": "∀ {a b : Prop}, b = True → (a ∧ b) = a",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Syntax.casesOn", "Lean.SyntaxNodeKind", "Unit.unit", "Unit"],
  "name": "_private.Init.Prelude.0.Lean.Syntax.getKind.match_1",
  "constType":
  "(motive : Syntax → Sort u_1) →\n  (stx : Syntax) →\n    ((info : SourceInfo) → (k : SyntaxNodeKind) → (args : Array Syntax) → motive (Syntax.node info k args)) →\n      (Unit → motive Syntax.missing) →\n        ((info : SourceInfo) → (v : String) → motive (Syntax.atom info v)) →\n          ((info : SourceInfo) →\n              (rawVal : Substring.Raw) →\n                (val : Name) →\n                  (preresolved : List Syntax.Preresolved) → motive (Syntax.ident info rawVal val preresolved)) →\n            motive stx",
  "constCategory": "Definition"},
 {"references": ["Nat.casesOn", "Nat.beq"],
  "name": "_private.Init.Prelude.0.Nat.ne_of_beq_eq_false.match_1_1",
  "constType":
  "∀ (motive : (x x_1 : ℕ) → x.beq x_1 = false → x = x_1 → Prop) (x x_1 : ℕ) (x_2 : x.beq x_1 = false) (x_3 : x = x_1),\n  (∀ (h₁ : Nat.zero.beq Nat.zero = false) (x : Nat.zero = Nat.zero), motive Nat.zero Nat.zero h₁ x) →\n    (∀ (n : ℕ) (x : Nat.zero.beq n.succ = false) (h₂ : Nat.zero = n.succ), motive Nat.zero n.succ x h₂) →\n      (∀ (n : ℕ) (x : n.succ.beq Nat.zero = false) (h₂ : n.succ = Nat.zero), motive n.succ Nat.zero x h₂) →\n        (∀ (n m : ℕ) (h₁ : n.succ.beq m.succ = false) (h₂ : n.succ = m.succ), motive n.succ m.succ h₁ h₂) →\n          motive x x_1 x_2 x_3",
  "constCategory": "Definition"},
 {"references": ["Lean.SyntaxNodeKind", "Lean.Syntax.getKind", "BEq.beq"],
  "name": "Lean.Syntax.isOfKind",
  "constType": "Syntax → SyntaxNodeKind → Bool",
  "constCategory": "Definition"},
 {"references":
  ["LT.lt",
   "eq_of_heq",
   "Eq.symm",
   "GetElem.getElem",
   "Eq.ndrec",
   "Eq.casesOn",
   "List.length"],
  "name": "List.getElem_of_eq",
  "constType":
  "∀ {α : Type u_1} {l l' : List α} (h : l = l') {i : ℕ} (w : i < l.length), l[i] = l'[i]",
  "constCategory": "Theorem"},
 {"references":
  ["Int.add_right_neg",
   "Int.add_le_add_right",
   "HAdd.hAdd",
   "Eq.mp",
   "Neg.neg",
   "LE.le",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Int.sub_nonpos_of_le",
  "constType": "∀ {a b : ℤ}, a ≤ b → a - b ≤ 0",
  "constCategory": "Theorem"},
 {"references": ["IntCast.intCast"],
  "name": "Int.cast",
  "constType": "{R : Type u} → [IntCast R] → ℤ → R",
  "constCategory": "Definition"},
 {"references": ["Lean.Grind.AC.hugeFuel", "Lean.Grind.AC.Seq.unionFuel"],
  "name": "Lean.Grind.AC.Seq.union",
  "constType": "Grind.AC.Seq → Grind.AC.Seq → Grind.AC.Seq",
  "constCategory": "Definition"},
 {"references": ["HAdd.hAdd", "eq_self", "of_eq_true", "LE.le", "OfNat.ofNat"],
  "name": "Lean.Grind.Nat.lt_eq",
  "constType": "∀ (a b : ℕ), (a < b) = (a + 1 ≤ b)",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.CALc", "Eq.ndrec", "CellularAutomatas.Advice.rt_closed"],
  "name": "CellularAutomatas.CALc.congr_simp",
  "constType":
  "∀ {α : Type} [inst : CellularAutomatas.Alphabet α] {Γ : Type} [inst_1 : CellularAutomatas.Alphabet Γ]\n  (adv adv_1 : CellularAutomatas.Advice α Γ) (e_adv : adv = adv_1) (h : adv.rt_closed) (c c_1 : Γ),\n  c = c_1 → CellularAutomatas.CALc adv h c = CellularAutomatas.CALc adv_1 ⋯ c_1",
  "constCategory": "Theorem"},
 {"references": ["CellularAutomatas.TwoStageAdvice.casesOn"],
  "name": "CellularAutomatas.TwoStageAdvice.noConfusionType",
  "constType":
  "{α Γ : Type} →\n  [inst : CellularAutomatas.Alphabet α] →\n    [inst_1 : CellularAutomatas.Alphabet Γ] →\n      Sort u → CellularAutomatas.TwoStageAdvice α Γ → CellularAutomatas.TwoStageAdvice α Γ → Sort u",
  "constCategory": "Definition"},
 {"references":
  ["CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "CellularAutomatas.CArtTransducer.toLCellAutomaton",
   "CellularAutomatas.composition.Params.noConfusionType",
   "CellularAutomatas.composition.Params.casesOn",
   "CellularAutomatas.CellAutomaton.Q",
   "Eq.ndrec"],
  "name": "CellularAutomatas.composition.Params.noConfusion",
  "constType":
  "{P : Sort u} →\n  {x1 x2 : CellularAutomatas.composition.Params} →\n    x1 = x2 → CellularAutomatas.composition.Params.noConfusionType P x1 x2",
  "constCategory": "Definition"},
 {"references": ["Lean.Grind.CommRing.Var"],
  "name": "Lean.Grind.CommRing.Expr.below",
  "constType":
  "{motive : Grind.CommRing.Expr → Sort u} → Grind.CommRing.Expr → Sort (max 1 u)",
  "constCategory": "Definition"},
 {"references": ["String.rawEndPos", "OfNat.ofNat"],
  "name": "String.toRawSubstring",
  "constType": "String → Substring.Raw",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Omega.Constraint.upperBound",
   "HDiv.hDiv",
   "Nat.cast",
   "Neg.neg",
   "Lean.Omega.Constraint.lowerBound",
   "Option.map"],
  "name": "Lean.Omega.Constraint.div",
  "constType": "Omega.Constraint → ℕ → Omega.Constraint",
  "constCategory": "Definition"},
 {"references":
  ["CellularAutomatas.tCellAutomaton.t",
   "Set",
   "Membership.mem",
   "HMul.hMul",
   "OfNat.ofNat",
   "setOf"],
  "name": "CellularAutomatas.t_2n",
  "constType":
  "(α : Type) → Set (CellularAutomatas.tCellAutomaton α) → Set (CellularAutomatas.tCellAutomaton α)",
  "constCategory": "Definition"},
 {"references":
  ["Not",
   "Eq.trans",
   "Eq.mp",
   "ite",
   "eq_true",
   "ite_cond_eq_true",
   "min_def",
   "Lean.Grind.nestedDecidable",
   "Lean.Grind.Order.le_eq_true",
   "Min.min",
   "eq_false",
   "Classical.byContradiction",
   "LE.le",
   "id",
   "Eq.symm"],
  "name": "_private.Mathlib.Order.Defs.LinearOrder.0.min_self._proof_1_1",
  "constType": "∀ {α : Type u_1} [inst : LinearOrder α] (a : α), min a a = a",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Omega.Constraint.upperBound",
   "Eq.trans",
   "Lean.Omega.Constraint.trivial",
   "Lean.Omega.UpperBound.sat",
   "decide_true",
   "Lean.Omega.LowerBound.sat",
   "Decidable.decide",
   "congrArg",
   "eq_self",
   "Decidable.decide.congr_simp",
   "and_self",
   "of_eq_true",
   "congr",
   "Lean.Omega.Constraint.lowerBound"],
  "name": "Lean.Omega.Constraint.trivial_say",
  "constType": "∀ {t : ℤ}, Omega.Constraint.trivial.sat t = true",
  "constCategory": "Theorem"},
 {"references": ["_private.Init.SimpLemmas.0.and_imp.match_1_1"],
  "name": "and_imp",
  "constType": "∀ {a b c : Prop}, a ∧ b → c ↔ a → b → c",
  "constCategory": "Theorem"},
 {"references": ["Option.casesOn", "CellularAutomatas.FiniteStateTransducer.Q"],
  "name": "CellularAutomatas.FiniteStateTransducer.δ?.match_1",
  "constType":
  "{α β : Type} →\n  (M : CellularAutomatas.FiniteStateTransducer α β) →\n    (motive : M.Q → Option α → Sort u_1) →\n      (x : M.Q) →\n        (x_1 : Option α) → ((q : M.Q) → motive q none) → ((q : M.Q) → (a : α) → motive q (some a)) → motive x x_1",
  "constCategory": "Definition"},
 {"references": ["rfl", "Min.min"],
  "name": "Int.min_def",
  "constType": "∀ (n m : ℤ), min n m = if n ≤ m then n else m",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.Word.get'",
   "CellularAutomatas.Word",
   "Set",
   "CellularAutomatas.Word.get_cone_0._proof_1",
   "Membership.mem",
   "CellularAutomatas.Word.cone",
   "OfNat.ofNat"],
  "name": "CellularAutomatas.Word.get_cone_0",
  "constType":
  "{α : Type u_1} → {w : CellularAutomatas.Word α} → {i : ℤ} → i ∈ w.cone 0 → α",
  "constCategory": "Definition"},
 {"references":
  ["Not",
   "Eq.trans",
   "Eq.mp",
   "Int.ne_of_lt",
   "congrArg",
   "LT.lt",
   "Or.casesOn",
   "eq_self",
   "False.elim",
   "Int.lt_trichotomy",
   "Int.ne_of_gt",
   "not_true_eq_false",
   "Ne"],
  "name": "Int.ne_iff_lt_or_gt",
  "constType": "∀ {a b : ℤ}, a ≠ b ↔ a < b ∨ b < a",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "AddZeroClass.add_zero",
  "constType": "∀ {M : Type u} [self : AddZeroClass M] (a : M), a + 0 = a",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.Word",
   "CellularAutomatas.FiniteStateTransducer.scanr_reduce_q.match_1",
   "List.brecOn.go",
   "List.brecOn",
   "CellularAutomatas.FiniteStateTransducer.Q",
   "Unit",
   "congrArg",
   "CellularAutomatas.FiniteStateTransducer.scanr_reduce_q",
   "List.below",
   "Eq.symm",
   "id",
   "Eq.mpr",
   "Eq.ndrec",
   "List.brecOn.eq",
   "_private.CellularAutomatas.proofs.finite_state_transducers.0.CellularAutomatas.FiniteStateTransducer.scanr_reduce_q.match_1.splitter",
   "CellularAutomatas.FiniteStateTransducer.δ"],
  "name": "CellularAutomatas.FiniteStateTransducer.scanr_reduce_q.eq_def",
  "constType":
  "∀ {α β : Type} (M : CellularAutomatas.FiniteStateTransducer α β) (q : M.Q) (x : CellularAutomatas.Word α),\n  M.scanr_reduce_q q x =\n    match x with\n    | [] => q\n    | c :: cs => M.δ (M.scanr_reduce_q q cs) c",
  "constCategory": "Theorem"},
 {"references": ["CellularAutomatas.CellAutomaton.Q"],
  "name": "CellularAutomatas.simulation.Params.recOn",
  "constType":
  "{motive : CellularAutomatas.simulation.Params → Sort u} →\n  (t : CellularAutomatas.simulation.Params) →\n    ((C_inr C_ctl : CellularAutomatas.CellAutomaton) →\n        (f : C_ctl.Q → Option C_inr.Q) → motive { C_inr := C_inr, C_ctl := C_ctl, f := f }) →\n      motive t",
  "constCategory": "Definition"},
 {"references": ["Int.mul", "Int.beq'", "OfNat.ofNat"],
  "name": "Lean.Grind.CommRing.Poly.mulConst_k",
  "constType": "ℤ → Grind.CommRing.Poly → Grind.CommRing.Poly",
  "constCategory": "Definition"},
 {"references":
  ["Nat.cast",
   "Eq.trans",
   "Nat.recAux",
   "add_zero",
   "OfNat.ofNat",
   "congrArg",
   "HAdd.hAdd",
   "eq_self",
   "of_eq_true",
   "add_assoc",
   "Nat.cast_zero",
   "Nat.add_succ",
   "id",
   "Eq.mpr",
   "Nat.cast_succ"],
  "name": "Nat.cast_add",
  "constType":
  "∀ {R : Type u_1} [inst : AddMonoidWithOne R] (m n : ℕ), ↑(m + n) = ↑m + ↑n",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "Lean.Grind.AC.Seq.insert",
   "Nat.blt",
   "Eq.trans",
   "Bool.of_not_eq_true",
   "true_and",
   "Lean.Grind.AC.Seq.unionFuel",
   "OfNat.ofNat",
   "congrArg",
   "Lean.Grind.AC.Var",
   "eq_self",
   "Lean.Grind.AC.Seq.unionFuel.induct_unfolding",
   "Lean.Grind.AC.Seq.unionFuel_k",
   "of_eq_true",
   "Eq.symm",
   "Lean.Grind.AC.Seq.cons.injEq",
   "id",
   "Lean.Grind.AC.Seq.concat",
   "Eq.mpr"],
  "name": "Lean.Grind.AC.Seq.unionFuel_k_eq_unionFuel",
  "constType":
  "∀ (fuel : ℕ) (s₁ s₂ : Grind.AC.Seq), Grind.AC.Seq.unionFuel_k fuel s₁ s₂ = Grind.AC.Seq.unionFuel fuel s₁ s₂",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.simulation.Params.C_ctl",
   "CellularAutomatas.CellAutomaton.Q",
   "CellularAutomatas.simulation.Q1.casesOn",
   "OfNat.ofNat"],
  "name": "CellularAutomatas.simulation.instFintypeQ1.match_5",
  "constType":
  "(e : CellularAutomatas.simulation.Params) →\n  (motive : CellularAutomatas.simulation.Q1 e → Sort u_1) →\n    (x : CellularAutomatas.simulation.Q1 e) →\n      ((a : e.C_ctl.Q) → (a_1 : Fin 3) → motive { state := a, counter := a_1 }) → motive x",
  "constCategory": "Definition"},
 {"references": ["Set", "Membership.mem"],
  "name": "Set.InjOn",
  "constType": "{α : Type u} → {β : Type v} → (α → β) → Set α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Nat.Linear.Context",
   "Nat.mul",
   "List.below",
   "Nat.add",
   "Nat.Linear.Poly.denote.match_1",
   "Nat.Linear.Var.denote",
   "List.brecOn",
   "OfNat.ofNat",
   "Nat.Linear.Var",
   "Unit",
   "Nat.Linear.Poly"],
  "name": "Nat.Linear.Poly.denote",
  "constType": "Nat.Linear.Context → Nat.Linear.Poly → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Not",
   "ne_eq",
   "not_or",
   "Int.mul_eq_zero",
   "id",
   "HMul.hMul",
   "Ne",
   "Eq.mpr",
   "Iff.rfl",
   "propext",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Int.mul_ne_zero_iff",
  "constType": "∀ {a b : ℤ}, a * b ≠ 0 ↔ a ≠ 0 ∧ b ≠ 0",
  "constCategory": "Theorem"},
 {"references": ["Min.min", "LE.le", "inf_le_left", "eq_true"],
  "name": "inf_le_left._simp_1",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeInf α] {a b : α}, (a ⊓ b ≤ a) = True",
  "constCategory": "Theorem"},
 {"references": ["CellularAutomatas.TwoStageAdvice.advice"],
  "name": "CellularAutomatas.Advice.is_two_stage_advice",
  "constType":
  "{α Γ : Type} → [CellularAutomatas.Alphabet α] → [CellularAutomatas.Alphabet Γ] → CellularAutomatas.Advice α Γ → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Ne",
   "_private.Lean.Data.Name.0.Lean.Name.eqStr._sparseCasesOn_1",
   "Lean.Name.casesOn",
   "OfNat.ofNat",
   "Unit.unit",
   "Lean.Name.ctorIdx",
   "Unit"],
  "name": "_private.Lean.Data.Name.0.Lean.Name.cmp.match_4",
  "constType":
  "(motive : Name → Name → Sort u_1) →\n  (x x_1 : Name) →\n    (Unit → motive Name.anonymous Name.anonymous) →\n      ((x : Name) → motive Name.anonymous x) →\n        ((x : Name) → motive x Name.anonymous) →\n          ((p₁ : Name) → (i₁ : ℕ) → (p₂ : Name) → (i₂ : ℕ) → motive (p₁.num i₁) (p₂.num i₂)) →\n            ((pre : Name) → (i : ℕ) → (pre_1 : Name) → (str : String) → motive (pre.num i) (pre_1.str str)) →\n              ((pre : Name) → (str : String) → (pre_1 : Name) → (i : ℕ) → motive (pre.str str) (pre_1.num i)) →\n                ((p₁ : Name) → (n₁ : String) → (p₂ : Name) → (n₂ : String) → motive (p₁.str n₁) (p₂.str n₂)) →\n                  motive x x_1",
  "constCategory": "Definition"},
 {"references": ["CellularAutomatas.FiniteStateTransducer.comp"],
  "name": "CellularAutomatas.FiniteStateTransducer.comp.eq_1",
  "constType":
  "∀ {β γ α : Type} (M2 : CellularAutomatas.FiniteStateTransducer β γ) (M1 : CellularAutomatas.FiniteStateTransducer α β),\n  M2 ⊚ M1 =\n    { Q := M1.Q ⨉ M2.Q, alphabetQ := CellularAutomatas.ProductAlphabet,\n      δ := fun x a =>\n        match x with\n        | (q1, q2) => (M1.δ q1 a, M2.δ q2 (M1.f (M1.δ q1 a))),\n      q0 := (M1.q0, M2.q0),\n      f := fun x =>\n        match x with\n        | (_q1, q2) => M2.f q2 }",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.CellAutomaton.dead", "CellularAutomatas.CellAutomaton.Q"],
  "name": "CellularAutomatas.CellAutomaton.dead.eq_1",
  "constType":
  "∀ (C : CellularAutomatas.CellAutomaton) (q : C.Q), C.dead q = C.delta_closed_set {q}",
  "constCategory": "Theorem"},
 {"references":
  ["List.getElem?_eq_getElem",
   "Option.some.inj",
   "List.map",
   "GetElem.getElem",
   "List.length_map",
   "List.getElem?_map",
   "congrArg",
   "LT.lt",
   "GetElem?.getElem?",
   "id",
   "Eq.symm",
   "Eq.mpr",
   "Option.map",
   "List.length"],
  "name": "List.getElem_map",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} (f : α → β) {l : List α} {i : ℕ} {h : i < (List.map f l).length},\n  (List.map f l)[i] = f l[i]",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "iff_self",
   "Eq.trans",
   "of_eq_true",
   "Lean.Grind.AddCommMonoid.zero_add",
   "_private.Init.Grind.Module.Basic.0.Lean.Grind.AddCommGroup.sub_eq_zero_iff._simp_1_1",
   "HSub.hSub",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Lean.Grind.AddCommGroup.sub_eq_zero_iff",
  "constType":
  "∀ {M : Type u} [inst : Grind.AddCommGroup M] {a b : M}, a - b = 0 ↔ a = b",
  "constCategory": "Theorem"},
 {"references":
  ["Or.elim",
   "Lean.Omega.LinearCombo.coordinate_eval_2",
   "Nat.cast",
   "Eq.trans",
   "le_of_le_of_eq",
   "Lean.Omega.LinearCombo.coordinate_eval_0",
   "Lean.Omega.Constraint.combine_sat'",
   "Int.sub_eq_zero_of_eq",
   "GE.ge",
   "Decidable.decide",
   "Lean.Omega.LinearCombo.neg_eval",
   "Lean.Omega.Coeffs.ofList",
   "Lean.Omega.Int.ofNat_sub_dichotomy",
   "HSub.hSub",
   "Lean.Omega.tidy_sat",
   "Eq.symm",
   "Lean.Omega.LinearCombo.add_eval",
   "Lean.Omega.Int.neg_congr",
   "Int.add_one_le_of_lt",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "And.left",
   "of_decide_eq_true",
   "Not",
   "Int.lt_or_gt_of_ne",
   "Neg.neg",
   "And.right",
   "Lean.Omega.Constraint.addInequality_sat",
   "Lean.Omega.Int.add_congr",
   "Lean.Omega.Constraint.isImpossible",
   "Lean.Omega.LinearCombo.coordinate",
   "Int.sub_nonneg_of_le",
   "OfNat.ofNat",
   "Lean.Omega.LinearCombo.coordinate_eval_1",
   "LT.lt",
   "HAdd.hAdd",
   "Lean.Omega.Int.ofNat_lt_of_lt",
   "Lean.Omega.LinearCombo.sub_eval",
   "Nat.lt_of_not_le",
   "LE.le",
   "Int.natCast_add",
   "id",
   "Lean.Omega.Constraint.addEquality_sat",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.Int.sub_congr"],
  "name":
  "_private.Init.Grind.Ring.Basic.0.Lean.Grind.Ring.intCast_add._proof_1_7",
  "constType":
  "∀ (x y : ℕ), ¬y ≥ x + 1 → ¬-↑(x + 1) + ↑y = -↑(x + 1 - y) → False",
  "constCategory": "Theorem"},
 {"references": ["Lean.Grind.AC.Seq.unionFuel_k", "Lean.Grind.AC.hugeFuel"],
  "name": "Lean.Grind.AC.Seq.union_k",
  "constType": "Grind.AC.Seq → Grind.AC.Seq → Grind.AC.Seq",
  "constCategory": "Definition"},
 {"references": [],
  "name": "LinearOrder.min_def",
  "constType":
  "∀ {α : Type u_2} [self : LinearOrder α] (a b : α), min a b = if a ≤ b then a else b",
  "constCategory": "Theorem"},
 {"references": ["Lean.Name.casesOn"],
  "name": "Lean.Name.hasMacroScopes.match_1",
  "constType":
  "(motive : Name → Sort u_1) →\n  (x : Name) →\n    ((pre : Name) → (s : String) → motive (pre.str s)) →\n      ((p : Name) → (i : ℕ) → motive (p.num i)) → ((x : Name) → motive x) → motive x",
  "constCategory": "Definition"},
 {"references": ["Nat.cast", "Nat.cast_eq_zero", "not_congr", "OfNat.ofNat"],
  "name": "Nat.cast_ne_zero",
  "constType":
  "∀ {R : Type u_1} [inst : AddMonoidWithOne R] [CharZero R] {n : ℕ}, ↑n ≠ 0 ↔ n ≠ 0",
  "constCategory": "Theorem"},
 {"references": ["Not", "Decidable.casesOn"],
  "name": "_private.Init.Prelude.0.of_decide_eq_true.match_1_1",
  "constType":
  "∀ {p : Prop} (motive : Decidable p → Prop) (inst : Decidable p),\n  (∀ (h₁ : p), motive (isTrue h₁)) → (∀ (h₁ : ¬p), motive (isFalse h₁)) → motive inst",
  "constCategory": "Definition"},
 {"references": ["outParam"],
  "name": "Membership.mem",
  "constType":
  "{α : outParam (Type u)} → {γ : Type v} → [self : Membership α γ] → γ → α → Prop",
  "constCategory": "Definition"},
 {"references": ["Lean.Omega.IntList"],
  "name": "Lean.Omega.Coeffs",
  "constType": "Type",
  "constCategory": "Definition"},
 {"references": ["OfNat.ofNat"],
  "name": "Lean.Grind.CommRing.Poly.ofMon",
  "constType": "Grind.CommRing.Mon → Grind.CommRing.Poly",
  "constCategory": "Definition"},
 {"references":
  ["CellularAutomatas.Advice.annotate",
   "CellularAutomatas.tCellAutomatonWithAdvice.C",
   "CellularAutomatas.tCellAutomatonWithAdvice.adv",
   "CellularAutomatas.tCellAutomaton.L",
   "CellularAutomatas.tCellAutomatonWithAdvice.Γ",
   "setOf"],
  "name": "CellularAutomatas.tCellAutomatonWithAdvice.L",
  "constType":
  "{α : Type} → CellularAutomatas.tCellAutomatonWithAdvice α → Language α",
  "constCategory": "Definition"},
 {"references":
  ["HAdd.hAdd",
   "Not",
   "LT.lt",
   "Array.findIdx?.loop._proof_2",
   "Array.size",
   "WellFounded.fix",
   "Array.findIdx?.loop._proof_1",
   "HSub.hSub",
   "invImage",
   "GetElem.getElem",
   "dite",
   "OfNat.ofNat"],
  "name": "Array.findIdx?.loop",
  "constType": "{α : Type u} → (α → Bool) → Array α → ℕ → Option ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Nat.one_mul",
   "id",
   "HMul.hMul",
   "Eq.mpr",
   "_private.Init.Data.Int.Lemmas.0.Int.one_mul.match_1_1",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Int.one_mul",
  "constType": "∀ (a : ℤ), 1 * a = a",
  "constCategory": "Theorem"},
 {"references": ["Task.get", "Lean.Environment.checked"],
  "name": "Lean.Environment.toKernelEnv",
  "constType": "Environment → Kernel.Environment",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CellularAutomatas.tCellAutomaton.p",
  "constType": "{α : Type} → CellularAutomatas.tCellAutomaton α → ℕ → ℕ",
  "constCategory": "Definition"},
 {"references": ["CellularAutomatas.Word", "OfNat.ofNat", "List.length"],
  "name": "CellularAutomatas.Advice._sizeOf_1",
  "constType":
  "{α Γ : Type} → [SizeOf α] → [SizeOf Γ] → CellularAutomatas.Advice α Γ → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Not",
   "Eq.trans",
   "iff_true",
   "noConfusion_of_Nat",
   "eq_false'",
   "iff_false",
   "congrArg",
   "eq_self",
   "Bool.casesOn",
   "Bool.not_eq_true",
   "False.elim",
   "of_eq_true",
   "iff_self",
   "Eq.symm",
   "Eq.ndrec",
   "Bool.ctorIdx"],
  "name": "Bool.eq_iff_iff",
  "constType": "∀ {a b : Bool}, a = b ↔ (a = true ↔ b = true)",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.le_refl._simp_1",
   "Eq.trans",
   "ite",
   "_private.Init.Data.Nat.MinMax.0.Nat.min_comm._simp_1_4",
   "Nat.lt_trichotomy",
   "ite_cond_eq_true",
   "_private.Init.Data.Nat.MinMax.0.Nat.min_comm._simp_1_3",
   "ite_cond_eq_false",
   "congrArg",
   "LT.lt",
   "eq_self",
   "of_eq_true",
   "Min.min",
   "_private.Init.Data.Nat.MinMax.0.Nat.min_comm.match_1_1",
   "congr",
   "LE.le"],
  "name": "Nat.min_comm",
  "constType": "∀ (a b : ℕ), min a b = min b a",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "CellularAutomatas.apply_iterated_zero",
   "CellularAutomatas.δδ",
   "Eq.trans",
   "of_eq_true",
   "CellularAutomatas.apply_iterated",
   "CellularAutomatas.CellAutomaton.Q",
   "OfNat.ofNat",
   "congrArg"],
  "name": "CellularAutomatas.δδt_zero",
  "constType":
  "∀ {C : CellularAutomatas.CellAutomaton} {q : C.Q}, CellularAutomatas.δδt q 0 = q",
  "constCategory": "Theorem"},
 {"references": ["LT.lt", "Not", "LE.le", "Iff.mp", "Int.not_le"],
  "name": "Lean.Omega.Int.lt_of_not_le",
  "constType": "∀ {x y : ℤ}, ¬x ≤ y → y < x",
  "constCategory": "Theorem"},
 {"references":
  ["Multiset.cons._proof_1",
   "Setoid.r",
   "Quot.liftOn",
   "Multiset.ofList",
   "Multiset"],
  "name": "Multiset.cons",
  "constType": "{α : Type u_1} → α → Multiset α → Multiset α",
  "constCategory": "Definition"},
 {"references":
  ["Finset.val", "Multiset.filter", "DecidablePred", "Finset.filter._proof_1"],
  "name": "Finset.filter",
  "constType":
  "{α : Type u_1} → (p : α → Prop) → [DecidablePred p] → Finset α → Finset α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "AddMonoidWithOne.natCast_succ",
  "constType":
  "∀ {R : Type u_2} [self : AddMonoidWithOne R] (n : ℕ), ↑(n + 1) = ↑n + 1",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Grind.CommRing.Poly.below", "Lean.Grind.CommRing.Poly.brecOn.go"],
  "name": "Lean.Grind.CommRing.Poly.brecOn",
  "constType":
  "{motive : Grind.CommRing.Poly → Sort u} →\n  (t : Grind.CommRing.Poly) → ((t : Grind.CommRing.Poly) → Grind.CommRing.Poly.below t → motive t) → motive t",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Lean.Grind.Ring.intCast",
  "constType": "{α : Type u} → [self : Grind.Ring α] → IntCast α",
  "constCategory": "Definition"},
 {"references": ["Or.casesOn"],
  "name": "_private.Init.SimpLemmas.0.or_self.match_1_1",
  "constType":
  "∀ (p : Prop) (motive : p ∨ p → Prop) (x : p ∨ p), (∀ (h : p), motive ⋯) → (∀ (h : p), motive ⋯) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["List.getLast._proof_2",
   "absurd",
   "List.getLast._proof_1",
   "List.below",
   "List.getLast.match_1",
   "List.brecOn",
   "Ne"],
  "name": "List.getLast",
  "constType": "{α : Type u} → (as : List α) → as ≠ [] → α",
  "constCategory": "Definition"},
 {"references":
  ["HAdd.hAdd",
   "Int.Linear.Var.denote",
   "Int.Linear.Context",
   "HMul.hMul",
   "Int.beq'",
   "OfNat.ofNat",
   "Int.Linear.Var"],
  "name": "Int.Linear.Poly.denote'.go",
  "constType": "Int.Linear.Context → Int.Linear.Poly → ℤ → ℤ",
  "constCategory": "Definition"},
 {"references":
  ["Eq.trans",
   "le_of_le_of_eq",
   "Membership.mem",
   "Lean.Omega.LinearCombo.coordinate_eval_4",
   "Subtype.val",
   "CellularAutomatas.tCellAutomaton.toLCellAutomaton",
   "Set.Elem",
   "CellularAutomatas.LCellAutomaton.scan_temporal_rt",
   "CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "Lean.Omega.tidy_sat",
   "HSub.hSub",
   "Eq.symm",
   "Lean.Omega.LinearCombo.add_eval",
   "Int.add_one_le_of_lt",
   "CellularAutomatas.CArtTransducer.advice",
   "Lean.Omega.combo_sat'",
   "Neg.neg",
   "Lean.Omega.Constraint.addInequality_sat",
   "List.map",
   "Lean.Omega.LinearCombo.coordinate",
   "Nat.lt_of_not_le",
   "id",
   "Lean.Omega.Constraint.addEquality_sat",
   "CellularAutomatas.tCellAutomaton.L",
   "Lean.Omega.Int.sub_congr",
   "List.length",
   "Lean.Omega.LinearCombo.coordinate_eval_7",
   "Nat.cast",
   "CellularAutomatas.tCellAutomaton.t",
   "Lean.Omega.Constraint.combine_sat'",
   "Int.sub_eq_zero_of_eq",
   "Decidable.decide",
   "Lean.Omega.Coeffs.ofList",
   "CellularAutomatas.CellAutomaton.Q",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "of_decide_eq_true",
   "Not",
   "CellularAutomatas.Word",
   "List.extract",
   "Set",
   "Lean.Omega.Int.ofNat_congr",
   "Lean.Omega.Int.add_congr",
   "Lean.Omega.Constraint.isImpossible",
   "Function.comp",
   "Int.sub_nonneg_of_le",
   "OfNat.ofNat",
   "LT.lt",
   "HAdd.hAdd",
   "CellularAutomatas.Advice.f",
   "List.range",
   "Lean.Omega.LinearCombo.coordinate_eval_1",
   "Lean.Omega.LinearCombo.coordinate_eval_6",
   "Lean.Omega.Int.ofNat_lt_of_lt",
   "Lean.Omega.LinearCombo.sub_eval",
   "List.take",
   "LE.le",
   "Int.natCast_add",
   "CellularAutomatas.CA_rt",
   "Lean.Omega.LinearCombo.eval",
   "CellularAutomatas.tCellAutomaton.F_pos",
   "Lean.Omega.LinearCombo.coordinate_eval_5"],
  "name": "CellularAutomatas.CA_rt_to_TwoStage_eq._proof_1_6",
  "constType":
  "∀ {α : Type} [CellularAutomatas.Alphabet α] (C : ↑(CellularAutomatas.CA_rt α)) (w : CellularAutomatas.Word α),\n  ∀ i < List.length w,\n    (List.take (i + 1) w).length = i + 1 →\n      (↑C).t (i + 1) = i →\n        List.length ((↑C).scan_temporal_rt (List.take (i + 1) w)) = i + 1 → ¬i + 1 ≤ List.length w → False",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Omega.Constraint.upperBound",
   "Eq.trans",
   "Lean.Omega.Coeffs",
   "and_true",
   "Decidable.decide",
   "GE.ge",
   "congrArg",
   "Decidable.decide.congr_simp",
   "congr",
   "HSub.hSub",
   "Eq.symm",
   "Lean.Omega.Constraint.lowerBound",
   "decide_eq_true_eq",
   "Neg.neg",
   "Lean.Omega.UpperBound.sat",
   "Lean.Omega.LowerBound.sat",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "eq_self",
   "Int.zero_sub",
   "LE.le",
   "id",
   "Eq.mpr",
   "Lean.Omega.Coeffs.dot",
   "Int.sub_left_le_of_le_add",
   "Lean.Omega.Constraint.sat'"],
  "name": "Lean.Omega.Constraint.addInequality_sat",
  "constType":
  "∀ {c : ℤ} {x y : Omega.Coeffs}, c + x.dot y ≥ 0 → { lowerBound := some (-c), upperBound := none }.sat' x y = true",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "CellularAutomatas.Word",
   "CellularAutomatas.FiniteStateTransducer.scanr_reduce_cons",
   "List.drop",
   "CellularAutomatas.FiniteStateTransducer.Q",
   "GetElem.getElem",
   "CellularAutomatas.FiniteStateTransducer.scanr_reduce",
   "List.drop_eq_getElem_cons",
   "CellularAutomatas.FiniteStateTransducer.scanr_get'_eq1._proof_1",
   "OfNat.ofNat",
   "congrArg",
   "HAdd.hAdd",
   "LT.lt",
   "Decidable.byContradiction",
   "Fin.val",
   "Fin.val_lt_of_le",
   "LE.le",
   "id",
   "Eq.mpr",
   "Fin.isLt",
   "CellularAutomatas.FiniteStateTransducer.scanr_reduce_drop._proof_1_3",
   "List.length",
   "CellularAutomatas.FiniteStateTransducer.δ"],
  "name": "CellularAutomatas.FiniteStateTransducer.scanr_reduce_drop",
  "constType":
  "∀ {α β : Type} {M : CellularAutomatas.FiniteStateTransducer α β} (w : CellularAutomatas.Word α)\n  (i : Fin (List.length w)), M.scanr_reduce w⟦↑i..*⟧ = M.δ (M.scanr_reduce w⟦↑i + 1..*⟧) w[i]",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CellularAutomatas.Advice.mk",
  "constType":
  "{α Γ : Type} →\n  (f : CellularAutomatas.Word α → CellularAutomatas.Word Γ) →\n    (∀ (w : CellularAutomatas.Word α), List.length (f w) = List.length w) → CellularAutomatas.Advice α Γ",
  "constCategory": "Other"},
 {"references": ["rfl", "HSub.hSub"],
  "name": "Nat.sub_succ",
  "constType": "∀ (n m : ℕ), n - m.succ = (n - m).pred",
  "constCategory": "Theorem"},
 {"references": ["Set"],
  "name": "Language",
  "constType": "Type u_4 → Type u_4",
  "constCategory": "Definition"},
 {"references": ["And.symm"],
  "name": "And.comm",
  "constType": "∀ {a b : Prop}, a ∧ b ↔ b ∧ a",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.lt_of_le_of_lt",
   "LT.lt",
   "absurd",
   "rfl",
   "_private.Init.Prelude.0.Nat.le_antisymm.match_1_1",
   "LE.le",
   "Nat.lt_irrefl"],
  "name": "Nat.le_antisymm",
  "constType": "∀ {n m : ℕ}, n ≤ m → m ≤ n → n = m",
  "constCategory": "Theorem"},
 {"references":
  ["Int.Linear.Poly.beq'",
   "Int.Linear.Poly.coeff",
   "Bool.not",
   "Int.Linear.Poly.combine_mul_k",
   "Neg.neg",
   "Int.beq'",
   "Bool.and'",
   "OfNat.ofNat",
   "Int.Linear.Var"],
  "name": "Int.Linear.diseq_eq_subst_cert",
  "constType":
  "Int.Linear.Var → Int.Linear.Poly → Int.Linear.Poly → Int.Linear.Poly → Bool",
  "constCategory": "Definition"},
 {"references":
  ["CellularAutomatas.Advice.f",
   "Finset.univ",
   "CellularAutomatas.Word",
   "CellularAutomatas.TwoStageAdvice.C",
   "CellularAutomatas.CArtTransducer.advice",
   "CellularAutomatas.FiniteStateTransducer.scanr_q",
   "Finset.image",
   "CellularAutomatas.FiniteStateTransducer.Q",
   "CellularAutomatas.TwoStageAdvice.β",
   "CellularAutomatas.TwoStageAdvice.M"],
  "name": "CellularAutomatas.possible_advice_prefixes",
  "constType":
  "{α : Type} →\n  [inst : CellularAutomatas.Alphabet α] →\n    {Γ : Type} →\n      [inst_1 : CellularAutomatas.Alphabet Γ] →\n        CellularAutomatas.TwoStageAdvice α Γ → CellularAutomatas.Word α → Finset (List Γ)",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Omega.Constraint.upperBound",
   "HAdd.hAdd",
   "Lean.Omega.Constraint.lowerBound",
   "Option.map",
   "Option.bind"],
  "name": "Lean.Omega.Constraint.add",
  "constType": "Omega.Constraint → Omega.Constraint → Omega.Constraint",
  "constCategory": "Definition"},
 {"references":
  ["Eq.trans",
   "Std.le_refl",
   "LE.le",
   "id",
   "iff_true",
   "Eq.mpr",
   "eq_iff_iff._simp_1"],
  "name": "Lean.Grind.Order.le_eq_true",
  "constType":
  "∀ {α : Type u_1} [inst : LE α] [Std.IsPreorder α] {a : α}, (a ≤ a) = True",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.FiniteStateTransducer.scanr_step",
   "CellularAutomatas.FiniteStateTransducer.Q"],
  "name": "CellularAutomatas.FiniteStateTransducer.scanr_step.eq_1",
  "constType":
  "∀ {α β : Type} (M : CellularAutomatas.FiniteStateTransducer α β) (a : α) (q : M.Q) (w : List β),\n  M.scanr_step a (q, w) = (M.δ q a, M.f (M.δ q a) :: w)",
  "constCategory": "Theorem"},
 {"references": ["rfl", "Nat.cast", "HMul.hMul"],
  "name": "Int.natCast_mul",
  "constType": "∀ (n m : ℕ), ↑(n * m) = ↑n * ↑m",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans",
   "Eq.mp",
   "Int.zero_add",
   "Int.Linear.Poly.denote",
   "HMul.hMul",
   "Lean.Data.AC.Context.eq_of_norm",
   "Int.one_mul",
   "congrArg",
   "Bool.casesOn",
   "Int.Linear.Var.denote",
   "congr",
   "Eq.symm",
   "Int.beq'",
   "Eq.ndrec",
   "Int.Linear.Poly.denote'.go",
   "Int.beq'_eq_beq",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "beq_iff_eq._simp_1",
   "eq_self",
   "Int.Linear.Context",
   "of_eq_true",
   "Int.add_comm",
   "id",
   "Eq.mpr",
   "BEq.beq",
   "Int.Linear.Var"],
  "name": "Int.Linear.Poly.denote'_go_eq_denote",
  "constType":
  "∀ (ctx : Int.Linear.Context) (p : Int.Linear.Poly) (r : ℤ),\n  Int.Linear.Poly.denote'.go ctx p r = Int.Linear.Poly.denote ctx p + r",
  "constCategory": "Theorem"},
 {"references":
  ["Finset.mem_def", "Finset.val", "Membership.mem", "Multiset", "propext"],
  "name": "_private.Mathlib.Data.Finset.Image.0.Finset.mem_image._simp_1_1",
  "constType": "∀ {α : Type u_1} {a : α} {s : Finset α}, (a ∈ s) = (a ∈ s.val)",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "implies_congr",
   "Lean.Grind.Ring.intCast",
   "Eq.trans",
   "Eq.mp",
   "BEq.rfl",
   "Int.blt'",
   "eq_iff_iff._simp_1",
   "iff_false",
   "Int.cast",
   "OfNat.ofNat",
   "congrArg",
   "HAdd.hAdd",
   "eq_self",
   "forall_const._simp_1",
   "Lean.Grind.Order.le_unsat_k",
   "LE.le",
   "id",
   "Lean.Grind.Order.le_trans_k",
   "Eq.mpr",
   "BEq.beq"],
  "name": "Lean.Grind.Order.le_eq_false_of_le_k",
  "constType":
  "∀ {α : Type u_1} [inst : LE α] [inst_1 : LT α] [LawfulOrderLT α] [inst_3 : Std.IsPreorder α] [inst_4 : Grind.Ring α]\n  [Grind.OrderedRing α] {a b : α} {k₁ k₂ : ℤ}, (k₂ + k₁).blt' 0 = true → a ≤ b + ↑k₁ → (b ≤ a + ↑k₂) = False",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Grind.CommRing.Poly.mulConst.go", "BEq.beq", "cond", "OfNat.ofNat"],
  "name": "Lean.Grind.CommRing.Poly.mulConst",
  "constType": "ℤ → Grind.CommRing.Poly → Grind.CommRing.Poly",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Omega.Constraint.sat", "Lean.Omega.Coeffs", "Lean.Omega.Coeffs.dot"],
  "name": "Lean.Omega.Constraint.sat'",
  "constType": "Omega.Constraint → Omega.Coeffs → Omega.Coeffs → Bool",
  "constCategory": "Definition"},
 {"references": ["CellularAutomatas.tCellAutomaton.L"],
  "name": "CellularAutomatas.instDefinesLanguageTCellAutomaton",
  "constType":
  "{α : Type} → CellularAutomatas.DefinesLanguage (CellularAutomatas.tCellAutomaton α) α",
  "constCategory": "Definition"},
 {"references": ["Nat.beq", "Int.beq'", "Bool.and'", "Int.Linear.Var"],
  "name": "Int.Linear.Poly.beq'",
  "constType": "Int.Linear.Poly → Int.Linear.Poly → Bool",
  "constCategory": "Definition"},
 {"references": ["List.casesOn"],
  "name": "List.ctorIdx",
  "constType": "{α : Type u} → List α → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["HAdd.hAdd",
   "AddLECancellable",
   "id",
   "Eq.mpr",
   "AddLECancellable.tsub_eq_of_eq_add",
   "add_comm",
   "congrArg"],
  "name": "AddLECancellable.add_tsub_cancel_right",
  "constType":
  "∀ {α : Type u_1} [inst : PartialOrder α] [inst_1 : AddCommSemigroup α] [inst_2 : Sub α] [OrderedSub α] {a b : α},\n  AddLECancellable b → a + b - b = a",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "Nat.add_sub_add_left",
   "id",
   "HSub.hSub",
   "Eq.mpr",
   "Nat.sub_zero",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Nat.add_sub_cancel_left",
  "constType": "∀ (n m : ℕ), n + m - n = m",
  "constCategory": "Theorem"},
 {"references": ["CellularAutomatas.marker_list"],
  "name": "CellularAutomatas.marker_list.eq_1",
  "constType":
  "∀ (n pos : ℕ), CellularAutomatas.marker_list n pos = List.map (fun i => i + 1 == pos) (List.range n)",
  "constCategory": "Theorem"},
 {"references": ["List.casesOn"],
  "name": "_private.Init.Data.List.Zip.0.List.zip_eq_zipWith.match_1_1",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} (motive : List α → List β → Prop) (x : List α) (x_1 : List β),\n  (∀ (x : List β), motive [] x) →\n    (∀ (x : List α), motive x []) →\n      (∀ (a : α) (l₁ : List α) (b : β) (l₂ : List β), motive (a :: l₁) (b :: l₂)) → motive x x_1",
  "constCategory": "Definition"},
 {"references": ["absurd", "Not", "Or.elim", "id"],
  "name": "Or.resolve_right",
  "constType": "∀ {a b : Prop}, a ∨ b → ¬b → a",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "Eq.trans",
   "Membership.mem",
   "Classical.propDecidable",
   "eq_true",
   "Lean.Grind.intro_with_eq'",
   "CellularAutomatas.advice_len",
   "List.getLast?",
   "Inhabited.default",
   "GetElem?.getElem?",
   "False.elim",
   "Lean.Grind.forall_imp_eq_or",
   "eq_of_heq",
   "funext",
   "Eq.symm",
   "forall_prop_domain_congr",
   "Lean.Grind.forall_propagator",
   "Finset.filter",
   "Lean.Grind.nestedDecidable_congr",
   "getElem?_pos",
   "List.getElem_of_getElem?",
   "Option.getD",
   "Language",
   "Lean.Grind.nestedProof",
   "Finset.toList",
   "Exists.casesOn",
   "Iff.of_eq",
   "eq_false",
   "Iff.mpr",
   "Classical.byContradiction",
   "id",
   "setOf",
   "List.length",
   "Eq.substr",
   "Option.some.inj",
   "Eq.mp",
   "CellularAutomatas.PrefixStableProof.f._proof_1_4",
   "DecidablePred",
   "GetElem.getElem",
   "congrArg",
   "Lean.Grind.imp_eq_of_eq_true_left",
   "Lean.Grind.Nat.lt_eq",
   "or_false",
   "Lean.Grind.nestedDecidable",
   "CellularAutomatas.PrefixStableProof.f._proof_1_3",
   "List.head?",
   "propext",
   "Not",
   "CellularAutomatas.Word",
   "Finset.univ",
   "Set.mem_setOf_eq",
   "Lean.Grind.em",
   "Lean.Grind.alreadyNorm",
   "Set",
   "OfNat.ofNat",
   "Eq.mpr_prop",
   "exists_prop_congr",
   "LT.lt",
   "CellularAutomatas.Advice.f",
   "HAdd.hAdd",
   "Or.casesOn",
   "of_eq_true",
   "List.take",
   "LE.le"],
  "name": "CellularAutomatas.PrefixStableProof.f._proof_1_5",
  "constType":
  "∀ {α Γ : Type} [inst : CellularAutomatas.Alphabet Γ] (adv : CellularAutomatas.Advice α Γ) (w : CellularAutomatas.Word α)\n  (i : ℕ) (h_i : i < List.length w),\n  adv.f (List.take (i + 1) w) = List.take (i + 1) (adv.f w) →\n    some ({c | List.getLast? (adv.f (List.take (i + 1) w)) = some c}.toList.head?.getD default) = (adv.f w)[i]? →\n      {c | List.take (i + 1) w ∈ {w | List.getLast? (adv.f w) = some c}}.toList.head?.getD default = (adv.f w)[i]",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.Word", "CellularAutomatas.Advice.casesOn", "List.length"],
  "name": "CellularAutomatas.Advice.noConfusionType",
  "constType":
  "{α Γ : Type} → Sort u → CellularAutomatas.Advice α Γ → CellularAutomatas.Advice α Γ → Sort u",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Omega.Constraint.combine",
   "Lean.Omega.Constraint.sat",
   "Lean.Omega.Coeffs",
   "Eq.mpr",
   "Lean.Omega.Constraint.combine_sat",
   "Lean.Omega.Coeffs.dot",
   "Lean.Omega.Constraint.sat'"],
  "name": "Lean.Omega.Constraint.combine_sat'",
  "constType":
  "∀ {s t : Omega.Constraint} {x y : Omega.Coeffs}, s.sat' x y = true → t.sat' x y = true → (s.combine t).sat' x y = true",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CellularAutomatas.backwards_fsm.Params.inst1",
  "constType":
  "(self : CellularAutomatas.backwards_fsm.Params) → CellularAutomatas.Alphabet self.α",
  "constCategory": "Definition"},
 {"references": ["Array.size", "Nat.le_refl"],
  "name": "Array.forIn'._proof_2",
  "constType": "∀ {α : Type u_1} (as : Array α), as.size ≤ as.size",
  "constCategory": "Theorem"},
 {"references":
  ["List.range",
   "HAdd.hAdd",
   "CellularAutomatas.Word",
   "List.extract",
   "CellularAutomatas.Advice.prefixes_in_L._proof_1",
   "List.map",
   "DecidablePred",
   "Language",
   "Decidable.decide",
   "OfNat.ofNat",
   "List.length"],
  "name": "CellularAutomatas.Advice.prefixes_in_L",
  "constType":
  "{α : Type} → (L : Language α) → [h : DecidablePred L] → CellularAutomatas.Advice α Bool",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CellularAutomatas.LCellAutomaton.embed",
  "constType":
  "{α : Type} → (self : CellularAutomatas.LCellAutomaton α) → α → self.Q",
  "constCategory": "Definition"},
 {"references": ["Bool.and", "Bool.and'_eq_and", "Eq.symm", "Bool.and'"],
  "name":
  "_private.Init.Grind.Ring.CommSolver.0.Lean.Grind.CommRing.Poly.beq'_eq._simp_1_2",
  "constType": "∀ (a b : Bool), (a && b) = a.and' b",
  "constCategory": "Theorem"},
 {"references": ["propext"],
  "name": "Eq.propIntro",
  "constType": "∀ {a b : Prop}, (a → b) → (b → a) → a = b",
  "constCategory": "Theorem"},
 {"references":
  ["OrderDual.toDual",
   "OrderDual",
   "Monotone",
   "Iff.mpr",
   "Function.comp",
   "monotone_dual_iff",
   "DFunLike.coe",
   "OrderDual.ofDual"],
  "name": "Monotone.dual",
  "constType":
  "∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : Preorder β] {f : α → β},\n  Monotone f → Monotone (⇑OrderDual.toDual ∘ f ∘ ⇑OrderDual.ofDual)",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "SizeOf.sizeOf",
   "CellularAutomatas.CellAutomaton.Q",
   "OfNat.ofNat"],
  "name": "CellularAutomatas.CArtTransducer.mk.sizeOf_spec",
  "constType":
  "∀ {α Γ : Type} [inst : CellularAutomatas.Alphabet α] [inst_1 : CellularAutomatas.Alphabet Γ] [inst_2 : SizeOf α]\n  [inst_3 : SizeOf Γ] (toLCellAutomaton : CellularAutomatas.LCellAutomaton α) (f : toLCellAutomaton.Q → Γ),\n  sizeOf { toLCellAutomaton := toLCellAutomaton, f := f } = 1 + sizeOf toLCellAutomaton",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CellularAutomatas.tCellAutomatonWithAdvice.recOn",
  "constType":
  "{α : Type} →\n  {motive : CellularAutomatas.tCellAutomatonWithAdvice α → Sort u} →\n    (t : CellularAutomatas.tCellAutomatonWithAdvice α) →\n      ((Γ : Type) →\n          [alphabetΓ : CellularAutomatas.Alphabet Γ] →\n            (adv : CellularAutomatas.Advice α Γ) →\n              (C : CellularAutomatas.tCellAutomaton (α ⨉ Γ)) →\n                motive { Γ := Γ, alphabetΓ := alphabetΓ, adv := adv, C := C }) →\n        motive t",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CellularAutomatas.LCellAutomaton.border",
  "constType":
  "{α : Type} → (self : CellularAutomatas.LCellAutomaton α) → self.Q",
  "constCategory": "Definition"},
 {"references":
  ["Int.add_le_add_right",
   "HAdd.hAdd",
   "Eq.mp",
   "Int.zero_add",
   "LE.le",
   "Int.sub_add_cancel",
   "HSub.hSub",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Int.le_of_sub_nonpos",
  "constType": "∀ {a b : ℤ}, a - b ≤ 0 → a ≤ b",
  "constCategory": "Theorem"},
 {"references": ["Subtype.forall", "propext"],
  "name": "CellularAutomatas.CellAutomaton.quiescent_of_dead._simp_1_2",
  "constType":
  "∀ {α : Sort u} {p : α → Prop} {q : { a // p a } → Prop}, (∀ (x : { a // p a }), q x) = ∀ (a : α) (b : p a), q ⟨a, b⟩",
  "constCategory": "Theorem"},
 {"references": ["eq_self", "of_eq_true", "List.length"],
  "name": "List.size_toArray",
  "constType": "∀ {α : Type u} {as : List α}, as.toArray.size = as.length",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CellularAutomatas.VerificationError.module",
  "constType": "CellularAutomatas.VerificationError → Name",
  "constCategory": "Definition"},
 {"references":
  ["LT.lt",
   "Not",
   "Int.lt_iff_le_not_le",
   "Int.le_total",
   "Iff.mpr",
   "LE.le",
   "Or.resolve_right"],
  "name": "Int.lt_of_not_ge",
  "constType": "∀ {a b : ℤ}, ¬a ≤ b → b < a",
  "constCategory": "Theorem"},
 {"references":
  ["rfl",
   "HAdd.hAdd",
   "Nat.add_left_cancel",
   "Unit",
   "_private.Init.Data.Nat.Lemmas.0.Nat.add_left_cancel_iff.match_1_1"],
  "name": "Nat.add_left_cancel_iff",
  "constType": "∀ {m k n : ℕ}, n + m = n + k ↔ m = k",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.Word.get'",
   "CellularAutomatas.Word.get'._proof_1",
   "Int.toNat",
   "Nat.cast",
   "Eq.trans",
   "Eq.mp",
   "Membership.mem",
   "eq_true",
   "GetElem.getElem",
   "GE.ge",
   "Nat.cast_nonneg._simp_1",
   "congrArg",
   "False.elim",
   "congr",
   "funext",
   "not_true_eq_false",
   "CellularAutomatas.Word.range",
   "CellularAutomatas.Word.get'?",
   "Eq.ndrec",
   "ge_iff_le._simp_1",
   "Not",
   "CellularAutomatas.Word",
   "Set",
   "Option.getD",
   "OfNat.ofNat",
   "LT.lt",
   "eq_self",
   "and_self",
   "of_eq_true",
   "dite_cond_eq_true",
   "LE.le",
   "id",
   "dite",
   "Fin.isLt",
   "Nat.cast_lt._simp_1",
   "setOf",
   "List.length"],
  "name": "CellularAutomatas.backwards_fsm.Word.get'_eq",
  "constType":
  "∀ {α : Type u_1} (w : CellularAutomatas.Word α) (i : ℕ) (h : i < List.length w) (val : α), (w.get'? ↑i).getD val = w[i]",
  "constCategory": "Theorem"},
 {"references": ["Int.Linear.Expr.casesOn", "Int.Linear.Var"],
  "name": "Int.Linear.Expr.denote.match_1",
  "constType":
  "(motive : Int.Linear.Expr → Sort u_1) →\n  (x : Int.Linear.Expr) →\n    ((a b : Int.Linear.Expr) → motive (a.add b)) →\n      ((a b : Int.Linear.Expr) → motive (a.sub b)) →\n        ((a : Int.Linear.Expr) → motive a.neg) →\n          ((k : ℤ) → motive (Int.Linear.Expr.num k)) →\n            ((v : Int.Linear.Var) → motive (Int.Linear.Expr.var v)) →\n              ((k : ℤ) → (e : Int.Linear.Expr) → motive (Int.Linear.Expr.mulL k e)) →\n                ((e : Int.Linear.Expr) → (k : ℤ) → motive (e.mulR k)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["_auto._@.Std.Data.TreeSet.Basic.2624796985._hygCtx._hyg.15", "autoParam"],
  "name": "Std.TreeSet.inner",
  "constType":
  "{α : Type u} → {cmp : autoParam (α → α → Ordering) _auto✝} → TreeSet α cmp → TreeMap α Unit cmp",
  "constCategory": "Definition"},
 {"references": ["Nat.le_min"],
  "name": "Nat.lt_min",
  "constType": "∀ {a b c : ℕ}, a < min b c ↔ a < b ∧ a < c",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Omega.LinearCombo.coordinate_eval_2",
   "Nat.cast",
   "Eq.trans",
   "le_of_le_of_eq",
   "Lean.Omega.LinearCombo.coordinate_eval_0",
   "Lean.Omega.Constraint.combine_sat'",
   "Decidable.decide",
   "Lean.Omega.Coeffs.ofList",
   "HSub.hSub",
   "Lean.Omega.tidy_sat",
   "Eq.symm",
   "Lean.Omega.LinearCombo.add_eval",
   "Lean.Omega.Int.lt_of_not_le",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "Int.add_one_le_of_lt",
   "And.left",
   "of_decide_eq_true",
   "Not",
   "Neg.neg",
   "Lean.Omega.Constraint.addInequality_sat",
   "Lean.Omega.Int.add_congr",
   "Lean.Omega.Constraint.isImpossible",
   "Lean.Omega.LinearCombo.coordinate",
   "OfNat.ofNat",
   "Int.sub_nonneg_of_le",
   "Lean.Omega.LinearCombo.coordinate_eval_1",
   "HAdd.hAdd",
   "Lean.Omega.LinearCombo.sub_eval",
   "LE.le",
   "Int.natCast_add",
   "id",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.Int.sub_congr"],
  "name": "CellularAutomatas.nextt_congr._proof_1_5",
  "constType":
  "∀ (t : ℕ) (i j : ℤ), i - ↑t ≤ j ∧ j ≤ i + ↑t → ¬i - ↑(t + 1) ≤ j - 1 → False",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "LT.lt",
   "_private.Init.Prelude.0.Lean.Name.hash.match_1",
   "Lean.Name.brecOn",
   "_private.Init.Prelude.0.Lean.Name.hash._proof_2",
   "UInt64.ofNatLT",
   "dite",
   "Lean.Name.below",
   "UInt64.size",
   "_private.Init.Prelude.0.Lean.Name.hash._proof_1",
   "OfNat.ofNat",
   "Unit"],
  "name": "Lean.Name.hash",
  "constType": "Name → UInt64",
  "constCategory": "Definition"},
 {"references":
  ["Int.Linear.Poly.beq'", "Int.Linear.Poly.combine_mul_k", "Neg.neg"],
  "name": "Int.Linear.eq_eq_subst'_cert",
  "constType":
  "ℤ → ℤ → Int.Linear.Poly → Int.Linear.Poly → Int.Linear.Poly → Bool",
  "constCategory": "Definition"},
 {"references":
  ["Int.natCast_nonneg._simp_1",
   "Eq.trans",
   "of_eq_true",
   "Int.neg_le_zero_iff._simp_1",
   "NatCast.natCast",
   "Neg.neg",
   "LE.le",
   "HMul.hMul",
   "Int.neg_one_mul",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Nat.ToInt.toNat_nonneg",
  "constType": "∀ (x : ℕ), -1 * ↑x ≤ 0",
  "constCategory": "Theorem"},
 {"references":
  ["HasSubset.Subset",
   "Finset.val",
   "Iff.mpr",
   "Multiset.card_le_card",
   "Finset.card",
   "LE.le",
   "Function.comp",
   "Finset.val_le_iff",
   "Multiset"],
  "name": "Finset.card_le_card",
  "constType": "∀ {α : Type u_1} {s t : Finset α}, s ⊆ t → s.card ≤ t.card",
  "constCategory": "Theorem"},
 {"references":
  ["Int.natCast_inj", "Nat.cast", "NatCast.natCast", "Iff.mp", "Eq.ndrec"],
  "name": "Lean.Grind.Order.nat_eq",
  "constType": "∀ (a b : ℕ) (x y : ℤ), ↑a = x → ↑b = y → x = y → a = b",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.cast_one",
   "CellularAutomatas.Word.get'",
   "Eq.trans",
   "CellularAutomatas.CellAutomaton.next",
   "CellularAutomatas.backwards_fsm.Params.inst3",
   "Membership.mem",
   "eq_true",
   "CellularAutomatas.Config",
   "CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "congrFun",
   "CellularAutomatas.LCellAutomaton.comp_succ_eq",
   "HSub.hSub",
   "CellularAutomatas.Word.range",
   "CellularAutomatas.Word.get'?",
   "Eq.ndrec",
   "CellularAutomatas.backwards_fsm.Params.α",
   "CellularAutomatas.Word.get'.congr_simp",
   "And.left",
   "rfl",
   "CellularAutomatas.CellAutomaton.δ",
   "CellularAutomatas.CArtTransducer.toLCellAutomaton",
   "List.drop",
   "CellularAutomatas.backwards_fsm.Params.β",
   "CellularAutomatas.backwards_fsm.Params.M",
   "CellularAutomatas.FiniteStateTransducer.scanr",
   "Nat.recAux",
   "Prod.snd",
   "CellularAutomatas.backwards_fsm.Params.inst2",
   "add_zero",
   "CellularAutomatas.LCellAutomaton.comp",
   "Decidable.byContradiction",
   "eq_false",
   "CellularAutomatas.backwards_fsm.inv._proof_1_5",
   "id",
   "Eq.mpr",
   "CellularAutomatas.backwards_fsm.inv._proof_1_9",
   "CellularAutomatas.LCellAutomaton.comp_zero",
   "CellularAutomatas.backwards_fsm.inv._proof_1_7",
   "Int.toNat",
   "CellularAutomatas.backwards_fsm.inv._proof_1_6",
   "Nat.cast",
   "CellularAutomatas.backwards_fsm.C'",
   "CellularAutomatas.backwards_fsm.Params.C",
   "Eq.mp",
   "CellularAutomatas.FiniteStateTransducer.δ?",
   "CellularAutomatas.FiniteStateTransducer.Q",
   "CellularAutomatas.FiniteStateTransducer.scanr_reduce",
   "CellularAutomatas.backwards_fsm.Params.γ",
   "Prod.fst",
   "congrArg",
   "CellularAutomatas.LCellAutomaton.embed",
   "dite_congr",
   "CellularAutomatas.backwards_fsm.inv._proof_1_4",
   "congr",
   "CellularAutomatas.LCellAutomaton.embed_word",
   "CellularAutomatas.CellAutomaton.Q",
   "CellularAutomatas.FiniteStateTransducer.scanr_reduce'?",
   "dite_cond_eq_false",
   "CellularAutomatas.LCellAutomaton.border",
   "Not",
   "CellularAutomatas.Word",
   "CellularAutomatas.backwards_fsm.inv._proof_1_8",
   "Set",
   "OfNat.ofNat",
   "Eq.mpr_prop",
   "Nat.cast_add",
   "HAdd.hAdd",
   "CellularAutomatas.backwards_fsm.inv._proof_1_10",
   "eq_self",
   "CellularAutomatas.FiniteStateTransducer.range_of_scanr",
   "CellularAutomatas.backwards_fsm.inv._proof_1_3",
   "CellularAutomatas.backwards_fsm.scanr_get'_eq2",
   "of_eq_true",
   "dite_cond_eq_true",
   "CharP.cast_eq_zero",
   "dite",
   "CellularAutomatas.FiniteStateTransducer.f"],
  "name": "CellularAutomatas.backwards_fsm.inv",
  "constType":
  "∀ (e : CellularAutomatas.backwards_fsm.Params) (w : CellularAutomatas.Word e.α) (t : ℕ) (p : ℤ),\n  have c' := (CellularAutomatas.backwards_fsm.C' e).comp w t p;\n  have q := e.M.scanr_reduce w⟦(p + ↑t).toNat..*⟧;\n  c'.2 q = e.C.comp (e.M.scanr w) t p ∧ c'.1 = w.get'? (p + ↑t)",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "Nat.cast",
   "_private.Init.Omega.Int.0.Lean.Omega.Int.ofNat_min._simp_1_1",
   "ite",
   "Decidable.casesOn",
   "congrArg",
   "ite_congr",
   "if_neg",
   "Min.min",
   "congr",
   "LE.le",
   "id",
   "Eq.mpr",
   "if_pos"],
  "name": "Lean.Omega.Int.ofNat_min",
  "constType": "∀ (a b : ℕ), ↑(min a b) = min ↑a ↑b",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "eq_self",
   "Eq.trans",
   "of_eq_true",
   "Int.add_zero",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Int.sub_zero",
  "constType": "∀ (a : ℤ), a - 0 = a",
  "constCategory": "Theorem"},
 {"references": ["Nat.not_le_of_gt", "LT.lt", "LE.le", "flip"],
  "name": "Nat.not_lt_of_le",
  "constType": "∀ {a b : ℕ}, a ≤ b → ¬b < a",
  "constCategory": "Theorem"},
 {"references": ["Bool.and", "Bool.casesOn", "Eq.symm", "Eq.ndrec"],
  "name": "Bool.true_and",
  "constType": "∀ (b : Bool), (true && b) = b",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.not_lt_of_le",
   "Eq.trans",
   "GetElem.getElem",
   "List.take_nil",
   "congrArg",
   "GetElem?.getElem?",
   "congr",
   "Eq.symm",
   "Eq.ndrec",
   "Nat.casesAuxOn",
   "getElem?_pos",
   "List.casesOn",
   "Nat.lt_of_succ_lt_succ",
   "Nat.recAux",
   "Nat.zero_le",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "absurd",
   "LT.lt",
   "eq_self",
   "of_eq_true",
   "List.take",
   "id",
   "Nat.zero_lt_succ._simp_1",
   "List.length"],
  "name": "List.getElem?_take_of_lt",
  "constType":
  "∀ {α : Type u_1} {l : List α} {i j : ℕ}, i < j → (List.take j l)[i]? = l[i]?",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "sorryAx",
  "constType": "(α : Sort u) → Bool → α",
  "constCategory": "Axiom"},
 {"references": ["Not", "Classical.propDecidable.match_1", "Classical.em"],
  "name": "Classical.propDecidable._proof_1",
  "constType": "∀ (a : Prop), Nonempty (Decidable a)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CellularAutomatas.AlphabetBool",
  "constType": "CellularAutomatas.Alphabet Bool",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Lean.MonadQuotation.getCurrMacroScope",
  "constType": "{m : Type → Type} → [self : MonadQuotation m] → m MacroScope",
  "constCategory": "Definition"},
 {"references": ["CellularAutomatas.backwards_fsm.spec._proof_1_1"],
  "name": "CellularAutomatas.backwards_fsm.spec",
  "constType":
  "∀ {α β γ : Type} [inst : CellularAutomatas.Alphabet α] [inst_1 : CellularAutomatas.Alphabet β]\n  [inst_2 : CellularAutomatas.Alphabet γ] {M : CellularAutomatas.FiniteStateTransducer α β}\n  {C : CellularAutomatas.CArtTransducer β γ},\n  C.advice.f ∘ M.advice.f =\n    (CellularAutomatas.backwards_fsm.M'\n            { α := α, β := β, γ := γ, inst1 := inst, inst2 := inst_1, inst3 := inst_2, M := M, C := C }).advice.f ∘\n      (CellularAutomatas.backwards_fsm.C'\n            { α := α, β := β, γ := γ, inst1 := inst, inst2 := inst_1, inst3 := inst_2, M := M, C := C }).advice.f",
  "constCategory": "Theorem"},
 {"references": ["HDiv.hDiv", "OfNat.ofNat"],
  "name": "CellularAutomatas.middle_idx",
  "constType": "ℕ → ℕ",
  "constCategory": "Definition"},
 {"references": [],
  "name": "IntCast.intCast",
  "constType": "{R : Type u} → [self : IntCast R] → ℤ → R",
  "constCategory": "Definition"},
 {"references":
  ["Int.mul",
   "Int.Linear.Expr.toPoly'.go.match_1",
   "Neg.neg",
   "id",
   "Int.Linear.Expr.below",
   "Function.comp",
   "Int.Linear.Poly.addConst",
   "BEq.beq",
   "cond",
   "Int.Linear.Expr.brecOn",
   "OfNat.ofNat",
   "Int.Linear.Var"],
  "name": "Int.Linear.Expr.toPoly'.go",
  "constType": "ℤ → Int.Linear.Expr → Int.Linear.Poly → Int.Linear.Poly",
  "constCategory": "Definition"},
 {"references":
  ["CellularAutomatas.Word",
   "Eq.trans",
   "List.map",
   "Nat.log2",
   "HPow.hPow",
   "List.length_map",
   "OfNat.ofNat",
   "congrArg",
   "List.range",
   "implies_true",
   "eq_self",
   "List.length_range",
   "of_eq_true",
   "forall_congr",
   "BEq.beq",
   "List.length"],
  "name": "CellularAutomatas.Advice.exp._proof_1",
  "constType":
  "∀ {α : Type} (a : CellularAutomatas.Word α),\n  (List.map (fun i => i == 2 ^ i.log2) (List.range (List.length a))).length = List.length a",
  "constCategory": "Theorem"},
 {"references": ["DecidableEq", "CellularAutomatas.Alphabet.casesOn"],
  "name": "CellularAutomatas.Alphabet.noConfusionType",
  "constType":
  "{α : Type} → Sort u → CellularAutomatas.Alphabet α → CellularAutomatas.Alphabet α → Sort u",
  "constCategory": "Definition"},
 {"references":
  ["implies_true",
   "eq_self",
   "Eq.trans",
   "of_eq_true",
   "Lean.Grind.AC.Seq.denote",
   "implies_congr_ctx",
   "congrArg"],
  "name": "Lean.Grind.AC.eq_simp_lhs_exact",
  "constType":
  "∀ {α : Sort u_1} (ctx : Grind.AC.Context α) (lhs₁ rhs₁ rhs₂ : Grind.AC.Seq),\n  Grind.AC.Seq.denote ctx lhs₁ = Grind.AC.Seq.denote ctx rhs₁ →\n    Grind.AC.Seq.denote ctx lhs₁ = Grind.AC.Seq.denote ctx rhs₂ →\n      Grind.AC.Seq.denote ctx rhs₁ = Grind.AC.Seq.denote ctx rhs₂",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.PrettyPrinter.UnexpandM",
   "Lean.TSyntax.raw",
   "EStateM",
   "Lean.Name.mkStr3",
   "Lean.Syntax.isOfKind",
   "Lean.MonadQuotation.getCurrMacroScope",
   "Lean.MacroScope",
   "Lean.Syntax.matchesNull",
   "Lean.Syntax.node4",
   "Lean.MonadRef.mkInfoFromRefPos",
   "Lean.MonadQuotation.getContext",
   "Unit.unit",
   "MonadExcept.throw",
   "Lean.Name.mkStr4",
   "Bind.bind",
   "Lean.SyntaxNodeKind",
   "Lean.Name.mkStr1",
   "ite",
   "Bool.or",
   "cond",
   "OfNat.ofNat",
   "Unit",
   "Lean.Syntax.getArg",
   "Pure.pure",
   "Lean.withRef"],
  "name":
  "CellularAutomatas.Word._aux_CellularAutomatas_defs___unexpand_List_drop_1",
  "constType": "PrettyPrinter.Unexpander",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CellularAutomatas.simulation.Q1.rec",
  "constType":
  "{e : CellularAutomatas.simulation.Params} →\n  {motive : CellularAutomatas.simulation.Q1 e → Sort u} →\n    ((state : e.C_ctl.Q) → (counter : Fin 3) → motive { state := state, counter := counter }) →\n      (t : CellularAutomatas.simulation.Q1 e) → motive t",
  "constCategory": "Other"},
 {"references":
  ["CellularAutomatas.CellAutomaton.δ", "CellularAutomatas.CellAutomaton.Q"],
  "name": "CellularAutomatas.CellAutomaton.initial",
  "constType": "(C : CellularAutomatas.CellAutomaton) → C.Q → Prop",
  "constCategory": "Definition"},
 {"references": ["outParam"],
  "name": "Lean.Grind.ToInt.toInt_mem",
  "constType":
  "∀ {α : Type u} {range : outParam Grind.IntInterval} [self : Grind.ToInt α range] (x : α), ↑x ∈ range",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "Int.toNat",
   "Eq.trans",
   "Eq.mp",
   "Membership.mem",
   "eq_true",
   "eagerReduce",
   "HMul.hMul",
   "Nat.Linear.ExprCnstr.eq_of_toNormPoly_eq",
   "IntCast.intCast",
   "CellularAutomatas.LcInRt.DiagonalShiftCA_comp_p0._proof_1_3",
   "Lean.Grind.dite_cond_eq_false'",
   "Nat.ToInt.natCast_ofNat",
   "congrArg",
   "Lean.Grind.Order.int_lt",
   "Lean.Grind.Nat.lt_eq",
   "GetElem?.getElem?",
   "Nat.not_le_eq",
   "Lean.Grind.nestedDecidable",
   "List.get",
   "NatCast.natCast",
   "Lean.Grind.eq_false_of_imp_eq_true",
   "Eq.symm",
   "Lean.Grind.Order.lt_of_not_le_k",
   "Not",
   "of_eq_false",
   "Neg.neg",
   "Set",
   "Lean.Grind.Order.le_eq_true_of_le_k",
   "CellularAutomatas.LcInRt.DiagonalShiftCA_comp_p0._proof_1_2",
   "Nat.ToInt.add_congr",
   "Lean.Grind.Order.eq_mp_not",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "LT.lt",
   "Lean.Grind.eq_congr'",
   "Nat.ToInt.le_eq",
   "of_eq_true",
   "eq_false",
   "LE.le",
   "id",
   "Lean.Grind.Order.eq_trans_false'",
   "Lean.Grind.CommRing.le_norm_expr",
   "dite",
   "Lean.Grind.Order.eq_trans_true",
   "getElem?_neg",
   "List.length",
   "setOf"],
  "name": "CellularAutomatas.LcInRt.DiagonalShiftCA_comp_p0._proof_1_6",
  "constType":
  "∀ {α : Type} {t : ℕ} (w : List α),\n  ¬(if h : ↑t ∈ {i | -1 * i ≤ 0 ∧ i + -1 * ↑w.length + 1 ≤ 0} then some (w.get ⟨(↑t).toNat, ⋯⟩) else none) = w[t]? →\n    ↑t ∉ {i | -1 * i ≤ 0 ∧ i + -1 * ↑w.length + 1 ≤ 0} → t < w.length",
  "constCategory": "Theorem"},
 {"references": ["Neg.neg", "Eq.ndrec"],
  "name": "Lean.Omega.Int.neg_congr",
  "constType": "∀ {a b : ℤ}, a = b → -a = -b",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Eq.ndrec",
  "constType":
  "{α : Sort u2} → {a : α} → {motive : α → Sort u1} → motive a → {b : α} → a = b → motive b",
  "constCategory": "Definition"},
 {"references": ["Nat.Linear.Var"],
  "name": "Nat.Linear.Expr.below",
  "constType":
  "{motive : Nat.Linear.Expr → Sort u} → Nat.Linear.Expr → Sort (max 1 u)",
  "constCategory": "Definition"},
 {"references":
  ["List.casesOn",
   "Membership.mem",
   "HMul.hMul",
   "Int.add_zero",
   "_private.Init.Omega.IntList.0.List.mem_cons_of_mem",
   "OfNat.ofNat",
   "congrArg",
   "HAdd.hAdd",
   "Int.zero_mul",
   "Lean.Omega.IntList",
   "Eq.symm",
   "id",
   "Lean.Omega.IntList.dot_cons₂",
   "_private.Init.Omega.IntList.0.List.mem_cons_self",
   "Eq.mpr",
   "Lean.Omega.IntList.dot",
   "Eq.ndrec"],
  "name": "Lean.Omega.IntList.dot_eq_zero_of_left_eq_zero",
  "constType": "∀ {xs ys : Omega.IntList}, (∀ x ∈ xs, x = 0) → xs.dot ys = 0",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Eq.trans",
   "of_eq_true",
   "Neg.neg",
   "HMul.hMul",
   "Int.neg_neg",
   "Int.neg_mul",
   "Int.mul_neg",
   "congrArg"],
  "name": "Int.neg_mul_neg",
  "constType": "∀ (a b : ℤ), -a * -b = a * b",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.Linear.Context",
   "Nat.Linear.Poly.denote_le",
   "Nat.Linear.Poly.cancel",
   "Nat.Linear.Poly.denote_le_cancel",
   "propext",
   "Nat.Linear.Poly.of_denote_le_cancel",
   "Nat.Linear.Poly"],
  "name": "Nat.Linear.Poly.denote_le_cancel_eq",
  "constType":
  "∀ (ctx : Nat.Linear.Context) (m₁ m₂ : Nat.Linear.Poly),\n  Nat.Linear.Poly.denote_le ctx (m₁.cancel m₂) = Nat.Linear.Poly.denote_le ctx (m₁, m₂)",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.CellAutomaton.nextt",
   "CellularAutomatas.CellAutomaton.Q",
   "CellularAutomatas.Config"],
  "name": "CellularAutomatas.CellAutomaton.nextt.eq_1",
  "constType":
  "∀ (C : CellularAutomatas.CellAutomaton), C.nextt = CellularAutomatas.apply_iterated C.next",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.le_refl._simp_1",
   "Nat.min_eq_right",
   "Eq.trans",
   "List.casesOn",
   "Nat.min_eq_left",
   "OfNat.ofNat",
   "congrArg",
   "HAdd.hAdd",
   "eq_self",
   "Nat.succ_min_succ",
   "of_eq_true",
   "Min.min",
   "congr",
   "Nat.add_left_cancel_iff._simp_1",
   "List.zipWith_nil_right",
   "LE.le",
   "Eq.symm",
   "List.zipWith",
   "Eq.ndrec",
   "Nat.le_add_left._simp_1",
   "List.length"],
  "name": "List.length_zipWith",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} {f : α → β → γ} {l₁ : List α} {l₂ : List β},\n  (List.zipWith f l₁ l₂).length = min l₁.length l₂.length",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.Linear.Context",
   "Nat.Linear.PolyCnstr.rhs",
   "Nat.Linear.PolyCnstr.eq",
   "Nat.Linear.Poly.denote_eq",
   "Nat.Linear.Poly.denote_le",
   "Nat.Linear.PolyCnstr.lhs",
   "cond",
   "Nat.Linear.Poly"],
  "name": "Nat.Linear.PolyCnstr.denote",
  "constType": "Nat.Linear.Context → Nat.Linear.PolyCnstr → Prop",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CellularAutomatas.CellAutomaton.rec",
  "constType":
  "{motive : CellularAutomatas.CellAutomaton → Sort u} →\n  ((Q : Type) →\n      [alphabetQ : CellularAutomatas.Alphabet Q] →\n        (δ : Q → Q → Q → Q) → motive { Q := Q, alphabetQ := alphabetQ, δ := δ }) →\n    (t : CellularAutomatas.CellAutomaton) → motive t",
  "constCategory": "Other"},
 {"references":
  ["Lean.Syntax.getPos?", "_private.Init.Prelude.0.Lean.replaceRef.match_1"],
  "name": "Lean.replaceRef",
  "constType": "Syntax → Syntax → Syntax",
  "constCategory": "Definition"},
 {"references": ["Option.getD.match_1", "Unit"],
  "name": "Option.getD",
  "constType": "{α : Type u_1} → Option α → α → α",
  "constCategory": "Definition"},
 {"references":
  ["Prod.casesOn",
   "List.casesOn",
   "Unit.unit",
   "Nat.Linear.Var",
   "Unit",
   "Nat.Linear.Poly"],
  "name":
  "_private.Init.Data.Nat.Linear.0.Nat.Linear.Poly.denote_norm_go.match_1_1",
  "constType":
  "∀ (motive : Nat.Linear.Poly → Prop) (p : Nat.Linear.Poly),\n  (∀ (a : Unit), motive []) →\n    (∀ (k : ℕ) (v : Nat.Linear.Var) (p : List (ℕ ⨉ Nat.Linear.Var)), motive ((k, v) :: p)) → motive p",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CellularAutomatas.composition.Params.β",
  "constType": "CellularAutomatas.composition.Params → Type",
  "constCategory": "Definition"},
 {"references":
  ["LT.lt",
   "Ne",
   "List.ne_nil_of_length_pos",
   "OfNat.ofNat",
   "List.length_pos_of_ne_nil",
   "List.length"],
  "name": "List.length_pos_iff_ne_nil",
  "constType": "∀ {α : Type u} {l : List α}, 0 < l.length ↔ l ≠ []",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "MulDivCancelClass.mul_div_cancel",
  "constType":
  "∀ {M₀ : Type u_2} {inst : MonoidWithZero M₀} {inst_1 : Div M₀} [self : MulDivCancelClass M₀] (a b : M₀),\n  b ≠ 0 → a * b / b = a",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "GetElem?.getElem?",
   "Iff.mpr",
   "LE.le",
   "List.getElem?_eq_none_iff",
   "List.length"],
  "name": "List.getElem?_eq_none",
  "constType":
  "∀ {α : Type u_1} {l : List α} {i : ℕ}, l.length ≤ i → l[i]? = none",
  "constCategory": "Theorem"},
 {"references": ["Lean.SyntaxNodeKind", "Array.mkArray6"],
  "name": "Lean.Syntax.node6",
  "constType":
  "SourceInfo → SyntaxNodeKind → Syntax → Syntax → Syntax → Syntax → Syntax → Syntax → Syntax",
  "constCategory": "Definition"},
 {"references": ["Std.TreeSet.insert", "Lean.NameSet", "Lean.Name.quickCmp"],
  "name": "Lean.NameSet.insert",
  "constType": "NameSet → Name → NameSet",
  "constCategory": "Definition"},
 {"references":
  ["_private.Init.Data.Nat.Basic.0.Nat.add_sub_add_right._simp_1_1",
   "HAdd.hAdd",
   "eq_self",
   "Eq.trans",
   "of_eq_true",
   "congr",
   "HSub.hSub",
   "Nat.recAux",
   "Nat.succ_sub_succ_eq_sub",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Nat.add_sub_add_right",
  "constType": "∀ (n k m : ℕ), n + k - (m + k) = n - m",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.succ_add",
   "Nat.add_le_of_le_sub",
   "Eq.mp",
   "Nat.ge_of_not_lt",
   "OfNat.ofNat",
   "congrArg",
   "LT.lt",
   "HAdd.hAdd",
   "Nat.not_lt_zero",
   "Nat.sub_eq_zero_of_le",
   "LE.le",
   "HSub.hSub",
   "Nat.le_of_lt"],
  "name": "Nat.add_lt_of_lt_sub",
  "constType": "∀ {a b c : ℕ}, a < c - b → a + b < c",
  "constCategory": "Theorem"},
 {"references": ["Lean.Grind.AC.Var", "Nat.beq", "Bool.and'"],
  "name": "Lean.Grind.AC.Seq.beq'",
  "constType": "Grind.AC.Seq → Grind.AC.Seq → Bool",
  "constCategory": "Definition"},
 {"references":
  ["CellularAutomatas.tCellAutomaton.t",
   "Set",
   "Membership.mem",
   "HSub.hSub",
   "OfNat.ofNat",
   "setOf"],
  "name": "CellularAutomatas.t_rt",
  "constType":
  "(α : Type) → Set (CellularAutomatas.tCellAutomaton α) → Set (CellularAutomatas.tCellAutomaton α)",
  "constCategory": "Definition"},
 {"references":
  ["_private.Mathlib.Order.Defs.LinearOrder.0.min_self._proof_1_1"],
  "name": "min_self",
  "constType": "∀ {α : Type u_1} [inst : LinearOrder α] (a : α), min a a = a",
  "constCategory": "Theorem"},
 {"references": ["MulOneClass.one_mul"],
  "name": "one_mul",
  "constType": "∀ {M : Type u} [inst : MulOneClass M] (a : M), 1 * a = a",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "Eq.trans",
   "Lean.Grind.Order.of_nat_eq",
   "HMul.hMul",
   "eagerReduce",
   "eq_true",
   "ite_cond_eq_true",
   "IntCast.intCast",
   "List.getLast?_append",
   "List.getLast?",
   "Lean.Grind.Order.le_of_offset_eq_2_k",
   "Nat.ToInt.natCast_ofNat",
   "Lean.Grind.Order.int_lt",
   "GetElem?.getElem?",
   "False.elim",
   "NatCast.natCast",
   "Lean.Grind.eq_false_of_imp_eq_true",
   "Eq.symm",
   "HSub.hSub",
   "CellularAutomatas.PrefixStableProof.getLastOfTake._proof_1_20",
   "forall_prop_domain_congr",
   "Lean.Grind.forall_propagator",
   "HAppend.hAppend",
   "of_eq_false",
   "List.drop",
   "getElem?_pos",
   "Neg.neg",
   "Lean.Grind.Order.le_of_eq_2_k",
   "Lean.Grind.Order.le_of_offset_eq_1_k",
   "List.take_add",
   "Lean.Grind.nestedProof",
   "eq_false",
   "id",
   "Lean.Grind.Order.le_trans_k",
   "Lean.Grind.Order.eq_trans_false'",
   "Lean.Grind.Order.eq_trans_true",
   "getElem?_neg",
   "List.length",
   "Int.Linear.norm_le",
   "Eq.substr",
   "Option.some_or",
   "Int.Linear.natCast_sub",
   "Eq.mp",
   "noConfusion_of_Nat",
   "GetElem.getElem",
   "Nat.Linear.ExprCnstr.eq_of_toNormPoly_eq",
   "Lean.Grind.Order.le_of_eq_1_k",
   "List.length_take",
   "Int.Linear.Expr.eq_of_norm_eq",
   "min_def",
   "congrArg",
   "Option.or",
   "Lean.Grind.Nat.lt_eq",
   "Nat.not_le_eq",
   "Lean.Grind.nestedDecidable",
   "CellularAutomatas.PrefixStableProof.getLastOfTake._proof_1_3",
   "Lean.Grind.Order.eq_of_le_of_le_0",
   "congr",
   "List.getLast?_eq_getElem?",
   "Lean.Grind.Order.lt_of_not_le_k",
   "Not",
   "ite",
   "Lean.Grind.Order.eq_trans_true'",
   "Nat.ToInt.add_congr",
   "Lean.Grind.Order.le_eq_true_of_le_k",
   "Lean.Grind.Order.eq_mp_not",
   "OfNat.ofNat",
   "ite_congr",
   "LT.lt",
   "HAdd.hAdd",
   "Nat.ToInt.le_eq",
   "of_eq_true",
   "Min.min",
   "Lean.Grind.CommRing.Expr.eq_of_toPoly_eq",
   "List.take",
   "Lean.Grind.Order.nat_eq",
   "LE.le",
   "CellularAutomatas.PrefixStableProof.getLastOfTake._proof_1_5",
   "Lean.Grind.Semiring.natCast",
   "Lean.Grind.CommRing.le_norm_expr",
   "Lean.Grind.Semiring.natCast_eq_ofNat",
   "Lean.Grind.Order.eq_mp"],
  "name": "CellularAutomatas.PrefixStableProof.getLastOfTake._proof_1_24",
  "constType":
  "∀ {i : ℕ} {α : Type u_1} {w : List α},\n  i + 1 ≤ w.length →\n    -1 * ↑(List.take 1 w⟦i..*⟧).length + 1 ≤ 0 →\n      -1 * ↑(List.take i w).length + 1 ≤ 0 →\n        (List.take (i + 1) w).length - ((List.take i w).length + 1) < (List.take 1 w⟦i..*⟧).length",
  "constCategory": "Theorem"},
 {"references": ["Setoid.r"],
  "name": "Quotient",
  "constType": "{α : Sort u} → Setoid α → Sort u",
  "constCategory": "Definition"},
 {"references":
  ["HAdd.hAdd",
   "CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "SizeOf.sizeOf",
   "CellularAutomatas.CellAutomaton.Q",
   "OfNat.ofNat"],
  "name": "CellularAutomatas.CArtTransducer._sizeOf_1",
  "constType":
  "{α Γ : Type} →\n  {inst : CellularAutomatas.Alphabet α} →\n    {inst_1 : CellularAutomatas.Alphabet Γ} → [SizeOf α] → [SizeOf Γ] → CellularAutomatas.CArtTransducer α Γ → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["List.range",
   "CellularAutomatas.Word",
   "List.getD",
   "List.map",
   "Inhabited.default",
   "List.length"],
  "name": "CellularAutomatas.ProdCA.zipMany",
  "constType":
  "{β : Type} →\n  [CellularAutomatas.Alphabet β] →\n    {γ : β → Type v} →\n      [(b : β) → Inhabited (γ b)] → ((b : β) → CellularAutomatas.Word (γ b)) → CellularAutomatas.Word ((b : β) → γ b)",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Lean.Omega.LinearCombo.coeffs",
  "constType": "Omega.LinearCombo → Omega.Coeffs",
  "constCategory": "Definition"},
 {"references": [],
  "name": "DecidableEq",
  "constType": "Sort u → Sort (max 1 u)",
  "constCategory": "Definition"},
 {"references": ["eq_false", "Membership.mem", "List.not_mem_nil"],
  "name": "List.not_mem_nil._simp_1",
  "constType": "∀ {α : Type u_1} {a : α}, (a ∈ []) = False",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "EStateM",
  "constType": "Type u → Type u → Type u → Type u",
  "constCategory": "Definition"},
 {"references": ["Lean.Grind.CommRing.Poly.mul.go", "OfNat.ofNat"],
  "name": "Lean.Grind.CommRing.Poly.mul",
  "constType":
  "Grind.CommRing.Poly → Grind.CommRing.Poly → Grind.CommRing.Poly",
  "constCategory": "Definition"},
 {"references": ["LT.lt", "Not", "Nat.lt_or_ge", "Or.resolve_left", "GE.ge"],
  "name": "Nat.ge_of_not_lt",
  "constType": "∀ {n m : ℕ}, ¬n < m → n ≥ m",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.FiniteStateTransducer.M_projQ",
   "CellularAutomatas.FiniteStateTransducer.Q"],
  "name": "CellularAutomatas.FiniteStateTransducer.M_projQ.eq_1",
  "constType":
  "∀ {α β : Type} (M : CellularAutomatas.FiniteStateTransducer α β),\n  M.M_projQ = { Q := M.Q, alphabetQ := M.alphabetQ, δ := M.δ, q0 := M.q0, f := id }",
  "constCategory": "Theorem"},
 {"references":
  ["List.ctorIdx",
   "Eq.trans",
   "List.casesOn",
   "noConfusion_of_Nat",
   "eq_false'",
   "congrArg",
   "eq_self",
   "False.elim",
   "of_eq_true",
   "iff_self",
   "congr",
   "Eq.symm",
   "Eq.ndrec"],
  "name": "List.nil_eq",
  "constType": "∀ {α : Type u_1} {xs : List α}, [] = xs ↔ xs = []",
  "constCategory": "Theorem"},
 {"references": ["CellularAutomatas.LcInRt.DiagonalShiftCA"],
  "name": "CellularAutomatas.LcInRt.DiagonalShiftCA.eq_1",
  "constType":
  "∀ (A : Type) [inst : CellularAutomatas.Alphabet A],\n  CellularAutomatas.LcInRt.DiagonalShiftCA A =\n    { Q := Option A, alphabetQ := CellularAutomatas.instAlphabetOfDecidableEqOfFintypeOfInhabited (Option A),\n      δ := fun x x_1 r => r, embed := some, border := none }",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Grind.Ring.zsmul_eq_intCast_mul",
   "Lean.Grind.AddCommMonoid.add_assoc",
   "Eq.trans",
   "Eq.mp",
   "Lean.Grind.CommRing.Poly.addConst",
   "HMul.hMul",
   "Lean.Grind.AddCommMonoid.add_comm",
   "Int.cast",
   "Lean.Grind.CommRing.hugeFuel",
   "congrArg",
   "Lean.Grind.Ring.intCast_add",
   "Lean.Grind.AddCommMonoid.zero_add",
   "congr",
   "Lean.Grind.Ring.intCast_zero",
   "Eq.symm",
   "Lean.Grind.CommRing.Poly.denote",
   "Lean.Grind.Ring.zsmul",
   "Lean.Grind.CommRing.Poly.combine.go.induct_unfolding",
   "Lean.Grind.CommRing.Poly.combine",
   "Lean.Grind.CommRing.Poly.denote_addConst",
   "Lean.Grind.Ring.intCast",
   "Lean.Grind.CommRing.Mon.denote",
   "Lean.Grind.CommRing.Mon.eq_of_grevlex",
   "Lean.Grind.CommRing.Poly.combine.go",
   "OfNat.ofNat",
   "Lean.Grind.AddCommMonoid.add_left_comm",
   "beq_iff_eq._simp_1",
   "HAdd.hAdd",
   "Lean.Grind.CommRing.Mon.grevlex",
   "eq_self",
   "of_eq_true",
   "HSMul.hSMul",
   "id",
   "Lean.Grind.CommRing.Poly.denote_concat",
   "Eq.mpr",
   "Lean.Grind.Semiring.zero_mul",
   "BEq.beq",
   "Lean.Grind.Semiring.right_distrib",
   "Lean.Grind.CommRing.Poly.concat",
   "Lean.Grind.CommRing.Context"],
  "name": "Lean.Grind.CommRing.Poly.denote_combine",
  "constType":
  "∀ {α : Type u_1} [inst : Grind.Ring α] (ctx : Grind.CommRing.Context α) (p₁ p₂ : Grind.CommRing.Poly),\n  Grind.CommRing.Poly.denote ctx (p₁.combine p₂) = Grind.CommRing.Poly.denote ctx p₁ + Grind.CommRing.Poly.denote ctx p₂",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "List.drop",
   "Eq.symm",
   "Eq.ndrec",
   "OfNat.ofNat",
   "Nat.casesAuxOn"],
  "name": "List.drop_nil",
  "constType": "∀ {α : Type u} {i : ℕ}, []⟦i..*⟧ = []",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd", "AddLeftMono", "rel_iff_cov", "LE.le", "AddLeftReflectLE"],
  "name": "add_le_add_iff_left",
  "constType":
  "∀ {α : Type u_1} [inst : Add α] [inst_1 : LE α] [AddLeftMono α] [AddLeftReflectLE α] (a : α) {b c : α},\n  a + b ≤ a + c ↔ b ≤ c",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.Word.get'",
   "Not",
   "CellularAutomatas.Word",
   "Eq.trans",
   "Eq.mp",
   "Set",
   "Membership.mem",
   "eq_true",
   "CellularAutomatas.LCellAutomaton.embed_word.eq_1",
   "Lean.Grind.nestedProof",
   "CellularAutomatas.LCellAutomaton.embed",
   "CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "Lean.Grind.nestedDecidable",
   "eq_false",
   "Classical.byContradiction",
   "CellularAutomatas.LCellAutomaton.embed_word",
   "Lean.Grind.dite_cond_eq_true'",
   "Eq.symm",
   "id",
   "CellularAutomatas.Word.range",
   "CellularAutomatas.CellAutomaton.Q",
   "CellularAutomatas.LCellAutomaton.border",
   "dite"],
  "name": "CellularAutomatas.LCellAutomaton.embed_word_eq._proof_1_4",
  "constType":
  "∀ {α : Type} (C : CellularAutomatas.LCellAutomaton α) {w : CellularAutomatas.Word α} {p : ℤ} (h : p ∈ w.range),\n  C.embed_word w p = C.embed (w.get' p h)",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "eq_self",
   "forall_const._simp_1",
   "Eq.trans",
   "of_eq_true",
   "congrArg"],
  "name": "Lean.Grind.imp_eq_of_eq_true_left",
  "constType": "∀ {a b : Prop}, a = True → (a → b) = b",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Omega.Constraint.scale",
   "Lean.Omega.Constraint.add_sat",
   "Lean.Omega.Constraint.sat",
   "HMul.hMul",
   "Lean.Omega.Constraint.scale_sat"],
  "name": "Lean.Omega.Constraint.combo_sat",
  "constType":
  "∀ {c₁ c₂ : Omega.Constraint} {x₁ x₂ : ℤ} (a : ℤ),\n  c₁.sat x₁ = true → ∀ (b : ℤ), c₂.sat x₂ = true → (Omega.Constraint.combo a c₁ b c₂).sat (a * x₁ + b * x₂) = true",
  "constCategory": "Theorem"},
 {"references":
  ["Bool.casesOn",
   "Eq.symm",
   "id",
   "Bool.or",
   "Eq.ndrec",
   "Decidable.decide",
   "of_decide_eq_true"],
  "name": "Bool.or_eq_true",
  "constType": "∀ (a b : Bool), ((a || b) = true) = (a = true ∨ b = true)",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans",
   "le_of_le_of_eq",
   "Membership.mem",
   "Subtype.val",
   "CellularAutomatas.tCellAutomaton.toLCellAutomaton",
   "Set.Elem",
   "Lean.Omega.Int.ofNat_le_of_le",
   "CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "CellularAutomatas.LCellAutomaton.scan_temporal_rt",
   "Lean.Omega.tidy_sat",
   "HSub.hSub",
   "Eq.symm",
   "Lean.Omega.LinearCombo.add_eval",
   "CellularAutomatas.CArtTransducer.advice",
   "Neg.neg",
   "Lean.Omega.Constraint.addInequality_sat",
   "List.map",
   "Lean.Omega.LinearCombo.coordinate",
   "id",
   "CellularAutomatas.tCellAutomaton.L",
   "Lean.Omega.Int.sub_congr",
   "List.length",
   "Nat.cast",
   "CellularAutomatas.tCellAutomaton.t",
   "Decidable.decide",
   "Lean.Omega.Coeffs.ofList",
   "CellularAutomatas.CellAutomaton.Q",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "of_decide_eq_true",
   "Not",
   "CellularAutomatas.Word",
   "List.extract",
   "Set",
   "Lean.Omega.Int.add_congr",
   "Function.comp",
   "Lean.Omega.Constraint.isImpossible",
   "OfNat.ofNat",
   "Int.sub_nonneg_of_le",
   "CellularAutomatas.Advice.f",
   "LT.lt",
   "HAdd.hAdd",
   "List.range",
   "Lean.Omega.LinearCombo.coordinate_eval_1",
   "Nat.le_of_not_lt",
   "Lean.Omega.LinearCombo.sub_eval",
   "List.take",
   "Int.natCast_add",
   "CellularAutomatas.CA_rt",
   "Lean.Omega.LinearCombo.eval",
   "CellularAutomatas.tCellAutomaton.F_pos"],
  "name": "CellularAutomatas.CA_rt_to_TwoStage_eq._proof_1_5",
  "constType":
  "∀ {α : Type} [CellularAutomatas.Alphabet α] (C : ↑(CellularAutomatas.CA_rt α)) (w : CellularAutomatas.Word α) (i : ℕ),\n  ¬i < i + 1 → False",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Lean.Grind.nestedDecidable",
  "constType": "{p : Prop} → Decidable p → Decidable p",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Lean.EnvironmentHeader.modules",
  "constType": "EnvironmentHeader → Array EffectiveImport",
  "constCategory": "Definition"},
 {"references": ["Lean.Omega.Coeffs", "Lean.Omega.IntList.set"],
  "name": "Lean.Omega.Coeffs.set",
  "constType": "Omega.Coeffs → ℕ → ℤ → Omega.Coeffs",
  "constCategory": "Definition"},
 {"references": ["Option.getD.match_1", "Unit"],
  "name": "Option.map",
  "constType":
  "{α : Type u_1} → {β : Type u_2} → (α → β) → Option α → Option β",
  "constCategory": "Definition"},
 {"references": ["outParam"],
  "name": "CellularAutomatas.DefinesLanguage.L",
  "constType":
  "{CA : Sort u_1} → {α : outParam Type} → [self : CellularAutomatas.DefinesLanguage CA α] → CA → Language α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Lean.MonadQuotation.getContext",
  "constType": "{m : Type → Type} → [self : MonadQuotation m] → m Name",
  "constCategory": "Definition"},
 {"references": [],
  "name": "propext",
  "constType": "∀ {a b : Prop}, (a ↔ b) → a = b",
  "constCategory": "Axiom"},
 {"references": ["LT.lt", "eq_true", "zero_lt_one", "OfNat.ofNat"],
  "name": "zero_lt_one._simp_1",
  "constType":
  "∀ {α : Type u_1} [inst : Zero α] [inst_1 : One α] [inst_2 : PartialOrder α] [ZeroLEOneClass α] [NeZero 1],\n  (0 < 1) = True",
  "constCategory": "Theorem"},
 {"references": ["Lean.Name.below"],
  "name": "Lean.Name.brecOn.go",
  "constType":
  "{motive : Name → Sort u} → (t : Name) → ((t : Name) → Name.below t → motive t) → motive t ×' Name.below t",
  "constCategory": "Definition"},
 {"references": ["CellularAutomatas.tCellAutomatonWithAdvice.casesOn"],
  "name": "CellularAutomatas.tCellAutomatonWithAdvice.noConfusionType",
  "constType":
  "{α : Type} →\n  Sort u → CellularAutomatas.tCellAutomatonWithAdvice α → CellularAutomatas.tCellAutomatonWithAdvice α → Sort u",
  "constCategory": "Definition"},
 {"references": ["Array.mkArray2", "Lean.SyntaxNodeKind"],
  "name": "Lean.Syntax.node2",
  "constType": "SourceInfo → SyntaxNodeKind → Syntax → Syntax → Syntax",
  "constCategory": "Definition"},
 {"references": [],
  "name": "cast",
  "constType": "{α β : Sort u} → α = β → α → β",
  "constCategory": "Definition"},
 {"references":
  ["Int.toNat",
   "Int.max_eq_left",
   "Max.max",
   "Nat.cast",
   "LE.le",
   "id",
   "Eq.mpr",
   "Int.toNat_eq_max",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Int.toNat_of_nonneg",
  "constType": "∀ {a : ℤ}, 0 ≤ a → ↑a.toNat = a",
  "constCategory": "Theorem"},
 {"references": ["HAdd.hAdd", "List.length_range'", "HSub.hSub", "OfNat.ofNat"],
  "name": "Nat.card_Icc",
  "constType": "∀ (a b : ℕ), (Finset.Icc a b).card = b + 1 - a",
  "constCategory": "Theorem"},
 {"references": ["Not", "Decidable.casesOn"],
  "name": "ite",
  "constType": "{α : Sort u} → (c : Prop) → [h : Decidable c] → α → α → α",
  "constCategory": "Definition"},
 {"references":
  ["CellularAutomatas.Word",
   "CellularAutomatas.FiniteStateTransducer.scanr_step",
   "CellularAutomatas.FiniteStateTransducer.Q",
   "Prod.snd",
   "List.foldr"],
  "name": "CellularAutomatas.FiniteStateTransducer.scanr_q",
  "constType":
  "{α β : Type} →\n  (M : CellularAutomatas.FiniteStateTransducer α β) → M.Q → CellularAutomatas.Word α → CellularAutomatas.Word β",
  "constCategory": "Definition"},
 {"references": ["HAdd.hAdd", "Eq.symm", "Lean.Grind.Semiring.add_assoc"],
  "name": "_private.Init.Grind.Order.0.Lean.Grind.Order.le_trans_k._simp_1_1",
  "constType":
  "∀ {α : Type u} [self : Grind.Semiring α] (a b c : α), a + (b + c) = a + b + c",
  "constCategory": "Theorem"},
 {"references": ["Nat.casesOn", "OfNat.ofNat"],
  "name": "List.range.loop.match_1",
  "constType":
  "(motive : ℕ → List ℕ → Sort u_1) →\n  (x : ℕ) →\n    (x_1 : List ℕ) → ((acc : List ℕ) → motive 0 acc) → ((n : ℕ) → (acc : List ℕ) → motive n.succ acc) → motive x x_1",
  "constCategory": "Definition"},
 {"references": ["CellularAutomatas.CellAutomaton.Q"],
  "name": "CellularAutomatas.LCellAutomaton.recOn",
  "constType":
  "{α : Type} →\n  {motive : CellularAutomatas.LCellAutomaton α → Sort u} →\n    (t : CellularAutomatas.LCellAutomaton α) →\n      ((toCellAutomaton : CellularAutomatas.CellAutomaton) →\n          (embed : α → toCellAutomaton.Q) →\n            (border : toCellAutomaton.Q) →\n              motive { toCellAutomaton := toCellAutomaton, embed := embed, border := border }) →\n        motive t",
  "constCategory": "Definition"},
 {"references": ["rfl", "List.get", "List.length"],
  "name": "List.get_eq_getElem",
  "constType":
  "∀ {α : Type u_1} {l : List α} {i : Fin l.length}, l.get i = l[↑i]",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "OfNat.ofNat",
  "constType": "{α : Type u} → (x : ℕ) → [self : OfNat α x] → α",
  "constCategory": "Definition"},
 {"references": ["Lean.Omega.Constraint.scale", "Lean.Omega.Constraint.add"],
  "name": "Lean.Omega.Constraint.combo",
  "constType": "ℤ → Omega.Constraint → ℤ → Omega.Constraint → Omega.Constraint",
  "constCategory": "Definition"},
 {"references":
  ["Eq.trans",
   "CellularAutomatas.backwards_fsm.Params.inst3",
   "eq_true",
   "eagerReduce",
   "CellularAutomatas.Config",
   "CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "NatCast.natCast",
   "funext",
   "HSub.hSub",
   "Eq.symm",
   "CellularAutomatas.Word.get'?",
   "CellularAutomatas.backwards_fsm.Params.α",
   "CellularAutomatas.CellAutomaton.δ",
   "CellularAutomatas.CArtTransducer.toLCellAutomaton",
   "List.drop",
   "CellularAutomatas.backwards_fsm.Params.β",
   "Neg.neg",
   "CellularAutomatas.backwards_fsm.Params.M",
   "CellularAutomatas.FiniteStateTransducer.scanr",
   "Prod.snd",
   "CellularAutomatas.backwards_fsm.Params.inst2",
   "CellularAutomatas.LCellAutomaton.comp",
   "eq_false",
   "Classical.byContradiction",
   "id",
   "Int.toNat",
   "Nat.cast",
   "CellularAutomatas.backwards_fsm.C'",
   "CellularAutomatas.backwards_fsm.Params.C",
   "Eq.mp",
   "CellularAutomatas.FiniteStateTransducer.Q",
   "CellularAutomatas.FiniteStateTransducer.δ?",
   "CellularAutomatas.FiniteStateTransducer.scanr_reduce",
   "CellularAutomatas.backwards_fsm.Params.γ",
   "Int.Linear.Expr.eq_of_norm_eq",
   "Prod.fst",
   "congrArg",
   "congr",
   "CellularAutomatas.CellAutomaton.Q",
   "Lean.Grind.forall_and",
   "Not",
   "CellularAutomatas.Word",
   "Lean.Grind.Semiring.natCast_add",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "eq_self",
   "True.casesOn",
   "Lean.Grind.intro_with_eq",
   "Lean.Grind.Semiring.natCast",
   "Lean.Grind.Semiring.natCast_eq_ofNat",
   "And.casesOn"],
  "name": "CellularAutomatas.backwards_fsm.inv._proof_1_10",
  "constType":
  "∀ (e : CellularAutomatas.backwards_fsm.Params) (w : CellularAutomatas.Word e.α) (t : ℕ) (p : ℤ),\n  (∀ (p : ℤ),\n      let c' := (CellularAutomatas.backwards_fsm.C' e).comp w t p;\n      let q := e.M.scanr_reduce w⟦(p + ↑t).toNat..*⟧;\n      c'.2 q = e.C.comp (e.M.scanr w) t p ∧ c'.1 = w.get'? (p + ↑t)) →\n    (CellularAutomatas.backwards_fsm.C' e).comp w t = (CellularAutomatas.backwards_fsm.C' e).comp w t →\n      (CellularAutomatas.backwards_fsm.C' e).comp w t (p - 1) =\n          (CellularAutomatas.backwards_fsm.C' e).comp w t (p - 1) →\n        (CellularAutomatas.backwards_fsm.C' e).comp w t p = (CellularAutomatas.backwards_fsm.C' e).comp w t p →\n          (CellularAutomatas.backwards_fsm.C' e).comp w (t + 1) p =\n              (((CellularAutomatas.backwards_fsm.C' e).comp w t (p + 1)).1, fun q =>\n                e.C.δ\n                  (((CellularAutomatas.backwards_fsm.C' e).comp w t (p - 1)).2\n                    (e.M.δ? (e.M.δ? q ((CellularAutomatas.backwards_fsm.C' e).comp w t p).1)\n                      ((CellularAutomatas.backwards_fsm.C' e).comp w t (p - 1)).1))\n                  (((CellularAutomatas.backwards_fsm.C' e).comp w t p).2\n                    (e.M.δ? q ((CellularAutomatas.backwards_fsm.C' e).comp w t p).1))\n                  (((CellularAutomatas.backwards_fsm.C' e).comp w t (p + 1)).2 q)) →\n            (CellularAutomatas.backwards_fsm.C' e).comp w t (p + 1) =\n                (CellularAutomatas.backwards_fsm.C' e).comp w t (p + 1) →\n              e.M.scanr_reduce w⟦(p + ↑(t + 1)).toNat..*⟧ = e.M.scanr_reduce w⟦(p + ↑(t + 1)).toNat..*⟧ →\n                (((CellularAutomatas.backwards_fsm.C' e).comp w (t + 1) p).2\n                      (e.M.scanr_reduce w⟦(p + ↑(t + 1)).toNat..*⟧) =\n                    let q_right :=\n                      e.M.δ? (e.M.scanr_reduce w⟦(p + ↑(t + 1)).toNat..*⟧)\n                        ((CellularAutomatas.backwards_fsm.C' e).comp w t p).1;\n                    let q_center := e.M.δ? q_right ((CellularAutomatas.backwards_fsm.C' e).comp w t (p - 1)).1;\n                    e.C.δ (((CellularAutomatas.backwards_fsm.C' e).comp w t (p - 1)).2 q_center)\n                      (((CellularAutomatas.backwards_fsm.C' e).comp w t p).2 q_right)\n                      (((CellularAutomatas.backwards_fsm.C' e).comp w t (p + 1)).2\n                        (e.M.scanr_reduce w⟦(p + ↑(t + 1)).toNat..*⟧))) →\n                  (let c' := (CellularAutomatas.backwards_fsm.C' e).comp w t (p + 1);\n                    let q := e.M.scanr_reduce w⟦(p + 1 + ↑t).toNat..*⟧;\n                    c'.2 q = e.C.comp (e.M.scanr w) t (p + 1) ∧ c'.1 = w.get'? (p + 1 + ↑t)) →\n                    ((CellularAutomatas.backwards_fsm.C' e).comp w t (p + 1)).2\n                            (e.M.scanr_reduce w⟦(p + ↑(t + 1)).toNat..*⟧) =\n                          e.C.comp (e.M.scanr w) t (p + 1) ∧\n                        ((CellularAutomatas.backwards_fsm.C' e).comp w t (p + 1)).1 = w.get'? (p + ↑t + 1) →\n                      ((CellularAutomatas.backwards_fsm.C' e).comp w t p).1 = w.get'? (p + ↑t) →\n                        e.M.δ? (e.M.scanr_reduce w⟦(p + ↑(t + 1)).toNat..*⟧)\n                              ((CellularAutomatas.backwards_fsm.C' e).comp w t p).1 =\n                            e.M.scanr_reduce w⟦(p + ↑t).toNat..*⟧ →\n                          ((CellularAutomatas.backwards_fsm.C' e).comp w t p).2\n                                (e.M.δ? (e.M.scanr_reduce w⟦(p + ↑(t + 1)).toNat..*⟧)\n                                  ((CellularAutomatas.backwards_fsm.C' e).comp w t p).1) =\n                              e.C.comp (e.M.scanr w) t p →\n                            ((CellularAutomatas.backwards_fsm.C' e).comp w t (p - 1)).1 = w.get'? (p + ↑t - 1) →\n                              ((CellularAutomatas.backwards_fsm.C' e).comp w t (p - 1)).2\n                                    (e.M.δ?\n                                      (e.M.δ? (e.M.scanr_reduce w⟦(p + ↑(t + 1)).toNat..*⟧)\n                                        ((CellularAutomatas.backwards_fsm.C' e).comp w t p).1)\n                                      ((CellularAutomatas.backwards_fsm.C' e).comp w t (p - 1)).1) =\n                                  e.C.comp (e.M.scanr w) t (p - 1) →\n                                ((CellularAutomatas.backwards_fsm.C' e).comp w t (p + 1)).1 = w.get'? (p + (↑t + 1))",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CellularAutomatas.FiniteStateTransducer.mk",
  "constType":
  "{α β : Type} →\n  (Q : Type) →\n    [alphabetQ : CellularAutomatas.Alphabet Q] → (Q → α → Q) → Q → (Q → β) → CellularAutomatas.FiniteStateTransducer α β",
  "constCategory": "Other"},
 {"references": [],
  "name": "Lean.Grind.CommRing.Poly.below",
  "constType":
  "{motive : Grind.CommRing.Poly → Sort u} → Grind.CommRing.Poly → Sort (max 1 u)",
  "constCategory": "Definition"},
 {"references":
  ["Int.add_right_neg",
   "HAdd.hAdd",
   "Int.add_left_cancel",
   "Int.add_assoc",
   "Neg.neg",
   "Int.add_comm",
   "Eq.symm",
   "id",
   "Int.add_zero",
   "Eq.mpr",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Int.neg_add",
  "constType": "∀ {a b : ℤ}, -(a + b) = -a + -b",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.mp",
   "congr",
   "Lean.Grind.CommRing.Poly.denote",
   "Lean.Grind.CommRing.Expr.denote",
   "LawfulBEq.eq_of_beq",
   "Lean.Grind.CommRing.Expr.denote_toPoly",
   "BEq.beq",
   "Lean.Grind.CommRing.Context",
   "congrArg",
   "Lean.Grind.CommRing.Expr.toPoly"],
  "name": "Lean.Grind.CommRing.Expr.eq_of_toPoly_eq",
  "constType":
  "∀ {α : Type u_1} [inst : Grind.CommRing α] (ctx : Grind.CommRing.Context α) (a b : Grind.CommRing.Expr),\n  (a.toPoly == b.toPoly) = true → Grind.CommRing.Expr.denote ctx a = Grind.CommRing.Expr.denote ctx b",
  "constCategory": "Theorem"},
 {"references":
  ["List.filter",
   "Setoid.r",
   "Multiset.filter._proof_1",
   "Quot.liftOn",
   "DecidablePred",
   "Multiset.ofList",
   "Decidable.decide",
   "Multiset"],
  "name": "Multiset.filter",
  "constType":
  "{α : Type u_1} → (p : α → Prop) → [DecidablePred p] → Multiset α → Multiset α",
  "constCategory": "Definition"},
 {"references": ["CellularAutomatas.δδ", "CellularAutomatas.CellAutomaton.Q"],
  "name": "CellularAutomatas.δδ.eq_1",
  "constType":
  "∀ {C : CellularAutomatas.CellAutomaton} (q : C.Q), CellularAutomatas.δδ q = C.δ q q q",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Lean.Omega.UpperBound",
  "constType": "Type",
  "constCategory": "Definition"},
 {"references":
  ["Nat.le_trans",
   "List.getElem?_eq_none",
   "List.take",
   "LE.le",
   "List.length_take_le",
   "List.length"],
  "name": "List.getElem?_take_eq_none",
  "constType":
  "∀ {α : Type u_1} {l : List α} {i j : ℕ}, i ≤ j → (List.take i l)[j]? = none",
  "constCategory": "Theorem"},
 {"references": ["beq_eq_beq", "BEq.beq", "propext"],
  "name": "beq_eq_beq._simp_1",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} [inst : BEq α] [LawfulBEq α] [inst_2 : BEq β] [LawfulBEq β] {a₁ a₂ : α} {b₁ b₂ : β},\n  ((a₁ == a₂) = (b₁ == b₂)) = (a₁ = a₂ ↔ b₁ = b₂)",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans",
   "Option.getD",
   "List.map",
   "Int.add_zero",
   "_private.Init.Omega.IntList.0.List.map_id'",
   "List.zipWithAll_nil",
   "OfNat.ofNat",
   "congrArg",
   "HAdd.hAdd",
   "eq_self",
   "Lean.Omega.IntList",
   "of_eq_true",
   "funext",
   "List.zipWithAll"],
  "name": "Lean.Omega.IntList.add_nil",
  "constType": "∀ (xs : Omega.IntList), xs + [] = xs",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "eq_self",
   "Int.subNatNat_add",
   "Int.subNatNat",
   "Nat.cast",
   "Eq.trans",
   "of_eq_true",
   "_private.Init.Data.Int.Lemmas.0.Int.add_assoc.aux1.match_1",
   "Nat.add_assoc",
   "OfNat.ofNat",
   "congrArg"],
  "name": "_private.Init.Data.Int.Lemmas.0.Int.add_assoc.aux1",
  "constType": "∀ (m n : ℕ) (c : ℤ), ↑m + ↑n + c = ↑m + (↑n + c)",
  "constCategory": "Theorem"},
 {"references": ["LT.lt", "Iff.rfl"],
  "name": "Int.lt_iff_add_one_le",
  "constType": "∀ {a b : ℤ}, a < b ↔ a + 1 ≤ b",
  "constCategory": "Theorem"},
 {"references":
  ["Or.elim",
   "Int.toNat",
   "Lean.Omega.LinearCombo.coordinate_eval_2",
   "Nat.cast",
   "Eq.trans",
   "le_of_le_of_eq",
   "Lean.Omega.LinearCombo.coordinate_eval_0",
   "Lean.Omega.Constraint.combine_sat'",
   "Int.sub_eq_zero_of_eq",
   "Decidable.decide",
   "Lean.Omega.Int.ofNat_le_of_le",
   "Lean.Omega.Coeffs.ofList",
   "Eq.symm",
   "Lean.Omega.tidy_sat",
   "HSub.hSub",
   "Lean.Omega.LinearCombo.add_eval",
   "Lean.Omega.ite_disjunction",
   "Int.add_one_le_of_lt",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "And.left",
   "of_decide_eq_true",
   "Not",
   "CellularAutomatas.Word",
   "Lean.Omega.combo_sat'",
   "ite",
   "Neg.neg",
   "And.right",
   "Lean.Omega.Constraint.addInequality_sat",
   "Lean.Omega.Int.add_congr",
   "Lean.Omega.Constraint.isImpossible",
   "Lean.Omega.LinearCombo.coordinate",
   "Int.sub_nonneg_of_le",
   "OfNat.ofNat",
   "Lean.Omega.LinearCombo.coordinate_eval_1",
   "HAdd.hAdd",
   "LT.lt",
   "Max.max",
   "Nat.le_of_not_lt",
   "Lean.Omega.LinearCombo.sub_eval",
   "Int.max_def",
   "LE.le",
   "Lean.Omega.Constraint.addEquality_sat",
   "id",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.Int.sub_congr",
   "Int.toNat_eq_max",
   "List.length"],
  "name": "CellularAutomatas.Word.get'._proof_3",
  "constType":
  "∀ {α : Type u_1} (w : CellularAutomatas.Word α) (i : ℤ), 0 ≤ i ∧ i < ↑(List.length w) → ¬i.toNat < List.length w → False",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "List.ctorIdx",
   "List.getLast",
   "Eq.trans",
   "List.getLast?_eq_some_getLast",
   "List.casesOn",
   "noConfusion_of_Nat",
   "List.map",
   "eq_false'",
   "List.getLast_map",
   "List.getLast?",
   "congrArg",
   "eq_self",
   "not_false_eq_true",
   "False.elim",
   "of_eq_true",
   "id",
   "Eq.symm",
   "List.head_map._proof_1",
   "Option.map",
   "Eq.mpr",
   "Eq.ndrec"],
  "name": "List.getLast?_map",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {f : α → β} {l : List α}, (List.map f l).getLast? = Option.map f l.getLast?",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "LT.lt",
   "Lean.Grind.OrderedAdd.add_lt_left",
   "id",
   "Lean.Grind.AddCommMonoid.add_comm",
   "Eq.mpr",
   "congrArg"],
  "name": "Lean.Grind.OrderedAdd.add_lt_right",
  "constType":
  "∀ {M : Type u} [inst : LE M] [inst_1 : Std.IsPreorder M] [inst_2 : Grind.AddCommMonoid M] [Grind.OrderedAdd M]\n  [inst_4 : LT M] [LawfulOrderLT M] {a b : M} (c : M), a < b → c + a < c + b",
  "constCategory": "Theorem"},
 {"references": ["Prod.casesOn", "Prod.noConfusionType", "Eq.ndrec"],
  "name": "Prod.noConfusion",
  "constType":
  "{α : Type u} → {β : Type v} → {P : Sort u_1} → {x1 x2 : α ⨉ β} → x1 = x2 → Prod.noConfusionType P x1 x2",
  "constCategory": "Definition"},
 {"references": [],
  "name": "And.casesOn",
  "constType":
  "{a b : Prop} → {motive : a ∧ b → Sort u} → (t : a ∧ b) → ((left : a) → (right : b) → motive ⋯) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["Inv.inv",
   "IsUnit.unit._proof_2",
   "Units.val",
   "IsUnit.unit._proof_1",
   "IsUnit",
   "Classical.choose",
   "Units.copy"],
  "name": "IsUnit.unit",
  "constType": "{M : Type u_1} → [inst : Monoid M] → {a : M} → IsUnit a → Mˣ",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Omega.IntList.dot_nil_right",
   "Eq.trans",
   "List.casesOn",
   "Membership.mem",
   "HMul.hMul",
   "Int.add_zero",
   "_private.Init.Omega.IntList.0.List.mem_cons_of_mem",
   "_private.Init.Omega.IntList.0.Lean.Omega.IntList.dot_of_left_zero._simp_1_1",
   "OfNat.ofNat",
   "congrArg",
   "HAdd.hAdd",
   "eq_self",
   "Int.zero_mul",
   "Lean.Omega.IntList",
   "of_eq_true",
   "Lean.Omega.IntList.dot_cons₂",
   "id",
   "Eq.symm",
   "Eq.mpr",
   "Lean.Omega.IntList.dot",
   "Eq.ndrec"],
  "name": "Lean.Omega.IntList.dot_of_left_zero",
  "constType": "∀ {xs ys : Omega.IntList}, (∀ x ∈ xs, x = 0) → xs.dot ys = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.cast",
   "Eq.mp",
   "LE.le",
   "HSub.hSub",
   "Int.le.dest_sub",
   "Int.sub_zero",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Int.eq_ofNat_of_zero_le",
  "constType": "∀ {a : ℤ}, 0 ≤ a → ∃ n, a = ↑n",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "Int.Linear.Poly.beq'",
   "Eq.trans",
   "Int.Linear.Poly.denote'_eq_denote",
   "Int.Linear.Poly.denote",
   "HMul.hMul",
   "Int.neg_one_mul",
   "congrArg",
   "Int.Linear.Var.denote",
   "Int.sub_self",
   "HSub.hSub",
   "Eq.symm",
   "Int.Linear.Poly.denote'",
   "Int.sub_eq_add_neg",
   "Eq.ndrec",
   "Int.Linear.eq_def_cert",
   "Neg.neg",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "Int.Linear.Context",
   "Int.add_comm",
   "Int.Linear.Poly.beq'_eq",
   "id",
   "Eq.mpr",
   "Int.Linear.Var"],
  "name": "Int.Linear.eq_def",
  "constType":
  "∀ (ctx : Int.Linear.Context) (x : Int.Linear.Var) (xPoly p : Int.Linear.Poly),\n  Int.Linear.eq_def_cert x xPoly p = true →\n    Int.Linear.Var.denote ctx x = Int.Linear.Poly.denote' ctx xPoly → Int.Linear.Poly.denote' ctx p = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Omega.LinearCombo.mul_eval",
   "Nat.cast",
   "Eq.trans",
   "le_of_le_of_eq",
   "HMul.hMul",
   "Lean.Omega.LinearCombo.coordinate_eval_0",
   "Lean.Omega.Constraint.combine_sat'",
   "Decidable.decide",
   "Lean.Omega.Int.ofNat_le_of_le",
   "Lean.Omega.Int.mul_congr",
   "Lean.Omega.Coeffs.ofList",
   "Lean.Omega.tidy_sat",
   "Eq.symm",
   "HSub.hSub",
   "Lean.Omega.LinearCombo.add_eval",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "of_decide_eq_true",
   "Not",
   "Neg.neg",
   "And.right",
   "Lean.Omega.Constraint.addInequality_sat",
   "Lean.Omega.Int.add_congr",
   "Lean.Omega.Constraint.isImpossible",
   "Lean.Omega.LinearCombo.coordinate",
   "OfNat.ofNat",
   "Int.sub_nonneg_of_le",
   "Lean.Omega.LinearCombo.coordinate_eval_1",
   "LT.lt",
   "HAdd.hAdd",
   "Lean.Omega.LinearCombo.mul",
   "Nat.le_of_not_lt",
   "Lean.Omega.LinearCombo.sub_eval",
   "Lean.Omega.Coeffs.isZero",
   "LE.le",
   "Int.natCast_add",
   "id",
   "Int.natCast_mul",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.Int.sub_congr"],
  "name": "CellularAutomatas.middle_reachable_card._proof_1_1",
  "constType":
  "∀ (k' : ℕ) ⦃pos : ℕ⦄, k' + 1 ≤ pos ∧ pos ≤ 2 * (k' + 1) → ¬pos < 2 * (k' + 1) + 1 → False",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "LT.lt",
   "Iff.trans",
   "zero_add",
   "AddRightStrictMono",
   "add_lt_add_iff_right",
   "id",
   "Eq.mpr",
   "Iff.rfl",
   "OfNat.ofNat",
   "congrArg",
   "AddRightReflectLT"],
  "name": "lt_add_iff_pos_left",
  "constType":
  "∀ {α : Type u_1} [inst : AddZeroClass α] [inst_1 : LT α] [AddRightStrictMono α] [AddRightReflectLT α] (a : α) {b : α},\n  a < b + a ↔ 0 < b",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.le_sub_iff_add_le",
   "HAdd.hAdd",
   "Nat.le_trans",
   "Nat.add_sub_assoc",
   "Nat.le_add_left",
   "LE.le",
   "Eq.symm",
   "id",
   "HSub.hSub",
   "Eq.mpr",
   "propext",
   "congrArg"],
  "name": "Nat.Simproc.add_le_add_le",
  "constType":
  "∀ (a c : ℕ) {b d : ℕ}, b ≤ d → (a + b ≤ c + d) = (a ≤ c + (d - b))",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Lean.MacroScopesView.imported",
  "constType": "MacroScopesView → Name",
  "constCategory": "Definition"},
 {"references":
  ["CellularAutomatas.Word",
   "CellularAutomatas.FiniteStateTransducer.comp_scanr_q",
   "CellularAutomatas.FiniteStateTransducer.comp",
   "funext",
   "id",
   "CellularAutomatas.FiniteStateTransducer.scanr",
   "Function.comp",
   "CellularAutomatas.FiniteStateTransducer.q0"],
  "name": "CellularAutomatas.FiniteStateTransducer.compose_spec2",
  "constType":
  "∀ {α β γ : Type} [CellularAutomatas.Alphabet α] [CellularAutomatas.Alphabet β] [CellularAutomatas.Alphabet γ]\n  (M2 : CellularAutomatas.FiniteStateTransducer β γ) (M1 : CellularAutomatas.FiniteStateTransducer α β),\n  (M2 ⊚ M1).scanr = M2.scanr ∘ M1.scanr",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CellularAutomatas.CellAutomaton.δ",
  "constType":
  "(self : CellularAutomatas.CellAutomaton) → self.Q → self.Q → self.Q → self.Q",
  "constCategory": "Definition"},
 {"references": ["CellularAutomatas.middle_not_two_stage_advice"],
  "name": "CellularAutomatas.results.result_middle_not_two_stage_advice",
  "constType":
  "∀ {α : Type} [inst : CellularAutomatas.Alphabet α], ¬(CellularAutomatas.Advice.middle α).is_two_stage_advice",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CellularAutomatas.LCellAutomaton.mk",
  "constType":
  "{α : Type} →\n  (toCellAutomaton : CellularAutomatas.CellAutomaton) →\n    (α → toCellAutomaton.Q) → toCellAutomaton.Q → CellularAutomatas.LCellAutomaton α",
  "constCategory": "Other"},
 {"references": [],
  "name": "CellularAutomatas.DefinesLanguage.rec",
  "constType":
  "{CA : Sort u_1} →\n  {α : Type} →\n    {motive : CellularAutomatas.DefinesLanguage CA α → Sort u} →\n      ((L : CA → Language α) → motive { L := L }) → (t : CellularAutomatas.DefinesLanguage CA α) → motive t",
  "constCategory": "Other"},
 {"references": [],
  "name": "Neg.neg",
  "constType": "{α : Type u} → [self : Neg α] → α → α",
  "constCategory": "Definition"},
 {"references":
  ["implies_congr",
   "Int.Linear.Poly.isUnsatDiseq_k",
   "Decidable.not_not._simp_1",
   "Eq.trans",
   "imp_self._simp_1",
   "Int.Linear.Poly.denote'_eq_denote",
   "Int.Linear.Poly.denote",
   "HMul.hMul",
   "Bool.false_eq_true",
   "congrArg",
   "Int.Linear.Var.denote",
   "Int.beq'_eq",
   "Eq.symm",
   "false_implies",
   "Int.beq'",
   "Int.Linear.Poly.denote'",
   "Eq.ndrec",
   "Not",
   "Int.Linear.Poly.casesOn",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "Int.Linear.Context",
   "of_eq_true",
   "Int.add_comm",
   "id",
   "Ne",
   "Eq.mpr",
   "imp_false._simp_1",
   "Int.Linear.Var"],
  "name": "Int.Linear.diseq_unsat",
  "constType":
  "∀ (ctx : Int.Linear.Context) (p : Int.Linear.Poly), p.isUnsatDiseq_k = true → Int.Linear.Poly.denote' ctx p ≠ 0 → False",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Lean.ConstantInfo.casesOn",
  "constType":
  "{motive : ConstantInfo → Sort u} →\n  (t : ConstantInfo) →\n    ((val : AxiomVal) → motive (ConstantInfo.axiomInfo val)) →\n      ((val : DefinitionVal) → motive (ConstantInfo.defnInfo val)) →\n        ((val : TheoremVal) → motive (ConstantInfo.thmInfo val)) →\n          ((val : OpaqueVal) → motive (ConstantInfo.opaqueInfo val)) →\n            ((val : QuotVal) → motive (ConstantInfo.quotInfo val)) →\n              ((val : InductiveVal) → motive (ConstantInfo.inductInfo val)) →\n                ((val : ConstructorVal) → motive (ConstantInfo.ctorInfo val)) →\n                  ((val : RecursorVal) → motive (ConstantInfo.recInfo val)) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["CellularAutomatas.LcInRt.O_L_eq_L_c",
   "rfl",
   "Eq.mp",
   "Set",
   "CellularAutomatas.LcInRt.myCA_in_rt",
   "Membership.mem",
   "CellularAutomatas.LcInRt.O",
   "Language",
   "CellularAutomatas.tCellAutomatonWithAdvice.L",
   "congrArg",
   "Exists.casesOn",
   "HAdd.hAdd",
   "CellularAutomatas.ℒ",
   "CellularAutomatas.LcInRt.AdvCALc",
   "CellularAutomatas.L_c",
   "Eq.symm",
   "id",
   "CellularAutomatas.CA_rt",
   "Eq.mpr",
   "CellularAutomatas.tCellAutomatonWithAdvice.with_advice",
   "CellularAutomatas.DefinesLanguage.L",
   "CellularAutomatas.tCellAutomaton.L",
   "And.casesOn",
   "CellularAutomatas.Advice.rt_closed"],
  "name": "CellularAutomatas.L_c_in_rt",
  "constType":
  "∀ {α : Type} [inst : CellularAutomatas.Alphabet α] {Γ : Type} [inst_1 : CellularAutomatas.Alphabet Γ]\n  (adv : CellularAutomatas.Advice α Γ),\n  adv.rt_closed → ∀ (c : Γ), ∃ M ∈ CellularAutomatas.CA_rt α, M.L = CellularAutomatas.L_c adv c",
  "constCategory": "Theorem"},
 {"references": ["rfl", "Nat.iterate", "funext", "OfNat.ofNat"],
  "name": "Function.iterate_one",
  "constType": "∀ {α : Type u} (f : α → α), f^[1] = f",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "id",
  "constType": "{α : Sort u} → α → α",
  "constCategory": "Definition"},
 {"references": ["Int.casesOn"],
  "name": "_private.Init.Data.Int.Lemmas.0.Int.one_mul.match_1_1",
  "constType":
  "∀ (motive : ℤ → Prop) (x : ℤ), (∀ (n : ℕ), motive (Int.ofNat n)) → (∀ (n : ℕ), motive (Int.negSucc n)) → motive x",
  "constCategory": "Definition"},
 {"references": ["LT.lt", "Nat.not_lt_zero", "eq_false", "OfNat.ofNat"],
  "name": "Nat.not_lt_zero._simp_1",
  "constType": "∀ (n : ℕ), (n < 0) = False",
  "constCategory": "Theorem"},
 {"references": ["and_imp"],
  "name": "not_and",
  "constType": "∀ {a b : Prop}, ¬(a ∧ b) ↔ a → ¬b",
  "constCategory": "Theorem"},
 {"references": ["CellularAutomatas.FiniteStateTransducer.advice"],
  "name": "CellularAutomatas.FiniteStateTransducer.advice.eq_1",
  "constType":
  "∀ {α β : Type} [inst : CellularAutomatas.Alphabet α] [inst_1 : CellularAutomatas.Alphabet β]\n  (M : CellularAutomatas.FiniteStateTransducer α β), M.advice = { f := fun w => M.scanr w, len := ⋯ }",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "CellularAutomatas.CArtTransducer.mk.noConfusion",
   "CellularAutomatas.CellAutomaton.Q"],
  "name": "CellularAutomatas.CArtTransducer.mk.inj",
  "constType":
  "∀ {α Γ : Type} {inst : CellularAutomatas.Alphabet α} {inst_1 : CellularAutomatas.Alphabet Γ}\n  {toLCellAutomaton : CellularAutomatas.LCellAutomaton α} {f : toLCellAutomaton.Q → Γ}\n  {toLCellAutomaton_1 : CellularAutomatas.LCellAutomaton α} {f_1 : toLCellAutomaton_1.Q → Γ},\n  { toLCellAutomaton := toLCellAutomaton, f := f } = { toLCellAutomaton := toLCellAutomaton_1, f := f_1 } →\n    toLCellAutomaton = toLCellAutomaton_1 ∧ f ≍ f_1",
  "constCategory": "Theorem"},
 {"references":
  ["List.foldrM_pure",
   "eq_self",
   "Eq.trans",
   "of_eq_true",
   "Pure.pure",
   "List.foldrM",
   "Id.run",
   "Id",
   "congrArg",
   "List.foldr"],
  "name": "List.foldr_eq_foldrM",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {f : α → β → β} {b : β} {l : List α},\n  List.foldr f b l = (List.foldrM (fun x1 x2 => pure (f x1 x2)) b l).run",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.left_distrib",
   "Nat.mul_one",
   "Nat.Linear.Expr.toPoly.go",
   "Eq.trans",
   "Nat.beq_refl",
   "HMul.hMul",
   "Nat.Linear.Expr.toPoly.go.induct",
   "Nat.Linear.Poly",
   "congrArg",
   "Nat.Linear.fixedVar",
   "Nat.beq",
   "congr",
   "funext",
   "Nat.mul_assoc",
   "Nat.Linear.Context",
   "Nat.mul",
   "Nat.mul_comm",
   "Nat.zero_add",
   "BEq.rfl",
   "Lean.RArray.get",
   "Nat.add_comm",
   "Nat.zero_mul",
   "Nat.add_assoc",
   "cond",
   "OfNat.ofNat",
   "Nat.Linear.Var",
   "HAdd.hAdd",
   "eq_self",
   "Nat.Linear.Expr.denote",
   "of_eq_true",
   "Nat.Linear.Var.denote",
   "id",
   "Nat.Linear.Poly.denote",
   "LawfulBEq.eq_of_beq",
   "BEq.beq"],
  "name": "Nat.Linear.Expr.denote_toPoly_go",
  "constType":
  "∀ {k : ℕ} {p : Nat.Linear.Poly} (ctx : Nat.Linear.Context) (e : Nat.Linear.Expr),\n  Nat.Linear.Poly.denote ctx (Nat.Linear.Expr.toPoly.go k e p) =\n    k * Nat.Linear.Expr.denote ctx e + Nat.Linear.Poly.denote ctx p",
  "constCategory": "Theorem"},
 {"references": ["Language"],
  "name": "CellularAutomatas.DefinesLanguage.casesOn",
  "constType":
  "{CA : Sort u_1} →\n  {α : Type} →\n    {motive : CellularAutomatas.DefinesLanguage CA α → Sort u} →\n      (t : CellularAutomatas.DefinesLanguage CA α) → ((L : CA → Language α) → motive { L := L }) → motive t",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Lean.Omega.LinearCombo.const",
  "constType": "Omega.LinearCombo → ℤ",
  "constCategory": "Definition"},
 {"references":
  ["CellularAutomatas.Word.get'",
   "CellularAutomatas.apply_iterated_zero",
   "Eq.trans",
   "CellularAutomatas.CellAutomaton.next",
   "CellularAutomatas.δδt",
   "Membership.mem",
   "CellularAutomatas.Config",
   "Int.natAbs_neg",
   "CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "congrFun",
   "CellularAutomatas.LCellAutomaton.comp_succ_eq",
   "HSub.hSub",
   "CellularAutomatas.Word.range",
   "isAddUnit_zero._simp_3",
   "rfl",
   "CellularAutomatas.CellAutomaton.δ",
   "CellularAutomatas.δδ",
   "Neg.neg",
   "Nat.recAux",
   "add_zero",
   "CellularAutomatas.LCellAutomaton.comp",
   "eq_false",
   "CellularAutomatas.apply_iterated",
   "id",
   "Eq.mpr",
   "CellularAutomatas.Word.cone_prop",
   "Eq.mp",
   "Int.natAbs_of_isUnit",
   "congrArg",
   "CellularAutomatas.LCellAutomaton.embed",
   "CellularAutomatas.Word.cone_zero_eq_range",
   "congr",
   "CellularAutomatas.LCellAutomaton.embed_word",
   "CellularAutomatas.CellAutomaton.Q",
   "Int.natAbs",
   "dite_cond_eq_false",
   "CellularAutomatas.LCellAutomaton.border",
   "le_refl._simp_1",
   "Not",
   "Nat.zero_le._simp_1",
   "CellularAutomatas.Word",
   "Set",
   "CellularAutomatas.Word.cone",
   "IsUnit",
   "OfNat.ofNat",
   "CellularAutomatas.δδt_succ",
   "HAdd.hAdd",
   "eq_self",
   "of_eq_true",
   "LE.le"],
  "name":
  "CellularAutomatas.LCellAutomaton.comp_outside_word_cone_eq_border_pow_t",
  "constType":
  "∀ {α : Type} {C : CellularAutomatas.LCellAutomaton α} {w : CellularAutomatas.Word α} {t : ℕ} {i : ℤ},\n  i ∉ w.cone t → C.comp w t i = CellularAutomatas.δδt C.border t",
  "constCategory": "Theorem"},
 {"references": ["Option.casesOn"],
  "name": "Option.ctorIdx",
  "constType": "{α : Type u} → Option α → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["_private.Init.Data.Int.LemmasAux.0.Int.blt'_eq_true._proof_1_3",
   "Nat.cast",
   "Eq.trans",
   "noConfusion_of_Nat",
   "_private.Init.Data.Int.LemmasAux.0.Int.blt'_eq_true._proof_1_2",
   "Int.blt'",
   "true_iff",
   "congrArg",
   "False.elim",
   "congr",
   "Int.not_lt._simp_1",
   "Eq.symm",
   "_private.Init.Data.Int.LemmasAux.0.Int.blt'_eq_true._proof_1_4",
   "Eq.ndrec",
   "Bool.ctorIdx",
   "Not",
   "Nat.blt",
   "Int.casesOn",
   "eq_false'",
   "eq_iff_iff._simp_1",
   "LT.lt",
   "eq_self",
   "Decidable.byContradiction",
   "of_eq_true",
   "false_iff",
   "LE.le",
   "Nat.blt_eq",
   "id",
   "Eq.mpr",
   "Int.ofNat_lt._simp_1"],
  "name": "Int.blt'_eq_true",
  "constType": "∀ (a b : ℤ), (a.blt' b = true) = (a < b)",
  "constCategory": "Theorem"},
 {"references":
  ["Prod.casesOn",
   "List.casesOn",
   "Unit.unit",
   "Nat.Linear.Var",
   "Unit",
   "Nat.Linear.Poly"],
  "name": "Nat.Linear.Poly.denote.match_1",
  "constType":
  "(motive : Nat.Linear.Poly → Sort u_1) →\n  (p : Nat.Linear.Poly) →\n    (Unit → motive []) →\n      ((k : ℕ) → (v : Nat.Linear.Var) → (p : List (ℕ ⨉ Nat.Linear.Var)) → motive ((k, v) :: p)) → motive p",
  "constCategory": "Definition"},
 {"references": ["Lean.Omega.UpperBound", "Lean.Omega.LowerBound"],
  "name": "Lean.Omega.Constraint.casesOn",
  "constType":
  "{motive : Omega.Constraint → Sort u} →\n  (t : Omega.Constraint) →\n    ((lowerBound : Omega.LowerBound) →\n        (upperBound : Omega.UpperBound) → motive { lowerBound := lowerBound, upperBound := upperBound }) →\n      motive t",
  "constCategory": "Definition"},
 {"references":
  ["HAdd.hAdd",
   "Lean.Grind.CommRing.Poly.brecOn",
   "Lean.Grind.Ring.intCast",
   "Lean.Grind.CommRing.Poly.denote.match_1",
   "Lean.Grind.CommRing.Poly.below",
   "Lean.Grind.CommRing.Mon.denote",
   "HSMul.hSMul",
   "Int.cast",
   "Lean.Grind.CommRing.Context"],
  "name": "Lean.Grind.CommRing.Poly.denote",
  "constType":
  "{α : Type u_1} → [Grind.Ring α] → Grind.CommRing.Context α → Grind.CommRing.Poly → α",
  "constCategory": "Definition"},
 {"references":
  ["Not",
   "CellularAutomatas.simulation.Params.C_ctl",
   "CellularAutomatas.CellAutomaton.Q",
   "CellularAutomatas.simulation.Q1.mk.noConfusion",
   "OfNat.ofNat"],
  "name": "CellularAutomatas.simulation.instDecidableEqQ1.decEq._proof_2",
  "constType":
  "∀ {e : CellularAutomatas.simulation.Params} (a : e.C_ctl.Q) (a_1 b : Fin 3),\n  ¬a_1 = b → { state := a, counter := a_1 } = { state := a, counter := b } → False",
  "constCategory": "Theorem"},
 {"references": ["Not", "Decidable.casesOn"],
  "name": "_private.Init.Core.0.dif_neg.match_1_1",
  "constType":
  "∀ {c : Prop} (motive : Decidable c → Prop) (h : Decidable c),\n  (∀ (hc : c), motive (isTrue hc)) → (∀ (h : ¬c), motive (isFalse h)) → motive h",
  "constCategory": "Definition"},
 {"references": ["Nat.casesOn", "List.casesOn", "OfNat.ofNat"],
  "name": "_private.Init.Data.List.TakeDrop.0.List.take_append_drop.match_1_1",
  "constType":
  "∀ {α : Type u_1} (motive : ℕ → List α → Prop) (x : ℕ) (x_1 : List α),\n  (∀ (x : List α), motive 0 x) →\n    (∀ (n : ℕ), motive n.succ []) → (∀ (n : ℕ) (x : α) (tail : List α), motive n.succ (x :: tail)) → motive x x_1",
  "constCategory": "Definition"},
 {"references": ["PartialOrder.le_antisymm"],
  "name": "le_antisymm",
  "constType":
  "∀ {α : Type u_1} [inst : PartialOrder α] {a b : α}, a ≤ b → b ≤ a → a = b",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "CellularAutomatas.ℒ",
   "Set",
   "CellularAutomatas.CA_rt",
   "Language"],
  "name": "CellularAutomatas.Advice.rt_closed",
  "constType":
  "{α Γ : Type} → [CellularAutomatas.Alphabet α] → [CellularAutomatas.Alphabet Γ] → CellularAutomatas.Advice α Γ → Prop",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CellularAutomatas.CellAutomaton.casesOn",
  "constType":
  "{motive : CellularAutomatas.CellAutomaton → Sort u} →\n  (t : CellularAutomatas.CellAutomaton) →\n    ((Q : Type) →\n        [alphabetQ : CellularAutomatas.Alphabet Q] →\n          (δ : Q → Q → Q → Q) → motive { Q := Q, alphabetQ := alphabetQ, δ := δ }) →\n      motive t",
  "constCategory": "Definition"},
 {"references": ["Setoid.r", "Quot.sound", "List.map", "List.Perm.map"],
  "name": "Multiset.map._proof_1",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} (f : α → β) (_l₁ _l₂ : List α),\n  (List.isSetoid α) _l₁ _l₂ →\n    Quot.mk (⇑(List.isSetoid β)) (List.map f _l₁) = Quot.mk (⇑(List.isSetoid β)) (List.map f _l₂)",
  "constCategory": "Theorem"},
 {"references": ["eq_true", "trivial"],
  "name": "true_or",
  "constType": "∀ (p : Prop), (True ∨ p) = True",
  "constCategory": "Theorem"},
 {"references": ["Not", "Decidable.byCases.match_1"],
  "name": "Decidable.byCases",
  "constType":
  "{p : Prop} → {q : Sort u} → [dec : Decidable p] → (p → q) → (¬p → q) → q",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Grind.CommRing.Poly.pow",
   "Lean.Grind.Ring.intCast",
   "Eq.trans",
   "Lean.Grind.Ring.intCast_one",
   "Lean.Grind.CommRing.Poly.mul",
   "HMul.hMul",
   "Lean.Grind.CommRing.Poly.pow.induct_unfolding",
   "Lean.Grind.Semiring.pow_zero",
   "Lean.Grind.CommRing.Poly.denote_mul",
   "Lean.Grind.Semiring.one_mul",
   "HPow.hPow",
   "Int.cast",
   "OfNat.ofNat",
   "congrArg",
   "HAdd.hAdd",
   "eq_self",
   "Lean.Grind.CommRing.mul_comm",
   "of_eq_true",
   "Lean.Grind.Semiring.pow_succ",
   "congr",
   "Lean.Grind.CommRing.Poly.denote",
   "Lean.Grind.CommRing.Context"],
  "name": "Lean.Grind.CommRing.Poly.denote_pow",
  "constType":
  "∀ {α : Type u_1} [inst : Grind.CommRing α] (ctx : Grind.CommRing.Context α) (p : Grind.CommRing.Poly) (k : ℕ),\n  Grind.CommRing.Poly.denote ctx (p.pow k) = Grind.CommRing.Poly.denote ctx p ^ k",
  "constCategory": "Theorem"},
 {"references": ["ReflBEq.rfl"],
  "name": "BEq.rfl",
  "constType":
  "∀ {α : Type u_1} [inst : BEq α] [ReflBEq α] {a : α}, (a == a) = true",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt", "Lean.Omega.Constraint.isImpossible.match_1", "Decidable.decide"],
  "name": "Lean.Omega.Constraint.isImpossible",
  "constType": "Omega.Constraint → Bool",
  "constCategory": "Definition"},
 {"references": ["CellularAutomatas.simulation.instDecidableEqQ1.decEq"],
  "name": "CellularAutomatas.simulation.instDecidableEqQ1",
  "constType":
  "{e : CellularAutomatas.simulation.Params} → DecidableEq (CellularAutomatas.simulation.Q1 e)",
  "constCategory": "Definition"},
 {"references":
  ["Not",
   "not_false_eq_true",
   "Eq.trans",
   "of_eq_true",
   "eq_false",
   "Eq.symm",
   "Eq.ndrec",
   "congrArg"],
  "name": "Lean.Grind.Order.eq_mp_not",
  "constType": "∀ {p q : Prop}, p = q → ¬p → ¬q",
  "constCategory": "Theorem"},
 {"references": ["LT.lt", "eq_false", "Int.lt_irrefl"],
  "name": "Int.lt_irrefl._simp_1",
  "constType": "∀ (a : ℤ), (a < a) = False",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Omega.Constraint.upperBound",
   "Max.max",
   "Min.min",
   "Lean.Omega.Constraint.lowerBound",
   "Option.merge"],
  "name": "Lean.Omega.Constraint.combine",
  "constType": "Omega.Constraint → Omega.Constraint → Omega.Constraint",
  "constCategory": "Definition"},
 {"references": [],
  "name": "SizeOf.sizeOf",
  "constType": "{α : Sort u} → [self : SizeOf α] → α → ℕ",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CellularAutomatas.FiniteStateTransducer.casesOn",
  "constType":
  "{α β : Type} →\n  {motive : CellularAutomatas.FiniteStateTransducer α β → Sort u} →\n    (t : CellularAutomatas.FiniteStateTransducer α β) →\n      ((Q : Type) →\n          [alphabetQ : CellularAutomatas.Alphabet Q] →\n            (δ : Q → α → Q) →\n              (q0 : Q) → (f : Q → β) → motive { Q := Q, alphabetQ := alphabetQ, δ := δ, q0 := q0, f := f }) →\n        motive t",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CellularAutomatas.VerificationError",
  "constType": "Type",
  "constCategory": "Other"},
 {"references": ["Inhabited.default"],
  "name": "CellularAutomatas.FiniteStateTransducer.M_map",
  "constType":
  "{α β : Type} →\n  [CellularAutomatas.Alphabet α] →\n    [CellularAutomatas.Alphabet β] → (α → β) → CellularAutomatas.FiniteStateTransducer α β",
  "constCategory": "Definition"},
 {"references":
  ["implies_congr",
   "forall_eq_or_imp._simp_1",
   "Eq.trans",
   "Membership.mem",
   "List.not_mem_nil._simp_1",
   "List.map",
   "congrArg",
   "eq_self",
   "implies_true",
   "of_eq_true",
   "iff_self",
   "List.cons.injEq",
   "congr",
   "forall_congr",
   "false_implies",
   "List.mem_cons._simp_1",
   "propext"],
  "name": "List.map_inj_left",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {l : List α} {f g : α → β}, List.map f l = List.map g l ↔ ∀ a ∈ l, f a = g a",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "LT.lt",
   "_private.Init.Data.Int.Order.0.Int.le_of_lt.match_1_1",
   "Nat.cast",
   "Int.lt.dest",
   "Int.le.intro",
   "LE.le"],
  "name": "Int.le_of_lt",
  "constType": "∀ {a b : ℤ}, a < b → a ≤ b",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "LT.lt",
   "Lean.Grind.AddCommGroup.sub_add_cancel",
   "Lean.Grind.AddCommMonoid.zero_add",
   "id",
   "HSub.hSub",
   "Eq.mpr",
   "Iff.rfl",
   "propext",
   "OfNat.ofNat",
   "Lean.Grind.OrderedAdd.add_lt_left_iff",
   "congrArg"],
  "name": "Lean.Grind.OrderedAdd.sub_pos_iff",
  "constType":
  "∀ {M : Type u} [inst : LE M] [inst_1 : Std.IsPreorder M] [inst_2 : Grind.AddCommGroup M] [Grind.OrderedAdd M]\n  [inst_4 : LT M] [LawfulOrderLT M] {a b : M}, 0 < a - b ↔ b < a",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "HAdd.hAdd",
   "Lean.Grind.Nat.lt_eq",
   "List.take",
   "LE.le",
   "HSub.hSub",
   "OfNat.ofNat",
   "Eq.mpr_prop",
   "List.length"],
  "name": "CellularAutomatas.PrefixStableProof.getLastOfTake._proof_1_16",
  "constType":
  "∀ {i : ℕ} {α : Type u_1} {w : List α},\n  (List.take (i + 1) w).length - 1 + 1 ≤ (List.take (List.take i w).length w).length →\n    (List.take (i + 1) w).length - 1 < (List.take (List.take i w).length w).length",
  "constCategory": "Theorem"},
 {"references": ["Iff.rfl"],
  "name": "imp_false",
  "constType": "∀ {a : Prop}, a → False ↔ ¬a",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Grind.Semiring.ofNat_eq_natCast",
   "Nat.cast",
   "NatCast.natCast",
   "id",
   "Eq.mpr",
   "Lean.Grind.Semiring.natCast",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Lean.Grind.Semiring.natCast_eq_ofNat",
  "constType":
  "∀ {α : Type u} [inst : Grind.Semiring α] (n : ℕ), ↑n = OfNat.ofNat n",
  "constCategory": "Theorem"},
 {"references": ["forall_eq_or_imp", "propext"],
  "name": "forall_eq_or_imp._simp_1",
  "constType":
  "∀ {α : Sort u_1} {p q : α → Prop} {a' : α}, (∀ (a : α), a = a' ∨ q a → p a) = (p a' ∧ ∀ (a : α), q a → p a)",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.Word",
   "CellularAutomatas.FiniteStateTransducer.Q",
   "CellularAutomatas.FiniteStateTransducer.scanr_reduce"],
  "name": "CellularAutomatas.FiniteStateTransducer.scanr_reduce_cons",
  "constType":
  "∀ {α β : Type} {M : CellularAutomatas.FiniteStateTransducer α β} {w : α} (ws : CellularAutomatas.Word α),\n  M.scanr_reduce (w :: ws) = M.δ (M.scanr_reduce ws) w",
  "constCategory": "Theorem"},
 {"references": ["HAdd.hAdd", "add_assoc", "Eq.symm"],
  "name": "Mathlib.Tactic.RingNF.add_assoc_rev",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] (a b c : R), a + (b + c) = a + b + c",
  "constCategory": "Theorem"},
 {"references": ["exists_eq_left'", "propext"],
  "name": "exists_eq_left'._simp_1",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {a' : α}, (∃ a, a' = a ∧ p a) = p a'",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CellularAutomatas.VerificationError.mk._flat_ctor",
  "constType":
  "Name → String → List String → CellularAutomatas.VerificationError",
  "constCategory": "Definition"},
 {"references": ["Subsingleton.allEq"],
  "name": "Subsingleton.elim",
  "constType": "∀ {α : Sort u} [h : Subsingleton α] (a b : α), a = b",
  "constCategory": "Theorem"},
 {"references": ["Classical.propDecidable._proof_1", "Classical.choice"],
  "name": "Classical.propDecidable",
  "constType": "(a : Prop) → Decidable a",
  "constCategory": "Definition"},
 {"references":
  ["rfl",
   "HAdd.hAdd",
   "_private.Init.Data.Int.Lemmas.0.Int.add_zero.match_1_1",
   "OfNat.ofNat"],
  "name": "Int.add_zero",
  "constType": "∀ (a : ℤ), a + 0 = a",
  "constCategory": "Theorem"},
 {"references": ["LT.lt", "Eq.ndrec"],
  "name": "Fin.mk.congr_simp",
  "constType":
  "∀ {n : ℕ} (val val_1 : ℕ) (e_val : val = val_1) (isLt : val < n), ⟨val, isLt⟩ = ⟨val_1, ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["absurd",
   "LT.lt",
   "Not",
   "le_refl",
   "le_of_lt",
   "LE.le",
   "_private.Mathlib.Order.Defs.LinearOrder.0.le_of_not_gt.match_1_1",
   "lt_trichotomy"],
  "name": "le_of_not_gt",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrder α] {a b : α}, ¬b < a → a ≤ b",
  "constCategory": "Theorem"},
 {"references":
  ["Multiset.map",
   "Setoid.r",
   "Multiset.Nodup",
   "Membership.mem",
   "Quot.induction_on",
   "List.Nodup.map_on",
   "Multiset"],
  "name": "Multiset.Nodup.map_on",
  "constType":
  "∀ {α : Type u_1} {β : Type v} {s : Multiset α} {f : α → β},\n  (∀ x ∈ s, ∀ y ∈ s, f x = f y → x = y) → s.Nodup → (Multiset.map f s).Nodup",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans",
   "Lean.Omega.Decidable.or_not_not_of_not_and",
   "le_of_le_of_eq",
   "Classical.propDecidable",
   "GE.ge",
   "Lean.Omega.tidy_sat",
   "HSub.hSub",
   "Eq.symm",
   "Lean.Omega.ite_disjunction",
   "Lean.Omega.Int.lt_of_not_le",
   "Lean.Omega.LinearCombo.add_eval",
   "Int.add_one_le_of_lt",
   "And.left",
   "Lean.Omega.combo_sat'",
   "Neg.neg",
   "And.right",
   "Lean.Omega.Constraint.addInequality_sat",
   "Lean.Omega.Int.le_of_not_lt",
   "Lean.Omega.LinearCombo.coordinate",
   "Nat.lt_of_not_le",
   "id",
   "Lean.Omega.Constraint.addEquality_sat",
   "Lean.Omega.Int.sub_congr",
   "Int.toNat_eq_max",
   "List.length",
   "Int.toNat",
   "Or.elim",
   "Nat.cast",
   "Lean.Omega.LinearCombo.coordinate_eval_2",
   "Lean.Omega.Constraint.combine_sat'",
   "Lean.Omega.LinearCombo.coordinate_eval_0",
   "Int.sub_eq_zero_of_eq",
   "Decidable.decide",
   "Lean.Omega.Coeffs.ofList",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "of_decide_eq_true",
   "Not",
   "CellularAutomatas.Word",
   "ite",
   "Lean.Omega.Int.add_congr",
   "Lean.Omega.Constraint.isImpossible",
   "OfNat.ofNat",
   "Int.sub_nonneg_of_le",
   "Int.ofNat_nonneg",
   "LT.lt",
   "HAdd.hAdd",
   "Lean.Omega.LinearCombo.coordinate_eval_1",
   "Max.max",
   "Lean.Omega.LinearCombo.sub_eval",
   "Lean.Omega.Int.ofNat_lt_of_lt",
   "Int.max_def",
   "LE.le",
   "Lean.Omega.LinearCombo.eval"],
  "name": "CellularAutomatas.FiniteStateTransducer.scanr_reduce'?._proof_1_6",
  "constType":
  "∀ {α : Type} (w : CellularAutomatas.Word α) (i : ℤ),\n  ¬(i ≥ 0 ∧ i < ↑(List.length w)) → ¬i < 0 → ¬i.toNat ≥ List.length w → False",
  "constCategory": "Theorem"},
 {"references":
  ["Inv.inv", "Units.val", "Units.copy._proof_2", "Units.copy._proof_1"],
  "name": "Units.copy",
  "constType":
  "{α : Type u} → [inst : Monoid α] → (u : αˣ) → (val : α) → val = ↑u → (inv : α) → inv = ↑u⁻¹ → αˣ",
  "constCategory": "Definition"},
 {"references":
  ["HAppend.hAppend",
   "eq_self",
   "Option.or",
   "of_eq_true",
   "List.casesOn",
   "Eq.symm",
   "Eq.ndrec",
   "List.head?"],
  "name": "List.head?_append",
  "constType":
  "∀ {α : Type u_1} {l' l : List α}, (l ++ l').head? = l.head?.or l'.head?",
  "constCategory": "Theorem"},
 {"references": ["Nat.below", "Nat.brecOn", "Nat.ble.match_1"],
  "name": "Nat.ble",
  "constType": "ℕ → ℕ → Bool",
  "constCategory": "Definition"},
 {"references": ["HAdd.hAdd", "LT.lt", "Int.add_comm", "Int.add_lt_add_left"],
  "name": "Int.add_lt_add_right",
  "constType": "∀ {a b : ℤ}, a < b → ∀ (c : ℤ), a + c < b + c",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CellularAutomatas.CArtTransducer.toLCellAutomaton",
  "constType":
  "{α Γ : Type} →\n  [inst : CellularAutomatas.Alphabet α] →\n    [inst_1 : CellularAutomatas.Alphabet Γ] → CellularAutomatas.CArtTransducer α Γ → CellularAutomatas.LCellAutomaton α",
  "constCategory": "Definition"},
 {"references":
  ["CellularAutomatas.Word.get'",
   "Not",
   "CellularAutomatas.Word",
   "Eq.trans",
   "Eq.mp",
   "Set",
   "CellularAutomatas.Word.get_cone_0._proof_1",
   "Membership.mem",
   "CellularAutomatas.Word.cone",
   "eq_true",
   "OfNat.ofNat",
   "congrArg",
   "CellularAutomatas.LCellAutomaton.embed",
   "CellularAutomatas.Word.cone_zero_eq_range",
   "CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "eq_self",
   "dite_cond_eq_true",
   "of_eq_true",
   "CellularAutomatas.CellAutomaton.Q",
   "CellularAutomatas.Word.range",
   "CellularAutomatas.LCellAutomaton.border",
   "dite"],
  "name": "CellularAutomatas.LCellAutomaton.embed_word_eq_embed",
  "constType":
  "∀ {α : Type} {C : CellularAutomatas.LCellAutomaton α} {w : CellularAutomatas.Word α} {i : ℤ} (h : i ∈ w.cone 0),\n  C.embed_word w i = C.embed (CellularAutomatas.Word.get_cone_0 h)",
  "constCategory": "Theorem"},
 {"references": ["lt_of_le_of_ne"],
  "name": "LE.le.lt_of_ne",
  "constType":
  "∀ {α : Type u_1} [inst : PartialOrder α] {a b : α}, a ≤ b → a ≠ b → a < b",
  "constCategory": "Theorem"},
 {"references": ["Fin.isLt"],
  "name": "Fin.is_lt",
  "constType": "∀ {n : ℕ} (a : Fin n), ↑a < n",
  "constCategory": "Theorem"},
 {"references":
  ["Int.Linear.le_unsat",
   "Eq.trans",
   "CellularAutomatas.CellAutomaton.next",
   "Membership.mem",
   "CellularAutomatas.ca_id",
   "eq_true",
   "HMul.hMul",
   "eagerReduce",
   "ite_cond_eq_true",
   "Lean.Grind.intro_with_eq'",
   "heq_of_eq",
   "IntCast.intCast",
   "CellularAutomatas.Config",
   "Nat.ToInt.natCast_ofNat",
   "Inhabited.default",
   "Fin.mk.congr_simp",
   "Nat.ToInt.ofNat_toNat",
   "CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "Fin.val",
   "NatCast.natCast",
   "eq_of_heq",
   "funext",
   "Eq.symm",
   "Eq.ndrec",
   "CellularAutomatas.CArtTransducer.toLCellAutomaton",
   "of_eq_false",
   "GetElem.getElem.hcongr_8",
   "Neg.neg",
   "Int.Linear.diseq_unsat",
   "Int.Linear.eq_diseq_subst",
   "Lean.Grind.Int.lt_eq",
   "ite_cond_eq_false",
   "Lean.Grind.nestedProof",
   "eq_false",
   "Classical.byContradiction",
   "Int.Linear.not_eq_norm_expr",
   "id",
   "Lean.Grind.Order.eq_trans_true",
   "Int.Linear.eq_of_le_ge",
   "setOf",
   "List.length",
   "CellularAutomatas.Word.get'._proof_1",
   "Int.Linear.norm_le",
   "Int.toNat",
   "Nat.cast",
   "Eq.mp",
   "Lean.Grind.and_eq_of_eq_true_right",
   "GetElem.getElem",
   "Lean.Grind.nestedProof_congr",
   "Int.Linear.Expr.eq_of_norm_eq",
   "Int.Linear.le_neg",
   "congrArg",
   "dite_congr",
   "Lean.Grind.Nat.lt_eq",
   "Lean.Grind.nestedDecidable",
   "List.get",
   "congr",
   "Lean.Grind.dite_cond_eq_true'",
   "Nat.ToInt.of_diseq",
   "CellularAutomatas.CellAutomaton.Q",
   "Int.Linear.eq_of_core",
   "Not",
   "CellularAutomatas.Word",
   "CellularAutomatas.ca_id_comp_p0._proof_1_6",
   "Set.mem_setOf_eq",
   "Lean.Grind.em",
   "Lean.Grind.alreadyNorm",
   "Lean.Grind.Order.eq_trans_true'",
   "ite",
   "Set",
   "CellularAutomatas.CellAutomaton.nextt",
   "Nat.ToInt.add_congr",
   "Lean.Grind.Order.le_eq_true_of_le_k",
   "List.get_eq_getElem",
   "OfNat.ofNat",
   "Eq.mpr_prop",
   "LT.lt",
   "HAdd.hAdd",
   "CellularAutomatas.ca_id_comp_p0._proof_1_5",
   "Or.casesOn",
   "Nat.ToInt.le_eq",
   "of_eq_true",
   "Nat.ToInt.toNat_nonneg",
   "LE.le",
   "Lean.Grind.intro_with_eq",
   "Lean.Grind.CommRing.le_norm_expr",
   "CellularAutomatas.ca_id_comp_p0._proof_1_7",
   "dite",
   "Int.Linear.le_combine",
   "Fin.isLt",
   "Lean.Grind.Order.eq_mp"],
  "name": "CellularAutomatas.ca_id_comp_p0._proof_1_8",
  "constType":
  "∀ {t : ℕ} {α : Type} [inst : CellularAutomatas.Alphabet α] {w : CellularAutomatas.Word α} (h : t < List.length w),\n  (∀ (c : CellularAutomatas.Config (CellularAutomatas.ca_id α).Q),\n      (CellularAutomatas.ca_id α).next c = fun i => c (i + 1)) →\n    (∀ (k : ℕ) (c : CellularAutomatas.Config (CellularAutomatas.ca_id α).Q) (i : ℤ),\n        (CellularAutomatas.ca_id α).nextt c k i = c (i + ↑k)) →\n      (if h : 0 + ↑t ∈ {i | i ≥ 0 ∧ i < ↑(List.length w)} then List.get w ⟨(0 + ↑t).toNat, ⋯⟩ else default) = w[t]",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "rfl",
   "HAppend.hAppend",
   "List.drop",
   "List.take",
   "Nat.below",
   "Nat.brecOn",
   "List.append",
   "_private.Init.Data.List.TakeDrop.0.List.take_append_drop.match_1_1",
   "OfNat.ofNat",
   "congrArg"],
  "name": "List.take_append_drop",
  "constType":
  "∀ {α : Type u_1} (i : ℕ) (l : List α), List.take i l ++ l⟦i..*⟧ = l",
  "constCategory": "Theorem"},
 {"references": ["Nat.ble"],
  "name": "Int.ble'",
  "constType": "ℤ → ℤ → Bool",
  "constCategory": "Definition"},
 {"references": ["CellularAutomatas.FiniteStateTransducer.noConfusion", "id"],
  "name": "CellularAutomatas.FiniteStateTransducer.mk.noConfusion",
  "constType":
  "{α β : Type} →\n  (P : Sort u) →\n    (Q : Type) →\n      [alphabetQ : CellularAutomatas.Alphabet Q] →\n        (δ : Q → α → Q) →\n          (q0 : Q) →\n            (f : Q → β) →\n              (Q' : Type) →\n                (alphabetQ' : CellularAutomatas.Alphabet Q') →\n                  (δ' : Q' → α → Q') →\n                    (q0' : Q') →\n                      (f' : Q' → β) →\n                        { Q := Q, alphabetQ := alphabetQ, δ := δ, q0 := q0, f := f } =\n                            { Q := Q', alphabetQ := alphabetQ', δ := δ', q0 := q0', f := f' } →\n                          (Q = Q' → alphabetQ ≍ alphabetQ' → δ ≍ δ' → q0 ≍ q0' → f ≍ f' → P) → P",
  "constCategory": "Definition"},
 {"references":
  ["HAdd.hAdd",
   "HAppend.hAppend",
   "eq_self",
   "Nat.succ_add",
   "Eq.trans",
   "of_eq_true",
   "congr",
   "Nat.zero_add",
   "OfNat.ofNat",
   "congrArg",
   "List.length"],
  "name": "List.length_append",
  "constType":
  "∀ {α : Type u} {as bs : List α}, (as ++ bs).length = as.length + bs.length",
  "constCategory": "Theorem"},
 {"references":
  ["rfl",
   "Classical.choose_spec",
   "Not",
   "Eq.trans",
   "_private.Init.Classical.0.Classical.em.match_1_3",
   "eq_iff_iff._simp_1",
   "iff_false",
   "Classical.choose",
   "congrArg",
   "mt",
   "not_false_eq_true",
   "of_eq_true",
   "congr",
   "funext",
   "id",
   "_private.Init.Classical.0.Classical.em.match_1_1",
   "not_true_eq_false",
   "Eq.mpr",
   "Ne",
   "propext"],
  "name": "Classical.em",
  "constType": "∀ (p : Prop), p ∨ ¬p",
  "constCategory": "Theorem"},
 {"references":
  ["rfl",
   "CellularAutomatas.simulation.Params.C_ctl",
   "CellularAutomatas.CellAutomaton.Q",
   "OfNat.ofNat"],
  "name": "CellularAutomatas.simulation.instDecidableEqQ1.decEq._proof_1",
  "constType":
  "∀ {e : CellularAutomatas.simulation.Params} (a : e.C_ctl.Q) (a_1 : Fin 3),\n  { state := a, counter := a_1 } = { state := a, counter := a_1 }",
  "constCategory": "Theorem"},
 {"references": ["List.noConfusionType", "List.casesOn", "Eq.ndrec"],
  "name": "List.noConfusion",
  "constType":
  "{α : Type u} → {P : Sort u_1} → {x1 x2 : List α} → x1 = x2 → List.noConfusionType P x1 x2",
  "constCategory": "Definition"},
 {"references": ["Not", "Decidable.casesOn"],
  "name": "_private.Init.Core.0.if_neg.match_1_1",
  "constType":
  "∀ {c : Prop} (motive : Decidable c → Prop) (h : Decidable c),\n  (∀ (hc : c), motive (isTrue hc)) → (∀ (h : ¬c), motive (isFalse h)) → motive h",
  "constCategory": "Definition"},
 {"references": ["absurd", "Not", "False.elim", "propext"],
  "name": "eq_false",
  "constType": "∀ {p : Prop}, ¬p → p = False",
  "constCategory": "Theorem"},
 {"references": ["OrderedSub.tsub_le_iff_right"],
  "name": "tsub_le_iff_right",
  "constType":
  "∀ {α : Type u_1} [inst : LE α] [inst_1 : Add α] [inst_2 : Sub α] [OrderedSub α] {a b c : α}, a - b ≤ c ↔ a ≤ c + b",
  "constCategory": "Theorem"},
 {"references": ["LT.lt", "gt_iff_lt", "GT.gt", "propext"],
  "name": "gt_iff_lt._simp_1",
  "constType": "∀ {α : Type u_1} [inst : LT α] {x y : α}, (x > y) = (y < x)",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "not_and_or",
   "Eq.trans",
   "OfNat.ofNat",
   "congrArg",
   "LT.lt",
   "HAdd.hAdd",
   "add_eq_zero",
   "iff_self",
   "of_eq_true",
   "congr",
   "Ne",
   "propext",
   "pos_iff_ne_zero"],
  "name": "add_pos_iff",
  "constType":
  "∀ {α : Type u} [inst : AddCommMonoid α] [inst_1 : PartialOrder α] [CanonicallyOrderedAdd α] {a b : α},\n  0 < a + b ↔ 0 < a ∨ 0 < b",
  "constCategory": "Theorem"},
 {"references":
  ["List.getElem_map",
   "GetElem.getElem.congr_simp",
   "Eq.trans",
   "List.getElem_range",
   "CellularAutomatas.LCellAutomaton.scan_temporal",
   "GetElem.getElem",
   "congrArg",
   "CellularAutomatas.LCellAutomaton.scan_temporal_rt",
   "CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "CellularAutomatas.LcInRt.DiagonalShiftCA",
   "GetElem?.getElem?",
   "List.length_range",
   "congr",
   "funext",
   "CellularAutomatas.LcInRt.DiagonalShiftCA_comp_p0",
   "CellularAutomatas.CellAutomaton.Q",
   "Eq.ndrec",
   "CellularAutomatas.Word",
   "CellularAutomatas.LcInRt.DiagonalShiftCA_scan_temporal._simp_1_1",
   "List.map",
   "CellularAutomatas.LCellAutomaton.comp",
   "List.length_map",
   "OfNat.ofNat",
   "List.range",
   "LT.lt",
   "eq_self",
   "of_eq_true",
   "List.ext_getElem",
   "id",
   "List.length"],
  "name": "CellularAutomatas.LcInRt.DiagonalShiftCA_scan_temporal",
  "constType":
  "∀ {Q : Type} [inst : CellularAutomatas.Alphabet Q] (w : CellularAutomatas.Word Q),\n  (CellularAutomatas.LcInRt.DiagonalShiftCA Q).scan_temporal_rt w = List.map some w",
  "constCategory": "Theorem"},
 {"references": ["CellularAutomatas.t_2n", "CellularAutomatas.OCA"],
  "name": "CellularAutomatas.OCA_2n",
  "constType": "(α : Type) → Set (CellularAutomatas.tCellAutomaton α)",
  "constCategory": "Definition"},
 {"references":
  ["Neg.neg",
   "Lean.Grind.Semiring.mul_assoc",
   "id",
   "Lean.Grind.Ring.neg_eq_neg_one_mul",
   "HMul.hMul",
   "Eq.mpr",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Lean.Grind.Ring.neg_mul",
  "constType":
  "∀ {α : Type u} [inst : Grind.Ring α] (a b : α), -a * b = -(a * b)",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "Eq.trans",
   "Int.add_lt_add_iff_right",
   "HMul.hMul",
   "Bool.and",
   "False.elim",
   "Eq.symm",
   "Int.Linear.Poly.addConst_k",
   "Eq.ndrec",
   "Int.neg_eq_zero._simp_1",
   "Int.lt_of_le_of_lt",
   "Neg.neg",
   "Bool.or",
   "Int.Linear.Poly.denote_addConst",
   "Int.Linear.Poly.denote_mul",
   "id",
   "Int.Linear.Poly.beq'_eq",
   "Eq.mpr",
   "Bool.and_eq_true",
   "Bool.and'",
   "Int.Linear.Poly.beq'",
   "Int.Linear.Poly.denote'_eq_denote",
   "Eq.mp",
   "Int.Linear.Poly.addConst_k_eq_addConst",
   "Int.Linear.Poly.mul_k_eq_mul",
   "and_imp._simp_1",
   "Int.Linear.Poly.denote",
   "Int.neg_one_mul",
   "congrArg",
   "Bool.or_eq_true",
   "Int.Linear.Poly.mul_k",
   "congr",
   "Int.le_of_lt_add_one",
   "Int.Linear.Poly.denote'",
   "Int.Linear.le_of_le_diseq_cert",
   "propext",
   "Not",
   "Int.lt_or_gt_of_ne",
   "Bool.and'_eq_and",
   "Int.Linear.Poly.mul",
   "OfNat.ofNat",
   "Int.lt_irrefl._simp_1",
   "HAdd.hAdd",
   "Or.casesOn",
   "LT.lt",
   "Int.Linear.Context",
   "LE.le",
   "Int.add_comm",
   "Ne",
   "Int.Linear.Poly.addConst"],
  "name": "Int.Linear.le_of_le_diseq",
  "constType":
  "∀ (ctx : Int.Linear.Context) (p₁ p₂ p₃ : Int.Linear.Poly),\n  Int.Linear.le_of_le_diseq_cert p₁ p₂ p₃ = true →\n    Int.Linear.Poly.denote' ctx p₁ ≤ 0 → Int.Linear.Poly.denote' ctx p₂ ≠ 0 → Int.Linear.Poly.denote' ctx p₃ ≤ 0",
  "constCategory": "Theorem"},
 {"references":
  ["Or.elim",
   "Lean.Omega.LinearCombo.coordinate_eval_2",
   "Nat.cast",
   "Eq.trans",
   "le_of_le_of_eq",
   "Lean.Omega.LinearCombo.coordinate_eval_0",
   "Lean.Omega.Constraint.combine_sat'",
   "Int.sub_eq_zero_of_eq",
   "GE.ge",
   "Decidable.decide",
   "Lean.Omega.Int.ofNat_le_of_le",
   "Lean.Omega.LinearCombo.neg_eval",
   "Lean.Omega.Coeffs.ofList",
   "Lean.Omega.Int.ofNat_sub_dichotomy",
   "HSub.hSub",
   "Lean.Omega.tidy_sat",
   "Eq.symm",
   "Lean.Omega.LinearCombo.add_eval",
   "Lean.Omega.Int.neg_congr",
   "Int.add_one_le_of_lt",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "And.left",
   "of_decide_eq_true",
   "Not",
   "Int.lt_or_gt_of_ne",
   "Neg.neg",
   "And.right",
   "Lean.Omega.Constraint.addInequality_sat",
   "Lean.Omega.Int.add_congr",
   "Lean.Omega.Constraint.isImpossible",
   "Lean.Omega.LinearCombo.coordinate",
   "Int.sub_nonneg_of_le",
   "OfNat.ofNat",
   "Lean.Omega.LinearCombo.coordinate_eval_1",
   "LT.lt",
   "HAdd.hAdd",
   "Lean.Omega.Int.ofNat_lt_of_lt",
   "Lean.Omega.LinearCombo.sub_eval",
   "LE.le",
   "Int.natCast_add",
   "id",
   "Lean.Omega.Constraint.addEquality_sat",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.Int.sub_congr"],
  "name":
  "_private.Init.Grind.Ring.Basic.0.Lean.Grind.Ring.intCast_add._proof_1_6",
  "constType":
  "∀ (x y : ℕ), y ≥ x + 1 → ¬-↑(x + 1) + ↑y = ↑(y - (x + 1)) → False",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.simulation.Params.C_ctl",
   "CellularAutomatas.CellAutomaton.Q",
   "CellularAutomatas.simulation.Q1.casesOn",
   "OfNat.ofNat"],
  "name": "CellularAutomatas.simulation.Q1.noConfusionType",
  "constType":
  "{e : CellularAutomatas.simulation.Params} →\n  Sort u → CellularAutomatas.simulation.Q1 e → CellularAutomatas.simulation.Q1 e → Sort u",
  "constCategory": "Definition"},
 {"references":
  ["LT.lt",
   "CellularAutomatas.Word",
   "Nat.cast",
   "Set",
   "Membership.mem",
   "id",
   "inferInstance",
   "CellularAutomatas.Word.range",
   "GE.ge",
   "OfNat.ofNat",
   "List.length",
   "setOf"],
  "name": "CellularAutomatas.Word.instDecidableMemIntSetRange",
  "constType":
  "{α : Type u} → (w : CellularAutomatas.Word α) → (i : ℤ) → Decidable (i ∈ w.range)",
  "constCategory": "Definition"},
 {"references":
  ["implies_congr",
   "Nat.cast_one",
   "CellularAutomatas.Word.get'",
   "List.getElem_map",
   "not_lt._simp_1",
   "Eq.trans",
   "zero_sub",
   "List.getElem_range",
   "Membership.mem",
   "CellularAutomatas.scan_temporal_length",
   "GE.ge",
   "CellularAutomatas.tCellAutomaton.toLCellAutomaton",
   "CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "CellularAutomatas.LCellAutomaton.scan_temporal_rt",
   "dif_pos",
   "CellularAutomatas.scan_temporal_in_F_pos._proof_1_7",
   "funext",
   "CellularAutomatas.scan_temporal_in_F_pos._proof_1_5",
   "HSub.hSub",
   "CellularAutomatas.Word.range",
   "dif_neg",
   "not_and._simp_1",
   "inf_eq_left._simp_1",
   "Neg.neg",
   "And.right",
   "Nat.cast_min",
   "List.map",
   "Language",
   "CellularAutomatas.LCellAutomaton.comp",
   "List.length_map",
   "List.length_take_le'",
   "zero_add",
   "Decidable.byContradiction",
   "id",
   "Eq.mpr",
   "CellularAutomatas.tCellAutomaton.L",
   "setOf",
   "List.length",
   "lt_inf_iff._simp_1",
   "CellularAutomatas.Word.get'._proof_1",
   "CellularAutomatas.scan_temporal_in_F_pos._proof_1_1",
   "Int.toNat",
   "Nat.cast",
   "min_eq_left",
   "Eq.mp",
   "CellularAutomatas.tCellAutomaton.t",
   "CellularAutomatas.LCellAutomaton.scan_temporal",
   "GetElem.getElem",
   "List.length_take",
   "Bool.coe_iff_coe._simp_1",
   "CellularAutomatas.LCellAutomaton.embed",
   "congrArg",
   "CellularAutomatas.CA",
   "congr",
   "CellularAutomatas.LCellAutomaton.embed_word",
   "CellularAutomatas.CellAutomaton.Q",
   "CellularAutomatas.LCellAutomaton.border",
   "ge_iff_le._simp_1",
   "Nat.lt_of_lt_of_le",
   "Not",
   "add_tsub_cancel_right",
   "CellularAutomatas.Word",
   "Set",
   "OfNat.ofNat",
   "Nat.cast_add",
   "HAdd.hAdd",
   "LT.lt",
   "List.range",
   "eq_self",
   "of_eq_true",
   "Min.min",
   "List.take",
   "LE.le",
   "CellularAutomatas.CA_rt",
   "CellularAutomatas.tCellAutomaton.F_pos",
   "CellularAutomatas.nextt_congr",
   "dite",
   "Fin.isLt",
   "List.getElem_take"],
  "name": "CellularAutomatas.scan_temporal_in_F_pos",
  "constType":
  "∀ {α : Type} {C : CellularAutomatas.tCellAutomaton α},\n  C ∈ CellularAutomatas.CA_rt α →\n    ∀ {w : CellularAutomatas.Word α} (i : ℕ) (h : i < List.length (C.scan_temporal_rt w)),\n      C.F_pos (C.scan_temporal_rt w)[i] = true ↔ List.take (i + 1) w ∈ C.L",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.ℒ",
   "sorryAx",
   "CellularAutomatas.OCA_lt",
   "Set",
   "CellularAutomatas.OCA_2n",
   "Language",
   "OfNat.ofNat"],
  "name": "CellularAutomatas.results_unproven.oca_linear_time_eq_2n",
  "constType":
  "∀ {α : Type} [CellularAutomatas.Alphabet α],\n  CellularAutomatas.ℒ (CellularAutomatas.OCA_lt α) = CellularAutomatas.ℒ (CellularAutomatas.OCA_2n α)",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd", "add_assoc", "Eq.symm", "id", "Eq.mpr", "add_comm", "congrArg"],
  "name": "add_left_comm",
  "constType":
  "∀ {G : Type u_3} [inst : AddCommSemigroup G] (a b c : G), a + (b + c) = b + (a + c)",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.propIntro",
   "eq_of_heq",
   "Eq.symm",
   "Eq.ndrec",
   "Eq.casesOn",
   "CellularAutomatas.backwards_fsm.Params.mk.noConfusion",
   "HEq.casesOn",
   "And.casesOn"],
  "name": "CellularAutomatas.backwards_fsm.Params.mk.injEq",
  "constType":
  "∀ {α β γ : Type} [inst1 : CellularAutomatas.Alphabet α] [inst2 : CellularAutomatas.Alphabet β]\n  [inst3 : CellularAutomatas.Alphabet γ] (M : CellularAutomatas.FiniteStateTransducer α β)\n  (C : CellularAutomatas.CArtTransducer β γ) (α_1 β_1 γ_1 : Type) (inst1_1 : CellularAutomatas.Alphabet α_1)\n  (inst2_1 : CellularAutomatas.Alphabet β_1) (inst3_1 : CellularAutomatas.Alphabet γ_1)\n  (M_1 : CellularAutomatas.FiniteStateTransducer α_1 β_1) (C_1 : CellularAutomatas.CArtTransducer β_1 γ_1),\n  ({ α := α, β := β, γ := γ, inst1 := inst1, inst2 := inst2, inst3 := inst3, M := M, C := C } =\n      { α := α_1, β := β_1, γ := γ_1, inst1 := inst1_1, inst2 := inst2_1, inst3 := inst3_1, M := M_1, C := C_1 }) =\n    (α = α_1 ∧ β = β_1 ∧ γ = γ_1 ∧ inst1 ≍ inst1_1 ∧ inst2 ≍ inst2_1 ∧ inst3 ≍ inst3_1 ∧ M ≍ M_1 ∧ C ≍ C_1)",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "Eq.trans",
   "Int.Linear.Poly.mul",
   "ite",
   "Int.Linear.Poly.mul'",
   "HMul.hMul",
   "Decidable.casesOn",
   "OfNat.ofNat",
   "congrArg",
   "ite_congr",
   "beq_iff_eq._simp_1",
   "eq_self",
   "Bool.not_eq_true",
   "of_eq_true",
   "if_neg",
   "Int.Linear.Poly.mul_k",
   "Int.beq'_eq",
   "Eq.symm",
   "id",
   "Int.beq'",
   "Eq.mpr",
   "BEq.beq",
   "if_pos",
   "Int.Linear.Var"],
  "name": "Int.Linear.Poly.mul_k_eq_mul",
  "constType": "∀ (k : ℤ) (p : Int.Linear.Poly), p.mul_k k = p.mul k",
  "constCategory": "Theorem"},
 {"references": ["CellularAutomatas.Word", "CellularAutomatas.ProdCA.zipMany"],
  "name": "CellularAutomatas.ProdCA.zipMany.eq_1",
  "constType":
  "∀ {β : Type} [inst : CellularAutomatas.Alphabet β] {γ : β → Type v} [inst_1 : (b : β) → Inhabited (γ b)]\n  (f : (b : β) → CellularAutomatas.Word (γ b)),\n  CellularAutomatas.ProdCA.zipMany f =\n    List.map (fun i b => List.getD (f b) i default) (List.range (List.length (f default)))",
  "constCategory": "Theorem"},
 {"references": ["LT.lt", "BitVec.ofNatLT", "OfNat.ofNat", "UInt64.size"],
  "name": "UInt64.ofNatLT",
  "constType": "(n : ℕ) → n < UInt64.size → UInt64",
  "constCategory": "Definition"},
 {"references": ["outParam"],
  "name": "GetElem.getElem",
  "constType":
  "{coll : Type u} →\n  {idx : Type v} →\n    {elem : outParam (Type w)} →\n      {valid : outParam (coll → idx → Prop)} →\n        [self : GetElem coll idx elem valid] → (xs : coll) → (i : idx) → valid xs i → elem",
  "constCategory": "Definition"},
 {"references":
  ["Eq.trans",
   "Eq.mp",
   "Lean.Grind.Order.of_nat_eq",
   "HMul.hMul",
   "eq_true",
   "eagerReduce",
   "ite_cond_eq_true",
   "List.length_drop",
   "IntCast.intCast",
   "List.length_take",
   "Lean.Grind.Order.lt_le_trans_k",
   "Nat.ToInt.natCast_ofNat",
   "min_def",
   "congrArg",
   "Lean.Grind.nestedDecidable",
   "NatCast.natCast",
   "HSub.hSub",
   "Eq.symm",
   "cast",
   "List.drop",
   "Nat.ToInt.lt_eq",
   "Lean.Grind.Order.lt_eq_true_of_lt_k",
   "ite",
   "Lean.Grind.Order.eq_trans_true'",
   "Neg.neg",
   "Lean.Grind.Order.le_of_eq_2_k",
   "Nat.ToInt.add_congr",
   "Lean.Grind.Order.le_eq_true_of_le_k",
   "List.getElem_drop._proof_1",
   "OfNat.ofNat",
   "Lean.Grind.nestedProof",
   "LT.lt",
   "HAdd.hAdd",
   "Nat.ToInt.le_eq",
   "of_eq_true",
   "Min.min",
   "List.take",
   "LE.le",
   "Lean.Grind.CommRing.lt_norm_expr",
   "id",
   "Lean.Grind.CommRing.le_norm_expr",
   "Lean.Grind.Order.eq_trans_true",
   "CellularAutomatas.PrefixStableProof.getLastOfTake._proof_1_6",
   "Lean.Grind.Order.eq_mp",
   "List.length"],
  "name": "CellularAutomatas.PrefixStableProof.getLastOfTake._proof_1_13",
  "constType":
  "∀ {i : ℕ} {α : Type u_1} {w : List α},\n  i + 1 ≤ w.length →\n    -1 * ↑(List.take 1 w⟦i..*⟧).length + 1 ≤ 0 → (List.take i w).length + ((List.take 1 w⟦i..*⟧).length - 1) < w.length",
  "constCategory": "Theorem"},
 {"references": ["CellularAutomatas.TwoStageAdvice.advice"],
  "name": "CellularAutomatas.TwoStageAdvice.advice.eq_1",
  "constType":
  "∀ {α Γ : Type} [inst : CellularAutomatas.Alphabet α] [inst_1 : CellularAutomatas.Alphabet Γ]\n  {adv : CellularAutomatas.TwoStageAdvice α Γ},\n  CellularAutomatas.TwoStageAdvice.advice = { f := adv.M.advice.f ∘ adv.C.advice.f, len := ⋯ }",
  "constCategory": "Theorem"},
 {"references": ["Setoid.r"],
  "name": "Multiset.ofList",
  "constType": "{α : Type u_1} → List α → Multiset α",
  "constCategory": "Definition"},
 {"references":
  ["List.getElem_map",
   "GetElem.getElem.congr_simp",
   "Eq.trans",
   "Eq.mp",
   "List.getElem_range",
   "CellularAutomatas.marker_list_len",
   "GetElem.getElem",
   "GT.gt",
   "congrArg",
   "HSub.hSub",
   "Eq.ndrec",
   "Not",
   "CellularAutomatas.marker_list",
   "List.map",
   "Iff.rfl",
   "List.length_map",
   "CellularAutomatas.marker_list_inj._proof_1_3",
   "OfNat.ofNat",
   "LT.lt",
   "HAdd.hAdd",
   "List.range",
   "beq_iff_eq._simp_1",
   "eq_self",
   "Bool.true_eq",
   "Decidable.byContradiction",
   "of_eq_true",
   "LE.le",
   "CellularAutomatas.marker_list_inj._proof_1_1",
   "beq_eq_beq._simp_1",
   "id",
   "Eq.mpr",
   "BEq.beq",
   "List.length"],
  "name": "CellularAutomatas.marker_list_inj",
  "constType":
  "∀ {n k1 k2 : ℕ}, k1 ≤ n → k1 > 0 → CellularAutomatas.marker_list n k1 = CellularAutomatas.marker_list n k2 → k1 = k2",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Id",
  "constType": "Type u → Type u",
  "constCategory": "Definition"},
 {"references":
  ["Array.size",
   "List.below",
   "List.mapIdx.go.match_1",
   "Array.push",
   "List.brecOn",
   "Array.toList"],
  "name": "List.mapIdx.go",
  "constType":
  "{α : Type u_1} → {β : Type u_2} → (ℕ → α → β) → List α → Array β → List β",
  "constCategory": "Definition"},
 {"references": ["Nat.casesOn", "OfNat.ofNat"],
  "name": "_private.Init.Data.Nat.Basic.0.Nat.add_comm.match_1_1",
  "constType":
  "∀ (motive : ℕ → ℕ → Prop) (x x_1 : ℕ), (∀ (n : ℕ), motive n 0) → (∀ (n m : ℕ), motive n m.succ) → motive x x_1",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CellularAutomatas.LcInRt.DiagonalShiftCA",
  "constType":
  "(A : Type) → [CellularAutomatas.Alphabet A] → CellularAutomatas.LCellAutomaton A",
  "constCategory": "Definition"},
 {"references":
  ["HAdd.hAdd",
   "Neg.neg",
   "Lean.Omega.Int.add_nonneg_iff_neg_le",
   "Int.add_comm",
   "LE.le",
   "id",
   "Eq.mpr",
   "Iff.rfl",
   "propext",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Lean.Omega.Int.add_nonneg_iff_neg_le'",
  "constType": "∀ {a b : ℤ}, 0 ≤ a + b ↔ -a ≤ b",
  "constCategory": "Theorem"},
 {"references":
  ["Multiset.dedup_eq_self",
   "Iff.mpr",
   "DecidableEq",
   "Multiset.Nodup",
   "Multiset.dedup",
   "Multiset"],
  "name": "Multiset.Nodup.dedup",
  "constType":
  "∀ {α : Type u_1} [inst : DecidableEq α] {s : Multiset α}, s.Nodup → s.dedup = s",
  "constCategory": "Theorem"},
 {"references": ["Std.DTreeMap.inner", "Std.DTreeMap.Internal.Impl.keys"],
  "name": "Std.DTreeMap.keys",
  "constType":
  "{α : Type u} → {β : α → Type v} → {cmp : α → α → Ordering} → DTreeMap α β cmp → List α",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Grind.CommRing.Power.denote.match_3",
   "Lean.Grind.CommRing.Var.denote",
   "Lean.Grind.CommRing.Power.denote.match_1",
   "HPow.hPow",
   "Lean.Grind.CommRing.Var",
   "OfNat.ofNat",
   "Lean.Grind.CommRing.Context",
   "Unit"],
  "name": "Lean.Grind.CommRing.Power.denote",
  "constType":
  "{α : Type u_1} → [Grind.Semiring α] → Grind.CommRing.Context α → Grind.CommRing.Power → α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Lean.MacroScopesView.scopes",
  "constType": "MacroScopesView → List MacroScope",
  "constCategory": "Definition"},
 {"references":
  ["Not",
   "Bind.bind",
   "Array.foldlM.loop.match_1",
   "GetElem.getElem",
   "Nat.brecOn",
   "OfNat.ofNat",
   "Unit",
   "HAdd.hAdd",
   "LT.lt",
   "Array.size",
   "LE.le",
   "Nat.below",
   "Pure.pure",
   "Array.foldlM.loop._proof_1",
   "dite"],
  "name": "Array.foldlM.loop",
  "constType":
  "{α : Type u} →\n  {β : Type v} →\n    {m : Type v → Type w} → [Monad m] → (β → α → m β) → (as : Array α) → (stop : ℕ) → stop ≤ as.size → ℕ → ℕ → β → m β",
  "constCategory": "Definition"},
 {"references": ["Not", "Decidable.casesOn"],
  "name": "_private.Init.Core.0.decide_false.match_1_1",
  "constType":
  "∀ (motive : Decidable False → Prop) (h : Decidable False),\n  (∀ (h : ¬False), motive (isFalse h)) → (∀ (h : False), motive (isTrue h)) → motive h",
  "constCategory": "Definition"},
 {"references":
  ["CellularAutomatas.simulation.Params.C_ctl",
   "CellularAutomatas.CellAutomaton.Q",
   "OfNat.ofNat"],
  "name": "CellularAutomatas.simulation.Q1.mk._flat_ctor",
  "constType":
  "{e : CellularAutomatas.simulation.Params} → e.C_ctl.Q → Fin 3 → CellularAutomatas.simulation.Q1 e",
  "constCategory": "Definition"},
 {"references":
  ["Eq.substr",
   "Eq.trans",
   "imp_self._simp_1",
   "List.getElem_range",
   "eq_true",
   "GetElem.getElem",
   "List.length_take",
   "congrArg",
   "List.length_range",
   "congr",
   "forall_congr",
   "forall_prop_domain_congr",
   "Nat.lt_of_lt_of_le",
   "List.length_take_le'",
   "LT.lt",
   "List.range",
   "implies_true",
   "eq_self",
   "and_self",
   "of_eq_true",
   "Min.min",
   "List.take",
   "List.ext_getElem",
   "_private.Init.Data.List.Nat.Range.0.List.take_range._simp_1_1",
   "List.getElem_take",
   "List.length"],
  "name": "List.take_range",
  "constType": "∀ {i n : ℕ}, List.take i (List.range n) = List.range (min i n)",
  "constCategory": "Theorem"},
 {"references":
  ["Int.neg_add_cancel_right",
   "HAdd.hAdd",
   "Neg.neg",
   "Eq.mp",
   "Int.zero_add",
   "id",
   "HSub.hSub",
   "Eq.mpr",
   "Int.sub_eq_add_neg",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Int.eq_of_sub_eq_zero",
  "constType": "∀ {a b : ℤ}, a - b = 0 → a = b",
  "constCategory": "Theorem"},
 {"references": ["Prod.casesOn"],
  "name": "CellularAutomatas.analyzeAndVerify.match_1",
  "constType":
  "(motive : Name ⨉ List Name → Sort u_1) →\n  (x : Name ⨉ List Name) → ((configModule : Name) → (snd : List Name) → motive (configModule, snd)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["LT.lt",
   "eq_self",
   "Eq.trans",
   "of_eq_true",
   "NatCast.natCast",
   "_private.Init.Data.Int.OfNat.0.Nat.ToInt.lt_eq._simp_1_1",
   "congr",
   "Eq.symm",
   "congrArg"],
  "name": "Nat.ToInt.lt_eq",
  "constType":
  "∀ {a b : ℕ} {a' b' : ℤ}, ↑a = a' → ↑b = b' → (a < b) = (a' < b')",
  "constCategory": "Theorem"},
 {"references":
  ["HAppend.hAppend",
   "Bind.bind",
   "Eq.trans",
   "List.foldr_eq_foldrM",
   "List.foldrM_append",
   "Id.run",
   "Id",
   "List.foldr",
   "congrArg",
   "eq_self",
   "of_eq_true",
   "congr",
   "List.foldrM",
   "Pure.pure"],
  "name": "List.foldr_append",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {f : α → β → β} {b : β} {l l' : List α},\n  List.foldr f b (l ++ l') = List.foldr f (List.foldr f b l') l",
  "constCategory": "Theorem"},
 {"references":
  ["List.range", "HAdd.hAdd", "List.map", "BEq.beq", "OfNat.ofNat"],
  "name": "CellularAutomatas.marker_list",
  "constType": "ℕ → ℕ → List Bool",
  "constCategory": "Definition"},
 {"references":
  ["absurd",
   "Int.Linear.instBEqPoly.beq._sparseCasesOn_1",
   "Eq.symm",
   "Ne",
   "Eq.ndrec",
   "OfNat.ofNat",
   "Int.Linear.Poly.ctorIdx"],
  "name":
  "_private.Init.Data.Int.Linear.0.Int.Linear.Poly.isUnsatEq.match_1.splitter",
  "constType":
  "(motive : Int.Linear.Poly → Sort u_1) →\n  (p : Int.Linear.Poly) →\n    ((k : ℤ) → motive (Int.Linear.Poly.num k)) →\n      ((x : Int.Linear.Poly) → (∀ (k : ℤ), x = Int.Linear.Poly.num k → False) → motive x) → motive p",
  "constCategory": "Definition"},
 {"references":
  ["Nat.Linear.Expr.toPoly",
   "Nat.Linear.ExprCnstr.lhs",
   "Nat.Linear.ExprCnstr.eq",
   "Nat.Linear.ExprCnstr.rhs"],
  "name": "Nat.Linear.ExprCnstr.toPoly",
  "constType": "Nat.Linear.ExprCnstr → Nat.Linear.PolyCnstr",
  "constCategory": "Definition"},
 {"references":
  ["rfl",
   "_private.Init.Data.Nat.Basic.0.Nat.add_assoc.match_1_1",
   "HAdd.hAdd",
   "Nat.add",
   "Nat.below",
   "Nat.brecOn",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Nat.add_assoc",
  "constType": "∀ (n m k : ℕ), n + m + k = n + (m + k)",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.not_le_of_gt", "LT.lt", "Not", "Nat.gt_of_not_le", "LE.le"],
  "name": "Nat.not_le",
  "constType": "∀ {a b : ℕ}, ¬a ≤ b ↔ b < a",
  "constCategory": "Theorem"},
 {"references": ["Finset.univ", "Membership.mem", "Finset.mem_univ", "eq_true"],
  "name": "Finset.mem_univ._simp_1",
  "constType":
  "∀ {α : Type u_1} [inst : Fintype α] (x : α), (x ∈ Finset.univ) = True",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt", "Array.size", "List.get", "Array.toList", "List.length"],
  "name": "Array.getInternal",
  "constType": "{α : Type u} → (a : Array α) → (i : ℕ) → i < a.size → α",
  "constCategory": "Definition"},
 {"references":
  ["HAdd.hAdd",
   "SizeOf.sizeOf",
   "CellularAutomatas.CellAutomaton.Q",
   "OfNat.ofNat"],
  "name": "CellularAutomatas.LCellAutomaton._sizeOf_1",
  "constType":
  "{α : Type} → [SizeOf α] → CellularAutomatas.LCellAutomaton α → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Not",
   "Bool.casesOn",
   "Eq.symm",
   "id",
   "Eq.ndrec",
   "Decidable.decide",
   "of_decide_eq_true"],
  "name": "Bool.not_eq_true",
  "constType": "∀ (b : Bool), (¬b = true) = (b = false)",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "CellularAutomatas.CellAutomaton.Q"],
  "name": "CellularAutomatas.tCellAutomaton.recOn",
  "constType":
  "{α : Type} →\n  {motive : CellularAutomatas.tCellAutomaton α → Sort u} →\n    (t : CellularAutomatas.tCellAutomaton α) →\n      ((toLCellAutomaton : CellularAutomatas.LCellAutomaton α) →\n          (t p : ℕ → ℕ) →\n            (F_pos : toLCellAutomaton.Q → Bool) →\n              motive { toLCellAutomaton := toLCellAutomaton, t := t, p := p, F_pos := F_pos }) →\n        motive t",
  "constCategory": "Definition"},
 {"references":
  ["CellularAutomatas.Advice.from_len_marker",
   "CellularAutomatas.middle_idx",
   "Function.comp"],
  "name": "CellularAutomatas.Advice.middle",
  "constType": "(α : Type) → CellularAutomatas.Advice α Bool",
  "constCategory": "Definition"},
 {"references":
  ["Multiset.mem_cons._simp_1",
   "or_false",
   "iff_self",
   "Eq.trans",
   "of_eq_true",
   "Multiset.notMem_zero._simp_1",
   "Membership.mem",
   "Multiset.cons",
   "Multiset",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Multiset.mem_singleton",
  "constType": "∀ {α : Type u_1} {a b : α}, b ∈ {a} ↔ b = a",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "Iff.trans",
   "AddLeftMono",
   "LE.le",
   "id",
   "Eq.mpr",
   "Iff.rfl",
   "add_zero",
   "AddLeftReflectLE",
   "OfNat.ofNat",
   "add_le_add_iff_left",
   "congrArg"],
  "name": "le_add_iff_nonneg_right",
  "constType":
  "∀ {α : Type u_1} [inst : AddZeroClass α] [inst_1 : LE α] [AddLeftMono α] [AddLeftReflectLE α] (a : α) {b : α},\n  a ≤ a + b ↔ 0 ≤ b",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Import.module",
   "Lean.EnvironmentHeader.modules",
   "Array.map",
   "Lean.EffectiveImport.toImport"],
  "name": "Lean.EnvironmentHeader.moduleNames",
  "constType": "EnvironmentHeader → Array Name",
  "constCategory": "Definition"},
 {"references":
  ["Set",
   "Membership.mem",
   "Set.mem_empty_iff_false",
   "EmptyCollection.emptyCollection",
   "propext"],
  "name": "Set.mem_empty_iff_false._simp_1",
  "constType": "∀ {α : Type u} (x : α), (x ∈ ∅) = False",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CellularAutomatas.Alphabet.fin",
  "constType": "{α : Type} → [self : CellularAutomatas.Alphabet α] → Fintype α",
  "constCategory": "Definition"},
 {"references":
  ["HAppend.hAppend",
   "eq_self",
   "Eq.trans",
   "of_eq_true",
   "List.append_cancel_left",
   "propext",
   "congrArg"],
  "name": "List.append_cancel_left_eq",
  "constType":
  "∀ {α : Type u_1} (as bs cs : List α), (as ++ bs = as ++ cs) = (bs = cs)",
  "constCategory": "Theorem"},
 {"references": ["le_of_eq"],
  "name": "Eq.le",
  "constType": "∀ {α : Type u_1} [inst : Preorder α] {a b : α}, a = b → a ≤ b",
  "constCategory": "Theorem"},
 {"references":
  ["Multiset.map",
   "Multiset.card",
   "Eq.trans",
   "Finset.val",
   "DecidableEq",
   "Finset.image_val_of_injOn",
   "Multiset",
   "congrArg",
   "eq_self",
   "SetLike.coe",
   "of_eq_true",
   "Set.InjOn",
   "Finset.image",
   "Multiset.card_map"],
  "name": "Finset.card_image_of_injOn",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {s : Finset α} {f : α → β} [inst : DecidableEq β],\n  Set.InjOn f ↑s → (Finset.image f s).card = s.card",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Int.Linear.Var",
  "constType": "Type",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Ord.compare",
  "constType": "{α : Type u} → [self : Ord α] → α → α → Ordering",
  "constCategory": "Definition"},
 {"references": ["Std.TreeMap.inner", "Std.DTreeMap.keys"],
  "name": "Std.TreeMap.keys",
  "constType":
  "{α : Type u} → {β : Type v} → {cmp : α → α → Ordering} → TreeMap α β cmp → List α",
  "constCategory": "Definition"},
 {"references": ["propext", "exists_const"],
  "name": "exists_const._simp_1",
  "constType": "∀ {b : Prop} (α : Sort u_1) [i : Nonempty α], (∃ x, b) = b",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.Word", "Set", "CellularAutomatas.Word.range"],
  "name": "CellularAutomatas.Word.range.eq_1",
  "constType":
  "∀ {α : Type u} (w : CellularAutomatas.Word α), w.range = {i | i ≥ 0 ∧ i < ↑(List.length w)}",
  "constCategory": "Theorem"},
 {"references": ["Lean.ConstantInfo.toConstantVal", "Lean.ConstantVal.type"],
  "name": "Lean.ConstantInfo.type",
  "constType": "ConstantInfo → Expr",
  "constCategory": "Definition"},
 {"references":
  ["_private.Init.Data.Nat.Basic.0.Nat.lt_trichotomy.match_1_1",
   "LT.lt",
   "Nat.lt_or_ge",
   "Eq.symm",
   "Nat.eq_or_lt_of_le",
   "GE.ge",
   "_private.Init.Data.Nat.Basic.0.Nat.lt_trichotomy.match_1_3"],
  "name": "Nat.lt_trichotomy",
  "constType": "∀ (a b : ℕ), a < b ∨ a = b ∨ b < a",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "Finset.range",
   "Classical.propDecidable",
   "GT.gt",
   "GE.ge",
   "OfNat.ofNat",
   "Finset.filter"],
  "name": "CellularAutomatas.reachable_markers",
  "constType": "(ℕ → Option ℕ) → ℕ → Finset ℕ",
  "constCategory": "Definition"},
 {"references": ["LT.lt"],
  "name": "GT.gt",
  "constType": "{α : Type u} → [LT α] → α → α → Prop",
  "constCategory": "Definition"},
 {"references": ["OfNat.ofNat", "Unit", "Nat.pow.match_1"],
  "name": "Nat.pred",
  "constType": "ℕ → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Grind.Ring.intCast",
   "Lean.Grind.Ring.intCast_one",
   "id",
   "Lean.Grind.CommRing.Poly.denote",
   "HMul.hMul",
   "Eq.mpr",
   "Lean.Grind.Semiring.one_mul",
   "Int.cast",
   "OfNat.ofNat",
   "Lean.Grind.CommRing.Context",
   "congrArg"],
  "name": "Lean.Grind.CommRing.Stepwise.d_init",
  "constType":
  "∀ {α : Type u_1} [inst : Grind.CommRing α] (ctx : Grind.CommRing.Context α) (p : Grind.CommRing.Poly),\n  ↑1 * Grind.CommRing.Poly.denote ctx p = Grind.CommRing.Poly.denote ctx p",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "CellularAutomatas.CArtTransducer.toLCellAutomaton",
   "CellularAutomatas.composition.Params.noConfusion",
   "id",
   "CellularAutomatas.CellAutomaton.Q"],
  "name": "CellularAutomatas.composition.Params.mk.noConfusion",
  "constType":
  "(P : Sort u) →\n  (α β : Type) →\n    [_inst_α : CellularAutomatas.Alphabet α] →\n      [_inst_β : CellularAutomatas.Alphabet β] →\n        (C : CellularAutomatas.LCellAutomaton β) →\n          (C_adv : CellularAutomatas.CArtTransducer α β) →\n            (f : C_adv.Q → Option C.Q) →\n              (α' β' : Type) →\n                (_inst_α' : CellularAutomatas.Alphabet α') →\n                  (_inst_β' : CellularAutomatas.Alphabet β') →\n                    (C' : CellularAutomatas.LCellAutomaton β') →\n                      (C_adv' : CellularAutomatas.CArtTransducer α' β') →\n                        (f' : C_adv'.Q → Option C'.Q) →\n                          { α := α, β := β, _inst_α := _inst_α, _inst_β := _inst_β, C := C, C_adv := C_adv, f := f } =\n                              { α := α', β := β', _inst_α := _inst_α', _inst_β := _inst_β', C := C', C_adv := C_adv',\n                                f := f' } →\n                            (α = α' →\n                                β = β' →\n                                  _inst_α ≍ _inst_α' → _inst_β ≍ _inst_β' → C ≍ C' → C_adv ≍ C_adv' → f ≍ f' → P) →\n                              P",
  "constCategory": "Definition"},
 {"references":
  ["CellularAutomatas.Word.get'",
   "implies_congr",
   "Eq.trans",
   "Lean.Grind.Order.eq_trans_false",
   "Membership.mem",
   "HMul.hMul",
   "eagerReduce",
   "eq_true",
   "Lean.Grind.intro_with_eq'",
   "IntCast.intCast",
   "GE.ge",
   "Nat.ToInt.natCast_ofNat",
   "CellularAutomatas.tCellAutomaton.toLCellAutomaton",
   "CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "NatCast.natCast",
   "funext",
   "Lean.Grind.eq_false_of_imp_eq_true",
   "CellularAutomatas.scan_temporal_in_F_pos._proof_1_6",
   "Eq.symm",
   "Neg.neg",
   "Lean.Grind.eq_true_of_and_eq_true_right",
   "Lean.Grind.Int.lt_eq",
   "Lean.Grind.nestedProof",
   "Classical.byContradiction",
   "id",
   "Lean.Grind.Order.le_trans_k",
   "Lean.Grind.Order.le_eq_false_of_le_k",
   "List.length",
   "setOf",
   "Int.Linear.norm_le",
   "Nat.cast",
   "CellularAutomatas.tCellAutomaton.t",
   "Eq.mp",
   "Lean.Grind.and_eq_of_eq_true_right",
   "CellularAutomatas.LCellAutomaton.embed",
   "congrArg",
   "Lean.Grind.Nat.lt_eq",
   "congr",
   "CellularAutomatas.CellAutomaton.Q",
   "CellularAutomatas.LCellAutomaton.border",
   "Not",
   "CellularAutomatas.Word",
   "Set.mem_setOf_eq",
   "Lean.Grind.Order.eq_trans_true'",
   "Set",
   "Nat.ToInt.add_congr",
   "OfNat.ofNat",
   "Eq.mpr_prop",
   "LT.lt",
   "HAdd.hAdd",
   "Nat.ToInt.le_eq",
   "of_eq_true",
   "Min.min",
   "List.take",
   "LE.le",
   "Lean.Grind.intro_with_eq",
   "Lean.Grind.CommRing.le_norm_expr",
   "Lean.Grind.Order.eq_mp",
   "And.casesOn"],
  "name": "CellularAutomatas.scan_temporal_in_F_pos._proof_1_7",
  "constType":
  "∀ {α : Type} {C : CellularAutomatas.tCellAutomaton α} {w : CellularAutomatas.Word α},\n  ∀ i < List.length w,\n    i < List.length w →\n      ∀ (j : ℤ) (h : j ∈ {i_1 | i_1 ≥ 0 ∧ i_1 < ↑(List.take (i + 1) w).length}),\n        i < List.length w →\n          i + 1 ≤ List.length w →\n            C.t (min (i + 1) (List.length w)) = i →\n              -↑i ≤ j ∧ j ≤ ↑i →\n                (0 ≤ j → ↑(List.length w) ≤ j) →\n                  C.border = C.embed (CellularAutomatas.Word.get' (List.take (i + 1) w) j h)",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "eq_self",
   "Lean.Grind.imp_eq",
   "Eq.trans",
   "of_eq_true",
   "id",
   "Classical.not_forall._simp_1",
   "Eq.mpr",
   "congrArg"],
  "name": "Lean.Grind.forall_imp_eq_or",
  "constType":
  "∀ {α : Sort u_1} (p : α → Prop) (q : Prop), ((∀ (a : α), p a) → q) = ((∃ a, ¬p a) ∨ q)",
  "constCategory": "Theorem"},
 {"references": ["rfl", "funext"],
  "name": "forall_congr",
  "constType":
  "∀ {α : Sort u} {p q : α → Prop}, (∀ (a : α), p a = q a) → (∀ (a : α), p a) = ∀ (a : α), q a",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "LT.lt",
   "Std.le_trans",
   "_private.Init.Grind.Ordered.Order.0.Lean.Grind.Preorder.lt_of_lt_of_le._simp_1_1",
   "Eq.mp",
   "And.right",
   "LE.le",
   "id",
   "Eq.mpr",
   "And.left"],
  "name": "Lean.Grind.Preorder.lt_of_lt_of_le",
  "constType":
  "∀ {α : Type u} [inst : LE α] [inst_1 : LT α] [LawfulOrderLT α] [Std.IsPreorder α] {a b c : α}, a < b → b ≤ c → a < c",
  "constCategory": "Theorem"},
 {"references": ["Int.neg.match_1"],
  "name": "_private.Init.Omega.Int.0.Int.neg.match_1.splitter",
  "constType":
  "(motive : ℤ → Sort u_1) → (n : ℤ) → ((n : ℕ) → motive (Int.ofNat n)) → ((n : ℕ) → motive (Int.negSucc n)) → motive n",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Name.mkStr4",
   "Bind.bind",
   "Lean.SyntaxNodeKind",
   "Lean.Name.mkStr1",
   "ite",
   "Lean.TSyntax.raw",
   "EStateM",
   "Lean.Name.mkStr3",
   "String.toRawSubstring'",
   "Lean.Syntax.isOfKind",
   "Lean.MonadQuotation.getCurrMacroScope",
   "Lean.MacroScope",
   "OfNat.ofNat",
   "Lean.MonadRef.mkInfoFromRefPos",
   "Pure.pure",
   "Lean.Syntax.getArg",
   "Lean.addMacroScope",
   "Lean.MonadQuotation.getContext",
   "Lean.Name.mkStr2",
   "Lean.MacroM",
   "MonadExcept.throw",
   "Lean.Syntax.node2"],
  "name":
  "CellularAutomatas.Word.«_aux_CellularAutomatas_defs___macroRules_CellularAutomatas_Word_term_⟦_..*⟧_1»",
  "constType": "Macro",
  "constCategory": "Definition"},
 {"references":
  ["sup_of_le_right",
   "Or.casesOn",
   "eq_self",
   "Max.max",
   "sup_of_le_left",
   "Monotone",
   "Eq.trans",
   "of_eq_true",
   "congr",
   "LE.le",
   "le_total",
   "congrArg"],
  "name": "Monotone.map_max",
  "constType":
  "∀ {α : Type u} {β : Type v} [inst : LinearOrder α] [inst_1 : LinearOrder β] {f : α → β} {a b : α},\n  Monotone f → f (max a b) = max (f a) (f b)",
  "constCategory": "Theorem"},
 {"references": ["Nat.casesOn", "OfNat.ofNat"],
  "name": "Nat.iterate.match_1",
  "constType":
  "{α : Sort u_2} →\n  (motive : ℕ → α → Sort u_1) →\n    (x : ℕ) → (x_1 : α) → ((a : α) → motive 0 a) → ((k : ℕ) → (a : α) → motive k.succ a) → motive x x_1",
  "constCategory": "Definition"},
 {"references": ["Int.add.match_1", "Int.negOfNat", "HMul.hMul"],
  "name": "Int.mul",
  "constType": "ℤ → ℤ → ℤ",
  "constCategory": "Definition"},
 {"references": ["False.elim", "Eq.mp"],
  "name": "of_eq_false",
  "constType": "∀ {p : Prop}, p = False → ¬p",
  "constCategory": "Theorem"},
 {"references": ["Nat.below", "Nat.brecOn", "List.take.match_1", "OfNat.ofNat"],
  "name": "List.drop",
  "constType": "{α : Type u} → ℕ → List α → List α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Std.IsPreorder.le_refl",
  "constType":
  "∀ {α : Type u} {inst : LE α} [self : Std.IsPreorder α] (a : α), a ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["rfl",
   "List.getLast",
   "_private.Init.Data.List.Lemmas.0.List.getLast?_eq_some_getLast.match_1_1",
   "Ne",
   "List.getLast?"],
  "name": "List.getLast?_eq_some_getLast",
  "constType":
  "∀ {α : Type u_1} {l : List α} (h : l ≠ []), l.getLast? = some (l.getLast h)",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "Int.lt_iff_le_not_le",
   "Eq.trans",
   "Int.le_refl",
   "HMul.hMul",
   "OfNat.ofNat",
   "congrArg",
   "LT.lt",
   "Int.le_refl._simp_1",
   "Int.le_antisymm",
   "Int.zero_mul",
   "of_eq_true",
   "Iff.mpr",
   "congr",
   "Int.le_of_lt",
   "LE.le",
   "id",
   "Int.mul_lt_mul_of_pos_left",
   "Eq.mpr",
   "dite"],
  "name": "Int.mul_le_mul_of_nonneg_left",
  "constType": "∀ {a b c : ℤ}, a ≤ b → 0 ≤ c → c * a ≤ c * b",
  "constCategory": "Theorem"},
 {"references": ["cond.match_1", "Unit"],
  "name": "Bool.or",
  "constType": "Bool → Bool → Bool",
  "constCategory": "Definition"},
 {"references": [],
  "name": "_private.Lean.Environment.0.Lean.AsyncConst.constInfo",
  "constType": "Lean.AsyncConst✝ → AsyncConstantInfo",
  "constCategory": "Definition"},
 {"references": ["HAdd.hAdd", "eq_self", "of_eq_true", "LE.le", "OfNat.ofNat"],
  "name": "Lean.Grind.Int.lt_eq",
  "constType": "∀ (a b : ℤ), (a < b) = (a + 1 ≤ b)",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "Eq.propIntro",
   "eq_of_heq",
   "Eq.symm",
   "CellularAutomatas.tCellAutomaton.mk.noConfusion",
   "CellularAutomatas.CellAutomaton.Q",
   "Eq.ndrec",
   "Eq.casesOn",
   "HEq.casesOn",
   "And.casesOn"],
  "name": "CellularAutomatas.tCellAutomaton.mk.injEq",
  "constType":
  "∀ {α : Type} (toLCellAutomaton : CellularAutomatas.LCellAutomaton α) (t p : ℕ → ℕ) (F_pos : toLCellAutomaton.Q → Bool)\n  (toLCellAutomaton_1 : CellularAutomatas.LCellAutomaton α) (t_1 p_1 : ℕ → ℕ) (F_pos_1 : toLCellAutomaton_1.Q → Bool),\n  ({ toLCellAutomaton := toLCellAutomaton, t := t, p := p, F_pos := F_pos } =\n      { toLCellAutomaton := toLCellAutomaton_1, t := t_1, p := p_1, F_pos := F_pos_1 }) =\n    (toLCellAutomaton = toLCellAutomaton_1 ∧ t = t_1 ∧ p = p_1 ∧ F_pos ≍ F_pos_1)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Std.HashMap.inner",
  "constType":
  "{α : Type u} → {β : Type v} → [inst : BEq α] → [inst_1 : Hashable α] → HashMap α β → DHashMap α fun x => β",
  "constCategory": "Definition"},
 {"references":
  ["Not",
   "CellularAutomatas.Word",
   "CellularAutomatas.Word.cone_prop''._proof_1_2",
   "Nat.cast",
   "Set",
   "Neg.neg",
   "Membership.mem",
   "CellularAutomatas.Word.cone",
   "neg_add_rev",
   "OfNat.ofNat",
   "congrArg",
   "HAdd.hAdd",
   "LT.lt",
   "Decidable.byContradiction",
   "funext",
   "LE.le",
   "id",
   "Eq.mpr",
   "setOf",
   "List.length"],
  "name": "CellularAutomatas.Word.cone_prop''",
  "constType":
  "∀ {α : Type u_1} {w : CellularAutomatas.Word α} {t : ℕ} {i : ℤ}, i ∈ w.cone t → i ∈ w.cone (t + 1)",
  "constCategory": "Theorem"},
 {"references": ["Std.TreeSet.contains", "Lean.NameSet", "Lean.Name.quickCmp"],
  "name": "Lean.NameSet.contains",
  "constType": "NameSet → Name → Bool",
  "constCategory": "Definition"},
 {"references": ["AddZeroClass.zero_add"],
  "name": "zero_add",
  "constType": "∀ {M : Type u} [inst : AddZeroClass M] (a : M), 0 + a = a",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "eq_self",
   "Eq.trans",
   "of_eq_true",
   "Neg.neg",
   "HSub.hSub",
   "Lean.Omega.Coeffs",
   "Lean.Omega.Coeffs.sub_eq_add_neg",
   "Lean.Omega.LinearCombo.casesOn",
   "congrArg",
   "Lean.Omega.LinearCombo.ext"],
  "name": "Lean.Omega.LinearCombo.sub_eq_add_neg",
  "constType": "∀ (l₁ l₂ : Omega.LinearCombo), l₁ - l₂ = l₁ + -l₂",
  "constCategory": "Theorem"},
 {"references":
  ["Or.elim",
   "Int.toNat",
   "Lean.Omega.LinearCombo.coordinate_eval_2",
   "Nat.cast",
   "Eq.trans",
   "Lean.Omega.LinearCombo.coordinate_eval_3",
   "le_of_le_of_eq",
   "Lean.Omega.Constraint.combine_sat'",
   "Lean.Omega.LinearCombo.coordinate_eval_0",
   "Int.sub_eq_zero_of_eq",
   "GT.gt",
   "Decidable.decide",
   "Nat.lt_or_gt_of_ne",
   "Lean.Omega.Coeffs.ofList",
   "HSub.hSub",
   "Eq.symm",
   "Lean.Omega.tidy_sat",
   "Lean.Omega.Int.lt_of_not_le",
   "Lean.Omega.LinearCombo.add_eval",
   "Lean.Omega.ite_disjunction",
   "Int.add_one_le_of_lt",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "And.left",
   "of_decide_eq_true",
   "Not",
   "Lean.Omega.combo_sat'",
   "ite",
   "Neg.neg",
   "And.right",
   "Lean.Omega.Constraint.addInequality_sat",
   "Lean.Omega.Int.add_congr",
   "Lean.Omega.Constraint.isImpossible",
   "Lean.Omega.LinearCombo.coordinate",
   "Int.sub_nonneg_of_le",
   "OfNat.ofNat",
   "Lean.Omega.LinearCombo.coordinate_eval_1",
   "LT.lt",
   "HAdd.hAdd",
   "Max.max",
   "Lean.Omega.LinearCombo.sub_eval",
   "Lean.Omega.Int.ofNat_lt_of_lt",
   "Int.max_def",
   "LE.le",
   "id",
   "Lean.Omega.Constraint.addEquality_sat",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.Int.sub_congr",
   "Int.toNat_eq_max"],
  "name": "CellularAutomatas.backwards_fsm.inv._proof_1_5",
  "constType":
  "∀ (t : ℕ) (p : ℤ), ¬(p + 1 + ↑t).toNat = (p + (↑t + 1)).toNat → False",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.Advice.from_len_marker",
   "CellularAutomatas.exp_middle_idx"],
  "name": "CellularAutomatas.Advice.exp_middle",
  "constType": "(α : Type) → CellularAutomatas.Advice α Bool",
  "constCategory": "Definition"},
 {"references":
  ["HAdd.hAdd",
   "AddLECancellable",
   "Iff.mpr",
   "tsub_le_iff_right",
   "LE.le",
   "id",
   "HSub.hSub",
   "Eq.mpr",
   "Eq.le",
   "le_antisymm",
   "AddLECancellable.le_add_tsub",
   "congrArg"],
  "name": "AddLECancellable.tsub_eq_of_eq_add",
  "constType":
  "∀ {α : Type u_1} [inst : PartialOrder α] [inst_1 : AddCommSemigroup α] [inst_2 : Sub α] [OrderedSub α] {a b c : α},\n  AddLECancellable b → a = c + b → a - b = c",
  "constCategory": "Theorem"},
 {"references":
  ["Finset.val", "Finset.nodup", "Multiset.Nodup.filter", "DecidablePred"],
  "name": "Finset.filter._proof_1",
  "constType":
  "∀ {α : Type u_1} (p : α → Prop) [inst : DecidablePred p] (s : Finset α), (Multiset.filter p s.val).Nodup",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Omega.LinearCombo.coordinate_eval_2",
   "Nat.cast",
   "Eq.trans",
   "le_of_le_of_eq",
   "Lean.Omega.Constraint.combine_sat'",
   "Decidable.decide",
   "CellularAutomatas.tCellAutomaton.toLCellAutomaton",
   "CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "CellularAutomatas.LCellAutomaton.scan_temporal_rt",
   "Lean.Omega.Coeffs.ofList",
   "Lean.Omega.tidy_sat",
   "Eq.symm",
   "HSub.hSub",
   "Lean.Omega.LinearCombo.add_eval",
   "CellularAutomatas.CellAutomaton.Q",
   "Int.add_one_le_of_lt",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "of_decide_eq_true",
   "Not",
   "CellularAutomatas.Word",
   "Neg.neg",
   "Lean.Omega.Constraint.addInequality_sat",
   "Lean.Omega.Int.add_congr",
   "Lean.Omega.Constraint.isImpossible",
   "Lean.Omega.LinearCombo.coordinate",
   "OfNat.ofNat",
   "Int.sub_nonneg_of_le",
   "Lean.Omega.LinearCombo.coordinate_eval_1",
   "HAdd.hAdd",
   "LT.lt",
   "Lean.Omega.LinearCombo.sub_eval",
   "Lean.Omega.Int.ofNat_lt_of_lt",
   "Nat.lt_of_not_le",
   "LE.le",
   "Int.natCast_add",
   "id",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.Int.sub_congr",
   "List.length"],
  "name": "CellularAutomatas.scan_temporal_in_F_pos._proof_1_1",
  "constType":
  "∀ {α : Type} {C : CellularAutomatas.tCellAutomaton α} {w : CellularAutomatas.Word α},\n  ∀ i < List.length w, ¬i + 1 ≤ List.length w → False",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.simulation.Q1.proxyTypeEquiv",
   "CellularAutomatas.simulation.Params.C_ctl",
   "CellularAutomatas.CellAutomaton.Q",
   "Fintype.ofEquiv",
   "OfNat.ofNat"],
  "name": "CellularAutomatas.simulation.instFintypeQ1",
  "constType":
  "{e : CellularAutomatas.simulation.Params} → Fintype (CellularAutomatas.simulation.Q1 e)",
  "constCategory": "Definition"},
 {"references": ["Int.toNat.match_1", "OfNat.ofNat"],
  "name": "Int.toNat",
  "constType": "ℤ → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["HAdd.hAdd",
   "CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "SizeOf.sizeOf",
   "CellularAutomatas.CArtTransducer.toLCellAutomaton",
   "CellularAutomatas.CellAutomaton.Q",
   "OfNat.ofNat"],
  "name": "CellularAutomatas.composition.Params.mk.sizeOf_spec",
  "constType":
  "∀ (α β : Type) [_inst_α : CellularAutomatas.Alphabet α] [_inst_β : CellularAutomatas.Alphabet β]\n  (C : CellularAutomatas.LCellAutomaton β) (C_adv : CellularAutomatas.CArtTransducer α β) (f : C_adv.Q → Option C.Q),\n  sizeOf { α := α, β := β, _inst_α := _inst_α, _inst_β := _inst_β, C := C, C_adv := C_adv, f := f } =\n    1 + sizeOf α + sizeOf β + sizeOf _inst_α + sizeOf _inst_β + sizeOf C + sizeOf C_adv",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Eq.mp",
  "constType": "{α β : Sort u} → α = β → α → β",
  "constCategory": "Definition"},
 {"references":
  ["_private.Init.Data.List.Basic.0.List.zipWith.match_1.eq_2",
   "Eq.trans",
   "id",
   "List.zipWith.eq_def",
   "Eq.mpr",
   "List.zipWith",
   "List.zipWith.match_1",
   "congrArg"],
  "name": "List.zipWith.eq_2",
  "constType":
  "∀ {α : Type u} {β : Type v} {γ : Type w} (f : α → β → γ) (x : List α) (x_1 : List β),\n  (∀ (x_2 : α) (xs : List α) (y : β) (ys : List β), x = x_2 :: xs → x_1 = y :: ys → False) → List.zipWith f x x_1 = []",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "DecidablePred",
  "constType": "{α : Sort u} → (α → Prop) → Sort (max 1 u)",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CellularAutomatas.backwards_fsm.Params.casesOn",
  "constType":
  "{motive : CellularAutomatas.backwards_fsm.Params → Sort u} →\n  (t : CellularAutomatas.backwards_fsm.Params) →\n    ({α β γ : Type} →\n        [inst1 : CellularAutomatas.Alphabet α] →\n          [inst2 : CellularAutomatas.Alphabet β] →\n            [inst3 : CellularAutomatas.Alphabet γ] →\n              (M : CellularAutomatas.FiniteStateTransducer α β) →\n                (C : CellularAutomatas.CArtTransducer β γ) →\n                  motive { α := α, β := β, γ := γ, inst1 := inst1, inst2 := inst2, inst3 := inst3, M := M, C := C }) →\n      motive t",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "Eq.trans",
   "of_eq_true",
   "Lean.Grind.AC.hugeFuel",
   "Lean.Grind.AC.Seq.denote",
   "Lean.Grind.AC.Context.op",
   "Lean.Grind.AC.Seq.unionFuel",
   "Lean.Grind.AC.Seq.denote_unionFuel",
   "congrArg"],
  "name": "Lean.Grind.AC.Seq.denote_union",
  "constType":
  "∀ {α : Sort u_1} (ctx : Grind.AC.Context α) {inst₁ : Associative ctx.op} {inst₂ : Commutative ctx.op}\n  (s₁ s₂ : Grind.AC.Seq),\n  Grind.AC.Seq.denote ctx (s₁.union s₂) = ctx.op (Grind.AC.Seq.denote ctx s₁) (Grind.AC.Seq.denote ctx s₂)",
  "constCategory": "Theorem"},
 {"references":
  ["List.toArray",
   "Lean.Environment.constants",
   "ite",
   "Array.push",
   "Lean.SMap.fold",
   "CellularAutomatas.getModuleConstants.match_1",
   "BEq.beq",
   "Lean.ModuleIdx",
   "Lean.Environment.getModuleIdx?",
   "Lean.Environment.getModuleIdxFor?",
   "Unit"],
  "name": "CellularAutomatas.getModuleConstants",
  "constType": "Environment → Name → Array Name",
  "constCategory": "Definition"},
 {"references": ["Not", "Decidable.casesOn"],
  "name": "Decidable.decide",
  "constType": "(p : Prop) → [h : Decidable p] → Bool",
  "constCategory": "Definition"},
 {"references":
  ["Not",
   "Lean.Grind.CommRing.Stepwise.imp_1eq",
   "Neg.neg",
   "eagerReduce",
   "HMul.hMul",
   "Lean.Grind.CommRing.Stepwise.d_init",
   "OfNat.ofNat",
   "congrArg",
   "HAdd.hAdd",
   "HDiv.hDiv",
   "NatCast.natCast",
   "Int.Linear.norm_eq",
   "Classical.byContradiction",
   "HSub.hSub",
   "id",
   "Lean.Grind.intro_with_eq"],
  "name": "CellularAutomatas.speedup_factor_k.compress_decompress._proof_1_1",
  "constType": "∀ (k : ℕ) (p : ℤ), p / ↑k * ↑k + (p - ↑k * (p / ↑k)) = p",
  "constCategory": "Theorem"},
 {"references": ["Lean.Grind.IntInterval.lo?.match_1", "Unit"],
  "name": "Lean.Grind.IntInterval.hi?",
  "constType": "Grind.IntInterval → Option ℤ",
  "constCategory": "Definition"},
 {"references":
  ["Or.casesOn",
   "Not",
   "dif_pos",
   "Eq.mpr_not",
   "Eq.symm",
   "id",
   "Eq.mpr",
   "dif_neg",
   "Decidable.em",
   "dite",
   "congrArg",
   "Eq.mpr_prop"],
  "name": "dite_congr",
  "constType":
  "∀ {b c : Prop} {α : Sort u_1} {x : Decidable b} [inst : Decidable c] {x_1 : b → α} {u : c → α} {y : ¬b → α} {v : ¬c → α}\n  (h₁ : b = c), (∀ (h : c), x_1 ⋯ = u h) → (∀ (h : ¬c), y ⋯ = v h) → dite b x_1 y = dite c u v",
  "constCategory": "Theorem"},
 {"references":
  ["Array.size",
   "Array.emptyWithCapacity",
   "OfNat.ofNat",
   "_private.Init.Data.Array.Basic.0.Array.mapM.map"],
  "name": "Array.mapM",
  "constType":
  "{α : Type u} → {β : Type v} → {m : Type v → Type w} → [Monad m] → (α → m β) → Array α → m (Array β)",
  "constCategory": "Definition"},
 {"references":
  ["Min.min", "List.take", "List.take_eq_take_iff", "propext", "List.length"],
  "name": "List.take_eq_take_iff._simp_1",
  "constType":
  "∀ {α : Type u_1} {l : List α} {i j : ℕ}, (List.take i l = List.take j l) = (min i l.length = min j l.length)",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.CA_rt_to_TwoStage",
   "CellularAutomatas.CA_rt",
   "Set.Elem"],
  "name": "CellularAutomatas.CA_rt_to_TwoStage.eq_1",
  "constType":
  "∀ {α : Type} [inst : CellularAutomatas.Alphabet α] (C : ↑(CellularAutomatas.CA_rt α)),\n  CellularAutomatas.CA_rt_to_TwoStage C =\n    { β := Bool, alphabetβ := CellularAutomatas.AlphabetBool,\n      C := { toLCellAutomaton := (↑C).toLCellAutomaton, f := (↑C).F_pos },\n      M := CellularAutomatas.FiniteStateTransducer.M_id Bool }",
  "constCategory": "Theorem"},
 {"references": ["CellularAutomatas.CA", "Set"],
  "name": "CellularAutomatas.CA.eq_1",
  "constType":
  "∀ (α : Type), CellularAutomatas.CA α = {C | C ∈ CellularAutomatas.tCellAutomatons α ∧ C.p = fun x => 0}",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Lean.Omega.Coeffs.ofList",
  "constType": "List ℤ → Omega.Coeffs",
  "constCategory": "Definition"},
 {"references":
  ["implies_congr",
   "HAdd.hAdd",
   "zero_add",
   "congr",
   "LE.le",
   "id",
   "Eq.mpr",
   "OfNat.ofNat",
   "congrArg"],
  "name": "addLECancellable_zero",
  "constType":
  "∀ {α : Type u_1} [inst : AddZeroClass α] [inst_1 : LE α], AddLECancellable 0",
  "constCategory": "Theorem"},
 {"references":
  ["List.below",
   "Nat.Linear.Poly.denote.match_1",
   "List.brecOn",
   "Nat.Linear.Poly.insert",
   "Nat.Linear.Var",
   "Unit",
   "Nat.Linear.Poly"],
  "name": "Nat.Linear.Poly.norm.go",
  "constType": "Nat.Linear.Poly → Nat.Linear.Poly → Nat.Linear.Poly",
  "constCategory": "Definition"},
 {"references":
  ["Nat.lt_of_lt_of_le",
   "List.drop",
   "Neg.neg",
   "HMul.hMul",
   "List.length_take_le'",
   "OfNat.ofNat",
   "Lean.Grind.nestedProof",
   "HAdd.hAdd",
   "LT.lt",
   "CellularAutomatas.PrefixStableProof.getLastOfTake._proof_1_7",
   "NatCast.natCast",
   "List.take",
   "LE.le",
   "HSub.hSub",
   "List.length"],
  "name": "CellularAutomatas.PrefixStableProof.getLastOfTake._proof_1_14",
  "constType":
  "∀ {i : ℕ} {α : Type u_1} {w : List α},\n  -1 * ↑(List.take 1 w⟦i..*⟧).length + 1 ≤ 0 → (List.take (i + 1) w).length - 1 < w.length",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CellularAutomatas.Advice.len",
  "constType":
  "∀ {α Γ : Type} (self : CellularAutomatas.Advice α Γ) (w : CellularAutomatas.Word α),\n  List.length (self.f w) = List.length w",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Fintype.complete",
  "constType": "∀ {α : Type u_4} [self : Fintype α] (x : α), x ∈ Fintype.elems",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Lean.Name.mkNum",
  "constType": "Name → ℕ → Name",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CellularAutomatas.FiniteStateTransducer",
  "constType": "Type → Type → Type 1",
  "constCategory": "Other"},
 {"references":
  ["HAdd.hAdd", "LT.lt", "Int.le_of_add_le_add_right", "OfNat.ofNat"],
  "name": "Int.le_of_lt_add_one",
  "constType": "∀ {a b : ℤ}, a < b + 1 → a ≤ b",
  "constCategory": "Theorem"},
 {"references": ["Min.min", "inf_eq_right", "LE.le", "propext"],
  "name": "inf_eq_right._simp_1",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeInf α] {a b : α}, (a ⊓ b = b) = (b ≤ a)",
  "constCategory": "Theorem"},
 {"references": ["Multiset.toList_singleton"],
  "name": "Finset.toList_singleton",
  "constType": "∀ {α : Type u_1} (a : α), {a}.toList = [a]",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.FiniteStateTransducer.compose_spec2",
   "CellularAutomatas.Word",
   "CellularAutomatas.FiniteStateTransducer.advice._proof_1",
   "CellularAutomatas.FiniteStateTransducer.comp",
   "Eq.trans",
   "CellularAutomatas.FiniteStateTransducer.scanr",
   "Function.comp",
   "congrArg",
   "CellularAutomatas.Advice.f",
   "eq_self",
   "of_eq_true",
   "congrFun",
   "CellularAutomatas.Advice.mk.congr_simp",
   "funext",
   "CellularAutomatas.FiniteStateTransducer.advice",
   "Eq.ndrec",
   "List.length"],
  "name": "CellularAutomatas.FiniteStateTransducer.compose_spec",
  "constType":
  "∀ {α β γ : Type} [inst : CellularAutomatas.Alphabet α] [inst_1 : CellularAutomatas.Alphabet β]\n  [inst_2 : CellularAutomatas.Alphabet γ] (M1 : CellularAutomatas.FiniteStateTransducer β γ)\n  (M2 : CellularAutomatas.FiniteStateTransducer α β), (M1 ⊚ M2).advice.f = M1.advice.f ∘ M2.advice.f",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "LT.lt",
   "CellularAutomatas.Word",
   "Nat.cast",
   "Neg.neg",
   "Set",
   "LE.le",
   "Membership.mem",
   "List.length",
   "setOf"],
  "name":
  "CellularAutomatas.instDecidableMemIntSetConeOfSetOfAndLeNegCastLtHAddLength",
  "constType":
  "{α : Type u_1} →\n  (w : CellularAutomatas.Word α) →\n    (t : ℕ) → (i : ℤ) → [d : Decidable (i ∈ {i | -↑t ≤ i ∧ i < ↑(List.length w) + ↑t})] → Decidable (i ∈ w.cone t)",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CellularAutomatas.VerificationError.casesOn",
  "constType":
  "{motive : CellularAutomatas.VerificationError → Sort u} →\n  (t : CellularAutomatas.VerificationError) →\n    ((module : Name) →\n        (message : String) →\n          (details : List String) → motive { module := module, message := message, details := details }) →\n      motive t",
  "constCategory": "Definition"},
 {"references": ["Or.casesOn"],
  "name": "_private.Init.Prelude.0.Or.elim.match_1_1",
  "constType":
  "∀ {a b : Prop} (motive : a ∨ b → Prop) (h : a ∨ b), (∀ (h : a), motive ⋯) → (∀ (h : b), motive ⋯) → motive h",
  "constCategory": "Definition"},
 {"references": ["id", "Eq.mpr", "congrArg"],
  "name": "CellularAutomatas.eq_of_app",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {f g : α → β}, f = g → ∀ (a : α), f a = g a",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CellularAutomatas.composition.Params._inst_β",
  "constType":
  "(self : CellularAutomatas.composition.Params) → CellularAutomatas.Alphabet self.β",
  "constCategory": "Definition"},
 {"references":
  ["CellularAutomatas.Word", "CellularAutomatas.Advice.casesOn", "List.length"],
  "name": "CellularAutomatas.Advice.ext.match_1",
  "constType":
  "∀ {α Γ : Type} (motive : CellularAutomatas.Advice α Γ → Prop) (h : CellularAutomatas.Advice α Γ),\n  (∀ (f : CellularAutomatas.Word α → CellularAutomatas.Word Γ)\n      (len : ∀ (w : CellularAutomatas.Word α), List.length (f w) = List.length w), motive { f := f, len := len }) →\n    motive h",
  "constCategory": "Definition"},
 {"references":
  ["HAppend.hAppend", "eq_self", "Eq.trans", "of_eq_true", "congrArg"],
  "name": "List.append_assoc",
  "constType":
  "∀ {α : Type u} (as bs cs : List α), as ++ bs ++ cs = as ++ (bs ++ cs)",
  "constCategory": "Theorem"},
 {"references":
  ["List.getElem_map",
   "List.map_map",
   "GetElem.getElem.congr_simp",
   "Eq.trans",
   "List.getElem_range",
   "CellularAutomatas.LCellAutomaton.scan_temporal",
   "CellularAutomatas.ca_id",
   "CellularAutomatas.CArtTransducer.f",
   "GetElem.getElem",
   "CellularAutomatas.advice_len",
   "congrArg",
   "CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "CellularAutomatas.LCellAutomaton.scan_temporal_rt",
   "CellularAutomatas.ca_id_comp_p0",
   "funext",
   "CellularAutomatas.CellAutomaton.Q",
   "Eq.ndrec",
   "CellularAutomatas.Word",
   "CellularAutomatas.CArtTransducer.advice",
   "CellularAutomatas.CArtTransducer.toLCellAutomaton",
   "id_eq",
   "List.map",
   "List.length_map",
   "CellularAutomatas.LCellAutomaton.comp",
   "CellularAutomatas.CArtTransducer.advice._proof_3",
   "OfNat.ofNat",
   "List.range",
   "CellularAutomatas.Advice.f",
   "LT.lt",
   "eq_self",
   "of_eq_true",
   "List.ext_getElem",
   "CellularAutomatas.Advice.mk.congr_simp",
   "id",
   "Eq.mpr",
   "List.length"],
  "name": "CellularAutomatas.ca_id_scan_temporal",
  "constType":
  "∀ {α : Type} [inst : CellularAutomatas.Alphabet α], (CellularAutomatas.ca_id α).advice.f = id",
  "constCategory": "Theorem"},
 {"references": ["Bool.noConfusionType", "Bool.casesOn", "Eq.ndrec"],
  "name": "Bool.noConfusion",
  "constType":
  "{P : Sort u} → {x1 x2 : Bool} → x1 = x2 → Bool.noConfusionType P x1 x2",
  "constCategory": "Definition"},
 {"references":
  ["CellularAutomatas.Advice.f",
   "CellularAutomatas.Word",
   "CellularAutomatas.Advice.ext",
   "Eq.symm",
   "Eq.ndrec",
   "Eq.casesOn"],
  "name": "CellularAutomatas.Advice.ext_iff",
  "constType":
  "∀ {α Γ : Type} {x y : CellularAutomatas.Advice α Γ}, x = y ↔ x.f = y.f",
  "constCategory": "Theorem"},
 {"references":
  ["Set.univ", "Set", "Membership.mem", "eq_true", "Set.mem_univ"],
  "name": "Set.mem_univ._simp_1",
  "constType": "∀ {α : Type u} (x : α), (x ∈ Set.univ) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.below",
   "LE.le",
   "_private.Init.Data.Nat.Basic.0.Nat.sub_le_sub_right.match_1_1",
   "HSub.hSub",
   "Nat.sub",
   "Nat.brecOn",
   "Nat.pred_le_pred",
   "OfNat.ofNat",
   "Unit"],
  "name": "Nat.sub_le_sub_right",
  "constType": "∀ {n m : ℕ}, n ≤ m → ∀ (k : ℕ), n - k ≤ m - k",
  "constCategory": "Theorem"},
 {"references": ["Not", "Decidable.byCases"],
  "name": "Decidable.em",
  "constType": "∀ (p : Prop) [Decidable p], p ∨ ¬p",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Lean.Grind.AddCommGroup.sub_eq_add_neg",
  "constType":
  "∀ {M : Type u} [self : Grind.AddCommGroup M] (a b : M), a - b = a + -b",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans",
   "Eq.mp",
   "CellularAutomatas.LCellAutomaton.scan_temporal",
   "CellularAutomatas.CArtTransducer.f",
   "eq_true",
   "congrArg",
   "CellularAutomatas.LCellAutomaton.scan_temporal_rt",
   "CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "List.length_range",
   "Eq.symm",
   "CellularAutomatas.CellAutomaton.Q",
   "Not",
   "CellularAutomatas.Word",
   "CellularAutomatas.CArtTransducer.toLCellAutomaton",
   "List.map",
   "CellularAutomatas.LCellAutomaton.comp",
   "List.length_map",
   "OfNat.ofNat",
   "List.range",
   "CellularAutomatas.LCellAutomaton.scan_temporal.eq_1",
   "eq_false",
   "Classical.byContradiction",
   "CellularAutomatas.LCellAutomaton.scan_temporal_rt.eq_1",
   "id",
   "List.length"],
  "name": "CellularAutomatas.CArtTransducer.advice._proof_3",
  "constType":
  "∀ {α Γ : Type} [inst : CellularAutomatas.Alphabet α] [inst_1 : CellularAutomatas.Alphabet Γ]\n  (adv : CellularAutomatas.CArtTransducer α Γ) (w : CellularAutomatas.Word α),\n  ((fun w => List.map adv.f (adv.scan_temporal_rt w)) w).length = List.length w",
  "constCategory": "Theorem"},
 {"references": ["Eq.symm"],
  "name": "Eq.mpr_prop",
  "constType": "∀ {p q : Prop}, p = q → q → p",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.CArtTransducer.compose",
   "CellularAutomatas.CArtTransducer.toLCellAutomaton",
   "CellularAutomatas.FiniteStateTransducer.comp",
   "CellularAutomatas.backwards_fsm.C'",
   "CellularAutomatas.backwards_fsm.Params.C",
   "CellularAutomatas.backwards_fsm.Params.β",
   "CellularAutomatas.backwards_fsm.Params.inst3",
   "CellularAutomatas.backwards_fsm.Params.M",
   "CellularAutomatas.FiniteStateTransducer.Q",
   "CellularAutomatas.TwoStageAdvice.from_transducers",
   "CellularAutomatas.TwoStageAdvice.β",
   "CellularAutomatas.backwards_fsm.Params.inst2",
   "CellularAutomatas.TwoStageAdvice.M",
   "CellularAutomatas.backwards_fsm.Params.γ",
   "CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "CellularAutomatas.TwoStageAdvice.C",
   "CellularAutomatas.CellAutomaton.Q",
   "CellularAutomatas.backwards_fsm.Params.α",
   "CellularAutomatas.backwards_fsm.M'"],
  "name": "CellularAutomatas.compose_two_stage",
  "constType":
  "{α Γ1 Γ : Type} →\n  [inst : CellularAutomatas.Alphabet α] →\n    [inst_1 : CellularAutomatas.Alphabet Γ1] →\n      [inst_2 : CellularAutomatas.Alphabet Γ] →\n        CellularAutomatas.TwoStageAdvice α Γ1 →\n          CellularAutomatas.TwoStageAdvice Γ1 Γ → CellularAutomatas.TwoStageAdvice α Γ",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Int.Linear.Context",
  "constType": "Type",
  "constCategory": "Definition"},
 {"references":
  ["Not", "LT.lt", "lt_iff_le_not_ge", "LE.le", "Iff.mp", "And.left"],
  "name": "le_of_lt",
  "constType": "∀ {α : Type u_1} [inst : Preorder α] {a b : α}, a < b → a ≤ b",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.propIntro",
   "List.cons.noConfusion",
   "Eq.symm",
   "Eq.ndrec",
   "Eq.casesOn",
   "And.casesOn"],
  "name": "List.cons.injEq",
  "constType":
  "∀ {α : Type u} (head : α) (tail : List α) (head_1 : α) (tail_1 : List α),\n  (head :: tail = head_1 :: tail_1) = (head = head_1 ∧ tail = tail_1)",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "Nat.succ_add",
   "Eq.trans",
   "imp_self._simp_1",
   "Nat.zero_add",
   "Nat.recAux",
   "OfNat.ofNat",
   "congrArg",
   "HAdd.hAdd",
   "of_eq_true",
   "congr",
   "Nat.succ.injEq",
   "id",
   "Eq.mpr"],
  "name": "Nat.add_left_cancel",
  "constType": "∀ {n m k : ℕ}, n + m = n + k → m = k",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.RArray.get", "Lean.Grind.CommRing.Var", "Lean.Grind.CommRing.Context"],
  "name": "Lean.Grind.CommRing.Var.denote",
  "constType":
  "{α : Type u_1} → Grind.CommRing.Context α → Grind.CommRing.Var → α",
  "constCategory": "Definition"},
 {"references": ["List.reverse", "List.foldlM"],
  "name": "List.foldrM",
  "constType":
  "{m : Type u → Type v} → [Monad m] → {s : Type u} → {α : Type w} → (α → s → m s) → s → List α → m s",
  "constCategory": "Definition"},
 {"references":
  ["Int.le_toNat",
   "Not",
   "Int.toNat",
   "Nat.cast",
   "Iff.rfl",
   "Int.not_le",
   "Nat.not_le",
   "OfNat.ofNat",
   "congrArg",
   "LT.lt",
   "LE.le",
   "id",
   "Eq.symm",
   "Eq.mpr",
   "propext"],
  "name": "Int.toNat_lt",
  "constType": "∀ {n : ℕ} {z : ℤ}, 0 ≤ z → (z.toNat < n ↔ z < ↑n)",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "rfl",
   "HSub.hSub",
   "Nat.sub",
   "Nat.pred",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Nat.succ_sub_succ_eq_sub",
  "constType": "∀ (n m : ℕ), n.succ - m.succ = n - m",
  "constCategory": "Theorem"},
 {"references":
  ["List.getElem_map",
   "Not",
   "CellularAutomatas.Word",
   "CellularAutomatas.Word.snd_len",
   "Eq.trans",
   "List.map",
   "GetElem.getElem",
   "Prod.snd",
   "List.length_map",
   "congrArg",
   "LT.lt",
   "eq_self",
   "Decidable.byContradiction",
   "Fin.val",
   "of_eq_true",
   "Fin.val_lt_of_le",
   "LE.le",
   "id",
   "CellularAutomatas.Word.get_fst._proof_1",
   "Eq.ndrec",
   "CellularAutomatas.Word.snd",
   "le_refl._simp_1",
   "List.length"],
  "name": "CellularAutomatas.Word.get_snd",
  "constType":
  "∀ {α β : Type} (w : CellularAutomatas.Word (α ⨉ β)) (t : Fin (List.length w)), w.snd[t] = w[t].2",
  "constCategory": "Theorem"},
 {"references": ["Set", "CellularAutomatas.t_rt"],
  "name": "CellularAutomatas.t_rt.eq_1",
  "constType":
  "∀ (α : Type) (S : Set (CellularAutomatas.tCellAutomaton α)),\n  CellularAutomatas.t_rt α S = {C | C ∈ S ∧ ∀ (n : ℕ), C.t n = n - 1}",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CellularAutomatas.backwards_fsm.Params.rec",
  "constType":
  "{motive : CellularAutomatas.backwards_fsm.Params → Sort u} →\n  ({α β γ : Type} →\n      [inst1 : CellularAutomatas.Alphabet α] →\n        [inst2 : CellularAutomatas.Alphabet β] →\n          [inst3 : CellularAutomatas.Alphabet γ] →\n            (M : CellularAutomatas.FiniteStateTransducer α β) →\n              (C : CellularAutomatas.CArtTransducer β γ) →\n                motive { α := α, β := β, γ := γ, inst1 := inst1, inst2 := inst2, inst3 := inst3, M := M, C := C }) →\n    (t : CellularAutomatas.backwards_fsm.Params) → motive t",
  "constCategory": "Other"},
 {"references":
  ["Int.add_le_add_right",
   "HAdd.hAdd",
   "Eq.mp",
   "Neg.neg",
   "Int.add_comm",
   "LE.le",
   "Int.add_neg_cancel_right",
   "congrArg"],
  "name": "Int.sub_left_le_of_le_add",
  "constType": "∀ {a b c : ℤ}, a ≤ b + c → a - b ≤ c",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.Word",
   "CellularAutomatas.FiniteStateTransducer.scanr_foldr_state",
   "Eq.trans",
   "CellularAutomatas.FiniteStateTransducer.scanr",
   "CellularAutomatas.FiniteStateTransducer.Q",
   "and_true",
   "Prod.snd",
   "CellularAutomatas.FiniteStateTransducer.scanr_reduce",
   "CellularAutomatas.FiniteStateTransducer.q0",
   "congrArg",
   "Prod.fst",
   "List.foldr",
   "CellularAutomatas.FiniteStateTransducer.scanr_reduce_q",
   "eq_self",
   "List.cons.injEq",
   "CellularAutomatas.FiniteStateTransducer.scanr_step",
   "id",
   "Eq.mpr",
   "CellularAutomatas.FiniteStateTransducer.f",
   "CellularAutomatas.FiniteStateTransducer.δ"],
  "name": "CellularAutomatas.FiniteStateTransducer.scanr_cons",
  "constType":
  "∀ {α β : Type} {M : CellularAutomatas.FiniteStateTransducer α β} (a : α) (w : CellularAutomatas.Word α),\n  M.scanr (a :: w) = M.f (M.δ (M.scanr_reduce w) a) :: M.scanr w",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "CellularAutomatas.CArtTransducer.toLCellAutomaton",
   "CellularAutomatas.backwards_fsm.C'",
   "CellularAutomatas.backwards_fsm.Params.C",
   "CellularAutomatas.backwards_fsm.Params.β",
   "CellularAutomatas.backwards_fsm.Params.inst3",
   "CellularAutomatas.backwards_fsm.Params.M",
   "CellularAutomatas.FiniteStateTransducer.Q",
   "CellularAutomatas.CellAutomaton.Q",
   "CellularAutomatas.backwards_fsm.Params.inst2",
   "CellularAutomatas.backwards_fsm.Params.α",
   "CellularAutomatas.backwards_fsm.Params.γ"],
  "name": "CellularAutomatas.backwards_fsm.C'.eq_1",
  "constType":
  "∀ (e : CellularAutomatas.backwards_fsm.Params),\n  CellularAutomatas.backwards_fsm.C' e =\n    { Q := Option e.α ⨉ (e.M.Q → e.C.Q), alphabetQ := CellularAutomatas.ProductAlphabet,\n      δ := fun x x_1 x_2 =>\n        match x with\n        | (al, fl) =>\n          match x_1 with\n          | (ac, fc) =>\n            match x_2 with\n            | (ar, fr) =>\n              (ar, fun q =>\n                have q_right := e.M.δ? q ac;\n                have q_center := e.M.δ? q_right al;\n                e.C.δ (fl q_center) (fc q_right) (fr q)),\n      embed := fun a => (some a, fun q => e.C.embed (e.M.f q)), border := (none, fun x => e.C.border),\n      f := fun x =>\n        match x with\n        | (a, f) => (a.getD default, f) }",
  "constCategory": "Theorem"},
 {"references":
  ["autoParam", "_auto._@.Std.Data.TreeMap.Basic.650080009._hygCtx._hyg.18"],
  "name": "Std.TreeMap.inner",
  "constType":
  "{α : Type u} →\n  {β : Type v} → {cmp : autoParam (α → α → Ordering) _auto✝} → TreeMap α β cmp → DTreeMap α (fun x => β) cmp",
  "constCategory": "Definition"},
 {"references": ["Trans.trans", "LE.le"],
  "name": "Std.le_trans",
  "constType":
  "∀ {α : Type u} [inst : LE α] [Trans (fun x1 x2 => x1 ≤ x2) (fun x1 x2 => x1 ≤ x2) fun x1 x2 => x1 ≤ x2] {a b c : α},\n  a ≤ b → b ≤ c → a ≤ c",
  "constCategory": "Theorem"},
 {"references": ["rfl"],
  "name": "exists_apply_eq_apply",
  "constType":
  "∀ {α : Sort u_2} {β : Sort u_1} (f : α → β) (a' : α), ∃ a, f a = f a'",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Eq.trans",
  "constType": "∀ {α : Sort u} {a b c : α}, a = b → b = c → a = c",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "CellularAutomatas.CArtTransducer.toLCellAutomaton",
   "CellularAutomatas.CellAutomaton.Q"],
  "name": "CellularAutomatas.composition.Params.mk._flat_ctor",
  "constType":
  "(α β : Type) →\n  [_inst_α : CellularAutomatas.Alphabet α] →\n    [_inst_β : CellularAutomatas.Alphabet β] →\n      (C : CellularAutomatas.LCellAutomaton β) →\n        (C_adv : CellularAutomatas.CArtTransducer α β) → (C_adv.Q → Option C.Q) → CellularAutomatas.composition.Params",
  "constCategory": "Definition"},
 {"references":
  ["Nat.mul_comm",
   "Nat.cast",
   "Eq.trans",
   "Int.casesOn",
   "HMul.hMul",
   "OfNat.ofNat",
   "congrArg",
   "HAdd.hAdd",
   "eq_self",
   "of_eq_true",
   "Eq.symm",
   "Int.negOfNat",
   "Eq.ndrec"],
  "name": "Int.mul_comm",
  "constType": "∀ (a b : ℤ), a * b = b * a",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Quot.inductionOn",
  "constType":
  "∀ {α : Sort u} {r : α → α → Prop} {motive : Quot r → Prop} (q : Quot r), (∀ (a : α), motive (Quot.mk r a)) → motive q",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "Not",
   "OfNat.ofNat",
   "LT.lt",
   "HAdd.hAdd",
   "Decidable.byContradiction",
   "Int.beq'_eq",
   "LE.le",
   "Eq.symm",
   "_private.Init.Grind.Order.0.Lean.Grind.Order.int_lt._proof_1_1",
   "HSub.hSub",
   "id",
   "Int.beq'",
   "Eq.mpr",
   "Eq.ndrec"],
  "name": "Lean.Grind.Order.int_lt",
  "constType":
  "∀ {x y k k' : ℤ}, k'.beq' (k - 1) = true → x < y + k → x ≤ y + k'",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.FiniteStateTransducer.scanr_reduce_q.match_1",
   "List.below",
   "CellularAutomatas.Word",
   "List.brecOn",
   "CellularAutomatas.FiniteStateTransducer.Q",
   "CellularAutomatas.FiniteStateTransducer.δ",
   "Unit"],
  "name": "CellularAutomatas.FiniteStateTransducer.scanr_reduce_q",
  "constType":
  "{α β : Type} → (M : CellularAutomatas.FiniteStateTransducer α β) → M.Q → CellularAutomatas.Word α → M.Q",
  "constCategory": "Definition"},
 {"references":
  ["Eq.trans",
   "Neg.neg",
   "Lean.Omega.Coeffs",
   "congrArg",
   "HAdd.hAdd",
   "eq_self",
   "of_eq_true",
   "Lean.Omega.IntList",
   "Int.neg_add",
   "Lean.Omega.IntList.dot_neg_left",
   "congr",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.IntList.dot",
   "Lean.Omega.LinearCombo.casesOn",
   "Lean.Omega.Coeffs.dot"],
  "name": "Lean.Omega.LinearCombo.neg_eval",
  "constType":
  "∀ (lc : Omega.LinearCombo) (v : Omega.Coeffs), (-lc).eval v = -lc.eval v",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "addLECancellable_zero",
   "Eq.symm",
   "add_zero",
   "AddLECancellable.tsub_eq_of_eq_add",
   "OfNat.ofNat"],
  "name": "tsub_zero",
  "constType":
  "∀ {α : Type u_1} [inst : PartialOrder α] [inst_1 : AddCommMonoid α] [inst_2 : Sub α] [OrderedSub α] (a : α), a - 0 = a",
  "constCategory": "Theorem"},
 {"references":
  ["Int.toNat",
   "Fin.is_lt._simp_1",
   "CellularAutomatas.FiniteStateTransducer.scanr_len",
   "Eq.trans",
   "CellularAutomatas.FiniteStateTransducer.scanr",
   "OfNat.ofNat",
   "Eq.mpr_prop",
   "congrArg",
   "HAdd.hAdd",
   "LT.lt",
   "Lean.Grind.Nat.lt_eq",
   "Fin.val",
   "of_eq_true",
   "LE.le",
   "List.length"],
  "name": "CellularAutomatas.FiniteStateTransducer.scanr_get'_eq._proof_1_3",
  "constType":
  "∀ {α β : Type} {M : CellularAutomatas.FiniteStateTransducer α β} (w : List α) (i : ℤ)\n  (h_nat_lt : i.toNat + 1 ≤ w.length), ↑⟨i.toNat, ⋯⟩ < List.length (M.scanr w)",
  "constCategory": "Theorem"},
 {"references": ["OrderDual", "sup_lt_iff"],
  "name": "lt_inf_iff",
  "constType":
  "∀ {α : Type u} [inst : LinearOrder α] {a b c : α}, a < min b c ↔ a < b ∧ a < c",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.CellAutomaton.δ",
   "forall_eq._simp_1",
   "Eq.trans",
   "Eq.mp",
   "Set",
   "Singleton.singleton",
   "Membership.mem",
   "Subtype.val",
   "Set.Elem",
   "congrArg",
   "eq_self",
   "of_eq_true",
   "congr",
   "Subtype.forall._simp_1",
   "forall_congr",
   "CellularAutomatas.CellAutomaton.quiescent",
   "id",
   "CellularAutomatas.CellAutomaton.Q",
   "Set.mem_singleton_iff._simp_1",
   "forall_prop_domain_congr"],
  "name": "CellularAutomatas.CellAutomaton.δ_of_quiescent",
  "constType":
  "∀ {C : CellularAutomatas.CellAutomaton} {q : C.Q}, C.quiescent q → C.δ q q q = q",
  "constCategory": "Theorem"},
 {"references": ["Membership.mem", "List.mem_cons", "propext"],
  "name": "List.mem_cons._simp_1",
  "constType":
  "∀ {α : Type u_1} {b : α} {l : List α} {a : α}, (a ∈ b :: l) = (a = b ∨ a ∈ l)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CellularAutomatas.tCellAutomaton.mk",
  "constType":
  "{α : Type} →\n  (toLCellAutomaton : CellularAutomatas.LCellAutomaton α) →\n    (ℕ → ℕ) → (ℕ → ℕ) → (toLCellAutomaton.Q → Bool) → CellularAutomatas.tCellAutomaton α",
  "constCategory": "Other"},
 {"references": [],
  "name": "rfl",
  "constType": "∀ {α : Sort u} {a : α}, a = a",
  "constCategory": "Definition"},
 {"references":
  ["Not", "LT.lt", "Iff.mpr", "LE.le", "Iff.mp", "Int.le_trans", "Int.not_le"],
  "name": "Int.lt_of_le_of_lt",
  "constType": "∀ {a b c : ℤ}, a ≤ b → b < c → a < c",
  "constCategory": "Theorem"},
 {"references":
  ["Or.elim",
   "Lean.Omega.LinearCombo.coordinate_eval_2",
   "Nat.cast",
   "Eq.trans",
   "Lean.Omega.LinearCombo.coordinate_eval_3",
   "le_of_le_of_eq",
   "Classical.propDecidable",
   "Lean.Omega.LinearCombo.coordinate_eval_0",
   "Lean.Omega.Constraint.combine_sat'",
   "Decidable.decide",
   "Lean.Omega.Coeffs.ofList",
   "Eq.symm",
   "Lean.Omega.tidy_sat",
   "HSub.hSub",
   "Lean.Omega.LinearCombo.add_eval",
   "Lean.Omega.Int.lt_of_not_le",
   "Decidable.not_or_of_imp",
   "Int.add_one_le_of_lt",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "And.left",
   "of_decide_eq_true",
   "Not",
   "CellularAutomatas.Word",
   "Lean.Omega.combo_sat'",
   "Neg.neg",
   "And.right",
   "Lean.Omega.Constraint.addInequality_sat",
   "Lean.Omega.Int.add_congr",
   "Lean.Omega.Constraint.isImpossible",
   "Lean.Omega.LinearCombo.coordinate",
   "Int.ofNat_nonneg",
   "OfNat.ofNat",
   "Int.sub_nonneg_of_le",
   "LT.lt",
   "HAdd.hAdd",
   "Lean.Omega.LinearCombo.sub_eval",
   "LE.le",
   "id",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.Int.sub_congr",
   "List.length"],
  "name":
  "CellularAutomatas.LCellAutomaton.scan_temporal_independence._proof_1_3",
  "constType":
  "∀ {α : Type} (p s : CellularAutomatas.Word α) (t : ℕ) (j : ℤ),\n  (0 ≤ j → ↑(List.length p) + ↑(List.length s) ≤ j) → 0 ≤ j ∧ j < ↑(List.length p) → False",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.Word.cone_zero_eq_range",
   "CellularAutomatas.Word",
   "Set",
   "Membership.mem",
   "CellularAutomatas.Word.cone",
   "CellularAutomatas.Word.range",
   "OfNat.ofNat"],
  "name": "CellularAutomatas.Word.get_cone_0._proof_1",
  "constType":
  "∀ {α : Type u_1} {w : CellularAutomatas.Word α} {i : ℤ}, i ∈ w.cone 0 → i ∈ w.range",
  "constCategory": "Theorem"},
 {"references": ["CellularAutomatas.rel_repr", "CellularAutomatas.Word"],
  "name": "CellularAutomatas.rel",
  "constType":
  "{α Γ : Type} →\n  CellularAutomatas.Advice α Γ → CellularAutomatas.Word α → CellularAutomatas.Word α → CellularAutomatas.Word α → Prop",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CellularAutomatas.backwards_fsm.Params.inst2",
  "constType":
  "(self : CellularAutomatas.backwards_fsm.Params) → CellularAutomatas.Alphabet self.β",
  "constCategory": "Definition"},
 {"references": ["Lean.Grind.CommRing.Power.beq'", "Bool.and'"],
  "name": "Lean.Grind.CommRing.Mon.beq'",
  "constType": "Grind.CommRing.Mon → Grind.CommRing.Mon → Bool",
  "constCategory": "Definition"},
 {"references": ["CellularAutomatas.Word", "List.length"],
  "name": "CellularAutomatas.Advice.mk._flat_ctor",
  "constType":
  "{α Γ : Type} →\n  (f : CellularAutomatas.Word α → CellularAutomatas.Word Γ) →\n    (∀ (w : CellularAutomatas.Word α), List.length (f w) = List.length w) → CellularAutomatas.Advice α Γ",
  "constCategory": "Definition"},
 {"references": [],
  "name": "List.below",
  "constType":
  "{α : Type u} → {motive : List α → Sort u_1} → List α → Sort (max (u + 1) u_1)",
  "constCategory": "Definition"},
 {"references": ["Classical.propDecidable", "inferInstance"],
  "name": "Classical.dec",
  "constType": "(p : Prop) → Decidable p",
  "constCategory": "Definition"},
 {"references":
  ["Array.size",
   "Lean.SyntaxNodeKind",
   "OfNat.ofNat",
   "_private.Init.Prelude.0.Lean.Syntax.setKind.match_1"],
  "name": "Lean.Syntax.getNumArgs",
  "constType": "Syntax → ℕ",
  "constCategory": "Definition"},
 {"references": ["CellularAutomatas.TwoStageAdvice.mk.noConfusion"],
  "name": "CellularAutomatas.TwoStageAdvice.mk.inj",
  "constType":
  "∀ {α Γ : Type} {inst : CellularAutomatas.Alphabet α} {inst_1 : CellularAutomatas.Alphabet Γ} {β : Type}\n  {alphabetβ : CellularAutomatas.Alphabet β} {C : CellularAutomatas.CArtTransducer α β}\n  {M : CellularAutomatas.FiniteStateTransducer β Γ} {β_1 : Type} {alphabetβ_1 : CellularAutomatas.Alphabet β_1}\n  {C_1 : CellularAutomatas.CArtTransducer α β_1} {M_1 : CellularAutomatas.FiniteStateTransducer β_1 Γ},\n  { β := β, alphabetβ := alphabetβ, C := C, M := M } = { β := β_1, alphabetβ := alphabetβ_1, C := C_1, M := M_1 } →\n    β = β_1 ∧ alphabetβ ≍ alphabetβ_1 ∧ C ≍ C_1 ∧ M ≍ M_1",
  "constCategory": "Theorem"},
 {"references": ["Not", "Decidable.byContradiction", "Classical.propDecidable"],
  "name": "Classical.byContradiction",
  "constType": "∀ {p : Prop}, (¬p → False) → p",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "Lean.Grind.Semiring.add_zero",
   "Nat.add_zero",
   "Nat.add_succ",
   "id",
   "Nat.recAux",
   "Eq.mpr",
   "Lean.Grind.Semiring.add_assoc",
   "OfNat.ofNat",
   "Lean.Grind.Semiring.ofNat_succ",
   "congrArg"],
  "name": "Lean.Grind.Semiring.ofNat_add",
  "constType":
  "∀ {α : Type u} [inst : Grind.Semiring α] (a b : ℕ), OfNat.ofNat (a + b) = OfNat.ofNat a + OfNat.ofNat b",
  "constCategory": "Theorem"},
 {"references":
  ["Int.Linear.Poly.beq'",
   "Int.Linear.Poly.combine_mul_k",
   "Neg.neg",
   "OfNat.ofNat"],
  "name": "Int.Linear.eq_of_core_cert",
  "constType": "Int.Linear.Poly → Int.Linear.Poly → Int.Linear.Poly → Bool",
  "constCategory": "Definition"},
 {"references":
  ["CellularAutomatas.Word",
   "Eq.trans",
   "List.casesOn",
   "CellularAutomatas.FiniteStateTransducer.scanr",
   "CellularAutomatas.FiniteStateTransducer.Q",
   "Prod.snd",
   "CellularAutomatas.FiniteStateTransducer.q0",
   "congrArg",
   "Prod.fst",
   "CellularAutomatas.FiniteStateTransducer.M_id",
   "List.foldr",
   "eq_self",
   "and_self",
   "of_eq_true",
   "List.cons.injEq",
   "congr",
   "funext",
   "CellularAutomatas.FiniteStateTransducer.scanr_step",
   "Eq.symm",
   "id",
   "Eq.mpr",
   "Eq.ndrec",
   "CellularAutomatas.FiniteStateTransducer.f",
   "CellularAutomatas.FiniteStateTransducer.δ"],
  "name": "CellularAutomatas.FiniteStateTransducer.M_id_scanr_eq",
  "constType":
  "∀ {α : Type} [inst : CellularAutomatas.Alphabet α], (CellularAutomatas.FiniteStateTransducer.M_id α).scanr = id",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CellularAutomatas.DefinesLanguage.mk",
  "constType":
  "{CA : Sort u_1} → {α : outParam Type} → (CA → Language α) → CellularAutomatas.DefinesLanguage CA α",
  "constCategory": "Other"},
 {"references": ["Nat.cast"],
  "name": "Nat.rawCast",
  "constType": "{α : Type u} → [AddMonoidWithOne α] → ℕ → α",
  "constCategory": "Definition"},
 {"references": ["Int.Linear.Expr.brecOn.go", "Int.Linear.Expr.below"],
  "name": "Int.Linear.Expr.brecOn",
  "constType":
  "{motive : Int.Linear.Expr → Sort u} →\n  (t : Int.Linear.Expr) → ((t : Int.Linear.Expr) → Int.Linear.Expr.below t → motive t) → motive t",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Std.IdempotentOp.idempotent",
  "constType":
  "∀ {α : Sort u} {op : α → α → α} [self : IdempotentOp op] (x : α), op x x = x",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.lt_of_lt_of_le",
   "List.drop",
   "Neg.neg",
   "HMul.hMul",
   "List.length_take_le'",
   "OfNat.ofNat",
   "Lean.Grind.nestedProof",
   "HAdd.hAdd",
   "LT.lt",
   "NatCast.natCast",
   "List.take",
   "LE.le",
   "HSub.hSub",
   "CellularAutomatas.PrefixStableProof.getLastOfTake._proof_1_5",
   "List.length"],
  "name": "CellularAutomatas.PrefixStableProof.getLastOfTake._proof_1_6",
  "constType":
  "∀ {i : ℕ} {α : Type u_1} {w : List α},\n  -1 * ↑(List.take 1 w⟦i..*⟧).length + 1 ≤ 0 → (List.take 1 w⟦i..*⟧).length - 1 < w⟦i..*⟧.length",
  "constCategory": "Theorem"},
 {"references":
  ["absurd", "LT.lt", "Nat.not_lt_zero", "Fin.elim0.match_1", "OfNat.ofNat"],
  "name": "Fin.elim0",
  "constType": "{α : Sort u} → Fin 0 → α",
  "constCategory": "Definition"},
 {"references": ["_private.Init.Prelude.0.Or.elim.match_1_1"],
  "name": "Or.elim",
  "constType": "∀ {a b c : Prop}, a ∨ b → (a → c) → (b → c) → c",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "LT.lt",
   "Nat.casesOn",
   "Fin.casesOn",
   "OfNat.ofNat",
   "List.length"],
  "name": "CellularAutomatas.FiniteStateTransducer.scanr_get'_eq2.match_1_1",
  "constType":
  "∀ {α : Type} (a : α) (w : List α) (motive : Fin (a :: w).length → Prop) (i : Fin (a :: w).length),\n  (∀ (isLt : 0 < (a :: w).length), motive ⟨0, isLt⟩) →\n    (∀ (n : ℕ) (h : n + 1 < (a :: w).length), motive ⟨n.succ, h⟩) → motive i",
  "constCategory": "Definition"},
 {"references": ["Pure.pure", "Array.foldlM", "Id.run", "Id"],
  "name": "Array.foldl",
  "constType":
  "{α : Type u} → {β : Type v} → (β → α → β) → β → (as : Array α) → optParam ℕ 0 → optParam ℕ as.size → β",
  "constCategory": "Definition"},
 {"references":
  ["HAdd.hAdd",
   "eq_self",
   "Int.Linear.Poly.addConst.induct_unfolding",
   "Eq.trans",
   "of_eq_true",
   "Eq.symm",
   "Int.Linear.Poly.addConst",
   "Int.Linear.Poly.addConst_k",
   "congrArg",
   "Int.Linear.Var"],
  "name": "Int.Linear.Poly.addConst_k_eq_addConst",
  "constType": "∀ (p : Int.Linear.Poly) (k : ℤ), p.addConst_k k = p.addConst k",
  "constCategory": "Theorem"},
 {"references":
  ["HAppend.hAppend",
   "Bind.bind",
   "Eq.trans",
   "List.foldrM_cons",
   "LawfulMonad.bind_assoc",
   "congrArg",
   "eq_self",
   "of_eq_true",
   "congr",
   "funext",
   "List.foldrM",
   "Pure.pure",
   "bind_pure"],
  "name": "List.foldrM_append",
  "constType":
  "∀ {m : Type u_1 → Type u_2} {α : Type u_3} {β : Type u_1} [inst : Monad m] [LawfulMonad m] {f : α → β → m β} {b : β}\n  {l l' : List α},\n  List.foldrM f b (l ++ l') = do\n    let init ← List.foldrM f b l'\n    List.foldrM f init l",
  "constCategory": "Theorem"},
 {"references": ["HAdd.hAdd", "SizeOf.sizeOf", "OfNat.ofNat"],
  "name": "CellularAutomatas.tCellAutomatonWithAdvice.mk.sizeOf_spec",
  "constType":
  "∀ {α : Type} [inst : SizeOf α] (Γ : Type) [alphabetΓ : CellularAutomatas.Alphabet Γ]\n  (adv : CellularAutomatas.Advice α Γ) (C : CellularAutomatas.tCellAutomaton (α ⨉ Γ)),\n  sizeOf { Γ := Γ, alphabetΓ := alphabetΓ, adv := adv, C := C } =\n    1 + sizeOf Γ + sizeOf alphabetΓ + sizeOf adv + sizeOf C",
  "constCategory": "Theorem"},
 {"references": ["id", "CellularAutomatas.CellAutomaton.noConfusion"],
  "name": "CellularAutomatas.CellAutomaton.mk.noConfusion",
  "constType":
  "(P : Sort u) →\n  (Q : Type) →\n    [alphabetQ : CellularAutomatas.Alphabet Q] →\n      (δ : Q → Q → Q → Q) →\n        (Q' : Type) →\n          (alphabetQ' : CellularAutomatas.Alphabet Q') →\n            (δ' : Q' → Q' → Q' → Q') →\n              { Q := Q, alphabetQ := alphabetQ, δ := δ } = { Q := Q', alphabetQ := alphabetQ', δ := δ' } →\n                (Q = Q' → alphabetQ ≍ alphabetQ' → δ ≍ δ' → P) → P",
  "constCategory": "Definition"},
 {"references":
  ["HAdd.hAdd",
   "LE.le",
   "Nat.le.brecOn",
   "OfNat.ofNat",
   "_private.Init.Prelude.0.Nat.succ_le_succ.match_1_4",
   "Unit"],
  "name": "Nat.succ_le_succ",
  "constType": "∀ {n m : ℕ}, n ≤ m → n.succ ≤ m.succ",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.succ_le_succ",
   "Or.casesOn",
   "Nat.min_eq_right",
   "Min.min",
   "LE.le",
   "id",
   "Nat.min_eq_left",
   "Nat.le_total",
   "Eq.mpr",
   "congrArg"],
  "name": "Nat.succ_min_succ",
  "constType": "∀ (x y : ℕ), min x.succ y.succ = (min x y).succ",
  "constCategory": "Theorem"},
 {"references": ["exists_and_left", "propext"],
  "name": "exists_and_left._simp_1",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {b : Prop}, (∃ x, b ∧ p x) = (b ∧ ∃ x, p x)",
  "constCategory": "Theorem"},
 {"references": ["rfl"],
  "name": "congr",
  "constType":
  "∀ {α : Sort u} {β : Sort v} {f₁ f₂ : α → β} {a₁ a₂ : α}, f₁ = f₂ → a₁ = a₂ → f₁ a₁ = f₂ a₂",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.FiniteStateTransducer.M_prod",
   "CellularAutomatas.FiniteStateTransducer.comp",
   "CellularAutomatas.FiniteStateTransducer.M_map",
   "Prod.snd",
   "Prod.fst",
   "CellularAutomatas.backwards_fsm.M_join.match_1"],
  "name": "CellularAutomatas.backwards_fsm.M_join",
  "constType":
  "{γ α β : Type} →\n  [CellularAutomatas.Alphabet γ] →\n    [CellularAutomatas.Alphabet α] →\n      [CellularAutomatas.Alphabet β] →\n        CellularAutomatas.FiniteStateTransducer α β → CellularAutomatas.FiniteStateTransducer (α ⨉ (β → γ)) γ",
  "constCategory": "Definition"},
 {"references": ["LE.le", "ge_iff_le", "GE.ge", "propext"],
  "name": "ge_iff_le._simp_1",
  "constType": "∀ {α : Type u_1} [inst : LE α] {x y : α}, (x ≥ y) = (y ≤ x)",
  "constCategory": "Theorem"},
 {"references": ["Lean.Omega.Coeffs", "Lean.Omega.IntList.gcd"],
  "name": "Lean.Omega.Coeffs.gcd",
  "constType": "Omega.Coeffs → ℕ",
  "constCategory": "Definition"},
 {"references": ["Multiset.range", "Multiset.nodup_range"],
  "name": "Finset.range",
  "constType": "ℕ → Finset ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Not",
   "CellularAutomatas.Word.get'",
   "CellularAutomatas.empty_word_range",
   "Eq.trans",
   "Set",
   "CellularAutomatas.uniform_config",
   "Membership.mem",
   "EmptyCollection.emptyCollection",
   "congrArg",
   "CellularAutomatas.LCellAutomaton.embed",
   "CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "eq_self",
   "of_eq_true",
   "funext",
   "CellularAutomatas.LCellAutomaton.embed_word",
   "Set.mem_empty_iff_false._simp_1",
   "CellularAutomatas.CellAutomaton.Q",
   "CellularAutomatas.Word.range",
   "dite_cond_eq_false",
   "CellularAutomatas.LCellAutomaton.border",
   "dite"],
  "name":
  "CellularAutomatas.LCellAutomaton.empty_word_config_eq_uniform_border",
  "constType":
  "∀ {α : Type} {C : CellularAutomatas.LCellAutomaton α}, C.embed_word [] = CellularAutomatas.uniform_config C.border",
  "constCategory": "Theorem"},
 {"references": ["LT.lt", "Nat.cast", "Int.ofNat_lt", "propext"],
  "name": "_private.Init.Data.Int.OfNat.0.Nat.ToInt.lt_eq._simp_1_1",
  "constType": "∀ {n m : ℕ}, (↑n < ↑m) = (n < m)",
  "constCategory": "Theorem"},
 {"references":
  ["ite",
   "Array.foldl",
   "Lean.Environment.find?",
   "CellularAutomatas.collectAxiomsFromEnv.visit.match_1",
   "CellularAutomatas.collectAxiomsFromEnv.visit._unsafe_rec",
   "CellularAutomatas.collectAxiomsFromEnv.visit.match_3",
   "OfNat.ofNat",
   "Unit",
   "Lean.NameSet.contains",
   "Array.size",
   "Lean.NameSet.insert",
   "Lean.ConstantInfo.getUsedConstantsAsSet",
   "Std.TreeSet.toArray",
   "Lean.NameSet",
   "Lean.Name.quickCmp"],
  "name": "CellularAutomatas.collectAxiomsFromEnv.visit._unsafe_rec",
  "constType": "Environment → Name → NameSet → NameSet → NameSet ⨉ NameSet",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Omega.LinearCombo.mul_eval",
   "Nat.cast",
   "Eq.trans",
   "le_of_le_of_eq",
   "HMul.hMul",
   "Lean.Omega.LinearCombo.coordinate_eval_0",
   "Lean.Omega.Constraint.combine_sat'",
   "Decidable.decide",
   "Lean.Omega.Int.ofNat_le_of_le",
   "Lean.Omega.Int.mul_congr",
   "Lean.Omega.Coeffs.ofList",
   "Eq.symm",
   "Lean.Omega.tidy_sat",
   "HSub.hSub",
   "Lean.Omega.LinearCombo.add_eval",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "Int.add_one_le_of_lt",
   "And.left",
   "of_decide_eq_true",
   "Not",
   "Neg.neg",
   "Lean.Omega.Constraint.addInequality_sat",
   "Lean.Omega.Int.add_congr",
   "Lean.Omega.Constraint.isImpossible",
   "Lean.Omega.LinearCombo.coordinate",
   "OfNat.ofNat",
   "Int.sub_nonneg_of_le",
   "Lean.Omega.LinearCombo.coordinate_eval_1",
   "HAdd.hAdd",
   "Lean.Omega.LinearCombo.mul",
   "Lean.Omega.LinearCombo.sub_eval",
   "Lean.Omega.Int.ofNat_lt_of_lt",
   "Lean.Omega.Coeffs.isZero",
   "LE.le",
   "Nat.lt_of_not_le",
   "Int.natCast_add",
   "id",
   "Int.natCast_mul",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.Int.sub_congr"],
  "name": "CellularAutomatas.middle_reachable_card._proof_1_3",
  "constType":
  "∀ (k' : ℕ) ⦃pos : ℕ⦄, k' + 1 ≤ pos ∧ pos ≤ 2 * (k' + 1) → ¬2 * (k' + 1) ≤ 2 * pos → False",
  "constCategory": "Theorem"},
 {"references": ["HAdd.hAdd", "Eq.ndrec"],
  "name": "Lean.Omega.Int.add_congr",
  "constType": "∀ {a b c d : ℤ}, a = b → c = d → a + c = b + d",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.iterate",
   "id",
   "Eq.mpr",
   "Function.comp",
   "Function.iterate_succ'",
   "congrArg"],
  "name": "Function.iterate_succ_apply'",
  "constType":
  "∀ {α : Type u} (f : α → α) (n : ℕ) (x : α), f^[n.succ] x = f (f^[n] x)",
  "constCategory": "Theorem"},
 {"references": ["And.casesOn"],
  "name": "_private.Init.Core.0.Decidable.not_and_iff_or_not.match_1_5",
  "constType":
  "∀ {p q : Prop} (motive : p ∧ q → Prop) (x : p ∧ q), (∀ (hp : p) (hq : q), motive ⋯) → motive x",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CellularAutomatas.LCellAutomaton.mk._flat_ctor",
  "constType":
  "{α : Type} →\n  (Q : Type) →\n    [alphabetQ : CellularAutomatas.Alphabet Q] → (Q → Q → Q → Q) → (α → Q) → Q → CellularAutomatas.LCellAutomaton α",
  "constCategory": "Definition"},
 {"references":
  ["HAdd.hAdd",
   "AddLeftMono",
   "Trans.trans",
   "LE.le",
   "Eq.symm",
   "add_zero",
   "add_le_add_right",
   "OfNat.ofNat"],
  "name": "le_add_of_nonneg_right",
  "constType":
  "∀ {α : Type u_1} [inst : AddZeroClass α] [inst_1 : LE α] [AddLeftMono α] {a b : α}, 0 ≤ b → a ≤ a + b",
  "constCategory": "Theorem"},
 {"references":
  ["Not", "LT.lt", "Nat.div.go", "Nat.lt_succ_self", "dite", "OfNat.ofNat"],
  "name": "Nat.div",
  "constType": "ℕ → ℕ → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Nat.below", "Nat.brecOn", "List.replicate.match_1", "OfNat.ofNat"],
  "name": "List.replicate",
  "constType": "{α : Type u} → ℕ → α → List α",
  "constCategory": "Definition"},
 {"references":
  ["Finset.univ",
   "CellularAutomatas.Word",
   "CellularAutomatas.CArtTransducer.advice",
   "CellularAutomatas.FiniteStateTransducer.scanr_q",
   "Finset.card",
   "le_trans",
   "CellularAutomatas.FiniteStateTransducer.Q",
   "CellularAutomatas.TwoStageAdvice.β",
   "CellularAutomatas.TwoStageAdvice.M",
   "CellularAutomatas.possible_advice_prefixes",
   "Fintype.card",
   "CellularAutomatas.Advice.f",
   "CellularAutomatas.TwoStageAdvice.C",
   "of_eq_true",
   "Finset.card_image_le",
   "Finset.image",
   "LE.le",
   "id",
   "le_refl._simp_1"],
  "name": "CellularAutomatas.two_stage_restriction_cardinality",
  "constType":
  "∀ {α : Type} [inst : CellularAutomatas.Alphabet α] {Γ : Type} [inst_1 : CellularAutomatas.Alphabet Γ]\n  (adv : CellularAutomatas.TwoStageAdvice α Γ) (p : CellularAutomatas.Word α),\n  (CellularAutomatas.possible_advice_prefixes adv p).card ≤ Fintype.card adv.M.Q",
  "constCategory": "Theorem"},
 {"references": ["id", "Eq.comm", "Eq.mpr", "propext", "congrArg"],
  "name": "Lean.Grind.eq_congr'",
  "constType":
  "∀ {α : Sort u} {a₁ b₁ a₂ b₂ : α}, a₁ = b₂ → b₁ = a₂ → (a₁ = b₁) = (a₂ = b₂)",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans",
   "Lean.Omega.IntList.get",
   "Lean.Omega.LinearCombo.coordinate",
   "OfNat.ofNat",
   "congrArg",
   "HAdd.hAdd",
   "eq_self",
   "Lean.Omega.LinearCombo.coordinate_eval",
   "of_eq_true",
   "Lean.Omega.Coeffs.ofList",
   "Lean.Omega.IntList.get_cons_succ",
   "Lean.Omega.Coeffs.get",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.IntList.get_cons_zero"],
  "name": "Lean.Omega.LinearCombo.coordinate_eval_6",
  "constType":
  "∀ {a0 a1 a2 a3 a4 a5 a6 : ℤ} {t : List ℤ},\n  (Omega.LinearCombo.coordinate 6).eval (Omega.Coeffs.ofList (a0 :: a1 :: a2 :: a3 :: a4 :: a5 :: a6 :: t)) = a6",
  "constCategory": "Theorem"},
 {"references":
  ["HAppend.hAppend",
   "eq_self",
   "Eq.trans",
   "of_eq_true",
   "id",
   "List.append",
   "congrArg"],
  "name": "List.append_nil",
  "constType": "∀ {α : Type u} (as : List α), as ++ [] = as",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.cast", "Int.natCast_nonneg", "LE.le", "eq_true", "OfNat.ofNat"],
  "name": "Int.natCast_nonneg._simp_1",
  "constType": "∀ (n : ℕ), (0 ≤ ↑n) = True",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "eq_self",
   "GetElem?.getElem?",
   "of_eq_true",
   "Option.getD",
   "OfNat.ofNat",
   "List.length"],
  "name": "Lean.Omega.IntList.get_cons_succ",
  "constType":
  "∀ {x : ℤ} {xs : List ℤ} {i : ℕ}, Omega.IntList.get (x :: xs) (i + 1) = Omega.IntList.get xs i",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "Int.Linear.Poly.coeff",
   "Int.Linear.Poly.beq'",
   "Eq.trans",
   "Eq.mp",
   "Int.Linear.Poly.denote'_eq_denote",
   "and_imp._simp_1",
   "Int.zero_add",
   "Int.Linear.Poly.denote",
   "eq_true",
   "Int.Linear.Poly.denote_combine_mul_k",
   "HMul.hMul",
   "congrArg",
   "Bool.and",
   "congr",
   "Int.Linear.eq_le_subst_nonneg_cert",
   "Eq.symm",
   "Int.ble'_eq_true",
   "Int.Linear.Poly.denote'",
   "Eq.ndrec",
   "Bool.and'_eq_and",
   "Int.mul_le_mul_of_nonneg_left",
   "Neg.neg",
   "Int.ble'",
   "OfNat.ofNat",
   "Int.mul_zero",
   "HAdd.hAdd",
   "of_eq_true",
   "Int.Linear.Poly.combine_mul_k",
   "Int.Linear.Context",
   "Int.add_comm",
   "LE.le",
   "id",
   "Int.Linear.Poly.beq'_eq",
   "Eq.mpr",
   "Bool.and_eq_true",
   "Bool.and'",
   "Int.Linear.Var"],
  "name": "Int.Linear.eq_le_subst_nonneg",
  "constType":
  "∀ (ctx : Int.Linear.Context) (x : Int.Linear.Var) (p₁ p₂ p₃ : Int.Linear.Poly),\n  Int.Linear.eq_le_subst_nonneg_cert x p₁ p₂ p₃ = true →\n    Int.Linear.Poly.denote' ctx p₁ = 0 → Int.Linear.Poly.denote' ctx p₂ ≤ 0 → Int.Linear.Poly.denote' ctx p₃ ≤ 0",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.Word",
   "Eq.trans",
   "List.map",
   "List.length_map",
   "OfNat.ofNat",
   "congrArg",
   "HAdd.hAdd",
   "List.range",
   "implies_true",
   "eq_self",
   "of_eq_true",
   "List.length_range",
   "forall_congr",
   "BEq.beq",
   "List.length"],
  "name": "CellularAutomatas.Advice.from_len_marker._proof_1",
  "constType":
  "∀ {α : Type} (f : ℕ → Option ℕ) (a : CellularAutomatas.Word α),\n  (List.map (fun i => some (i + 1) == f (List.length a)) (List.range (List.length a))).length = List.length a",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans",
   "le_of_le_of_eq",
   "Membership.mem",
   "Lean.Omega.LinearCombo.coordinate_eval_4",
   "Subtype.val",
   "CellularAutomatas.tCellAutomaton.toLCellAutomaton",
   "Set.Elem",
   "CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "CellularAutomatas.LCellAutomaton.scan_temporal_rt",
   "Lean.Omega.tidy_sat",
   "HSub.hSub",
   "Eq.symm",
   "Lean.Omega.LinearCombo.add_eval",
   "Int.add_one_le_of_lt",
   "CellularAutomatas.CArtTransducer.advice",
   "Neg.neg",
   "Lean.Omega.Constraint.addInequality_sat",
   "List.map",
   "Lean.Omega.LinearCombo.coordinate",
   "Nat.lt_of_not_le",
   "id",
   "CellularAutomatas.tCellAutomaton.L",
   "Lean.Omega.Int.sub_congr",
   "List.length",
   "Nat.cast",
   "Lean.Omega.Constraint.combine_sat'",
   "Decidable.decide",
   "Lean.Omega.Coeffs.ofList",
   "CellularAutomatas.CellAutomaton.Q",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "of_decide_eq_true",
   "Not",
   "CellularAutomatas.Word",
   "List.extract",
   "Set",
   "Lean.Omega.Int.add_congr",
   "Function.comp",
   "Lean.Omega.Constraint.isImpossible",
   "OfNat.ofNat",
   "Int.sub_nonneg_of_le",
   "CellularAutomatas.Advice.f",
   "LT.lt",
   "HAdd.hAdd",
   "List.range",
   "Lean.Omega.LinearCombo.coordinate_eval_1",
   "Lean.Omega.LinearCombo.sub_eval",
   "Lean.Omega.Int.ofNat_lt_of_lt",
   "LE.le",
   "Int.natCast_add",
   "CellularAutomatas.CA_rt",
   "Lean.Omega.LinearCombo.eval",
   "CellularAutomatas.tCellAutomaton.F_pos"],
  "name": "CellularAutomatas.CA_rt_to_TwoStage_eq._proof_1_4",
  "constType":
  "∀ {α : Type} [CellularAutomatas.Alphabet α] (C : ↑(CellularAutomatas.CA_rt α)) (w : CellularAutomatas.Word α),\n  ∀ i < List.length w, ¬i + 1 ≤ List.length w → False",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "Eq.mp",
   "id",
   "List.map_eq_nil_iff._simp_1",
   "List.map",
   "Ne",
   "congrArg"],
  "name": "List.head_map._proof_1",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {f : α → β} {l : List α}, List.map f l ≠ [] → l ≠ []",
  "constCategory": "Theorem"},
 {"references": ["Lean.Omega.IntList.sub_eq_add_neg", "Lean.Omega.Coeffs"],
  "name": "Lean.Omega.Coeffs.sub_eq_add_neg",
  "constType": "∀ (xs ys : Omega.Coeffs), xs - ys = xs + -ys",
  "constCategory": "Theorem"},
 {"references": ["Not", "Decidable.casesOn"],
  "name": "dite",
  "constType":
  "{α : Sort u} → (c : Prop) → [h : Decidable c] → (c → α) → (¬c → α) → α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Fin.isLt",
  "constType": "∀ {n : ℕ} (self : Fin n), ↑self < n",
  "constCategory": "Theorem"},
 {"references":
  ["absurd", "Not", "rfl", "ite", "_private.Init.Core.0.if_pos.match_1_1"],
  "name": "if_pos",
  "constType":
  "∀ {c : Prop} {h : Decidable c}, c → ∀ {α : Sort u} {t e : α}, (if c then t else e) = t",
  "constCategory": "Theorem"},
 {"references": ["outParam"],
  "name": "Trans.trans",
  "constType":
  "{α : Sort u_1} →\n  {β : Sort u_2} →\n    {γ : Sort u_3} →\n      {r : α → β → Sort u} →\n        {s : β → γ → Sort v} →\n          {t : outParam (α → γ → Sort w)} → [self : Trans r s t] → {a : α} → {b : β} → {c : γ} → r a b → s b c → t a c",
  "constCategory": "Definition"},
 {"references": ["SetLike.coe", "SetLike.coe_injective'", "Set"],
  "name": "SetLike.coe_injective",
  "constType":
  "∀ {A : Type u_1} {B : Type u_2} [i : SetLike A B], Function.Injective SetLike.coe",
  "constCategory": "Theorem"},
 {"references": ["List.casesOn"],
  "name": "_private.Init.Data.List.TakeDrop.0.List.take_left.match_1_1",
  "constType":
  "∀ {α : Type u_1} (motive : List α → List α → Prop) (x x_1 : List α),\n  (∀ (x : List α), motive [] x) → (∀ (a : α) (tail x : List α), motive (a :: tail) x) → motive x x_1",
  "constCategory": "Definition"},
 {"references": ["Int.casesOn"],
  "name": "Int.ctorIdx",
  "constType": "ℤ → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "CellularAutomatas.Word",
   "CellularAutomatas.LCellAutomaton.embed_word",
   "CellularAutomatas.CellAutomaton.Q"],
  "name": "CellularAutomatas.LCellAutomaton.embed_word.eq_1",
  "constType":
  "∀ {α : Type} (C : CellularAutomatas.LCellAutomaton α) (w : CellularAutomatas.Word α) (p : ℤ),\n  C.embed_word w p = if h : p ∈ w.range then C.embed (w.get' p h) else C.border",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.succ_le_succ",
   "Nat.le_succ_of_le",
   "LE.le",
   "_private.Init.Data.List.Sublist.0.List.Sublist.length_le.match_1_4",
   "List.Sublist.brecOn",
   "Nat.le_refl",
   "OfNat.ofNat",
   "Unit",
   "List.length"],
  "name": "List.Sublist.length_le",
  "constType":
  "∀ {α : Type u_1} {l₁ l₂ : List α}, l₁.Sublist l₂ → l₁.length ≤ l₂.length",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CellularAutomatas.TwoStageAdvice.M",
  "constType":
  "{α Γ : Type} →\n  [inst : CellularAutomatas.Alphabet α] →\n    [inst_1 : CellularAutomatas.Alphabet Γ] →\n      (self : CellularAutomatas.TwoStageAdvice α Γ) → CellularAutomatas.FiniteStateTransducer self.β Γ",
  "constCategory": "Definition"},
 {"references":
  ["HAdd.hAdd",
   "LT.lt",
   "List.getElem_cons_drop",
   "List.drop",
   "Eq.symm",
   "GetElem.getElem",
   "OfNat.ofNat",
   "List.length"],
  "name": "List.drop_eq_getElem_cons",
  "constType":
  "∀ {α : Type u_1} {i : ℕ} {l : List α} (h : i < l.length), l⟦i..*⟧ = l[i] :: l⟦i + 1..*⟧",
  "constCategory": "Theorem"},
 {"references": ["trivial"],
  "name": "Set.mem_univ",
  "constType": "∀ {α : Type u} (x : α), x ∈ Set.univ",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "Eq.trans",
   "Lean.Grind.Order.of_nat_eq",
   "HMul.hMul",
   "eagerReduce",
   "eq_true",
   "ite_cond_eq_true",
   "IntCast.intCast",
   "List.getLast?_append",
   "List.getLast?",
   "Nat.ToInt.natCast_ofNat",
   "Lean.Grind.Order.le_of_offset_eq_2_k",
   "Lean.Grind.Order.int_lt",
   "GetElem?.getElem?",
   "False.elim",
   "NatCast.natCast",
   "Lean.Grind.eq_false_of_imp_eq_true",
   "HSub.hSub",
   "Eq.symm",
   "forall_prop_domain_congr",
   "Lean.Grind.forall_propagator",
   "HAppend.hAppend",
   "of_eq_false",
   "List.drop",
   "getElem?_pos",
   "Neg.neg",
   "Lean.Grind.Order.le_of_eq_2_k",
   "Lean.Grind.Order.le_of_offset_eq_1_k",
   "List.take_add",
   "Lean.Grind.nestedProof",
   "eq_false",
   "CellularAutomatas.PrefixStableProof.getLastOfTake._proof_1_17",
   "id",
   "Lean.Grind.Order.le_trans_k",
   "Lean.Grind.Order.eq_trans_false'",
   "Lean.Grind.Order.eq_trans_true",
   "getElem?_neg",
   "List.length",
   "Int.Linear.norm_le",
   "Eq.substr",
   "Option.some_or",
   "Int.Linear.natCast_sub",
   "Eq.mp",
   "noConfusion_of_Nat",
   "GetElem.getElem",
   "Nat.Linear.ExprCnstr.eq_of_toNormPoly_eq",
   "Lean.Grind.Order.le_of_eq_1_k",
   "List.length_take",
   "Int.Linear.Expr.eq_of_norm_eq",
   "min_def",
   "congrArg",
   "Option.or",
   "Lean.Grind.Nat.lt_eq",
   "Nat.not_le_eq",
   "Lean.Grind.nestedDecidable",
   "CellularAutomatas.PrefixStableProof.getLastOfTake._proof_1_3",
   "congr",
   "Lean.Grind.Order.eq_of_le_of_le_0",
   "List.getLast?_eq_getElem?",
   "Lean.Grind.Order.lt_of_not_le_k",
   "Not",
   "ite",
   "Lean.Grind.Order.eq_trans_true'",
   "Lean.Grind.Order.le_eq_true_of_le_k",
   "Nat.ToInt.add_congr",
   "Lean.Grind.Order.eq_mp_not",
   "OfNat.ofNat",
   "ite_congr",
   "LT.lt",
   "HAdd.hAdd",
   "Nat.ToInt.le_eq",
   "of_eq_true",
   "Min.min",
   "Lean.Grind.CommRing.Expr.eq_of_toPoly_eq",
   "List.take",
   "LE.le",
   "Lean.Grind.Order.nat_eq",
   "CellularAutomatas.PrefixStableProof.getLastOfTake._proof_1_5",
   "Lean.Grind.Semiring.natCast",
   "Lean.Grind.CommRing.le_norm_expr",
   "Lean.Grind.Semiring.natCast_eq_ofNat",
   "Lean.Grind.Order.eq_mp"],
  "name": "CellularAutomatas.PrefixStableProof.getLastOfTake._proof_1_25",
  "constType":
  "∀ {i : ℕ} {α : Type u_1} {w : List α},\n  i + 1 ≤ w.length →\n    -1 * ↑(List.take 1 w⟦i..*⟧).length + 1 ≤ 0 →\n      -1 * ↑(List.take i w).length + 1 ≤ 0 →\n        (List.take (i + 1) w).length - ((List.take (List.take i w).length w).length + 1) <\n          (List.take (List.take 1 w⟦i..*⟧).length w⟦(List.take i w).length..*⟧).length",
  "constCategory": "Theorem"},
 {"references":
  ["Or.elim",
   "Nat.cast",
   "Eq.trans",
   "le_of_le_of_eq",
   "Lean.Omega.LinearCombo.coordinate_eval_0",
   "GT.gt",
   "Decidable.decide",
   "Nat.lt_or_gt_of_ne",
   "Lean.Omega.Coeffs.ofList",
   "Eq.symm",
   "Lean.Omega.tidy_sat",
   "HSub.hSub",
   "Lean.Omega.LinearCombo.add_eval",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "Int.add_one_le_of_lt",
   "of_decide_eq_true",
   "Not",
   "Neg.neg",
   "Lean.Omega.Constraint.addInequality_sat",
   "Lean.Omega.Int.add_congr",
   "Lean.Omega.Constraint.isImpossible",
   "Lean.Omega.LinearCombo.coordinate",
   "OfNat.ofNat",
   "Int.sub_nonneg_of_le",
   "Lean.Omega.LinearCombo.coordinate_eval_1",
   "LT.lt",
   "HAdd.hAdd",
   "Array.size",
   "Lean.Omega.LinearCombo.sub_eval",
   "Lean.Omega.Int.ofNat_lt_of_lt",
   "Int.natCast_add",
   "id",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.Int.sub_congr",
   "List.length"],
  "name": "_private.Init.Data.List.MapIdx.0.List.length_mapIdx_go._proof_1_6",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} (l : List α) (x : Array β), ¬l.length + (x.size + 1) = l.length + 1 + x.size → False",
  "constCategory": "Theorem"},
 {"references":
  ["Int.Linear.Poly.leadCoeff.match_1", "OfNat.ofNat", "Int.Linear.Var"],
  "name": "Int.Linear.Poly.leadCoeff",
  "constType": "Int.Linear.Poly → ℤ",
  "constCategory": "Definition"},
 {"references":
  ["Nat.Linear.Context",
   "Nat.Linear.Poly.denote",
   "Prod.snd",
   "Prod.fst",
   "Nat.Linear.Poly"],
  "name": "Nat.Linear.Poly.denote_eq",
  "constType": "Nat.Linear.Context → Nat.Linear.Poly ⨉ Nat.Linear.Poly → Prop",
  "constCategory": "Definition"},
 {"references": ["outParam"],
  "name": "HSub.hSub",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → [self : HSub α β γ] → α → β → γ",
  "constCategory": "Definition"},
 {"references":
  ["Eq.mp",
   "Lean.Grind.Order.of_nat_eq",
   "eagerReduce",
   "eq_true",
   "IntCast.intCast",
   "Nat.ToInt.natCast_ofNat",
   "CellularAutomatas.ProdCA.scan_temporal._proof_1_2",
   "List.length_range",
   "NatCast.natCast",
   "Neg.neg",
   "Lean.Grind.Order.eq_trans_true'",
   "Lean.Grind.Order.le_of_eq_2_k",
   "Nat.ToInt.add_congr",
   "Lean.Grind.Order.le_eq_true_of_le_k",
   "OfNat.ofNat",
   "List.range",
   "HAdd.hAdd",
   "Nat.ToInt.le_eq",
   "of_eq_true",
   "LE.le",
   "id",
   "Lean.Grind.Order.le_trans_k",
   "Lean.Grind.Order.eq_trans_true",
   "Lean.Grind.CommRing.le_norm_expr",
   "List.length",
   "Lean.Grind.Order.eq_mp"],
  "name": "CellularAutomatas.ProdCA.scan_temporal._proof_1_3",
  "constType": "∀ {t : ℕ} (t_1 : ℕ), t_1 + 1 ≤ t → t_1 < (List.range t).length",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "Nat.add_sub_cancel_left",
   "Nat.le.dest",
   "Nat.add_succ",
   "LE.le",
   "Eq.symm",
   "id",
   "HSub.hSub",
   "_private.Init.Data.Nat.Basic.0.Nat.succ_sub.match_1_1",
   "Eq.mpr",
   "congrArg"],
  "name": "Nat.succ_sub",
  "constType": "∀ {m n : ℕ}, n ≤ m → m.succ - n = (m - n).succ",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "HAdd.hAdd",
   "Lean.Grind.Nat.lt_eq",
   "Eq.substr",
   "List.drop",
   "List.take",
   "LE.le",
   "HSub.hSub",
   "OfNat.ofNat",
   "List.length"],
  "name": "CellularAutomatas.PrefixStableProof.getLastOfTake._proof_1_10",
  "constType":
  "∀ {i : ℕ} {α : Type u_1} {w : List α},\n  (List.take (List.take 1 w⟦i..*⟧).length w⟦(List.take i w).length..*⟧).length - 1 + 1 ≤\n      (List.take (List.take 1 w⟦i..*⟧).length w⟦(List.take i w).length..*⟧).length →\n    (List.take (List.take 1 w⟦i..*⟧).length w⟦(List.take i w).length..*⟧).length - 1 <\n      (List.take (List.take 1 w⟦i..*⟧).length w⟦(List.take i w).length..*⟧).length",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "HAdd.hAdd",
   "Lean.Grind.Nat.lt_eq",
   "Eq.substr",
   "Fin.val",
   "LE.le",
   "OfNat.ofNat",
   "List.length"],
  "name":
  "CellularAutomatas.FiniteStateTransducer.scanr_reduce_drop._proof_1_2",
  "constType":
  "∀ {α : Type} (w : List α) (i : Fin w.length), ↑i + 1 ≤ w.length → ↑i < w.length",
  "constCategory": "Theorem"},
 {"references": ["Not", "not_and", "propext"],
  "name": "not_and._simp_1",
  "constType": "∀ {a b : Prop}, (¬(a ∧ b)) = (a → ¬b)",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.lt_trans",
   "absurd",
   "LT.lt",
   "Nat.lt_or_ge",
   "LE.le",
   "_private.Init.Data.Nat.Basic.0.Nat.not_le_of_gt.match_1_1",
   "Eq.subst",
   "GT.gt",
   "GE.ge",
   "Nat.le_antisymm",
   "Nat.lt_irrefl"],
  "name": "Nat.not_le_of_gt",
  "constType": "∀ {n m : ℕ}, n > m → ¬n ≤ m",
  "constCategory": "Theorem"},
 {"references":
  ["_private.Lean.Declaration.0.Lean.ConstantInfo.toConstantVal.match_1"],
  "name": "Lean.ConstantInfo.toConstantVal",
  "constType": "ConstantInfo → ConstantVal",
  "constCategory": "Definition"},
 {"references":
  ["CellularAutomatas.Word",
   "CellularAutomatas.tCellAutomaton.t",
   "Set.Mem",
   "Membership.mem",
   "Language",
   "CellularAutomatas.LCellAutomaton.comp",
   "CellularAutomatas.tCellAutomaton.toLCellAutomaton",
   "OfNat.ofNat",
   "id",
   "inferInstance",
   "CellularAutomatas.tCellAutomaton.L",
   "CellularAutomatas.tCellAutomaton.F_pos",
   "List.length"],
  "name": "CellularAutomatas.instDecidableMemWordLanguageL",
  "constType":
  "{α : Type} → (C : CellularAutomatas.tCellAutomaton α) → (w : CellularAutomatas.Word α) → Decidable (w ∈ C.L)",
  "constCategory": "Definition"},
 {"references": ["AddZeroClass.add_zero"],
  "name": "add_zero",
  "constType": "∀ {M : Type u} [inst : AddZeroClass M] (a : M), a + 0 = a",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "CellularAutomatas.CArtTransducer.toLCellAutomaton",
   "CellularAutomatas.CellAutomaton.Q"],
  "name": "CellularAutomatas.composition.Params.recOn",
  "constType":
  "{motive : CellularAutomatas.composition.Params → Sort u} →\n  (t : CellularAutomatas.composition.Params) →\n    ((α β : Type) →\n        [_inst_α : CellularAutomatas.Alphabet α] →\n          [_inst_β : CellularAutomatas.Alphabet β] →\n            (C : CellularAutomatas.LCellAutomaton β) →\n              (C_adv : CellularAutomatas.CArtTransducer α β) →\n                (f : C_adv.Q → Option C.Q) →\n                  motive { α := α, β := β, _inst_α := _inst_α, _inst_β := _inst_β, C := C, C_adv := C_adv, f := f }) →\n      motive t",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Int.NonNeg.casesOn",
  "constType":
  "∀ {motive : (a : ℤ) → a.NonNeg → Prop} {a : ℤ} (t : a.NonNeg), (∀ (n : ℕ), motive (Int.ofNat n) ⋯) → motive a t",
  "constCategory": "Definition"},
 {"references": ["Not"],
  "name": "absurd",
  "constType": "{a : Prop} → {b : Sort v} → a → ¬a → b",
  "constCategory": "Definition"},
 {"references":
  ["Ordering.ctorIdx", "Ne", "Nat.ne_of_beq_eq_false", "OfNat.ofNat"],
  "name": "_private.Lean.Data.Name.0.Lean.Name.cmp._sparseCasesOn_1",
  "constType":
  "{motive : Ordering → Sort u} → (t : Ordering) → motive Ordering.eq → (t.ctorIdx ≠ 1 → motive t) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["CellularAutomatas.backwards_fsm.Params.noConfusionType",
   "CellularAutomatas.backwards_fsm.Params.casesOn",
   "Eq.ndrec"],
  "name": "CellularAutomatas.backwards_fsm.Params.noConfusion",
  "constType":
  "{P : Sort u} →\n  {x1 x2 : CellularAutomatas.backwards_fsm.Params} →\n    x1 = x2 → CellularAutomatas.backwards_fsm.Params.noConfusionType P x1 x2",
  "constCategory": "Definition"},
 {"references":
  ["HAdd.hAdd",
   "LT.lt",
   "Nat.cast",
   "Eq.mp",
   "Int.add_comm",
   "Int.le.dest",
   "Int.add_left_comm",
   "OfNat.ofNat",
   "congrArg",
   "_private.Init.Data.Int.Order.0.Int.lt.dest.match_1_1"],
  "name": "Int.lt.dest",
  "constType": "∀ {a b : ℤ}, a < b → ∃ n, a + ↑n.succ = b",
  "constCategory": "Theorem"},
 {"references": ["Option.merge.match_1", "Unit"],
  "name": "Option.merge",
  "constType": "{α : Type u_1} → (α → α → α) → Option α → Option α → Option α",
  "constCategory": "Definition"},
 {"references": ["implies_dep_congr_ctx"],
  "name": "implies_congr_ctx",
  "constType":
  "∀ {p₁ p₂ q₁ q₂ : Prop}, p₁ = p₂ → (p₂ → q₁ = q₂) → (p₁ → q₁) = (p₂ → q₂)",
  "constCategory": "Theorem"},
 {"references":
  ["HAppend.hAppend",
   "CellularAutomatas.Word",
   "CellularAutomatas.CArtTransducer.advice",
   "CellularAutomatas.CArtTransducer.toLCellAutomaton",
   "CellularAutomatas.LCellAutomaton.scan_temporal_independence",
   "List.map",
   "CellularAutomatas.CArtTransducer.f",
   "CellularAutomatas.CArtTransducer.advice._proof_3",
   "congrArg",
   "CellularAutomatas.Advice.f",
   "CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "CellularAutomatas.LCellAutomaton.scan_temporal_rt",
   "List.map_take",
   "List.take",
   "Eq.symm",
   "id",
   "CellularAutomatas.CellAutomaton.Q",
   "Eq.mpr",
   "List.length"],
  "name": "CellularAutomatas.CArtTransducer.scan_temporal_independence",
  "constType":
  "∀ {α Γ : Type} [inst : CellularAutomatas.Alphabet α] [inst_1 : CellularAutomatas.Alphabet Γ]\n  (C : CellularAutomatas.CArtTransducer α Γ) (p s : CellularAutomatas.Word α),\n  List.take (List.length p) (C.advice.f (p ++ s)) = C.advice.f p",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.propIntro",
   "Eq.symm",
   "Eq.ndrec",
   "Eq.casesOn",
   "Lean.Grind.CommRing.Poly.num.noConfusion"],
  "name": "Lean.Grind.CommRing.Poly.num.injEq",
  "constType":
  "∀ (k k_1 : ℤ), (Grind.CommRing.Poly.num k = Grind.CommRing.Poly.num k_1) = (k = k_1)",
  "constCategory": "Theorem"},
 {"references":
  ["Int.sub_mul",
   "Lean.Omega.IntList.dot_nil_right",
   "Eq.trans",
   "Eq.mp",
   "Int.zero_add",
   "Int.sub_add_cancel",
   "HMul.hMul",
   "Int.add_zero",
   "Lean.Omega.IntList.get",
   "congrArg",
   "Int.add_right_comm",
   "Int.zero_mul",
   "Lean.Omega.IntList",
   "congr",
   "forall_congr",
   "HSub.hSub",
   "Eq.symm",
   "Lean.Omega.IntList.dot",
   "Eq.ndrec",
   "Int.add_assoc",
   "List.casesOn",
   "Nat.recAux",
   "Lean.Omega.IntList.set",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "Int.mul_zero",
   "eq_self",
   "Lean.Omega.IntList.get_cons_succ",
   "of_eq_true",
   "Int.add_comm",
   "id",
   "Eq.mpr",
   "Lean.Omega.IntList.get_cons_zero",
   "Int.sub_zero"],
  "name": "Lean.Omega.IntList.dot_set_left",
  "constType":
  "∀ (xs ys : Omega.IntList) (i : ℕ) (z : ℤ), (xs.set i z).dot ys = xs.dot ys + (z - xs.get i) * ys.get i",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "GetElem?.getElem?",
   "id",
   "LawfulGetElem.getElem?_def",
   "GetElem.getElem",
   "Eq.mpr",
   "dif_neg",
   "dite",
   "congrArg"],
  "name": "getElem?_neg",
  "constType":
  "∀ {cont : Type u_1} {idx : Type u_2} {elem : Type u_3} {dom : cont → idx → Prop} [inst : GetElem? cont idx elem dom]\n  [LawfulGetElem cont idx elem dom] (c : cont) (i : idx), ¬dom c i → c[i]? = none",
  "constCategory": "Theorem"},
 {"references": ["Lean.Grind.CommRing.Var"],
  "name": "Lean.Grind.CommRing.Expr.casesOn",
  "constType":
  "{motive : Grind.CommRing.Expr → Sort u} →\n  (t : Grind.CommRing.Expr) →\n    ((k : ℤ) → motive (Grind.CommRing.Expr.num k)) →\n      ((k : ℕ) → motive (Grind.CommRing.Expr.natCast k)) →\n        ((k : ℤ) → motive (Grind.CommRing.Expr.intCast k)) →\n          ((i : Grind.CommRing.Var) → motive (Grind.CommRing.Expr.var i)) →\n            ((a : Grind.CommRing.Expr) → motive a.neg) →\n              ((a b : Grind.CommRing.Expr) → motive (a.add b)) →\n                ((a b : Grind.CommRing.Expr) → motive (a.sub b)) →\n                  ((a b : Grind.CommRing.Expr) → motive (a.mul b)) →\n                    ((a : Grind.CommRing.Expr) → (k : ℕ) → motive (a.pow k)) → motive t",
  "constCategory": "Definition"},
 {"references": ["imp_self", "propext"],
  "name": "imp_self._simp_1",
  "constType": "∀ {a : Prop}, (a → a) = True",
  "constCategory": "Theorem"},
 {"references": ["le_of_add_le_add_left", "AddLeftReflectLE"],
  "name": "Contravariant.AddLECancellable",
  "constType":
  "∀ {α : Type u_1} [inst : Add α] [inst_1 : LE α] [AddLeftReflectLE α] {a : α}, AddLECancellable a",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "List.range",
   "HAdd.hAdd",
   "Lean.Grind.Nat.lt_eq",
   "Eq.substr",
   "LE.le",
   "OfNat.ofNat",
   "List.length"],
  "name": "CellularAutomatas.ProdCA.scan_temporal._proof_1_2",
  "constType":
  "∀ {t : ℕ} (t_1 : ℕ), t_1 + 1 ≤ (List.range t).length → t_1 < (List.range t).length",
  "constCategory": "Theorem"},
 {"references":
  ["Int.add_right_neg",
   "HAdd.hAdd",
   "Int.add_assoc",
   "Neg.neg",
   "id",
   "Int.add_zero",
   "Eq.mpr",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Int.add_neg_cancel_right",
  "constType": "∀ (a b : ℤ), a + b + -b = a",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Omega.LinearCombo.coordinate_eval_2",
   "Nat.cast",
   "Eq.trans",
   "le_of_le_of_eq",
   "Lean.Omega.LinearCombo.coordinate_eval_0",
   "Lean.Omega.Constraint.combine_sat'",
   "Decidable.decide",
   "Lean.Omega.Coeffs.ofList",
   "Lean.Omega.tidy_sat",
   "HSub.hSub",
   "Eq.symm",
   "Lean.Omega.LinearCombo.add_eval",
   "Lean.Omega.Int.lt_of_not_le",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "Int.add_one_le_of_lt",
   "of_decide_eq_true",
   "Not",
   "Neg.neg",
   "And.right",
   "Lean.Omega.Constraint.addInequality_sat",
   "Lean.Omega.Int.add_congr",
   "Lean.Omega.Constraint.isImpossible",
   "Lean.Omega.LinearCombo.coordinate",
   "OfNat.ofNat",
   "Int.sub_nonneg_of_le",
   "Lean.Omega.LinearCombo.coordinate_eval_1",
   "HAdd.hAdd",
   "Lean.Omega.LinearCombo.sub_eval",
   "LE.le",
   "Int.natCast_add",
   "id",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.Int.sub_congr"],
  "name": "CellularAutomatas.nextt_congr._proof_1_10",
  "constType":
  "∀ (t : ℕ) (i j : ℤ), i - ↑t ≤ j ∧ j ≤ i + ↑t → ¬j + 1 ≤ i + ↑(t + 1) → False",
  "constCategory": "Theorem"},
 {"references": ["Bool.and", "Bool.and'_eq_and", "Eq.symm", "Bool.and'"],
  "name": "_private.Init.Grind.AC.0.Lean.Grind.AC.Seq.beq'_eq._simp_1_2",
  "constType": "∀ (a b : Bool), (a && b) = a.and' b",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "Not",
   "LE.le",
   "Eq.symm",
   "id",
   "Eq.mpr",
   "Iff.rfl",
   "Int.not_le",
   "Decidable.not_not",
   "propext",
   "congrArg"],
  "name": "Int.not_lt",
  "constType": "∀ {a b : ℤ}, ¬a < b ↔ b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "Lean.Grind.Ring.intCast",
   "Eq.trans",
   "Int.cast",
   "OfNat.ofNat",
   "congrArg",
   "HAdd.hAdd",
   "Lean.Grind.Semiring.add_zero",
   "Std.IsPartialOrder.le_antisymm",
   "LE.le",
   "Lean.Grind.Ring.intCast_zero",
   "id",
   "Eq.mpr"],
  "name": "Lean.Grind.Order.eq_of_le_of_le_0",
  "constType":
  "∀ {α : Type u_1} [inst : LE α] [Std.IsPartialOrder α] [inst_2 : Grind.Ring α] {a b : α}, a ≤ b + ↑0 → b ≤ a + ↑0 → a = b",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "eq_self",
   "dite_cond_eq_true",
   "Eq.trans",
   "of_eq_true",
   "dite",
   "congrArg"],
  "name": "Lean.Grind.dite_cond_eq_true'",
  "constType":
  "∀ {α : Sort u} {c : Prop} {x : Decidable c} {a : c → α} {b : ¬c → α} {r : α} (h₁ : c = True), a ⋯ = r → dite c a b = r",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Lean.Omega.Constraint.lowerBound",
  "constType": "Omega.Constraint → Omega.LowerBound",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Omega.Constraint.upperBound",
   "Eq.trans",
   "Eq.mp",
   "Lean.Omega.Constraint.sat",
   "eq_true",
   "and_true",
   "Decidable.decide",
   "congrArg",
   "Decidable.decide.congr_simp",
   "Lean.Omega.Constraint.casesOn",
   "congr",
   "Lean.Omega.Constraint.lowerBound",
   "decide_eq_true_eq",
   "Lean.Omega.UpperBound.sat",
   "Neg.neg",
   "Lean.Omega.Constraint.neg",
   "Lean.Omega.LowerBound.sat",
   "decide_true",
   "Int.neg_le_neg_iff._simp_1",
   "true_and",
   "Option.casesOn",
   "eq_self",
   "and_self",
   "of_eq_true",
   "LE.le",
   "Lean.Omega.UpperBound",
   "id",
   "Lean.Omega.LowerBound"],
  "name": "Lean.Omega.Constraint.neg_sat",
  "constType":
  "∀ {c : Omega.Constraint} {v : ℤ}, c.sat v = true → c.neg.sat (-v) = true",
  "constCategory": "Theorem"},
 {"references": ["List.below", "List.brecOn.go", "List.casesOn", "List.brecOn"],
  "name": "List.brecOn.eq",
  "constType":
  "∀ {α : Type u} {motive : List α → Sort u_1} (t : List α) (F_1 : (t : List α) → List.below t → motive t),\n  List.brecOn t F_1 = F_1 t (List.brecOn.go t F_1).2",
  "constCategory": "Theorem"},
 {"references": ["Int.Linear.Var"],
  "name": "Int.Linear.Poly.below",
  "constType":
  "{motive : Int.Linear.Poly → Sort u} → Int.Linear.Poly → Sort (max 1 u)",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CommMagma.mul_comm",
  "constType": "∀ {G : Type u} [self : CommMagma G] (a b : G), a * b = b * a",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CellularAutomatas.Word",
  "constType": "Type u → Type u",
  "constCategory": "Definition"},
 {"references": ["Lean.Name.mkStr1", "Lean.Name.mkStr3", "OfNat.ofNat"],
  "name": "CellularAutomatas.FiniteStateTransducer.«term_⊚_»",
  "constType": "TrailingParserDescr",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Omega.Coeffs.dot_smul_left",
   "Lean.Omega.Constraint.sat",
   "Lean.Omega.Coeffs",
   "HMul.hMul",
   "Prod.fst",
   "congrArg",
   "Lean.Omega.IntList",
   "Lean.Omega.positivizeConstraint",
   "congr",
   "Lean.Omega.positivizeCoeffs",
   "Eq.symm",
   "Lean.Omega.Coeffs.smul",
   "Lean.Omega.Coeffs.leading",
   "Lean.Omega.Constraint.neg_sat",
   "Not",
   "Int.neg_eq_neg_one_mul",
   "Lean.Omega.Constraint.neg",
   "ite",
   "Neg.neg",
   "Option.getD",
   "Decidable.casesOn",
   "Prod.snd",
   "OfNat.ofNat",
   "if_neg",
   "LE.le",
   "id",
   "Eq.mpr",
   "Lean.Omega.Coeffs.dot",
   "if_pos",
   "Lean.Omega.Constraint.sat'"],
  "name": "Lean.Omega.positivize_sat",
  "constType":
  "∀ {s : Omega.Constraint} {x v : Omega.Coeffs},\n  s.sat' x v = true → (Omega.positivizeConstraint s x).sat' (Omega.positivizeCoeffs s x) v = true",
  "constCategory": "Theorem"},
 {"references": ["Or.casesOn", "LT.lt"],
  "name": "_private.Init.Data.Nat.Basic.0.Nat.lt_or_gt_of_ne.match_1_1",
  "constType":
  "∀ {a b : ℕ} (motive : a < b ∨ a = b ∨ b < a → Prop) (x : a < b ∨ a = b ∨ b < a),\n  (∀ (h : a < b), motive ⋯) → (∀ (e : a = b), motive ⋯) → (∀ (h : b < a), motive ⋯) → motive x",
  "constCategory": "Definition"},
 {"references": ["SubtractionMonoid.neg_add_rev"],
  "name": "neg_add_rev",
  "constType":
  "∀ {G : Type u_1} [inst : SubtractionMonoid G] (a b : G), -(a + b) = -b + -a",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "rfl",
   "False.elim",
   "_private.Init.Core.0.decide_true.match_1_1",
   "Decidable.decide"],
  "name": "decide_true",
  "constType": "∀ (h : Decidable True), decide True = true",
  "constCategory": "Theorem"},
 {"references": ["Nat.pos_of_neZero", "Nat.mod_lt"],
  "name": "Fin.ofNat._proof_1",
  "constType": "∀ (n : ℕ) [NeZero n] (a : ℕ), a % n < n",
  "constCategory": "Theorem"},
 {"references": ["Quotient"],
  "name": "Cardinal",
  "constType": "Type (u + 1)",
  "constCategory": "Definition"},
 {"references": ["Quotient"],
  "name": "Multiset",
  "constType": "Type u → Type u",
  "constCategory": "Definition"},
 {"references":
  ["Not",
   "Nat.not_lt_zero._simp_1",
   "List.toArray",
   "Eq.trans",
   "GetElem.getElem",
   "congrArg",
   "LT.lt",
   "List.mapIdx.go",
   "eq_self",
   "GetElem?.getElem?",
   "Array.size",
   "of_eq_true",
   "List.getElem?_mapIdx_go",
   "HSub.hSub",
   "Option.map",
   "dite_cond_eq_false",
   "dite",
   "List.size_toArray",
   "List.length"],
  "name": "List.getElem?_mapIdx",
  "constType":
  "∀ {α : Type u_1} {α_1 : Type u_2} {f : ℕ → α → α_1} {l : List α} {i : ℕ}, (List.mapIdx f l)[i]? = Option.map (f i) l[i]?",
  "constCategory": "Theorem"},
 {"references":
  ["implies_true",
   "eq_self",
   "Eq.trans",
   "of_eq_true",
   "Lean.Grind.AC.Seq.denote",
   "implies_congr_ctx",
   "congrArg"],
  "name": "Lean.Grind.AC.eq_simp_rhs_exact",
  "constType":
  "∀ {α : Sort u_1} (ctx : Grind.AC.Context α) (lhs₁ rhs₁ lhs₂ : Grind.AC.Seq),\n  Grind.AC.Seq.denote ctx lhs₁ = Grind.AC.Seq.denote ctx rhs₁ →\n    Grind.AC.Seq.denote ctx lhs₂ = Grind.AC.Seq.denote ctx lhs₁ →\n      Grind.AC.Seq.denote ctx lhs₂ = Grind.AC.Seq.denote ctx rhs₁",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.mpr",
   "_private.Init.PropLemmas.0.exists_prop_congr.match_1_3",
   "Iff.mp",
   "_private.Init.PropLemmas.0.exists_prop_congr.match_1_1"],
  "name": "exists_prop_congr",
  "constType":
  "∀ {p p' : Prop} {q q' : p → Prop}, (∀ (h : p), q h ↔ q' h) → ∀ (hp : p ↔ p'), Exists q ↔ ∃ (h : p'), q' ⋯",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Sigma.casesOn",
  "constType":
  "{α : Type u} →\n  {β : α → Type v} →\n    {motive : Sigma β → Sort u_1} → (t : Sigma β) → ((fst : α) → (snd : β fst) → motive ⟨fst, snd⟩) → motive t",
  "constCategory": "Definition"},
 {"references": ["DecidableEq", "id", "CellularAutomatas.Alphabet.noConfusion"],
  "name": "CellularAutomatas.Alphabet.mk.noConfusion",
  "constType":
  "{α : Type} →\n  (P : Sort u) →\n    [dec : DecidableEq α] →\n      [fin : Fintype α] →\n        [inh : Inhabited α] →\n          (dec' : DecidableEq α) →\n            (fin' : Fintype α) →\n              (inh' : Inhabited α) →\n                { dec := dec, fin := fin, inh := inh } = { dec := dec', fin := fin', inh := inh' } →\n                  (dec = dec' → fin = fin' → inh = inh' → P) → P",
  "constCategory": "Definition"},
 {"references":
  ["Eq.propIntro",
   "CellularAutomatas.Word",
   "Eq.symm",
   "CellularAutomatas.Advice.mk.noConfusion",
   "Eq.ndrec",
   "Eq.casesOn",
   "List.length"],
  "name": "CellularAutomatas.Advice.mk.injEq",
  "constType":
  "∀ {α Γ : Type} (f : CellularAutomatas.Word α → CellularAutomatas.Word Γ)\n  (len : ∀ (w : CellularAutomatas.Word α), List.length (f w) = List.length w)\n  (f_1 : CellularAutomatas.Word α → CellularAutomatas.Word Γ)\n  (len_1 : ∀ (w : CellularAutomatas.Word α), List.length (f_1 w) = List.length w),\n  ({ f := f, len := len } = { f := f_1, len := len_1 }) = (f = f_1)",
  "constCategory": "Theorem"},
 {"references": ["Std.TreeSet.inner", "Std.TreeMap.contains", "Unit"],
  "name": "Std.TreeSet.contains",
  "constType":
  "{α : Type u} → {cmp : α → α → Ordering} → TreeSet α cmp → α → Bool",
  "constCategory": "Definition"},
 {"references":
  ["_private.Init.SimpLemmas.0.and_assoc.match_1_1",
   "_private.Init.SimpLemmas.0.and_assoc.match_1_3"],
  "name": "and_assoc",
  "constType": "∀ {a b c : Prop}, (a ∧ b) ∧ c ↔ a ∧ b ∧ c",
  "constCategory": "Theorem"},
 {"references":
  ["id",
   "CellularAutomatas.FiniteStateTransducer.Q",
   "CellularAutomatas.FiniteStateTransducer.q0",
   "CellularAutomatas.FiniteStateTransducer.δ"],
  "name": "CellularAutomatas.FiniteStateTransducer.M_projQ",
  "constType":
  "{α β : Type} → (M : CellularAutomatas.FiniteStateTransducer α β) → CellularAutomatas.FiniteStateTransducer α M.Q",
  "constCategory": "Definition"},
 {"references":
  ["Nat.cast",
   "Dvd.dvd",
   "dvd_rfl",
   "outParam",
   "Iff.mpr",
   "CharP.cast_eq_zero_iff",
   "OfNat.ofNat"],
  "name": "CharP.cast_eq_zero",
  "constType":
  "∀ (R : Type u_1) [inst : AddMonoidWithOne R] (p : ℕ) [CharP R p], ↑p = 0",
  "constCategory": "Theorem"},
 {"references": ["LT.lt", "Nat.lt_min", "Min.min", "propext"],
  "name": "_private.Init.Data.List.Nat.Range.0.List.take_range._simp_1_1",
  "constType": "∀ {a b c : ℕ}, (a < min b c) = (a < b ∧ a < c)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Quot.sound",
  "constType":
  "∀ {α : Sort u} {r : α → α → Prop} {a b : α}, r a b → Quot.mk r a = Quot.mk r b",
  "constCategory": "Axiom"},
 {"references": ["Or.casesOn"],
  "name": "_private.Init.Classical.0.Classical.em.match_1_1",
  "constType":
  "∀ (p u v : Prop),\n  let U := fun x => x = True ∨ p;\n  let V := fun x => x = False ∨ p;\n  ∀ (motive : U u → V v → Prop) (u_def : U u) (v_def : V v),\n    (∀ (h : p) (x : V v), motive ⋯ x) →\n      (∀ (x : U u) (h : p), motive x ⋯) → (∀ (hut : u = True) (hvf : v = False), motive ⋯ ⋯) → motive u_def v_def",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Multiset.ofList",
   "Multiset",
   "propext",
   "Multiset.mem_coe"],
  "name": "Multiset.mem_coe._simp_1",
  "constType": "∀ {α : Type u_1} {a : α} {l : List α}, (a ∈ ↑l) = (a ∈ l)",
  "constCategory": "Theorem"},
 {"references": ["CellularAutomatas.FiniteStateTransducer.M_prod"],
  "name": "CellularAutomatas.FiniteStateTransducer.M_prod.eq_1",
  "constType":
  "∀ {α β1 β2 : Type} [inst : CellularAutomatas.Alphabet α] (M1 : CellularAutomatas.FiniteStateTransducer α β1)\n  (M2 : CellularAutomatas.FiniteStateTransducer α β2),\n  M1.M_prod M2 =\n    { Q := M1.Q ⨉ M2.Q, alphabetQ := CellularAutomatas.ProductAlphabet,\n      δ := fun x a =>\n        match x with\n        | (m_q, c_q) => (M1.δ m_q a, M2.δ c_q a),\n      q0 := (M1.q0, M2.q0),\n      f := fun x =>\n        match x with\n        | (m_q, c_q) => (M1.f m_q, M2.f c_q) }",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.casesOn", "Int.casesOn", "Unit.unit", "OfNat.ofNat", "Unit"],
  "name": "_private.Init.Data.Int.Order.0.Int.natAbs_neg.match_1_1",
  "constType":
  "∀ (motive : ℤ → Prop) (x : ℤ),\n  (∀ (a : Unit), motive 0) → (∀ (n : ℕ), motive (Int.ofNat n.succ)) → (∀ (a : ℕ), motive (Int.negSucc a)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Int.Linear.Poly.brecOn",
   "Int.Linear.Poly.denote.match_1",
   "Int.Linear.Poly.addConst",
   "Int.Linear.Var",
   "Int.Linear.Poly.below"],
  "name": "Int.Linear.Poly.append",
  "constType": "Int.Linear.Poly → Int.Linear.Poly → Int.Linear.Poly",
  "constCategory": "Definition"},
 {"references":
  ["rfl",
   "Nat.zero_le",
   "Nat.brecOn",
   "OfNat.ofNat",
   "LT.lt",
   "Nat.succ_le_succ",
   "absurd",
   "HAdd.hAdd",
   "Nat.not_succ_le_zero",
   "Nat.le_of_succ_le_succ",
   "LE.le",
   "Nat.below",
   "Nat.eq_or_lt_of_le.match_3",
   "Nat.eq_or_lt_of_le.match_1"],
  "name": "Nat.eq_or_lt_of_le",
  "constType": "∀ {n m : ℕ}, n ≤ m → n = m ∨ n < m",
  "constCategory": "Definition"},
 {"references": ["rfl", "Neg.neg", "OfNat.ofNat"],
  "name": "Int.neg_zero",
  "constType": "-0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["List.range",
   "List.filter",
   "LE.le",
   "List.max?",
   "List.map",
   "HMul.hMul",
   "HPow.hPow",
   "Decidable.decide",
   "OfNat.ofNat"],
  "name": "CellularAutomatas.exp_middle_idx",
  "constType": "ℕ → Option ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Name.hasMacroScopes.match_1",
   "Lean.Name.brecOn",
   "BEq.beq",
   "Lean.Name.below"],
  "name": "Lean.Name.hasMacroScopes",
  "constType": "Name → Bool",
  "constCategory": "Definition"},
 {"references": ["id", "CellularAutomatas.VerificationError.noConfusion"],
  "name": "CellularAutomatas.VerificationError.mk.noConfusion",
  "constType":
  "(P : Sort u) →\n  (module : Name) →\n    (message : String) →\n      (details : List String) →\n        (module' : Name) →\n          (message' : String) →\n            (details' : List String) →\n              { module := module, message := message, details := details } =\n                  { module := module', message := message', details := details' } →\n                (module = module' → message = message' → details = details' → P) → P",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Lean.MonadRef.getRef",
  "constType": "{m : Type → Type} → [self : MonadRef m] → m Syntax",
  "constCategory": "Definition"},
 {"references": ["rfl"],
  "name": "Eq.symm",
  "constType": "∀ {α : Sort u} {a b : α}, a = b → b = a",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Grind.AC.Expr.toSeq'.match_1",
   "_private.Init.Grind.AC.0.Lean.Grind.AC.Expr.toSeq'.match_1.congr_eq_2",
   "congrArg",
   "Lean.Grind.AC.Var",
   "_private.Init.Grind.AC.0.Lean.Grind.AC.Expr.toSeq'.match_1.congr_eq_1",
   "Lean.Grind.AC.Expr.brecOn",
   "_private.Init.Grind.AC.0.Lean.Grind.AC.Expr.toSeq'.match_1.splitter",
   "eq_of_heq",
   "id",
   "Lean.Grind.AC.Expr.below",
   "Lean.Grind.AC.Expr.toSeq'",
   "Eq.mpr",
   "Lean.Grind.AC.Expr.toSeq",
   "Lean.Grind.AC.Expr.toSeq.eq_def"],
  "name": "Lean.Grind.AC.Expr.toSeq.induct_unfolding",
  "constType":
  "∀ (motive : Grind.AC.Expr → Grind.AC.Seq → Prop),\n  (∀ (x : Grind.AC.Var), motive (Grind.AC.Expr.var x) (Grind.AC.Seq.var x)) →\n    (∀ (a b : Grind.AC.Expr), motive b b.toSeq → motive (a.op b) (a.toSeq' b.toSeq)) →\n      ∀ (e : Grind.AC.Expr), motive e e.toSeq",
  "constCategory": "Theorem"},
 {"references":
  ["Or.elim",
   "Nat.cast",
   "Eq.trans",
   "le_of_le_of_eq",
   "Classical.propDecidable",
   "Int.negSucc_eq",
   "Lean.Omega.LinearCombo.coordinate_eval_0",
   "Lean.Omega.Constraint.combine_sat'",
   "Decidable.decide",
   "Lean.Omega.Int.ofNat_le_of_le",
   "Lean.Omega.LinearCombo.neg_eval",
   "Lean.Omega.Coeffs.ofList",
   "Eq.symm",
   "Lean.Omega.tidy_sat",
   "HSub.hSub",
   "Lean.Omega.LinearCombo.add_eval",
   "Int.add_one_le_of_lt",
   "Lean.Omega.Int.neg_congr",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "And.left",
   "of_decide_eq_true",
   "Not",
   "Neg.neg",
   "And.right",
   "Lean.Omega.Constraint.addInequality_sat",
   "Lean.Omega.Int.add_congr",
   "Lean.Omega.Constraint.isImpossible",
   "Lean.Omega.Int.le_of_not_lt",
   "Lean.Omega.LinearCombo.coordinate",
   "OfNat.ofNat",
   "Int.sub_nonneg_of_le",
   "Lean.Omega.LinearCombo.coordinate_eval_1",
   "HAdd.hAdd",
   "LT.lt",
   "Nat.le_of_not_lt",
   "Lean.Omega.Int.ofNat_lt_of_lt",
   "Lean.Omega.LinearCombo.sub_eval",
   "id",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.Int.sub_congr",
   "Lean.Omega.Decidable.and_not_or_not_and_of_not_iff"],
  "name": "_private.Init.Data.Int.LemmasAux.0.Int.blt'_eq_true._proof_1_4",
  "constType":
  "∀ (a a_1 : ℕ), ¬(a_1 < a ↔ Int.negSucc a < Int.negSucc a_1) → False",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Nat.Linear.ExprCnstr.lhs",
  "constType": "Nat.Linear.ExprCnstr → Nat.Linear.Expr",
  "constCategory": "Definition"},
 {"references":
  ["Int.Linear.Poly.brecOn.eq",
   "Int.Linear.Poly.denote",
   "Int.Linear.Poly.denote.match_1",
   "HMul.hMul",
   "congrArg",
   "HAdd.hAdd",
   "Int.Linear.Var.denote",
   "Int.Linear.Poly.brecOn",
   "Int.Linear.Context",
   "Eq.symm",
   "id",
   "Int.Linear.Poly.brecOn.go",
   "Eq.mpr",
   "_private.Init.Data.Int.Linear.0.Int.Linear.Poly.denote.match_1.splitter",
   "Eq.ndrec",
   "Int.Linear.Var",
   "Int.Linear.Poly.below"],
  "name": "Int.Linear.Poly.denote.eq_def",
  "constType":
  "∀ (ctx : Int.Linear.Context) (p : Int.Linear.Poly),\n  Int.Linear.Poly.denote ctx p =\n    match p with\n    | Int.Linear.Poly.num k => k\n    | Int.Linear.Poly.add k v p => k * Int.Linear.Var.denote ctx v + Int.Linear.Poly.denote ctx p",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "Eq.trans",
   "Eq.mpr_not",
   "Lean.Grind.Order.of_nat_eq",
   "eq_true",
   "HMul.hMul",
   "eagerReduce",
   "ite_cond_eq_true",
   "IntCast.intCast",
   "List.getLast?_append",
   "Nat.ToInt.natCast_ofNat",
   "List.getLast?",
   "Lean.Grind.Order.int_lt",
   "GetElem?.getElem?",
   "Nat.sub_sub",
   "False.elim",
   "NatCast.natCast",
   "Lean.Grind.eq_false_of_imp_eq_true",
   "Eq.symm",
   "HSub.hSub",
   "forall_prop_domain_congr",
   "Lean.Grind.forall_propagator",
   "HAppend.hAppend",
   "of_eq_false",
   "List.drop",
   "getElem?_pos",
   "Neg.neg",
   "Lean.Grind.Order.le_of_eq_2_k",
   "Lean.Grind.Order.le_of_offset_eq_1_k",
   "List.take_add",
   "Nat.Linear.Expr.eq_of_toNormPoly_eq",
   "Lean.Grind.nestedProof",
   "List.getElem_append._proof_1",
   "CellularAutomatas.PrefixStableProof.getLastOfTake._proof_1_7",
   "eq_false",
   "Lean.Grind.CommRing.lt_norm_expr",
   "id",
   "Lean.Grind.Order.le_trans_k",
   "Lean.Grind.Order.eq_trans_false'",
   "Lean.Grind.Order.lt_eq_true_of_le_k",
   "Lean.Grind.Order.eq_trans_true",
   "getElem?_neg",
   "List.length",
   "Int.Linear.norm_le",
   "Eq.substr",
   "Option.some_or",
   "Int.Linear.natCast_sub",
   "Eq.mp",
   "noConfusion_of_Nat",
   "GetElem.getElem",
   "Nat.Linear.ExprCnstr.eq_of_toNormPoly_eq",
   "Int.Linear.Expr.eq_of_norm_eq",
   "congrArg",
   "Option.or",
   "Lean.Grind.Nat.lt_eq",
   "Nat.not_le_eq",
   "Lean.Grind.nestedDecidable",
   "CellularAutomatas.PrefixStableProof.getLastOfTake._proof_1_3",
   "List.getLast?_eq_getElem?",
   "Lean.Grind.Order.lt_of_not_le_k",
   "cast",
   "Not",
   "Nat.ToInt.lt_eq",
   "ite",
   "Lean.Grind.Order.le_eq_true_of_le_k",
   "Nat.ToInt.add_congr",
   "Lean.Grind.Order.eq_mp_not",
   "OfNat.ofNat",
   "ite_congr",
   "HAdd.hAdd",
   "LT.lt",
   "Nat.ToInt.le_eq",
   "of_eq_true",
   "Lean.Grind.CommRing.Expr.eq_of_toPoly_eq",
   "List.take",
   "LE.le",
   "Lean.Grind.Semiring.natCast",
   "CellularAutomatas.PrefixStableProof.getLastOfTake._proof_1_5",
   "Lean.Grind.CommRing.le_norm_expr",
   "Lean.Grind.Semiring.natCast_eq_ofNat"],
  "name": "CellularAutomatas.PrefixStableProof.getLastOfTake._proof_1_20",
  "constType":
  "∀ {i : ℕ} {α : Type u_1} {w : List α},\n  -1 * ↑(List.take 1 w⟦i..*⟧).length + 1 ≤ 0 →\n    ¬(List.take (i + 1) w).length - 1 + 1 ≤ (List.take i w).length →\n      (List.take (i + 1) w).length - ((List.take i w).length + 1) < (List.take 1 w⟦i..*⟧).length",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CellularAutomatas.tCellAutomaton",
  "constType": "Type → Type 1",
  "constCategory": "Other"},
 {"references":
  ["Eq.trans",
   "_private.Init.Data.Nat.Basic.0.Nat.le_sub_of_add_le.match_1_1",
   "Nat.add_comm",
   "congrArg",
   "HAdd.hAdd",
   "eq_self",
   "of_eq_true",
   "Nat.le.dest",
   "congr",
   "LE.le",
   "Nat.sub_eq_of_eq_add",
   "HSub.hSub",
   "Eq.symm",
   "Nat.le.intro",
   "Nat.add_left_comm"],
  "name": "Nat.le_sub_of_add_le",
  "constType": "∀ {a b c : ℕ}, a + b ≤ c → a ≤ c - b",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.trans",
   "inf_le_right._simp_1",
   "Eq.trans",
   "le_inf_iff._simp_1",
   "and_true",
   "true_and",
   "congrArg",
   "le_antisymm_iff",
   "iff_self",
   "of_eq_true",
   "Min.min",
   "congr",
   "LE.le",
   "le_refl._simp_1"],
  "name": "inf_eq_right",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeInf α] {a b : α}, a ⊓ b = b ↔ b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Grind.IntInterval.mem_ci", "LE.le", "Membership.mem", "propext"],
  "name": "Lean.Grind.IntInterval.mem_ci._simp_1",
  "constType": "∀ (lo x : ℤ), (x ∈ Grind.IntInterval.ci lo) = (lo ≤ x)",
  "constCategory": "Theorem"},
 {"references": ["Function.Surjective", "Function.Injective"],
  "name": "Function.Bijective",
  "constType": "{α : Sort u₁} → {β : Sort u₂} → (α → β) → Prop",
  "constCategory": "Definition"},
 {"references":
  ["CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "Eq.propIntro",
   "CellularAutomatas.CArtTransducer.mk.noConfusion",
   "eq_of_heq",
   "Eq.symm",
   "CellularAutomatas.CellAutomaton.Q",
   "Eq.ndrec",
   "Eq.casesOn",
   "HEq.casesOn",
   "And.casesOn"],
  "name": "CellularAutomatas.CArtTransducer.mk.injEq",
  "constType":
  "∀ {α Γ : Type} [inst : CellularAutomatas.Alphabet α] [inst_1 : CellularAutomatas.Alphabet Γ]\n  (toLCellAutomaton : CellularAutomatas.LCellAutomaton α) (f : toLCellAutomaton.Q → Γ)\n  (toLCellAutomaton_1 : CellularAutomatas.LCellAutomaton α) (f_1 : toLCellAutomaton_1.Q → Γ),\n  ({ toLCellAutomaton := toLCellAutomaton, f := f } = { toLCellAutomaton := toLCellAutomaton_1, f := f_1 }) =\n    (toLCellAutomaton = toLCellAutomaton_1 ∧ f ≍ f_1)",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.CArtTransducer.compose_spec",
   "Trans.trans",
   "CellularAutomatas.TwoStageAdvice.advice",
   "CellularAutomatas.backwards_fsm.C'",
   "Eq.trans",
   "CellularAutomatas.backwards_fsm.Params.C",
   "CellularAutomatas.backwards_fsm.Params.inst3",
   "CellularAutomatas.FiniteStateTransducer.Q",
   "CellularAutomatas.TwoStageAdvice.from_transducers",
   "CellularAutomatas.TwoStageAdvice.β",
   "CellularAutomatas.backwards_fsm.spec",
   "CellularAutomatas.TwoStageAdvice.M",
   "CellularAutomatas.backwards_fsm.Params.γ",
   "CellularAutomatas.TwoStageAdvice.from_transducers_eq",
   "congrArg",
   "CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "CellularAutomatas.TwoStageAdvice.C",
   "congr",
   "CellularAutomatas.CellAutomaton.Q",
   "CellularAutomatas.FiniteStateTransducer.advice",
   "Eq.comm",
   "CellularAutomatas.FiniteStateTransducer.compose_spec",
   "CellularAutomatas.backwards_fsm.Params.α",
   "propext",
   "rfl",
   "CellularAutomatas.Word",
   "CellularAutomatas.CArtTransducer.compose",
   "CellularAutomatas.CArtTransducer.advice",
   "CellularAutomatas.CArtTransducer.toLCellAutomaton",
   "CellularAutomatas.FiniteStateTransducer.comp",
   "CellularAutomatas.backwards_fsm.Params.β",
   "CellularAutomatas.backwards_fsm.Params.M",
   "Function.comp",
   "CellularAutomatas.backwards_fsm.Params.inst2",
   "CellularAutomatas.TwoStageAdvice.advice_eq",
   "CellularAutomatas.Advice.f",
   "eq_self",
   "CellularAutomatas.compose_two_stage",
   "of_eq_true",
   "id",
   "Eq.mpr",
   "CellularAutomatas.backwards_fsm.M'"],
  "name": "CellularAutomatas.advice_two_stage_closed_under_composition",
  "constType":
  "∀ {Γ' Γ α : Type} [inst : CellularAutomatas.Alphabet Γ'] [inst_1 : CellularAutomatas.Alphabet Γ]\n  [inst_2 : CellularAutomatas.Alphabet α] (a1 : CellularAutomatas.TwoStageAdvice α Γ')\n  (a2 : CellularAutomatas.TwoStageAdvice Γ' Γ),\n  CellularAutomatas.TwoStageAdvice.advice.f =\n    CellularAutomatas.TwoStageAdvice.advice.f ∘ CellularAutomatas.TwoStageAdvice.advice.f",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Lean.Name.below",
  "constType": "{motive : Name → Sort u} → Name → Sort (max 1 u)",
  "constCategory": "Definition"},
 {"references": ["Nat.casesOn", "OfNat.ofNat"],
  "name": "List.replicate.match_1",
  "constType":
  "{α : Type u_2} →\n  (motive : ℕ → α → Sort u_1) →\n    (x : ℕ) → (x_1 : α) → ((x : α) → motive 0 x) → ((n : ℕ) → (a : α) → motive n.succ a) → motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["rfl",
   "absurd",
   "Not",
   "_private.Init.Prelude.0.decide_eq_false.match_1_1",
   "Decidable.decide"],
  "name": "decide_eq_false",
  "constType": "∀ {p : Prop} [inst : Decidable p], ¬p → decide p = false",
  "constCategory": "Theorem"},
 {"references":
  ["Int.add",
   "Lean.Grind.CommRing.Poly.addConst_k",
   "Int.beq'",
   "Lean.Grind.CommRing.Mon.grevlex_k",
   "OfNat.ofNat",
   "Lean.Grind.CommRing.Poly.concat",
   "Lean.Grind.CommRing.hugeFuel"],
  "name": "Lean.Grind.CommRing.Poly.combine_k",
  "constType":
  "Grind.CommRing.Poly → Grind.CommRing.Poly → Grind.CommRing.Poly",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Lean.OpaqueVal.value",
  "constType": "OpaqueVal → Expr",
  "constCategory": "Definition"},
 {"references": ["eq_true", "trivial"],
  "name": "implies_true",
  "constType": "∀ (α : Sort u), (∀ (a : α), True) = True",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "Eq.trans",
   "eagerReduce",
   "HMul.hMul",
   "eq_true",
   "ite_cond_eq_true",
   "IntCast.intCast",
   "List.getLast?_append",
   "Nat.ToInt.natCast_ofNat",
   "List.getLast?",
   "Lean.Grind.Order.int_lt",
   "GetElem?.getElem?",
   "False.elim",
   "NatCast.natCast",
   "Lean.Grind.eq_false_of_imp_eq_true",
   "HSub.hSub",
   "Eq.symm",
   "forall_prop_domain_congr",
   "Lean.Grind.forall_propagator",
   "HAppend.hAppend",
   "of_eq_false",
   "List.drop",
   "getElem?_pos",
   "Neg.neg",
   "Lean.Grind.Order.le_of_eq_2_k",
   "Lean.Grind.Order.le_of_offset_eq_1_k",
   "List.take_add",
   "Lean.Grind.nestedProof",
   "eq_false",
   "id",
   "Lean.Grind.Order.le_trans_k",
   "Lean.Grind.Order.eq_trans_false'",
   "Lean.Grind.Order.eq_trans_true",
   "getElem?_neg",
   "List.length",
   "Int.Linear.norm_le",
   "Eq.substr",
   "Option.some_or",
   "Int.Linear.natCast_sub",
   "Eq.mp",
   "noConfusion_of_Nat",
   "GetElem.getElem",
   "Nat.Linear.ExprCnstr.eq_of_toNormPoly_eq",
   "Int.Linear.Expr.eq_of_norm_eq",
   "congrArg",
   "Lean.Grind.Nat.lt_eq",
   "Option.or",
   "Nat.not_le_eq",
   "Lean.Grind.nestedDecidable",
   "CellularAutomatas.PrefixStableProof.getLastOfTake._proof_1_3",
   "List.getLast?_eq_getElem?",
   "Lean.Grind.Order.lt_of_not_le_k",
   "Not",
   "ite",
   "CellularAutomatas.PrefixStableProof.getLastOfTake._proof_1_2",
   "Lean.Grind.Order.le_eq_true_of_le_k",
   "Nat.ToInt.add_congr",
   "Lean.Grind.Order.eq_mp_not",
   "OfNat.ofNat",
   "ite_congr",
   "HAdd.hAdd",
   "LT.lt",
   "Nat.ToInt.le_eq",
   "of_eq_true",
   "Lean.Grind.CommRing.Expr.eq_of_toPoly_eq",
   "List.take",
   "LE.le",
   "Lean.Grind.Semiring.natCast",
   "CellularAutomatas.PrefixStableProof.getLastOfTake._proof_1_5",
   "Lean.Grind.CommRing.le_norm_expr",
   "Lean.Grind.Semiring.natCast_eq_ofNat"],
  "name": "CellularAutomatas.PrefixStableProof.getLastOfTake._proof_1_7",
  "constType":
  "∀ {i : ℕ} {α : Type u_1} {w : List α},\n  -1 * ↑(List.take 1 w⟦i..*⟧).length + 1 ≤ 0 → (List.take (i + 1) w).length - 1 < (List.take (i + 1) w).length",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Name.mkStr4",
   "Bind.bind",
   "Lean.SyntaxNodeKind",
   "Lean.Name.mkStr1",
   "ite",
   "Lean.TSyntax.raw",
   "EStateM",
   "String.toRawSubstring'",
   "Lean.Syntax.isOfKind",
   "Lean.MonadQuotation.getCurrMacroScope",
   "Lean.MacroScope",
   "OfNat.ofNat",
   "Lean.MonadRef.mkInfoFromRefPos",
   "Pure.pure",
   "Lean.Syntax.getArg",
   "Lean.addMacroScope",
   "Lean.MonadQuotation.getContext",
   "Lean.MacroM",
   "Lean.Name.mkStr2",
   "MonadExcept.throw",
   "Lean.Syntax.node2"],
  "name":
  "CellularAutomatas.«_aux_CellularAutomatas_defs___macroRules_CellularAutomatas_term_⨉__1»",
  "constType": "Macro",
  "constCategory": "Definition"},
 {"references":
  ["Not",
   "Eq.substr",
   "Eq.trans",
   "getElem?_pos",
   "Eq.mp",
   "eq_true",
   "GetElem.getElem",
   "congrArg",
   "LT.lt",
   "List.ext_getElem?",
   "eq_self",
   "GetElem?.getElem?",
   "Nat.le_of_not_lt",
   "List.getElem?_eq_none",
   "of_eq_true",
   "congr",
   "LE.le",
   "forall_congr",
   "Eq.symm",
   "id",
   "Eq.mpr",
   "dite",
   "forall_prop_domain_congr",
   "List.length"],
  "name": "List.ext_getElem",
  "constType":
  "∀ {α : Type u_1} {l₁ l₂ : List α},\n  l₁.length = l₂.length → (∀ (i : ℕ) (h₁ : i < l₁.length) (h₂ : i < l₂.length), l₁[i] = l₂[i]) → l₁ = l₂",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd", "Nat.rel_of_forall_rel_succ_of_le", "LE.le", "OfNat.ofNat"],
  "name": "monotone_nat_of_le_succ",
  "constType":
  "∀ {α : Type u} [inst : Preorder α] {f : ℕ → α}, (∀ (n : ℕ), f n ≤ f (n + 1)) → Monotone f",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "autoParam",
  "constType": "Sort u → Syntax → Sort u",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CellularAutomatas.tCellAutomatonWithAdvice.adv",
  "constType":
  "{α : Type} → (self : CellularAutomatas.tCellAutomatonWithAdvice α) → CellularAutomatas.Advice α self.Γ",
  "constCategory": "Definition"},
 {"references": ["Setoid.r", "Quot.out"],
  "name": "Quotient.out",
  "constType": "{α : Sort u_1} → {s : Setoid α} → Quotient s → α",
  "constCategory": "Definition"},
 {"references":
  ["CellularAutomatas.tCellAutomaton.p",
   "Set",
   "Membership.mem",
   "CellularAutomatas.tCellAutomatons",
   "setOf"],
  "name": "CellularAutomatas.CAr",
  "constType": "(α : Type) → Set (CellularAutomatas.tCellAutomaton α)",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CellularAutomatas.tCellAutomatonWithAdvice.mk",
  "constType":
  "{α : Type} →\n  (Γ : Type) →\n    [alphabetΓ : CellularAutomatas.Alphabet Γ] →\n      CellularAutomatas.Advice α Γ →\n        CellularAutomatas.tCellAutomaton (α ⨉ Γ) → CellularAutomatas.tCellAutomatonWithAdvice α",
  "constCategory": "Other"},
 {"references": ["Bool.and", "Bool.and'_eq_and", "Eq.symm", "Bool.and'"],
  "name": "_private.Init.Data.Int.Linear.0.Int.Linear.Poly.beq'_eq._simp_1_2",
  "constType": "∀ (a b : Bool), (a && b) = a.and' b",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.propIntro",
   "Int.Linear.Poly.add.noConfusion",
   "Eq.symm",
   "Eq.ndrec",
   "Eq.casesOn",
   "And.casesOn",
   "Int.Linear.Var"],
  "name": "Int.Linear.Poly.add.injEq",
  "constType":
  "∀ (k : ℤ) (v : Int.Linear.Var) (p : Int.Linear.Poly) (k_1 : ℤ) (v_1 : Int.Linear.Var) (p_1 : Int.Linear.Poly),\n  (Int.Linear.Poly.add k v p = Int.Linear.Poly.add k_1 v_1 p_1) = (k = k_1 ∧ v = v_1 ∧ p = p_1)",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.cast",
   "Int.ofNat_le",
   "Iff.rfl",
   "Int.natCast_succ",
   "OfNat.ofNat",
   "congrArg",
   "LT.lt",
   "HAdd.hAdd",
   "LE.le",
   "id",
   "Eq.symm",
   "Eq.mpr",
   "Int.lt_iff_add_one_le",
   "propext"],
  "name": "Int.ofNat_lt",
  "constType": "∀ {n m : ℕ}, ↑n < ↑m ↔ n < m",
  "constCategory": "Theorem"},
 {"references": ["Nat.casesOn", "Unit.unit", "Unit"],
  "name": "_private.Init.Prelude.0.Nat.lt_or_ge.match_1_5",
  "constType":
  "∀ (motive : ℕ → Prop) (m : ℕ), (∀ (a : Unit), motive Nat.zero) → (∀ (m : ℕ), motive m.succ) → motive m",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CellularAutomatas.backwards_fsm.Params.γ",
  "constType": "CellularAutomatas.backwards_fsm.Params → Type",
  "constCategory": "Definition"},
 {"references":
  ["LE.le",
   "Nat.le_of_ble_eq_true",
   "Nat.ble_eq_true_of_le",
   "Nat.ble",
   "propext"],
  "name": "Nat.ble_eq",
  "constType": "∀ {x y : ℕ}, (x.ble y = true) = (x ≤ y)",
  "constCategory": "Theorem"},
 {"references": ["Or.casesOn", "False.elim", "False.casesOn"],
  "name": "_private.Init.SimpLemmas.0.or_false.match_1_1",
  "constType":
  "∀ (p : Prop) (motive : p ∨ False → Prop) (x : p ∨ False), (∀ (h : p), motive ⋯) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["CellularAutomatas.ℒ",
   "CellularAutomatas.CA",
   "sorryAx",
   "Set",
   "CellularAutomatas.CA_lt",
   "Language",
   "OfNat.ofNat",
   "CellularAutomatas.CAr"],
  "name":
  "CellularAutomatas.results_unproven.ca_rt_equals_lt_of_closure_under_reversal",
  "constType":
  "∀ {α : Type} [CellularAutomatas.Alphabet α],\n  CellularAutomatas.ℒ (CellularAutomatas.CA α) = CellularAutomatas.ℒ (CellularAutomatas.CAr α) →\n    CellularAutomatas.ℒ (CellularAutomatas.CA α) = CellularAutomatas.ℒ (CellularAutomatas.CA_lt α)",
  "constCategory": "Theorem"},
 {"references": ["LinearOrder.min_def"],
  "name": "min_def",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrder α] (a b : α), min a b = if a ≤ b then a else b",
  "constCategory": "Theorem"},
 {"references":
  ["Int.le_refl._simp_1",
   "Int.le_antisymm",
   "implies_true",
   "and_self",
   "Eq.trans",
   "of_eq_true",
   "congr",
   "LE.le",
   "implies_congr_ctx",
   "_private.Init.Data.Int.Order.0.Int.eq_iff_le_and_ge.match_1_1",
   "congrArg"],
  "name": "Int.eq_iff_le_and_ge",
  "constType": "∀ {x y : ℤ}, x = y ↔ x ≤ y ∧ y ≤ x",
  "constCategory": "Theorem"},
 {"references": ["List.nil_eq", "propext"],
  "name": "List.nil_eq._simp_1",
  "constType": "∀ {α : Type u_1} {xs : List α}, ([] = xs) = (xs = [])",
  "constCategory": "Theorem"},
 {"references":
  ["List.filter",
   "Eq.trans",
   "Membership.mem",
   "Quot.inductionOn",
   "DecidablePred",
   "Multiset.ofList",
   "Multiset",
   "Decidable.decide",
   "congrArg",
   "Setoid.r",
   "iff_self",
   "of_eq_true",
   "Multiset.filter",
   "congr",
   "Multiset.mem_coe._simp_1",
   "List.mem_filter._simp_1",
   "decide_eq_true_eq"],
  "name": "Multiset.mem_filter",
  "constType":
  "∀ {α : Type u_1} {p : α → Prop} [inst : DecidablePred p] {a : α} {s : Multiset α}, a ∈ Multiset.filter p s ↔ a ∈ s ∧ p a",
  "constCategory": "Theorem"},
 {"references": ["Set", "Membership.mem", "setOf"],
  "name": "CellularAutomatas.tCellAutomatonWithAdvice.with_advice",
  "constType":
  "{α Γ : Type} →\n  [CellularAutomatas.Alphabet Γ] →\n    Set (CellularAutomatas.tCellAutomaton (α ⨉ Γ)) →\n      CellularAutomatas.Advice α Γ → Set (CellularAutomatas.tCellAutomatonWithAdvice α)",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Omega.Constraint.upperBound",
   "Eq.trans",
   "Lean.Omega.Constraint.sat",
   "and_true",
   "Decidable.decide",
   "congrArg",
   "Decidable.decide.congr_simp",
   "_private.Init.Omega.Constraint.0.Lean.Omega.Constraint.combine_sat._simp_1_4",
   "Lean.Omega.Constraint.casesOn",
   "congr",
   "Eq.symm",
   "Lean.Omega.Constraint.lowerBound",
   "propext",
   "decide_eq_true_eq",
   "Lean.Omega.UpperBound.sat",
   "Lean.Omega.LowerBound.sat",
   "decide_true",
   "Iff.rfl",
   "eq_iff_iff._simp_1",
   "true_and",
   "And.comm",
   "Option.casesOn",
   "Lean.Omega.Constraint.combine",
   "eq_self",
   "Max.max",
   "and_self",
   "of_eq_true",
   "_private.Init.Omega.Constraint.0.Lean.Omega.Constraint.combine_sat._simp_1_3",
   "Min.min",
   "and_assoc",
   "LE.le",
   "id",
   "Lean.Omega.UpperBound",
   "Eq.mpr",
   "Lean.Omega.LowerBound"],
  "name": "Lean.Omega.Constraint.combine_sat",
  "constType":
  "∀ (c c' : Omega.Constraint) (t : ℤ), ((c.combine c').sat t = true) = (c.sat t = true ∧ c'.sat t = true)",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.propIntro",
   "eq_of_heq",
   "Eq.symm",
   "CellularAutomatas.TwoStageAdvice.mk.noConfusion",
   "Eq.ndrec",
   "Eq.casesOn",
   "HEq.casesOn",
   "And.casesOn"],
  "name": "CellularAutomatas.TwoStageAdvice.mk.injEq",
  "constType":
  "∀ {α Γ : Type} [inst : CellularAutomatas.Alphabet α] [inst_1 : CellularAutomatas.Alphabet Γ] (β : Type)\n  [alphabetβ : CellularAutomatas.Alphabet β] (C : CellularAutomatas.CArtTransducer α β)\n  (M : CellularAutomatas.FiniteStateTransducer β Γ) (β_1 : Type) (alphabetβ_1 : CellularAutomatas.Alphabet β_1)\n  (C_1 : CellularAutomatas.CArtTransducer α β_1) (M_1 : CellularAutomatas.FiniteStateTransducer β_1 Γ),\n  ({ β := β, alphabetβ := alphabetβ, C := C, M := M } = { β := β_1, alphabetβ := alphabetβ_1, C := C_1, M := M_1 }) =\n    (β = β_1 ∧ alphabetβ ≍ alphabetβ_1 ∧ C ≍ C_1 ∧ M ≍ M_1)",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.below",
   "Lean.Grind.CommRing.Poly.mul",
   "Nat.brecOn",
   "OfNat.ofNat",
   "Unit",
   "Lean.Grind.CommRing.Poly.pow.match_1"],
  "name": "Lean.Grind.CommRing.Poly.pow",
  "constType": "Grind.CommRing.Poly → ℕ → Grind.CommRing.Poly",
  "constCategory": "Definition"},
 {"references":
  ["Multiset.map._proof_1",
   "Setoid.r",
   "Quot.liftOn",
   "List.map",
   "Multiset.ofList",
   "Multiset"],
  "name": "Multiset.map",
  "constType":
  "{α : Type u_1} → {β : Type v} → (α → β) → Multiset α → Multiset β",
  "constCategory": "Definition"},
 {"references": ["Option.some.injEq", "id", "Eq.mpr", "Iff.rfl", "congrArg"],
  "name": "Option.some_inj",
  "constType": "∀ {α : Type u_1} {a b : α}, some a = some b ↔ a = b",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "CellularAutomatas.ℒ",
   "CellularAutomatas.CA",
   "sorryAx",
   "CellularAutomatas.tCellAutomaton.t",
   "Set",
   "Membership.mem",
   "HSub.hSub",
   "CellularAutomatas.CA_rt",
   "Language",
   "OfNat.ofNat",
   "setOf"],
  "name": "CellularAutomatas.results_unproven.const_speed_up",
  "constType":
  "∀ {α : Type} [CellularAutomatas.Alphabet α],\n  CellularAutomatas.ℒ {C | C ∈ CellularAutomatas.CA α ∧ ∃ k, ∀ (n : ℕ), C.t n = n + k - 1} =\n    CellularAutomatas.ℒ (CellularAutomatas.CA_rt α)",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Grind.Ring.zsmul_eq_intCast_mul",
   "Lean.Grind.Semiring.left_distrib",
   "Eq.trans",
   "Lean.Grind.Ring.intCast_one",
   "HMul.hMul",
   "Int.cast",
   "congrArg",
   "congr",
   "Lean.Grind.Ring.intCast_zero",
   "Eq.symm",
   "Lean.Grind.CommRing.Poly.denote",
   "Bool.cond_eq_ite",
   "Lean.Grind.Ring.zsmul",
   "Not",
   "Lean.Grind.Ring.intCast_mul",
   "Lean.Grind.IntModule.mul_zsmul",
   "Lean.Grind.Ring.intCast",
   "ite",
   "Lean.Grind.CommRing.Mon.denote",
   "Lean.Grind.CommRing.Poly.mulConst.go",
   "Decidable.casesOn",
   "Lean.Grind.Semiring.one_mul",
   "cond",
   "OfNat.ofNat",
   "ite_congr",
   "beq_iff_eq._simp_1",
   "Lean.Grind.CommRing.Poly.mulConst.go.induct_unfolding",
   "HAdd.hAdd",
   "eq_self",
   "of_eq_true",
   "if_neg",
   "HSMul.hSMul",
   "id",
   "Eq.mpr",
   "Lean.Grind.Semiring.zero_mul",
   "BEq.beq",
   "Lean.Grind.CommRing.Context",
   "if_pos",
   "Lean.Grind.CommRing.Poly.mulConst"],
  "name": "Lean.Grind.CommRing.Poly.denote_mulConst",
  "constType":
  "∀ {α : Type u_1} [inst : Grind.Ring α] (ctx : Grind.CommRing.Context α) (k : ℤ) (p : Grind.CommRing.Poly),\n  Grind.CommRing.Poly.denote ctx (Grind.CommRing.Poly.mulConst k p) = ↑k * Grind.CommRing.Poly.denote ctx p",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "AddMonoidWithOne.natCast_zero",
  "constType": "∀ {R : Type u_2} [self : AddMonoidWithOne R], ↑0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self", "Eq.trans", "of_eq_true", "Eq.symm", "Eq.ndrec", "congrArg"],
  "name": "Lean.Grind.Order.eq_trans_true'",
  "constType": "∀ {p q : Prop}, p = q → p = True → q = True",
  "constCategory": "Theorem"},
 {"references": ["Lean.Grind.CommRing.Poly.casesOn"],
  "name": "Lean.Grind.CommRing.Poly.ctorIdx",
  "constType": "Grind.CommRing.Poly → ℕ",
  "constCategory": "Definition"},
 {"references": ["HAdd.hAdd", "SizeOf.sizeOf", "OfNat.ofNat"],
  "name": "CellularAutomatas.TwoStageAdvice.mk.sizeOf_spec",
  "constType":
  "∀ {α Γ : Type} [inst : CellularAutomatas.Alphabet α] [inst_1 : CellularAutomatas.Alphabet Γ] [inst_2 : SizeOf α]\n  [inst_3 : SizeOf Γ] (β : Type) [alphabetβ : CellularAutomatas.Alphabet β] (C : CellularAutomatas.CArtTransducer α β)\n  (M : CellularAutomatas.FiniteStateTransducer β Γ),\n  sizeOf { β := β, alphabetβ := alphabetβ, C := C, M := M } = 1 + sizeOf β + sizeOf alphabetβ + sizeOf C + sizeOf M",
  "constCategory": "Theorem"},
 {"references":
  ["rfl",
   "List.getElem?_eq_getElem",
   "Option.some_inj",
   "List.lt_length_left_of_zipWith",
   "GetElem.getElem",
   "congrArg",
   "LT.lt",
   "GetElem?.getElem?",
   "id",
   "Eq.symm",
   "List.zipWith",
   "Eq.mpr",
   "List.getElem?_zipWith_eq_some",
   "propext",
   "List.length",
   "List.lt_length_right_of_zipWith"],
  "name": "List.getElem_zipWith",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} {f : α → β → γ} {l : List α} {l' : List β} {i : ℕ}\n  {h : i < (List.zipWith f l l').length}, (List.zipWith f l l')[i] = f l[i] l'[i]",
  "constCategory": "Theorem"},
 {"references":
  ["rfl",
   "LT.lt",
   "Fin.val",
   "_private.Init.Prelude.0.Fin.eq_of_val_eq.match_1_1"],
  "name": "Fin.eq_of_val_eq",
  "constType": "∀ {n : ℕ} {i j : Fin n}, ↑i = ↑j → i = j",
  "constCategory": "Theorem"},
 {"references": ["List.length_concat", "Array.toList"],
  "name": "Array.size_push",
  "constType":
  "∀ {α : Type u} {xs : Array α} (v : α), (xs.push v).size = xs.size + 1",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.Word",
   "CellularAutomatas.FiniteStateTransducer.scanr_q",
   "CellularAutomatas.FiniteStateTransducer.Q"],
  "name": "CellularAutomatas.FiniteStateTransducer.scanr_q.eq_1",
  "constType":
  "∀ {α β : Type} (M : CellularAutomatas.FiniteStateTransducer α β) (q : M.Q) (w : CellularAutomatas.Word α),\n  M.scanr_q q w = (List.foldr M.scanr_step (q, []) w).2",
  "constCategory": "Theorem"},
 {"references": ["rfl", "eq_true"],
  "name": "eq_self",
  "constType": "∀ {α : Sort u_1} (a : α), (a = a) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Int.neg_le_neg",
   "Eq.mp",
   "Neg.neg",
   "LE.le",
   "Int.neg_zero",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Int.neg_nonneg_of_nonpos",
  "constType": "∀ {a : ℤ}, a ≤ 0 → 0 ≤ -a",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "CellularAutomatas.CellAutomaton.Q"],
  "name": "CellularAutomatas.tCellAutomaton.casesOn",
  "constType":
  "{α : Type} →\n  {motive : CellularAutomatas.tCellAutomaton α → Sort u} →\n    (t : CellularAutomatas.tCellAutomaton α) →\n      ((toLCellAutomaton : CellularAutomatas.LCellAutomaton α) →\n          (t p : ℕ → ℕ) →\n            (F_pos : toLCellAutomaton.Q → Bool) →\n              motive { toLCellAutomaton := toLCellAutomaton, t := t, p := p, F_pos := F_pos }) →\n        motive t",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CellularAutomatas.simulation.Params.rec",
  "constType":
  "{motive : CellularAutomatas.simulation.Params → Sort u} →\n  ((C_inr C_ctl : CellularAutomatas.CellAutomaton) →\n      (f : C_ctl.Q → Option C_inr.Q) → motive { C_inr := C_inr, C_ctl := C_ctl, f := f }) →\n    (t : CellularAutomatas.simulation.Params) → motive t",
  "constCategory": "Other"},
 {"references":
  ["List.getElem?_eq_getElem",
   "List.getElem_mapIdx._proof_1",
   "Option.some_inj",
   "List.length_mapIdx",
   "Eq.mp",
   "Iff.mp",
   "GetElem.getElem",
   "List.getElem?_mapIdx",
   "congrArg",
   "LT.lt",
   "eq_self",
   "GetElem?.getElem?",
   "of_eq_true",
   "List.mapIdx",
   "id",
   "Eq.symm",
   "Option.map",
   "Eq.mpr",
   "List.length"],
  "name": "List.getElem_mapIdx",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {l : List α} {f : ℕ → α → β} {i : ℕ} {h : i < (List.mapIdx f l).length},\n  (List.mapIdx f l)[i] = f i l[i]",
  "constCategory": "Theorem"},
 {"references":
  ["not_lt._simp_1",
   "Nat.cast",
   "Eq.trans",
   "Eq.mp",
   "Membership.mem",
   "GT.gt",
   "congrArg",
   "CellularAutomatas.Word.cone_succ_not._proof_1_2",
   "funext",
   "HSub.hSub",
   "Not",
   "not_and._simp_1",
   "CellularAutomatas.Word",
   "Neg.neg",
   "Set",
   "CellularAutomatas.Word.cone",
   "neg_add_rev",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "LT.lt",
   "Decidable.byContradiction",
   "gt_iff_lt._simp_1",
   "LE.le",
   "id",
   "Eq.mpr",
   "implies_congr_ctx",
   "List.length",
   "setOf"],
  "name": "CellularAutomatas.Word.cone_succ_not",
  "constType":
  "∀ {α : Type u_1} {w : CellularAutomatas.Word α} {t : ℕ} {i : ℤ},\n  List.length w > 0 → i - 1 ∉ w.cone t → i ∉ w.cone t → i + 1 ∉ w.cone t → i ∉ w.cone (t + 1)",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.mkAtom",
   "Lean.Name.mkStr4",
   "Lean.Name.mkStr1",
   "Array.push",
   "String.toRawSubstring",
   "Array.empty"],
  "name": "_auto._@.Std.Data.TreeSet.Basic.2624796985._hygCtx._hyg.15",
  "constType": "Syntax",
  "constCategory": "Definition"},
 {"references":
  ["Int.add",
   "Eq.trans",
   "Eq.mp",
   "Lean.Grind.CommRing.Poly.addConst",
   "_private.Init.Grind.Ring.CommSolver.0.Lean.Grind.CommRing.Poly.insert.go.match_1.splitter",
   "Lean.Grind.CommRing.hugeFuel",
   "congrArg",
   "Lean.Grind.CommRing.Poly.combine.go.eq_def",
   "congr",
   "Lean.Grind.CommRing.Poly.addConst_k",
   "funext",
   "Eq.symm",
   "Int.beq'",
   "Lean.Grind.CommRing.Poly.combine.go.match_1",
   "_private.Init.Grind.Ring.CommSolver.0.Lean.Grind.CommRing.Poly.combine.go.match_1.splitter",
   "Eq.ndrec",
   "Lean.Grind.CommRing.Poly.combine",
   "cond.match_1",
   "Nat.recAux",
   "true_and",
   "cond",
   "Int.beq'_eq_beq",
   "Lean.Grind.CommRing.Mon.grevlex_k",
   "Lean.Grind.CommRing.Poly.combine.go",
   "Lean.Grind.CommRing.Poly.insert.go.match_1",
   "_private.Init.Grind.Ring.CommSolver.0.Lean.Grind.CommRing.Poly.combine_k_eq_combine._simp_1_7",
   "OfNat.ofNat",
   "Unit",
   "_private.Init.Grind.Ring.CommSolver.0.Lean.Grind.CommRing.Poly.combine_k_eq_combine._simp_1_8",
   "HAdd.hAdd",
   "Lean.Grind.CommRing.Poly.combine_k",
   "Lean.Grind.CommRing.Mon.grevlex",
   "eq_self",
   "Lean.Grind.CommRing.Mon.mul.go.match_3",
   "of_eq_true",
   "_private.Init.Grind.Ring.CommSolver.0.cond.match_1.splitter",
   "id",
   "Lean.Grind.CommRing.Poly.add.injEq",
   "Eq.mpr",
   "BEq.beq",
   "Lean.Grind.CommRing.Poly.concat"],
  "name": "Lean.Grind.CommRing.Poly.combine_k_eq_combine",
  "constType":
  "∀ (p₁ p₂ : Grind.CommRing.Poly), p₁.combine_k p₂ = p₁.combine p₂",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Nat.Linear.ExprCnstr.rhs",
  "constType": "Nat.Linear.ExprCnstr → Nat.Linear.Expr",
  "constCategory": "Definition"},
 {"references":
  ["HAdd.hAdd",
   "eq_self",
   "Int.toNat",
   "Max.max",
   "Nat.cast",
   "Eq.trans",
   "of_eq_true",
   "Neg.neg",
   "Int.ofNat_max_zero",
   "OfNat.ofNat",
   "_private.Init.Data.Int.Order.0.Int.ofNat_toNat.match_1_1",
   "congrArg"],
  "name": "Int.ofNat_toNat",
  "constType": "∀ (a : ℤ), ↑a.toNat = max a 0",
  "constCategory": "Theorem"},
 {"references": ["Std.DTreeMap.inner", "Std.DTreeMap.Internal.Impl.keysArray"],
  "name": "Std.DTreeMap.keysArray",
  "constType":
  "{α : Type u} → {β : α → Type v} → {cmp : α → α → Ordering} → DTreeMap α β cmp → Array α",
  "constCategory": "Definition"},
 {"references":
  ["HAdd.hAdd",
   "List.range'.match_1",
   "Nat.below",
   "Nat.brecOn",
   "OfNat.ofNat"],
  "name": "List.range'",
  "constType": "ℕ → ℕ → optParam ℕ 1 → List ℕ",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CellularAutomatas.CArtTransducer.mk",
  "constType":
  "{α Γ : Type} →\n  [inst : CellularAutomatas.Alphabet α] →\n    [inst_1 : CellularAutomatas.Alphabet Γ] →\n      (toLCellAutomaton : CellularAutomatas.LCellAutomaton α) →\n        (toLCellAutomaton.Q → Γ) → CellularAutomatas.CArtTransducer α Γ",
  "constCategory": "Other"},
 {"references":
  ["HAdd.hAdd",
   "eq_self",
   "zero_add",
   "Eq.trans",
   "of_eq_true",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Mathlib.Tactic.Ring.add_pf_zero_add",
  "constType": "∀ {R : Type u_1} [inst : CommSemiring R] (b : R), 0 + b = b",
  "constCategory": "Theorem"},
 {"references": ["CellularAutomatas.CellAutomaton.Q"],
  "name": "CellularAutomatas.uniform_config",
  "constType":
  "{C : CellularAutomatas.CellAutomaton} → C.Q → CellularAutomatas.Config C.Q",
  "constCategory": "Definition"},
 {"references":
  ["implies_congr",
   "Eq.trans",
   "Lean.Grind.Order.of_nat_eq",
   "eagerReduce",
   "eq_true",
   "HMul.hMul",
   "ite_cond_eq_true",
   "IntCast.intCast",
   "List.getLast?_append",
   "Nat.ToInt.natCast_ofNat",
   "List.getLast?",
   "Lean.Grind.Order.int_lt",
   "GetElem?.getElem?",
   "False.elim",
   "NatCast.natCast",
   "Lean.Grind.eq_false_of_imp_eq_true",
   "Eq.symm",
   "HSub.hSub",
   "forall_prop_domain_congr",
   "Lean.Grind.forall_propagator",
   "HAppend.hAppend",
   "of_eq_false",
   "List.drop",
   "getElem?_pos",
   "Neg.neg",
   "Lean.Grind.Order.le_of_eq_2_k",
   "Lean.Grind.Order.le_of_offset_eq_1_k",
   "List.take_add",
   "Lean.Grind.nestedProof",
   "CellularAutomatas.PrefixStableProof.getLastOfTake._proof_1_7",
   "eq_false",
   "Lean.Grind.CommRing.lt_norm_expr",
   "id",
   "Lean.Grind.Order.le_trans_k",
   "Lean.Grind.Order.eq_trans_false'",
   "Lean.Grind.Order.lt_eq_true_of_le_k",
   "Lean.Grind.Order.eq_trans_true",
   "getElem?_neg",
   "List.length",
   "Int.Linear.norm_le",
   "Eq.substr",
   "Option.some_or",
   "Int.Linear.natCast_sub",
   "Eq.mp",
   "noConfusion_of_Nat",
   "GetElem.getElem",
   "Nat.Linear.ExprCnstr.eq_of_toNormPoly_eq",
   "Int.Linear.Expr.eq_of_norm_eq",
   "congrArg",
   "Option.or",
   "Lean.Grind.Nat.lt_eq",
   "Nat.not_le_eq",
   "Lean.Grind.nestedDecidable",
   "CellularAutomatas.PrefixStableProof.getLastOfTake._proof_1_3",
   "List.getLast?_eq_getElem?",
   "Lean.Grind.Order.lt_of_not_le_k",
   "cast",
   "Not",
   "Nat.ToInt.lt_eq",
   "ite",
   "Lean.Grind.Order.le_eq_true_of_le_k",
   "Nat.ToInt.add_congr",
   "Lean.Grind.Order.eq_mp_not",
   "OfNat.ofNat",
   "ite_congr",
   "HAdd.hAdd",
   "LT.lt",
   "Nat.ToInt.le_eq",
   "of_eq_true",
   "Lean.Grind.CommRing.Expr.eq_of_toPoly_eq",
   "List.take",
   "LE.le",
   "Lean.Grind.Semiring.natCast",
   "CellularAutomatas.PrefixStableProof.getLastOfTake._proof_1_5",
   "Lean.Grind.CommRing.le_norm_expr",
   "Lean.Grind.Semiring.natCast_eq_ofNat"],
  "name": "CellularAutomatas.PrefixStableProof.getLastOfTake._proof_1_18",
  "constType":
  "∀ {i : ℕ} {α : Type u_1} {w : List α},\n  -1 * ↑(List.take 1 w⟦i..*⟧).length + 1 ≤ 0 →\n    (List.take (i + 1) w).length - 1 < (List.take i w ++ List.take 1 w⟦i..*⟧).length",
  "constCategory": "Theorem"},
 {"references":
  ["Int.mul_comm",
   "LE.le",
   "Int.mul_le_mul_of_nonpos_right",
   "id",
   "HMul.hMul",
   "Eq.mpr",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Int.mul_le_mul_of_nonpos_left",
  "constType": "∀ {a b c : ℤ}, a ≤ 0 → c ≤ b → a * b ≤ a * c",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CellularAutomatas.VerificationError.ctorIdx",
  "constType": "CellularAutomatas.VerificationError → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["CellularAutomatas.CellAutomaton.delta_closed_set",
   "Set",
   "Singleton.singleton",
   "CellularAutomatas.CellAutomaton.Q"],
  "name": "CellularAutomatas.CellAutomaton.dead",
  "constType": "(C : CellularAutomatas.CellAutomaton) → C.Q → Prop",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Lean.Name.mkSimple",
  "constType": "String → Name",
  "constCategory": "Definition"},
 {"references":
  ["Eq.trans",
   "List.take_nil",
   "congrArg",
   "Nat.sub_eq_zero_of_le",
   "congr",
   "HSub.hSub",
   "Eq.symm",
   "Eq.ndrec",
   "Nat.casesAuxOn",
   "Not",
   "HAppend.hAppend",
   "true_and",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "eq_self",
   "Decidable.byContradiction",
   "of_eq_true",
   "List.append_nil",
   "_private.Init.Data.List.Nat.TakeDrop.0.List.take_append._proof_1_1",
   "List.cons.injEq",
   "List.take",
   "LE.le",
   "id",
   "Eq.mpr",
   "List.append_cancel_left_eq",
   "List.length",
   "Nat.le_add_left._simp_1"],
  "name": "List.take_append",
  "constType":
  "∀ {α : Type u_1} {l₁ l₂ : List α} {i : ℕ}, List.take i (l₁ ++ l₂) = List.take i l₁ ++ List.take (i - l₁.length) l₂",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Eq.trans",
   "of_eq_true",
   "ite",
   "LE.le",
   "eq_true",
   "ite_cond_eq_true",
   "congrArg"],
  "name": "Int.max_eq_right",
  "constType": "∀ {a b : ℤ}, a ≤ b → max a b = b",
  "constCategory": "Theorem"},
 {"references":
  ["Not", "Nat.find", "Classical.dec", "Set", "Membership.mem", "dite"],
  "name": "CellularAutomatas.min_nat",
  "constType": "Set ℕ → Option ℕ",
  "constCategory": "Definition"},
 {"references": ["absurd", "False.elim", "List.casesOn", "Ne"],
  "name":
  "_private.Init.Data.List.Lemmas.0.List.getLast?_eq_some_getLast.match_1_1",
  "constType":
  "∀ {α : Type u_1} (motive : (x : List α) → x ≠ [] → Prop) (x : List α) (x_1 : x ≠ []),\n  (∀ (head : α) (tail : List α) (x : head :: tail ≠ []), motive (head :: tail) x) → motive x x_1",
  "constCategory": "Definition"},
 {"references": ["Array.mkArray4", "Lean.SyntaxNodeKind"],
  "name": "Lean.Syntax.node4",
  "constType":
  "SourceInfo → SyntaxNodeKind → Syntax → Syntax → Syntax → Syntax → Syntax",
  "constCategory": "Definition"},
 {"references": ["LT.lt", "Nat.le_of_succ_le_succ", "List.length"],
  "name": "List.get._proof_1",
  "constType":
  "∀ {α : Type u_1} (head : α) (as : List α) (i : ℕ), i.succ < (head :: as).length → i.succ ≤ as.length",
  "constCategory": "Theorem"},
 {"references": ["HMod.hMod", "HSub.hSub"],
  "name": "CellularAutomatas.word_dvd_k_ext",
  "constType": "ℕ → ℕ → ℕ",
  "constCategory": "Definition"},
 {"references": ["Neg.neg", "Int.neg_mul_eq_neg_mul", "Eq.symm", "HMul.hMul"],
  "name": "Int.neg_mul",
  "constType": "∀ (a b : ℤ), -a * b = -(a * b)",
  "constCategory": "Theorem"},
 {"references":
  ["rfl",
   "List.zip",
   "CellularAutomatas.Word",
   "Eq.trans",
   "List.zip_nil_right",
   "CellularAutomatas.FiniteStateTransducer.Q",
   "CellularAutomatas.FiniteStateTransducer.scanr",
   "CellularAutomatas.FiniteStateTransducer.scanr_reduce",
   "CellularAutomatas.FiniteStateTransducer.q0",
   "_private.CellularAutomatas.proofs.finite_state_transducers.0.CellularAutomatas.FiniteStateTransducer.m_prod_scanr_reduce_q",
   "congrArg",
   "CellularAutomatas.FiniteStateTransducer.scanr_reduce_q",
   "CellularAutomatas.FiniteStateTransducer.M_prod",
   "eq_self",
   "of_eq_true",
   "congr",
   "funext",
   "id",
   "Eq.mpr",
   "CellularAutomatas.FiniteStateTransducer.scanr_cons",
   "CellularAutomatas.FiniteStateTransducer.f",
   "CellularAutomatas.FiniteStateTransducer.δ"],
  "name": "CellularAutomatas.FiniteStateTransducer.M_prod_spec",
  "constType":
  "∀ {α β1 β2 : Type} [inst : CellularAutomatas.Alphabet α] {M1 : CellularAutomatas.FiniteStateTransducer α β1}\n  {M2 : CellularAutomatas.FiniteStateTransducer α β2},\n  (M1.M_prod M2).scanr = fun w => List.zip (M1.scanr w) (M2.scanr w)",
  "constCategory": "Theorem"},
 {"references": ["Lean.Omega.Coeffs", "Lean.Omega.normalize", "Prod.fst"],
  "name": "Lean.Omega.normalizeConstraint",
  "constType": "Omega.Constraint → Omega.Coeffs → Omega.Constraint",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CellularAutomatas.TwoStageAdvice.recOn",
  "constType":
  "{α Γ : Type} →\n  [inst : CellularAutomatas.Alphabet α] →\n    [inst_1 : CellularAutomatas.Alphabet Γ] →\n      {motive : CellularAutomatas.TwoStageAdvice α Γ → Sort u} →\n        (t : CellularAutomatas.TwoStageAdvice α Γ) →\n          ((β : Type) →\n              [alphabetβ : CellularAutomatas.Alphabet β] →\n                (C : CellularAutomatas.CArtTransducer α β) →\n                  (M : CellularAutomatas.FiniteStateTransducer β Γ) →\n                    motive { β := β, alphabetβ := alphabetβ, C := C, M := M }) →\n            motive t",
  "constCategory": "Definition"},
 {"references":
  ["Nat.mul.match_1", "Nat.add", "Nat.below", "Nat.brecOn", "OfNat.ofNat"],
  "name": "Nat.mul",
  "constType": "ℕ → ℕ → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["implies_congr",
   "Eq.trans",
   "Eq.mp",
   "Singleton.singleton",
   "CellularAutomatas.PrefixStableProof.f._proof_1_4",
   "Membership.mem",
   "eq_true",
   "GetElem.getElem",
   "Lean.Grind.intro_with_eq'",
   "Finset.mem_singleton",
   "Lean.Grind.not_eq_prop",
   "congrArg",
   "Lean.Grind.Nat.lt_eq",
   "or_false",
   "Lean.Grind.forall_imp_eq_or",
   "funext",
   "forall_congr",
   "Eq.symm",
   "Finset.mem_univ",
   "Lean.Grind.false_of_not_eq_self",
   "Finset.filter",
   "Not",
   "Finset.univ",
   "CellularAutomatas.Word",
   "OfNat.ofNat",
   "Lean.Grind.nestedProof",
   "Eq.mpr_prop",
   "HAdd.hAdd",
   "CellularAutomatas.Advice.f",
   "LT.lt",
   "Exists.casesOn",
   "Lean.Grind.eq_congr'",
   "Lean.Grind.and_eq_of_eq_true_left",
   "Lean.Grind.iff_eq",
   "eq_false",
   "List.take",
   "Finset.mem_filter",
   "LE.le",
   "Classical.byContradiction",
   "id",
   "Finset.ext",
   "List.length"],
  "name": "CellularAutomatas.PrefixStableProof.f._proof_1_6",
  "constType":
  "∀ {α Γ : Type} [inst : CellularAutomatas.Alphabet Γ] (adv : CellularAutomatas.Advice α Γ)\n  (w : CellularAutomatas.Word α),\n  ∀ i < List.length w,\n    adv.f (List.take (i + 1) w) = List.take (i + 1) (adv.f w) →\n      ∀ (this : i < List.length (adv.f w)), {c | (adv.f w)[i] = c} = {(adv.f w)[i]}",
  "constCategory": "Theorem"},
 {"references":
  ["List.ctorIdx",
   "False.elim",
   "List.casesOn",
   "id",
   "Ne",
   "Nat.ne_of_beq_eq_false",
   "List.zipWith.match_1",
   "OfNat.ofNat",
   "List.beq._sparseCasesOn_2"],
  "name": "_private.Init.Data.List.Basic.0.List.zipWith.match_1.eq_2",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} (motive : List α → List β → Sort u_3) (x : List α) (x_1 : List β)\n  (h_1 : (x : α) → (xs : List α) → (y : β) → (ys : List β) → motive (x :: xs) (y :: ys))\n  (h_2 : (x : List α) → (x_2 : List β) → motive x x_2),\n  (∀ (x_2 : α) (xs : List α) (y : β) (ys : List β), x = x_2 :: xs → x_1 = y :: ys → False) →\n    (match x, x_1 with\n      | x :: xs, y :: ys => h_1 x xs y ys\n      | x, x_3 => h_2 x x_3) =\n      h_2 x x_1",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Eq.trans",
   "of_eq_true",
   "congr",
   "List.casesOn",
   "List.zipWith_nil_right",
   "Eq.symm",
   "List.map",
   "List.zipWith",
   "Eq.ndrec",
   "congrArg"],
  "name": "List.map_zipWith",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} {δ : Type u_4} {f : α → β} {g : γ → δ → α} {l : List γ} {l' : List δ},\n  List.map f (List.zipWith g l l') = List.zipWith (fun x y => f (g x y)) l l'",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "List.casesOn",
  "constType":
  "{α : Type u} →\n  {motive : List α → Sort u_1} →\n    (t : List α) → motive [] → ((head : α) → (tail : List α) → motive (head :: tail)) → motive t",
  "constCategory": "Definition"},
 {"references": ["Nat.ble"],
  "name": "Lean.RArray.get",
  "constType": "{α : Type u} → RArray α → ℕ → α",
  "constCategory": "Definition"},
 {"references": ["List.casesOn"],
  "name": "List.concat.match_1",
  "constType":
  "{α : Type u_1} →\n  (motive : List α → α → Sort u_2) →\n    (x : List α) →\n      (x_1 : α) → ((b : α) → motive [] b) → ((a : α) → (as : List α) → (b : α) → motive (a :: as) b) → motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["HAdd.hAdd",
   "Lean.Grind.Ring.intCast",
   "Std.IsPreorder.le_refl",
   "LE.le",
   "Eq.symm",
   "Eq.ndrec",
   "Int.cast"],
  "name": "Lean.Grind.Order.le_of_offset_eq_1_k",
  "constType":
  "∀ {α : Type u_1} [inst : LE α] [inst_1 : LT α] [LawfulOrderLT α] [inst_3 : Std.IsPreorder α] [inst_4 : Grind.Ring α]\n  [Grind.OrderedRing α] {a b : α} {k : ℤ}, a = b + ↑k → a ≤ b + ↑k",
  "constCategory": "Theorem"},
 {"references":
  ["Finset.univ",
   "Finset.map",
   "Fintype.ofBijective._proof_1",
   "Fintype.ofBijective._proof_2",
   "Function.Bijective"],
  "name": "Fintype.ofBijective",
  "constType":
  "{α : Type u_1} → {β : Type u_2} → [Fintype α] → (f : α → β) → Function.Bijective f → Fintype β",
  "constCategory": "Definition"},
 {"references": ["OfNat.ofNat"],
  "name": "UInt64.size",
  "constType": "ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Int.neg_le_neg",
   "Eq.mp",
   "Neg.neg",
   "congr",
   "LE.le",
   "Int.neg_neg",
   "congrArg"],
  "name": "Int.le_of_neg_le_neg",
  "constType": "∀ {a b : ℤ}, -b ≤ -a → a ≤ b",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Exists.casesOn",
  "constType":
  "∀ {α : Sort u} {p : α → Prop} {motive : Exists p → Prop} (t : Exists p), (∀ (w : α) (h : p w), motive ⋯) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["HAdd.hAdd",
   "Lean.Grind.AddCommMonoid.add_assoc",
   "Neg.neg",
   "id",
   "HSub.hSub",
   "Lean.Grind.AddCommMonoid.add_zero",
   "Eq.mpr",
   "Lean.Grind.AddCommGroup.sub_eq_add_neg",
   "Lean.Grind.AddCommGroup.neg_add_cancel",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Lean.Grind.AddCommGroup.sub_add_cancel",
  "constType":
  "∀ {M : Type u} [inst : Grind.AddCommGroup M] {a b : M}, a - b + b = a",
  "constCategory": "Theorem"},
 {"references":
  ["Int.neg_mul_eq_mul_neg",
   "Int.le_of_neg_le_neg",
   "Eq.mp",
   "Neg.neg",
   "Int.neg_nonneg_of_nonpos",
   "Int.mul_le_mul_of_nonneg_right",
   "LE.le",
   "Eq.symm",
   "HMul.hMul",
   "GE.ge",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Int.mul_le_mul_of_nonpos_right",
  "constType": "∀ {a b c : ℤ}, b ≤ a → c ≤ 0 → a * c ≤ b * c",
  "constCategory": "Theorem"},
 {"references": ["Or.casesOn", "LT.lt", "GE.ge"],
  "name": "_private.Init.Data.Nat.Basic.0.Nat.lt_trichotomy.match_1_3",
  "constType":
  "∀ (a b : ℕ) (motive : a < b ∨ a ≥ b → Prop) (x : a < b ∨ a ≥ b),\n  (∀ (h : a < b), motive ⋯) → (∀ (h : a ≥ b), motive ⋯) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Int.toNat",
   "Int.max_eq_left",
   "Max.max",
   "Int.max_eq_right",
   "Nat.cast",
   "Int.natCast_nonneg",
   "Int.le_of_lt",
   "Int.negSucc_lt_zero",
   "Eq.symm",
   "_private.Init.Data.Int.Order.0.Int.toNat_eq_max.match_1_1",
   "OfNat.ofNat"],
  "name": "Int.toNat_eq_max",
  "constType": "∀ (a : ℤ), ↑a.toNat = max a 0",
  "constCategory": "Theorem"},
 {"references":
  ["Int.Linear.Poly.brecOn",
   "Int.Linear.Poly.coeff.match_1",
   "BEq.beq",
   "cond",
   "OfNat.ofNat",
   "Int.Linear.Poly.below",
   "Int.Linear.Var"],
  "name": "Int.Linear.Poly.coeff",
  "constType": "Int.Linear.Poly → Int.Linear.Var → ℤ",
  "constCategory": "Definition"},
 {"references":
  ["Eq.trans",
   "CellularAutomatas.backwards_fsm.Params.inst3",
   "eq_true",
   "eagerReduce",
   "CellularAutomatas.Config",
   "CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "NatCast.natCast",
   "funext",
   "Eq.symm",
   "HSub.hSub",
   "CellularAutomatas.Word.get'?",
   "CellularAutomatas.backwards_fsm.Params.α",
   "CellularAutomatas.CellAutomaton.δ",
   "CellularAutomatas.CArtTransducer.toLCellAutomaton",
   "List.drop",
   "CellularAutomatas.backwards_fsm.Params.β",
   "Neg.neg",
   "CellularAutomatas.backwards_fsm.Params.M",
   "CellularAutomatas.FiniteStateTransducer.scanr",
   "Prod.snd",
   "CellularAutomatas.backwards_fsm.Params.inst2",
   "CellularAutomatas.LCellAutomaton.comp",
   "eq_false",
   "Classical.byContradiction",
   "id",
   "Int.toNat",
   "Lean.Grind.not_true",
   "Nat.cast",
   "CellularAutomatas.backwards_fsm.C'",
   "Lean.Grind.not_and",
   "CellularAutomatas.backwards_fsm.Params.C",
   "Eq.mp",
   "CellularAutomatas.FiniteStateTransducer.Q",
   "CellularAutomatas.FiniteStateTransducer.δ?",
   "CellularAutomatas.FiniteStateTransducer.scanr_reduce",
   "CellularAutomatas.backwards_fsm.Params.γ",
   "Int.Linear.Expr.eq_of_norm_eq",
   "Prod.fst",
   "congrArg",
   "or_false",
   "congr",
   "CellularAutomatas.CellAutomaton.Q",
   "Lean.Grind.forall_and",
   "Not",
   "CellularAutomatas.Word",
   "Lean.Grind.Semiring.natCast_add",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "eq_self",
   "True.casesOn",
   "Lean.Grind.intro_with_eq",
   "Lean.Grind.Semiring.natCast",
   "Lean.Grind.Semiring.natCast_eq_ofNat",
   "And.casesOn"],
  "name": "CellularAutomatas.backwards_fsm.inv._proof_1_6",
  "constType":
  "∀ (e : CellularAutomatas.backwards_fsm.Params) (w : CellularAutomatas.Word e.α) (t : ℕ) (p : ℤ),\n  (∀ (p : ℤ),\n      let c' := (CellularAutomatas.backwards_fsm.C' e).comp w t p;\n      let q := e.M.scanr_reduce w⟦(p + ↑t).toNat..*⟧;\n      c'.2 q = e.C.comp (e.M.scanr w) t p ∧ c'.1 = w.get'? (p + ↑t)) →\n    (CellularAutomatas.backwards_fsm.C' e).comp w t = (CellularAutomatas.backwards_fsm.C' e).comp w t →\n      (CellularAutomatas.backwards_fsm.C' e).comp w t (p - 1) =\n          (CellularAutomatas.backwards_fsm.C' e).comp w t (p - 1) →\n        (CellularAutomatas.backwards_fsm.C' e).comp w t p = (CellularAutomatas.backwards_fsm.C' e).comp w t p →\n          (CellularAutomatas.backwards_fsm.C' e).comp w (t + 1) p =\n              (((CellularAutomatas.backwards_fsm.C' e).comp w t (p + 1)).1, fun q =>\n                e.C.δ\n                  (((CellularAutomatas.backwards_fsm.C' e).comp w t (p - 1)).2\n                    (e.M.δ? (e.M.δ? q ((CellularAutomatas.backwards_fsm.C' e).comp w t p).1)\n                      ((CellularAutomatas.backwards_fsm.C' e).comp w t (p - 1)).1))\n                  (((CellularAutomatas.backwards_fsm.C' e).comp w t p).2\n                    (e.M.δ? q ((CellularAutomatas.backwards_fsm.C' e).comp w t p).1))\n                  (((CellularAutomatas.backwards_fsm.C' e).comp w t (p + 1)).2 q)) →\n            (CellularAutomatas.backwards_fsm.C' e).comp w t (p + 1) =\n                (CellularAutomatas.backwards_fsm.C' e).comp w t (p + 1) →\n              e.M.scanr_reduce w⟦(p + ↑(t + 1)).toNat..*⟧ = e.M.scanr_reduce w⟦(p + ↑(t + 1)).toNat..*⟧ →\n                (((CellularAutomatas.backwards_fsm.C' e).comp w (t + 1) p).2\n                      (e.M.scanr_reduce w⟦(p + ↑(t + 1)).toNat..*⟧) =\n                    let q_right :=\n                      e.M.δ? (e.M.scanr_reduce w⟦(p + ↑(t + 1)).toNat..*⟧)\n                        ((CellularAutomatas.backwards_fsm.C' e).comp w t p).1;\n                    let q_center := e.M.δ? q_right ((CellularAutomatas.backwards_fsm.C' e).comp w t (p - 1)).1;\n                    e.C.δ (((CellularAutomatas.backwards_fsm.C' e).comp w t (p - 1)).2 q_center)\n                      (((CellularAutomatas.backwards_fsm.C' e).comp w t p).2 q_right)\n                      (((CellularAutomatas.backwards_fsm.C' e).comp w t (p + 1)).2\n                        (e.M.scanr_reduce w⟦(p + ↑(t + 1)).toNat..*⟧))) →\n                  (let c' := (CellularAutomatas.backwards_fsm.C' e).comp w t (p + 1);\n                    let q := e.M.scanr_reduce w⟦(p + 1 + ↑t).toNat..*⟧;\n                    c'.2 q = e.C.comp (e.M.scanr w) t (p + 1) ∧ c'.1 = w.get'? (p + 1 + ↑t)) →\n                    e.M.scanr_reduce w⟦(p + 1 + ↑t).toNat..*⟧ = e.M.scanr_reduce w⟦(p + ↑(t + 1)).toNat..*⟧ →\n                      ((CellularAutomatas.backwards_fsm.C' e).comp w t (p + 1)).2\n                              (e.M.scanr_reduce w⟦(p + ↑(t + 1)).toNat..*⟧) =\n                            e.C.comp (e.M.scanr w) t (p + 1) ∧\n                          ((CellularAutomatas.backwards_fsm.C' e).comp w t (p + 1)).1 = w.get'? (p + 1 + ↑t) →\n                        ((CellularAutomatas.backwards_fsm.C' e).comp w t (p + 1)).2\n                              (e.M.scanr_reduce w⟦(p + ↑(t + 1)).toNat..*⟧) =\n                            e.C.comp (e.M.scanr w) t (p + 1) ∧\n                          w.get'? (p + 1 + ↑t) = w.get'? (p + ↑t + 1)",
  "constCategory": "Theorem"},
 {"references": ["NatCast.natCast"],
  "name": "Nat.cast",
  "constType": "{R : Type u} → [NatCast R] → ℕ → R",
  "constCategory": "Definition"},
 {"references": ["LT.lt", "GetElem?.getElem?", "Option.getD", "List.length"],
  "name": "List.getD",
  "constType": "{α : Type u_1} → List α → ℕ → α → α",
  "constCategory": "Definition"},
 {"references":
  ["Not",
   "false_and",
   "Eq.trans",
   "ite",
   "eq_true",
   "noConfusion_of_Nat",
   "eq_false'",
   "Decidable.casesOn",
   "true_and",
   "congrArg",
   "Option.ctorIdx",
   "False.elim",
   "not_false_eq_true",
   "if_neg",
   "of_eq_true",
   "iff_self",
   "congr",
   "eq_false",
   "id",
   "not_true_eq_false",
   "Eq.mpr",
   "if_pos"],
  "name": "Option.some_eq_ite_none_left",
  "constType":
  "∀ {β : Type u_1} {a : β} {p : Prop} {x : Decidable p} {b : Option β}, (some a = if p then none else b) ↔ ¬p ∧ some a = b",
  "constCategory": "Theorem"},
 {"references": ["Int.casesOn"],
  "name": "_private.Init.Data.Int.Lemmas.0.Int.add_zero.match_1_1",
  "constType":
  "∀ (motive : ℤ → Prop) (x : ℤ), (∀ (a : ℕ), motive (Int.ofNat a)) → (∀ (a : ℕ), motive (Int.negSucc a)) → motive x",
  "constCategory": "Definition"},
 {"references": ["HAdd.hAdd", "Int.add_comm", "Int.add_zero", "OfNat.ofNat"],
  "name": "Int.zero_add",
  "constType": "∀ (a : ℤ), 0 + a = a",
  "constCategory": "Theorem"},
 {"references": ["Int.Linear.Poly.casesOn", "Int.Linear.Var"],
  "name": "Int.Linear.Poly.denote.match_1",
  "constType":
  "(motive : Int.Linear.Poly → Sort u_1) →\n  (p : Int.Linear.Poly) →\n    ((k : ℤ) → motive (Int.Linear.Poly.num k)) →\n      ((k : ℤ) → (v : Int.Linear.Var) → (p : Int.Linear.Poly) → motive (Int.Linear.Poly.add k v p)) → motive p",
  "constCategory": "Definition"},
 {"references":
  ["Option.casesOn",
   "Ne",
   "OfNat.ofNat",
   "Unit.unit",
   "Lean.ConstantInfo.ctorIdx",
   "CellularAutomatas.collectAxiomsFromEnv.visit._sparseCasesOn_3",
   "Unit"],
  "name": "CellularAutomatas.collectAxiomsFromEnv.visit.match_3",
  "constType":
  "(motive : Option ConstantInfo → Sort u_1) →\n  (x : Option ConstantInfo) →\n    ((val : AxiomVal) → motive (some (ConstantInfo.axiomInfo val))) →\n      ((info : ConstantInfo) → motive (some info)) → (Unit → motive none) → motive x",
  "constCategory": "Definition"},
 {"references": ["LE.le", "if_pos"],
  "name": "Nat.min_eq_left",
  "constType": "∀ {a b : ℕ}, a ≤ b → min a b = a",
  "constCategory": "Theorem"},
 {"references": ["OfNat.ofNat"],
  "name": "Lean.Omega.Constraint.impossible",
  "constType": "Omega.Constraint",
  "constCategory": "Definition"},
 {"references":
  ["absurd",
   "Bool.noConfusion",
   "Nat.noConfusion",
   "Nat.beq",
   "Nat.below",
   "_private.Init.Prelude.0.Nat.ne_of_beq_eq_false.match_1_1",
   "Nat.brecOn"],
  "name": "Nat.ne_of_beq_eq_false",
  "constType": "∀ {n m : ℕ}, n.beq m = false → ¬n = m",
  "constCategory": "Theorem"},
 {"references":
  ["List.reverse",
   "Eq.symm",
   "id",
   "Eq.mpr",
   "List.getLast?_reverse",
   "List.head?",
   "List.getLast?",
   "List.reverse_reverse",
   "congrArg"],
  "name": "List.head?_reverse",
  "constType": "∀ {α : Type u_1} {l : List α}, l.reverse.head? = l.getLast?",
  "constCategory": "Theorem"},
 {"references": ["Set", "ENat.card", "Set.Elem"],
  "name": "Set.encard",
  "constType": "{α : Type u_1} → Set α → ℕ∞",
  "constCategory": "Definition"},
 {"references":
  ["Lean.SyntaxNodeKind",
   "Bool.and",
   "Lean.Syntax.getNumArgs",
   "Lean.Syntax.isOfKind",
   "BEq.beq"],
  "name": "Lean.Syntax.isNodeOf",
  "constType": "Syntax → SyntaxNodeKind → ℕ → Bool",
  "constCategory": "Definition"},
 {"references":
  ["Or.elim",
   "Lean.Omega.LinearCombo.coordinate_eval_2",
   "Nat.cast",
   "Eq.trans",
   "le_of_le_of_eq",
   "Lean.Omega.LinearCombo.coordinate_eval_0",
   "Lean.Omega.Constraint.combine_sat'",
   "Int.sub_eq_zero_of_eq",
   "GE.ge",
   "Decidable.decide",
   "Lean.Omega.Int.ofNat_le_of_le",
   "Lean.Omega.LinearCombo.neg_eval",
   "Lean.Omega.Coeffs.ofList",
   "Lean.Omega.Int.ofNat_sub_dichotomy",
   "HSub.hSub",
   "Lean.Omega.tidy_sat",
   "Eq.symm",
   "Lean.Omega.LinearCombo.add_eval",
   "Lean.Omega.Int.neg_congr",
   "Int.add_one_le_of_lt",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "And.left",
   "of_decide_eq_true",
   "Not",
   "Int.lt_or_gt_of_ne",
   "Neg.neg",
   "And.right",
   "Lean.Omega.Constraint.addInequality_sat",
   "Lean.Omega.Int.add_congr",
   "Lean.Omega.Constraint.isImpossible",
   "Lean.Omega.LinearCombo.coordinate",
   "Int.sub_nonneg_of_le",
   "OfNat.ofNat",
   "Lean.Omega.LinearCombo.coordinate_eval_1",
   "LT.lt",
   "HAdd.hAdd",
   "Lean.Omega.Int.ofNat_lt_of_lt",
   "Lean.Omega.LinearCombo.sub_eval",
   "LE.le",
   "Int.natCast_add",
   "id",
   "Lean.Omega.Constraint.addEquality_sat",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.Int.sub_congr"],
  "name":
  "_private.Init.Grind.Ring.Basic.0.Lean.Grind.Ring.intCast_add._proof_1_3",
  "constType":
  "∀ (x y : ℕ), x ≥ y + 1 → ¬↑x + -↑(y + 1) = ↑(x - (y + 1)) → False",
  "constCategory": "Theorem"},
 {"references": ["Prod.casesOn", "CellularAutomatas.FiniteStateTransducer.Q"],
  "name": "CellularAutomatas.FiniteStateTransducer.M_prod.match_1",
  "constType":
  "{α β1 β2 : Type} →\n  (M1 : CellularAutomatas.FiniteStateTransducer α β1) →\n    (M2 : CellularAutomatas.FiniteStateTransducer α β2) →\n      (motive : M1.Q ⨉ M2.Q → Sort u_1) →\n        (x : M1.Q ⨉ M2.Q) → ((m_q : M1.Q) → (c_q : M2.Q) → motive (m_q, c_q)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["AddLeftMono",
   "Nat.cast",
   "Nat.cast_zero",
   "LE.le",
   "Nat.zero_le",
   "Nat.mono_cast",
   "OfNat.ofNat"],
  "name": "Nat.cast_nonneg'",
  "constType":
  "∀ {α : Type u_1} [inst : AddMonoidWithOne α] [inst_1 : PartialOrder α] [AddLeftMono α] [ZeroLEOneClass α] (n : ℕ),\n  0 ≤ ↑n",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Lean.Grind.IntInterval.casesOn",
  "constType":
  "{motive : Grind.IntInterval → Sort u} →\n  (t : Grind.IntInterval) →\n    ((lo hi : ℤ) → motive (Grind.IntInterval.co lo hi)) →\n      ((lo : ℤ) → motive (Grind.IntInterval.ci lo)) →\n        ((hi : ℤ) → motive (Grind.IntInterval.io hi)) → motive Grind.IntInterval.ii → motive t",
  "constCategory": "Definition"},
 {"references":
  ["Eq.trans",
   "Eq.mp",
   "Lean.Grind.Order.of_nat_eq",
   "HMul.hMul",
   "eq_true",
   "eagerReduce",
   "ite_cond_eq_true",
   "List.length_drop",
   "IntCast.intCast",
   "List.length_take",
   "Lean.Grind.Order.lt_le_trans_k",
   "Nat.ToInt.natCast_ofNat",
   "min_def",
   "congrArg",
   "Lean.Grind.nestedDecidable",
   "NatCast.natCast",
   "HSub.hSub",
   "Eq.symm",
   "cast",
   "List.drop",
   "Nat.ToInt.lt_eq",
   "Lean.Grind.Order.lt_eq_true_of_lt_k",
   "ite",
   "Lean.Grind.Order.eq_trans_true'",
   "Neg.neg",
   "Lean.Grind.Order.le_of_eq_2_k",
   "Nat.ToInt.add_congr",
   "Lean.Grind.Order.le_eq_true_of_le_k",
   "Lean.Grind.nestedProof",
   "OfNat.ofNat",
   "LT.lt",
   "HAdd.hAdd",
   "Nat.ToInt.le_eq",
   "of_eq_true",
   "Min.min",
   "List.take",
   "LE.le",
   "Lean.Grind.CommRing.lt_norm_expr",
   "id",
   "Lean.Grind.CommRing.le_norm_expr",
   "Lean.Grind.Order.eq_trans_true",
   "CellularAutomatas.PrefixStableProof.getLastOfTake._proof_1_6",
   "Lean.Grind.Order.eq_mp",
   "List.length"],
  "name": "CellularAutomatas.PrefixStableProof.getLastOfTake._proof_1_12",
  "constType":
  "∀ {i : ℕ} {α : Type u_1} {w : List α},\n  i + 1 ≤ w.length →\n    -1 * ↑(List.take 1 w⟦i..*⟧).length + 1 ≤ 0 → (List.take 1 w⟦i..*⟧).length - 1 < w⟦(List.take i w).length..*⟧.length",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.Word",
   "CellularAutomatas.FiniteStateTransducer.Q",
   "CellularAutomatas.FiniteStateTransducer.scanr_reduce"],
  "name": "CellularAutomatas.FiniteStateTransducer.scanr_reduce.eq_1",
  "constType":
  "∀ {α β : Type} (M : CellularAutomatas.FiniteStateTransducer α β), M.scanr_reduce = M.scanr_reduce_q M.q0",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd", "eq_self", "Eq.trans", "of_eq_true", "add_assoc", "congrArg"],
  "name": "Mathlib.Tactic.Ring.add_pf_add_lt",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a₂ b c : R} (a₁ : R), a₂ + b = c → a₁ + a₂ + b = a₁ + c",
  "constCategory": "Theorem"},
 {"references": ["HAdd.hAdd", "rfl"],
  "name": "Nat.add_succ",
  "constType": "∀ (n m : ℕ), n + m.succ = (n + m).succ",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "sorryAx",
   "CellularAutomatas.compress_by_3.C'",
   "CellularAutomatas.CellAutomaton.Q",
   "OfNat.ofNat"],
  "name": "CellularAutomatas.compress_by_3.f",
  "constType":
  "{α : Type} →\n  {C : CellularAutomatas.LCellAutomaton α} → (CellularAutomatas.compress_by_3.C' C).Q → Option (C.Q ⨉ (C.Q ⨉ C.Q))",
  "constCategory": "Definition"},
 {"references":
  ["rfl",
   "_private.Init.Data.List.Lemmas.0.List.eq_nil_of_length_eq_zero.match_1_1",
   "OfNat.ofNat",
   "List.length"],
  "name": "List.eq_nil_of_length_eq_zero",
  "constType": "∀ {α : Type u_1} {l : List α}, l.length = 0 → l = []",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "CellularAutomatas.Word",
   "Nat.cast",
   "Eq.trans",
   "Int.neg_le_zero_iff._simp_1",
   "Neg.neg",
   "Set",
   "Membership.mem",
   "CellularAutomatas.Word.cone",
   "true_and",
   "GT.gt",
   "OfNat.ofNat",
   "congrArg",
   "LT.lt",
   "HAdd.hAdd",
   "Decidable.byContradiction",
   "Int.natCast_nonneg._simp_1",
   "LE.le",
   "id",
   "Eq.mpr",
   "CellularAutomatas.Word.zero_mem_cone._proof_1_2",
   "List.length"],
  "name": "CellularAutomatas.Word.zero_mem_cone",
  "constType":
  "∀ {α : Type u_1} {w : CellularAutomatas.Word α}, List.length w > 0 → ∀ (t : ℕ), 0 ∈ w.cone t",
  "constCategory": "Theorem"},
 {"references": ["Language"],
  "name": "CellularAutomatas.DefinesLanguage.recOn",
  "constType":
  "{CA : Sort u_1} →\n  {α : Type} →\n    {motive : CellularAutomatas.DefinesLanguage CA α → Sort u} →\n      (t : CellularAutomatas.DefinesLanguage CA α) → ((L : CA → Language α) → motive { L := L }) → motive t",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Not",
  "constType": "Prop → Prop",
  "constCategory": "Definition"},
 {"references":
  ["LT.lt",
   "HAdd.hAdd",
   "Lean.Grind.Nat.lt_eq",
   "LE.le",
   "OfNat.ofNat",
   "Eq.mpr_prop",
   "List.length"],
  "name": "CellularAutomatas.ca_id_comp_p0._proof_1_6",
  "constType":
  "∀ {t : ℕ} {α : Type} {w : List α}, t + 1 ≤ w.length → t < w.length",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans",
   "_private.Init.Data.Nat.Basic.0.Nat.add_le_of_le_sub.match_1_1",
   "Nat.add_comm",
   "congrArg",
   "HAdd.hAdd",
   "eq_self",
   "Nat.eq_add_of_sub_eq",
   "of_eq_true",
   "congr",
   "Nat.le.dest",
   "LE.le",
   "HSub.hSub",
   "id",
   "Eq.symm",
   "Eq.mpr",
   "Nat.add_left_comm",
   "Nat.le.intro"],
  "name": "Nat.add_le_of_le_sub",
  "constType": "∀ {a b c : ℕ}, b ≤ c → a ≤ c - b → a + b ≤ c",
  "constCategory": "Theorem"},
 {"references": ["CellularAutomatas.CArtTransducer.advice"],
  "name": "CellularAutomatas.CArtTransducer.advice.eq_1",
  "constType":
  "∀ {α Γ : Type} [inst : CellularAutomatas.Alphabet α] [inst_1 : CellularAutomatas.Alphabet Γ]\n  (adv : CellularAutomatas.CArtTransducer α Γ),\n  adv.advice = { f := fun w => List.map adv.f (adv.scan_temporal_rt w), len := ⋯ }",
  "constCategory": "Theorem"},
 {"references":
  ["Multiset.leInductionOn",
   "Multiset.card",
   "LE.le",
   "List.Sublist.length_le",
   "Multiset"],
  "name": "Multiset.card_le_card",
  "constType": "∀ {α : Type u_1} {s t : Multiset α}, s ≤ t → s.card ≤ t.card",
  "constCategory": "Theorem"},
 {"references":
  ["Std.TreeSet.inner", "Std.TreeMap.insertIfNew", "Unit.unit", "Unit"],
  "name": "Std.TreeSet.insert",
  "constType":
  "{α : Type u} → {cmp : α → α → Ordering} → TreeSet α cmp → α → TreeSet α cmp",
  "constCategory": "Definition"},
 {"references":
  ["HAdd.hAdd",
   "eq_self",
   "Nat.cast",
   "Eq.trans",
   "of_eq_true",
   "congr",
   "Nat.rawCast",
   "add_zero",
   "_private.Mathlib.Tactic.Ring.Basic.0.Mathlib.Tactic.Ring.cast_pos.match_1_1",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Mathlib.Tactic.Ring.cast_pos",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a : R} {n : ℕ}, Mathlib.Meta.NormNum.IsNat a n → a = n.rawCast + 0",
  "constCategory": "Theorem"},
 {"references":
  ["Exists.casesOn",
   "Nat.cast",
   "eq_of_heq",
   "LE.le",
   "Eq.symm",
   "Eq.ndrec",
   "Eq.casesOn",
   "OfNat.ofNat"],
  "name": "_private.Init.Data.Int.Order.0.Int.toNat_add.match_1_1",
  "constType":
  "∀ (motive : (a b : ℤ) → (∃ n, a = ↑n) → (∃ n, b = ↑n) → 0 ≤ a → 0 ≤ b → Prop) (a b : ℤ) (x : ∃ n, a = ↑n)\n  (x_1 : ∃ n, b = ↑n) (ha : 0 ≤ a) (hb : 0 ≤ b),\n  (∀ (w w_1 : ℕ) (ha : 0 ≤ ↑w) (hb : 0 ≤ ↑w_1), motive ↑w ↑w_1 ⋯ ⋯ ha hb) → motive a b x x_1 ha hb",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Classical.choice",
  "constType": "{α : Sort u} → Nonempty α → α",
  "constCategory": "Axiom"},
 {"references":
  ["Or.elim",
   "Lean.Omega.LinearCombo.coordinate_eval_2",
   "Nat.cast",
   "Eq.trans",
   "le_of_le_of_eq",
   "Lean.Omega.Constraint.combine_sat'",
   "Int.sub_eq_zero_of_eq",
   "GT.gt",
   "Decidable.decide",
   "Nat.lt_or_gt_of_ne",
   "Lean.Omega.Coeffs.ofList",
   "Lean.Omega.Int.ofNat_sub_dichotomy",
   "HSub.hSub",
   "Lean.Omega.tidy_sat",
   "Eq.symm",
   "Lean.Omega.LinearCombo.add_eval",
   "Int.add_one_le_of_lt",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "And.left",
   "of_decide_eq_true",
   "Not",
   "Neg.neg",
   "And.right",
   "Lean.Omega.Constraint.addInequality_sat",
   "Lean.Omega.Int.add_congr",
   "Lean.Omega.Constraint.isImpossible",
   "Lean.Omega.LinearCombo.coordinate",
   "Int.sub_nonneg_of_le",
   "OfNat.ofNat",
   "Lean.Omega.LinearCombo.coordinate_eval_1",
   "LT.lt",
   "HAdd.hAdd",
   "Lean.Omega.Int.ofNat_lt_of_lt",
   "Lean.Omega.LinearCombo.sub_eval",
   "LE.le",
   "Int.natCast_add",
   "id",
   "Lean.Omega.Constraint.addEquality_sat",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.Int.sub_congr"],
  "name": "CellularAutomatas.marker_list_inj._proof_1_3",
  "constType": "∀ {n : ℕ} {k1 : ℕ}, k1 > 0 → ¬k1 - 1 + 1 = k1 → False",
  "constCategory": "Theorem"},
 {"references": ["List.map_inj_left", "Membership.mem", "List.map", "propext"],
  "name": "List.map_inj_left._simp_1",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {l : List α} {f g : α → β}, (List.map f l = List.map g l) = ∀ a ∈ l, f a = g a",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Option.casesOn",
  "constType":
  "{α : Type u} →\n  {motive : Option α → Sort u_1} → (t : Option α) → motive none → ((val : α) → motive (some val)) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["LT.lt",
   "eq_self",
   "GetElem?.getElem?",
   "of_eq_true",
   "Option.getD",
   "List.length"],
  "name": "List.getD_eq_getElem?_getD",
  "constType":
  "∀ {α : Type u_1} {l : List α} {i : ℕ} {a : α}, l.getD i a = l[i]?.getD a",
  "constCategory": "Theorem"},
 {"references": ["LT.lt", "Not", "not_lt_of_ge", "le_of_not_gt", "LE.le"],
  "name": "not_lt",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrder α] {a b : α}, ¬a < b ↔ b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "Lean.Grind.AC.Seq.brecOn",
   "Lean.Grind.AC.Seq.insert",
   "Lean.Grind.AC.Seq.below",
   "Nat.blt",
   "ite",
   "_private.Init.Grind.AC.0.Lean.Grind.AC.Seq.erase0.match_1.congr_eq_2",
   "congrArg",
   "Lean.Grind.AC.Var",
   "_private.Init.Grind.AC.0.Lean.Grind.AC.Seq.erase0.match_1.splitter",
   "if_neg",
   "eq_of_heq",
   "id",
   "_private.Init.Grind.AC.0.Lean.Grind.AC.Seq.erase0.match_1.congr_eq_1",
   "Eq.mpr",
   "Lean.Grind.AC.Seq.erase0.match_1",
   "Lean.Grind.AC.Seq.insert.eq_def",
   "dite",
   "if_pos"],
  "name": "Lean.Grind.AC.Seq.insert.induct_unfolding",
  "constType":
  "∀ (x : Grind.AC.Var) (motive : Grind.AC.Seq → Grind.AC.Seq → Prop),\n  (∀ (x_1 : Grind.AC.Var),\n      Nat.blt x x_1 = true → motive (Grind.AC.Seq.var x_1) (Grind.AC.Seq.cons x (Grind.AC.Seq.var x_1))) →\n    (∀ (x_1 : Grind.AC.Var),\n        ¬Nat.blt x x_1 = true → motive (Grind.AC.Seq.var x_1) (Grind.AC.Seq.cons x_1 (Grind.AC.Seq.var x))) →\n      (∀ (x_1 : Grind.AC.Var) (s : Grind.AC.Seq),\n          Nat.blt x x_1 = true → motive (Grind.AC.Seq.cons x_1 s) (Grind.AC.Seq.cons x (Grind.AC.Seq.cons x_1 s))) →\n        (∀ (x_1 : Grind.AC.Var) (s : Grind.AC.Seq),\n            ¬Nat.blt x x_1 = true →\n              motive s (Grind.AC.Seq.insert x s) →\n                motive (Grind.AC.Seq.cons x_1 s) (Grind.AC.Seq.cons x_1 (Grind.AC.Seq.insert x s))) →\n          ∀ (s : Grind.AC.Seq), motive s (Grind.AC.Seq.insert x s)",
  "constCategory": "Theorem"},
 {"references": ["zero_le", "tsub_eq_zero_of_le", "OfNat.ofNat"],
  "name": "zero_tsub",
  "constType":
  "∀ {α : Type u_1} [inst : AddCommMonoid α] [inst_1 : PartialOrder α] [CanonicallyOrderedAdd α] [inst_3 : Sub α]\n  [OrderedSub α] (a : α), 0 - a = 0",
  "constCategory": "Theorem"},
 {"references": ["eq_self", "Eq.trans", "of_eq_true", "true_and", "congrArg"],
  "name": "Lean.Grind.and_eq_of_eq_true_left",
  "constType": "∀ {a b : Prop}, a = True → (a ∧ b) = b",
  "constCategory": "Theorem"},
 {"references": ["rfl", "Max.max"],
  "name": "Int.max_def",
  "constType": "∀ (n m : ℤ), max n m = if n ≤ m then m else n",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Iff.rfl",
   "Language",
   "CellularAutomatas.tCellAutomatonWithAdvice.L"],
  "name": "CellularAutomatas.tCellAutomatonWithAdvice.elem_L_iff",
  "constType":
  "∀ {α : Type} {w : List α} {O : CellularAutomatas.tCellAutomatonWithAdvice α},\n  w ∈ O.L ↔ CellularAutomatas.Advice.annotate w ∈ O.C.L",
  "constCategory": "Theorem"},
 {"references": ["LT.lt", "False.elim", "lt_irrefl"],
  "name": "lt_self_iff_false",
  "constType": "∀ {α : Type u_2} [inst : Preorder α] (x : α), x < x ↔ False",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Grind.AddCommMonoid.add_assoc",
   "Nat.cast",
   "Eq.trans",
   "Lean.Grind.Semiring.natCast_zero",
   "Eq.mp",
   "Lean.Grind.AddCommGroup.sub_self",
   "Nat.sub_self",
   "Lean.Grind.Ring.intCast_natCast_add_one",
   "Lean.Grind.Ring.intCast_natCast",
   "Lean.Grind.AddCommMonoid.add_comm",
   "Lean.Grind.Ring.sub_eq_add_neg",
   "Int.cast",
   "GE.ge",
   "congrArg",
   "_private.Init.Grind.Ring.Basic.0.Lean.Grind.Ring.intCast_nat_sub._proof_1_2",
   "Lean.Grind.AddCommMonoid.zero_add",
   "_private.Init.Grind.Ring.Basic.0.Lean.Grind.Ring.intCast_nat_sub._proof_1_1",
   "congr",
   "Lean.Grind.Ring.intCast_zero",
   "Eq.symm",
   "HSub.hSub",
   "Lean.Grind.Semiring.natCast_succ",
   "Lean.Grind.AddCommGroup.neg_zero",
   "_private.Init.Grind.Ring.Basic.0.Lean.Grind.Ring.intCast_nat_sub._proof_1_3",
   "Not",
   "Lean.Grind.Ring.intCast",
   "Neg.neg",
   "Nat.recAux",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "eq_self",
   "Decidable.byContradiction",
   "of_eq_true",
   "id",
   "Eq.mpr",
   "Lean.Grind.Semiring.natCast",
   "dite"],
  "name": "Lean.Grind.Ring.intCast_nat_sub",
  "constType":
  "∀ {α : Type u} [inst : Grind.Ring α] {x y : ℕ}, x ≥ y → ↑↑(x - y) = ↑x - ↑y",
  "constCategory": "Theorem"},
 {"references":
  ["Finset.mem_filter",
   "Membership.mem",
   "DecidablePred",
   "propext",
   "Finset.filter"],
  "name": "Finset.mem_filter._simp_1",
  "constType":
  "∀ {α : Type u_1} {p : α → Prop} [inst : DecidablePred p] {s : Finset α} {a : α}, (a ∈ Finset.filter p s) = (a ∈ s ∧ p a)",
  "constCategory": "Theorem"},
 {"references":
  ["GetElem?.getElem?",
   "_private.Lean.Environment.0.Lean.VisibilityMap.get",
   "Membership.mem",
   "Lean.Kernel.Environment.const2ModIdx",
   "_private.Lean.Environment.0.Lean.Environment.base",
   "Lean.ModuleIdx"],
  "name": "Lean.Environment.getModuleIdxFor?",
  "constType": "Environment → Name → Option ModuleIdx",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Lean.Grind.Semiring.ofNat_succ",
  "constType":
  "∀ {α : Type u} [self : Grind.Semiring α] (a : ℕ), OfNat.ofNat (a + 1) = OfNat.ofNat a + 1",
  "constCategory": "Theorem"},
 {"references":
  ["Set.univ",
   "CellularAutomatas.rel_repr",
   "CellularAutomatas.Word",
   "Set.image",
   "Nat.cast",
   "LE.le",
   "ENat",
   "Set.encard"],
  "name": "CellularAutomatas.Advice.finite_lookahead",
  "constType": "{α Γ : Type} → CellularAutomatas.Advice α Γ → Prop",
  "constCategory": "Definition"},
 {"references":
  ["DecidableEq",
   "CellularAutomatas.Alphabet.casesOn",
   "Eq.ndrec",
   "CellularAutomatas.Alphabet.noConfusionType"],
  "name": "CellularAutomatas.Alphabet.noConfusion",
  "constType":
  "{α : Type} →\n  {P : Sort u} → {x1 x2 : CellularAutomatas.Alphabet α} → x1 = x2 → CellularAutomatas.Alphabet.noConfusionType P x1 x2",
  "constCategory": "Definition"},
 {"references":
  ["Eq.trans",
   "HMul.hMul",
   "congrArg",
   "Int.beq'_eq",
   "congr",
   "Eq.symm",
   "Int.beq'",
   "Bool.cond_eq_ite",
   "Not",
   "ite",
   "Lean.Grind.CommRing.Poly.mulConst.go",
   "Decidable.casesOn",
   "cond",
   "OfNat.ofNat",
   "Lean.Grind.CommRing.Poly.mulConst_k",
   "ite_congr",
   "beq_iff_eq._simp_1",
   "eq_self",
   "Bool.not_eq_true",
   "if_neg",
   "of_eq_true",
   "id",
   "Eq.mpr",
   "BEq.beq",
   "if_pos",
   "Lean.Grind.CommRing.Poly.mulConst"],
  "name": "Lean.Grind.CommRing.Poly.mulConst_k_eq_mulConst",
  "constType":
  "∀ (k : ℤ) (p : Grind.CommRing.Poly), Grind.CommRing.Poly.mulConst_k k p = Grind.CommRing.Poly.mulConst k p",
  "constCategory": "Theorem"},
 {"references": ["Subtype.property", "Classical.indefiniteDescription"],
  "name": "Classical.choose_spec",
  "constType":
  "∀ {α : Sort u} {p : α → Prop} (h : ∃ x, p x), p (Classical.choose h)",
  "constCategory": "Theorem"},
 {"references": ["rfl"],
  "name": "List.getLast._proof_1",
  "constType": "∀ {α : Type u_1}, [] = []",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt", "List.range", "List.mem_range", "Membership.mem", "propext"],
  "name": "List.mem_range._simp_1",
  "constType": "∀ {m n : ℕ}, (m ∈ List.range n) = (m < n)",
  "constCategory": "Theorem"},
 {"references": ["Int.negOfNat.match_1", "HSub.hSub", "Unit"],
  "name": "Int.subNatNat",
  "constType": "ℕ → ℕ → ℤ",
  "constCategory": "Definition"},
 {"references":
  ["Or.elim",
   "Lean.Omega.LinearCombo.coordinate_eval_2",
   "Nat.cast",
   "Eq.trans",
   "Lean.Omega.Decidable.or_not_not_of_not_and",
   "le_of_le_of_eq",
   "Classical.propDecidable",
   "Lean.Omega.LinearCombo.coordinate_eval_0",
   "Lean.Omega.Constraint.combine_sat'",
   "Decidable.decide",
   "Lean.Omega.LinearCombo.neg_eval",
   "Lean.Omega.Coeffs.ofList",
   "Eq.symm",
   "Lean.Omega.tidy_sat",
   "HSub.hSub",
   "Lean.Omega.LinearCombo.add_eval",
   "Lean.Omega.Int.lt_of_not_le",
   "Lean.Omega.Int.neg_congr",
   "Int.add_one_le_of_lt",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "And.left",
   "of_decide_eq_true",
   "Not",
   "CellularAutomatas.Word",
   "Neg.neg",
   "And.right",
   "Lean.Omega.Constraint.addInequality_sat",
   "Lean.Omega.Int.add_congr",
   "Lean.Omega.Constraint.isImpossible",
   "Lean.Omega.Int.le_of_not_lt",
   "Lean.Omega.LinearCombo.coordinate",
   "OfNat.ofNat",
   "Int.sub_nonneg_of_le",
   "Lean.Omega.LinearCombo.coordinate_eval_1",
   "HAdd.hAdd",
   "LT.lt",
   "Lean.Omega.LinearCombo.sub_eval",
   "LE.le",
   "id",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.Int.sub_congr",
   "List.length"],
  "name": "CellularAutomatas.Word.cone_prop''._proof_1_2",
  "constType":
  "∀ {α : Type u_1} {w : CellularAutomatas.Word α} {t : ℕ} {i : ℤ},\n  -↑t ≤ i ∧ i < ↑(List.length w) + ↑t → ¬(-1 + -↑t ≤ i ∧ i < ↑(List.length w) + (↑t + 1)) → False",
  "constCategory": "Theorem"},
 {"references": ["Not", "Decidable.casesOn"],
  "name": "Decidable.byCases.match_1",
  "constType":
  "{p : Prop} →\n  (motive : Decidable p → Sort u_1) →\n    (dec : Decidable p) → ((h : p) → motive (isTrue h)) → ((h : ¬p) → motive (isFalse h)) → motive dec",
  "constCategory": "Definition"},
 {"references": ["LT.lt", "HAdd.hAdd", "Function.swap"],
  "name": "AddRightStrictMono",
  "constType": "(M : Type u_1) → [Add M] → [LT M] → Prop",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "CellularAutomatas.FiniteStateTransducer.scanr_q_len",
   "Eq.trans",
   "of_eq_true",
   "CellularAutomatas.FiniteStateTransducer.scanr_q",
   "CellularAutomatas.FiniteStateTransducer.q0",
   "congrArg",
   "List.length"],
  "name": "CellularAutomatas.FiniteStateTransducer.scanr_len",
  "constType":
  "∀ {α β : Type} (M : CellularAutomatas.FiniteStateTransducer α β) (w : List α), List.length (M.scanr w) = w.length",
  "constCategory": "Theorem"},
 {"references": ["rfl"],
  "name": "Int.ofNat_eq_natCast",
  "constType": "∀ (n : ℕ), Int.ofNat n = ↑n",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.FiniteStateTransducer.noConfusionType",
   "CellularAutomatas.FiniteStateTransducer.casesOn",
   "Eq.ndrec"],
  "name": "CellularAutomatas.FiniteStateTransducer.noConfusion",
  "constType":
  "{α β : Type} →\n  {P : Sort u} →\n    {x1 x2 : CellularAutomatas.FiniteStateTransducer α β} →\n      x1 = x2 → CellularAutomatas.FiniteStateTransducer.noConfusionType P x1 x2",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CellularAutomatas.FiniteStateTransducer.recOn",
  "constType":
  "{α β : Type} →\n  {motive : CellularAutomatas.FiniteStateTransducer α β → Sort u} →\n    (t : CellularAutomatas.FiniteStateTransducer α β) →\n      ((Q : Type) →\n          [alphabetQ : CellularAutomatas.Alphabet Q] →\n            (δ : Q → α → Q) →\n              (q0 : Q) → (f : Q → β) → motive { Q := Q, alphabetQ := alphabetQ, δ := δ, q0 := q0, f := f }) →\n        motive t",
  "constCategory": "Definition"},
 {"references": ["Eq.mp", "Eq.mpr_prop"],
  "name": "Lean.Grind.intro_with_eq'",
  "constType":
  "(p p' : Prop) → (q : p → Sort u) → (he : p = p') → ((h : p') → q ⋯) → (h : p) → q h",
  "constCategory": "Definition"},
 {"references": ["List.getLast?.match_1", "Unit"],
  "name": "List.isEmpty",
  "constType": "{α : Type u} → List α → Bool",
  "constCategory": "Definition"},
 {"references": ["Or.casesOn", "Not"],
  "name": "_private.Init.Core.0.Decidable.not_and_iff_or_not.match_1_3",
  "constType":
  "∀ {p q : Prop} (motive : ¬p ∨ ¬q → Prop) (h : ¬p ∨ ¬q), (∀ (h : ¬p), motive ⋯) → (∀ (h : ¬q), motive ⋯) → motive h",
  "constCategory": "Definition"},
 {"references": ["LE.le"],
  "name": "Nat.le_succ_of_le",
  "constType": "∀ {n m : ℕ}, n ≤ m → n ≤ m.succ",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.find_eq_zero", "Nat.find", "DecidablePred", "OfNat.ofNat", "propext"],
  "name": "Nat.find_eq_zero._simp_1",
  "constType":
  "∀ {p : ℕ → Prop} [inst : DecidablePred p] (h : ∃ n, p n), (Nat.find h = 0) = p 0",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Omega.IntList.combo",
   "Lean.Omega.IntList.nil_add",
   "Eq.trans",
   "Int.zero_add",
   "HMul.hMul",
   "Int.add_zero",
   "congrArg",
   "Lean.Omega.IntList",
   "congr",
   "funext",
   "Eq.symm",
   "Eq.ndrec",
   "Lean.Omega.IntList.cons_add_cons",
   "List.casesOn",
   "List.map",
   "Option.getD",
   "List.zipWithAll_nil",
   "true_and",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "Int.mul_zero",
   "eq_self",
   "of_eq_true",
   "List.cons.injEq",
   "id",
   "Eq.mpr",
   "Lean.Omega.IntList.add_nil",
   "List.zipWithAll"],
  "name": "Lean.Omega.IntList.combo_eq_smul_add_smul",
  "constType":
  "∀ (a : ℤ) (xs : Omega.IntList) (b : ℤ) (ys : Omega.IntList), Omega.IntList.combo a xs b ys = a * xs + b * ys",
  "constCategory": "Theorem"},
 {"references": ["rfl", "HSub.hSub"],
  "name": "Int.sub_eq_add_neg",
  "constType": "∀ {a b : ℤ}, a - b = a + -b",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "HEq.casesOn",
  "constType":
  "{α : Sort u} →\n  {a : α} →\n    {motive : {β : Sort u} → (a_1 : β) → a ≍ a_1 → Sort u_1} →\n      {β : Sort u} → {a_1 : β} → (t : a ≍ a_1) → motive a ⋯ → motive a_1 t",
  "constCategory": "Definition"},
 {"references":
  ["Nat.cast",
   "Eq.trans",
   "le_of_le_of_eq",
   "Int.negSucc_eq",
   "Lean.Omega.Constraint.combine_sat'",
   "Lean.Omega.LinearCombo.coordinate_eval_0",
   "Decidable.decide",
   "Lean.Omega.LinearCombo.neg_eval",
   "Lean.Omega.Coeffs.ofList",
   "Lean.Omega.tidy_sat",
   "Eq.symm",
   "HSub.hSub",
   "Lean.Omega.LinearCombo.add_eval",
   "Lean.Omega.Int.neg_congr",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "of_decide_eq_true",
   "Not",
   "Lean.Omega.combo_sat'",
   "Neg.neg",
   "Lean.Omega.Constraint.addInequality_sat",
   "Lean.Omega.Int.add_congr",
   "Lean.Omega.Constraint.isImpossible",
   "Lean.Omega.Int.le_of_not_lt",
   "Lean.Omega.LinearCombo.coordinate",
   "OfNat.ofNat",
   "Int.ofNat_nonneg",
   "Int.sub_nonneg_of_le",
   "Lean.Omega.LinearCombo.coordinate_eval_1",
   "HAdd.hAdd",
   "LT.lt",
   "Lean.Omega.LinearCombo.sub_eval",
   "id",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.Int.sub_congr"],
  "name": "_private.Init.Data.Int.LemmasAux.0.Int.ble'_eq_true._proof_1_2",
  "constType": "∀ (a a_1 : ℕ), ¬Int.negSucc a_1 < ↑a → False",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "LocallyFiniteOrder.finset_mem_Icc",
  "constType":
  "∀ {α : Type u_1} {inst : Preorder α} [self : LocallyFiniteOrder α] (a b x : α),\n  x ∈ LocallyFiniteOrder.finsetIcc a b ↔ a ≤ x ∧ x ≤ b",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Grind.CommRing.Poly.combine.go", "Lean.Grind.CommRing.hugeFuel"],
  "name": "Lean.Grind.CommRing.Poly.combine",
  "constType":
  "Grind.CommRing.Poly → Grind.CommRing.Poly → Grind.CommRing.Poly",
  "constCategory": "Definition"},
 {"references": ["CellularAutomatas.Word", "List.casesOn", "Unit.unit", "Unit"],
  "name": "CellularAutomatas.FiniteStateTransducer.scanr_reduce_q.match_1",
  "constType":
  "{α : Type} →\n  (motive : CellularAutomatas.Word α → Sort u_1) →\n    (x : CellularAutomatas.Word α) → (Unit → motive []) → ((c : α) → (cs : List α) → motive (c :: cs)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["LT.lt",
   "GetElem?.getElem?",
   "Iff.mp",
   "GetElem.getElem",
   "List.getElem?_eq_some_iff",
   "List.length"],
  "name": "List.getElem_of_getElem?",
  "constType":
  "∀ {α : Type u_1} {i : ℕ} {a : α} {l : List α}, l[i]? = some a → ∃ (h : i < l.length), l[i] = a",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "GetElem?.getElem?",
   "dif_pos",
   "id",
   "LawfulGetElem.getElem?_def",
   "GetElem.getElem",
   "Eq.mpr",
   "dite",
   "congrArg"],
  "name": "getElem?_pos",
  "constType":
  "∀ {cont : Type u_1} {idx : Type u_2} {elem : Type u_3} {dom : cont → idx → Prop} [inst : GetElem? cont idx elem dom]\n  [LawfulGetElem cont idx elem dom] (c : cont) (i : idx) (h : dom c i), c[i]? = some c[i]",
  "constCategory": "Theorem"},
 {"references":
  ["eq_false",
   "Membership.mem",
   "Multiset.notMem_zero",
   "Multiset",
   "OfNat.ofNat"],
  "name": "Multiset.notMem_zero._simp_1",
  "constType": "∀ {α : Type u_1} (a : α), (a ∈ 0) = False",
  "constCategory": "Theorem"},
 {"references": ["rfl", "Eq.symm"],
  "name": "forall_eq",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {a' : α}, (∀ (a : α), a = a' → p a) ↔ p a'",
  "constCategory": "Theorem"},
 {"references": ["Min.min", "LE.le", "le_inf_iff", "propext"],
  "name": "le_inf_iff._simp_1",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeInf α] {a b c : α}, (a ≤ b ⊓ c) = (a ≤ b ∧ a ≤ c)",
  "constCategory": "Theorem"},
 {"references": ["LT.lt"],
  "name": "Fin.casesOn",
  "constType":
  "{n : ℕ} → {motive : Fin n → Sort u} → (t : Fin n) → ((val : ℕ) → (isLt : val < n) → motive ⟨val, isLt⟩) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["CellularAutomatas.Advice.f",
   "eq_self",
   "CellularAutomatas.Word",
   "CellularAutomatas.TwoStageAdvice.C",
   "CellularAutomatas.CArtTransducer.advice",
   "of_eq_true",
   "CellularAutomatas.TwoStageAdvice.β",
   "CellularAutomatas.FiniteStateTransducer.advice",
   "Function.comp",
   "CellularAutomatas.TwoStageAdvice.M"],
  "name": "CellularAutomatas.TwoStageAdvice.advice_eq",
  "constType":
  "∀ {Γ α : Type} [inst : CellularAutomatas.Alphabet Γ] [inst_1 : CellularAutomatas.Alphabet α]\n  (t : CellularAutomatas.TwoStageAdvice α Γ), CellularAutomatas.TwoStageAdvice.advice.f = t.M.advice.f ∘ t.C.advice.f",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans",
   "of_eq_true",
   "Min.min",
   "List.take",
   "LE.le",
   "List.length_take",
   "_private.Init.Data.List.Nat.TakeDrop.0.List.length_take_le'._simp_1_1",
   "congrArg",
   "List.length"],
  "name": "List.length_take_le'",
  "constType":
  "∀ {α : Type u_1} (i : ℕ) (l : List α), (List.take i l).length ≤ l.length",
  "constCategory": "Theorem"},
 {"references": ["Language", "CellularAutomatas.tCellAutomatonWithAdvice.L"],
  "name": "CellularAutomatas.tCellAutomatonWithAdvice.L.eq_1",
  "constType":
  "∀ {α : Type} (C : CellularAutomatas.tCellAutomatonWithAdvice α), C.L = {w | C.C.L (CellularAutomatas.Advice.annotate w)}",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.simulation.Params.C_ctl",
   "CellularAutomatas.simulation.instInhabitedQ1.default._proof_1",
   "CellularAutomatas.CellAutomaton.Q",
   "OfNat.ofNat",
   "Inhabited.default"],
  "name": "CellularAutomatas.simulation.instInhabitedQ1.default",
  "constType":
  "{a : CellularAutomatas.simulation.Params} → CellularAutomatas.simulation.Q1 a",
  "constCategory": "Definition"},
 {"references":
  ["Multiset.mem_cons",
   "Membership.mem",
   "Multiset.cons",
   "Multiset",
   "propext"],
  "name": "Multiset.mem_cons._simp_1",
  "constType":
  "∀ {α : Type u_1} {a b : α} {s : Multiset α}, (a ∈ b ::ₘ s) = (a = b ∨ a ∈ s)",
  "constCategory": "Theorem"},
 {"references": ["outParam"],
  "name": "CellularAutomatas.DefinesLanguage.ctorIdx",
  "constType":
  "{CA : Sort u_1} → {α : outParam Type} → CellularAutomatas.DefinesLanguage CA α → ℕ",
  "constCategory": "Definition"},
 {"references": ["Set", "funext", "Membership.mem", "propext"],
  "name": "Set.ext",
  "constType":
  "∀ {α : Type u} {a b : Set α}, (∀ (x : α), x ∈ a ↔ x ∈ b) → a = b",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "_private.Lean.Environment.0.Lean.Environment.base",
  "constType": "Environment → Lean.VisibilityMap✝ Kernel.Environment",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Grind.AC.Var",
   "Lean.Grind.AC.Expr.toSeq'.match_1",
   "Lean.Grind.AC.Expr.brecOn",
   "Lean.Grind.AC.Expr.below",
   "Lean.Grind.AC.Expr.toSeq'"],
  "name": "Lean.Grind.AC.Expr.toSeq",
  "constType": "Grind.AC.Expr → Grind.AC.Seq",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CellularAutomatas.tCellAutomatonWithAdvice.Γ",
  "constType":
  "{α : Type} → CellularAutomatas.tCellAutomatonWithAdvice α → Type",
  "constCategory": "Definition"},
 {"references":
  ["absurd",
   "Not",
   "rfl",
   "_private.Init.Prelude.0.decide_eq_true.match_1_1",
   "Decidable.decide"],
  "name": "decide_eq_true",
  "constType": "∀ {p : Prop} [inst : Decidable p], p → decide p = true",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "CellularAutomatas.CellAutomaton.Q",
   "Ne",
   "CellularAutomatas.LCellAutomaton.embed"],
  "name": "CellularAutomatas.LCellAutomaton.internal_state",
  "constType":
  "{α : Type} → (C : CellularAutomatas.LCellAutomaton α) → C.Q → Prop",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CellularAutomatas.tCellAutomatonWithAdvice.alphabetΓ",
  "constType":
  "{α : Type} → (self : CellularAutomatas.tCellAutomatonWithAdvice α) → CellularAutomatas.Alphabet self.Γ",
  "constCategory": "Definition"},
 {"references": ["Option.some.noConfusion"],
  "name": "Option.some.inj",
  "constType":
  "∀ {α : Type u} {val val_1 : α}, some val = some val_1 → val = val_1",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.CellAutomaton.δ",
   "CellularAutomatas.CArtTransducer.toLCellAutomaton",
   "CellularAutomatas.backwards_fsm.Params.β",
   "CellularAutomatas.backwards_fsm.Params.C",
   "CellularAutomatas.backwards_fsm.Params.inst3",
   "CellularAutomatas.backwards_fsm.Params.M",
   "CellularAutomatas.FiniteStateTransducer.Q",
   "CellularAutomatas.FiniteStateTransducer.δ?",
   "Option.getD",
   "CellularAutomatas.backwards_fsm.Params.inst2",
   "CellularAutomatas.backwards_fsm.Params.γ",
   "Inhabited.default",
   "CellularAutomatas.LCellAutomaton.embed",
   "CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "CellularAutomatas.CellAutomaton.Q",
   "CellularAutomatas.LCellAutomaton.border",
   "CellularAutomatas.backwards_fsm.Params.α",
   "CellularAutomatas.backwards_fsm.C'.match_1",
   "CellularAutomatas.FiniteStateTransducer.f"],
  "name": "CellularAutomatas.backwards_fsm.C'",
  "constType":
  "(e : CellularAutomatas.backwards_fsm.Params) → CellularAutomatas.CArtTransducer e.α (e.α ⨉ (e.M.Q → e.C.Q))",
  "constCategory": "Definition"},
 {"references": ["HAdd.hAdd"],
  "name": "Int.natCast_nonneg",
  "constType": "∀ (n : ℕ), 0 ≤ ↑n",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CellularAutomatas.TwoStageAdvice.β",
  "constType":
  "{α Γ : Type} →\n  [inst : CellularAutomatas.Alphabet α] →\n    [inst_1 : CellularAutomatas.Alphabet Γ] → CellularAutomatas.TwoStageAdvice α Γ → Type",
  "constCategory": "Definition"},
 {"references":
  ["LT.lt",
   "GetElem?.getElem?",
   "Lean.Omega.IntList",
   "Option.getD",
   "OfNat.ofNat",
   "List.length"],
  "name": "Lean.Omega.IntList.get",
  "constType": "Omega.IntList → ℕ → ℤ",
  "constCategory": "Definition"},
 {"references": [],
  "name": "EmptyCollection.emptyCollection",
  "constType": "{α : Type u} → [self : EmptyCollection α] → α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Array.toList",
  "constType": "{α : Type u} → Array α → List α",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Grind.Order.lt_le_trans",
   "Lean.Grind.Ring.intCast",
   "_private.Init.Grind.Order.0.Lean.Grind.Order.lt_le_trans_k._simp_1_1",
   "Lean.Grind.OrderedAdd.add_le_left_iff",
   "Eq.trans",
   "Eq.mp",
   "Iff.mp",
   "eq_true",
   "Int.cast",
   "congrArg",
   "beq_iff_eq._simp_1",
   "LT.lt",
   "HAdd.hAdd",
   "Lean.Grind.Ring.intCast_add",
   "of_eq_true",
   "LE.le",
   "Eq.symm",
   "BEq.beq",
   "Eq.ndrec"],
  "name": "Lean.Grind.Order.lt_le_trans_k",
  "constType":
  "∀ {α : Type u_1} [inst : LE α] [inst_1 : LT α] [LawfulOrderLT α] [inst_3 : Std.IsPreorder α] [inst_4 : Grind.Ring α]\n  [Grind.OrderedRing α] {a b c : α} {k₁ k₂ : ℤ} (k : ℤ), a < b + ↑k₁ → b ≤ c + ↑k₂ → (k == k₂ + k₁) = true → a < c + ↑k",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "Eq.trans",
   "eq_true",
   "Std.IsLinearPreorder.le_total",
   "congrArg",
   "LT.lt",
   "Or.casesOn",
   "and_self",
   "not_false_eq_true",
   "False.elim",
   "of_eq_true",
   "eq_false",
   "congr",
   "LE.le",
   "id",
   "Eq.mpr",
   "Std.LawfulOrderLT.lt_iff",
   "propext"],
  "name": "Lean.Grind.Order.lt_of_not_le",
  "constType":
  "∀ {α : Type u_1} [inst : LE α] [inst_1 : LT α] [LawfulOrderLT α] [IsLinearPreorder α] {a b : α}, ¬a ≤ b → b < a",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans",
   "le_of_le_of_eq",
   "Lean.Omega.LinearCombo.coordinate_eval_3",
   "GE.ge",
   "Lean.Omega.Int.ofNat_le_of_le",
   "HSub.hSub",
   "Lean.Omega.tidy_sat",
   "Eq.symm",
   "Lean.Omega.ite_disjunction",
   "Lean.Omega.LinearCombo.add_eval",
   "Int.add_one_le_of_lt",
   "And.left",
   "Lean.Omega.combo_sat'",
   "Neg.neg",
   "And.right",
   "Lean.Omega.Constraint.addInequality_sat",
   "Lean.Omega.Int.le_of_not_lt",
   "Lean.Omega.LinearCombo.coordinate",
   "Nat.lt_of_not_le",
   "id",
   "Lean.Omega.Constraint.addEquality_sat",
   "Lean.Omega.Int.sub_congr",
   "Int.toNat_eq_max",
   "List.length",
   "Int.toNat",
   "Or.elim",
   "Nat.cast",
   "Lean.Omega.LinearCombo.coordinate_eval_2",
   "Lean.Omega.Constraint.combine_sat'",
   "Lean.Omega.LinearCombo.coordinate_eval_0",
   "Int.sub_eq_zero_of_eq",
   "Decidable.decide",
   "Lean.Omega.Coeffs.ofList",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "of_decide_eq_true",
   "Not",
   "CellularAutomatas.Word",
   "ite",
   "Lean.Omega.Int.add_congr",
   "Lean.Omega.Constraint.isImpossible",
   "OfNat.ofNat",
   "Int.sub_nonneg_of_le",
   "Int.ofNat_nonneg",
   "LT.lt",
   "HAdd.hAdd",
   "Lean.Omega.LinearCombo.coordinate_eval_1",
   "Max.max",
   "Lean.Omega.Int.ofNat_lt_of_lt",
   "Lean.Omega.LinearCombo.sub_eval",
   "Int.max_def",
   "LE.le",
   "Lean.Omega.LinearCombo.eval"],
  "name": "CellularAutomatas.FiniteStateTransducer.scanr_reduce'?._proof_1_7",
  "constType":
  "∀ {α : Type} (w : CellularAutomatas.Word α) (i : ℤ),\n  ¬i < 0 → i.toNat ≥ List.length w → ¬(i + 1).toNat ≥ List.length w → False",
  "constCategory": "Theorem"},
 {"references": ["Int.mul", "Int.beq'", "OfNat.ofNat", "Int.Linear.Var"],
  "name": "Int.Linear.Poly.mul_k",
  "constType": "Int.Linear.Poly → ℤ → Int.Linear.Poly",
  "constCategory": "Definition"},
 {"references":
  ["HAdd.hAdd",
   "Eq.mp",
   "Nat.zero_add",
   "Nat.add_sub_add_right",
   "id",
   "HSub.hSub",
   "Eq.mpr",
   "Nat.sub_zero",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Nat.add_sub_cancel",
  "constType": "∀ (n m : ℕ), n + m - m = n",
  "constCategory": "Theorem"},
 {"references": ["Std.TreeMap.inner", "Std.DTreeMap.contains"],
  "name": "Std.TreeMap.contains",
  "constType":
  "{α : Type u} → {β : Type v} → {cmp : α → α → Ordering} → TreeMap α β cmp → α → Bool",
  "constCategory": "Definition"},
 {"references":
  ["CellularAutomatas.FiniteStateTransducer.scanr_get'_eq2.match_1_1",
   "Fin.is_lt._simp_1",
   "CellularAutomatas.FiniteStateTransducer.scanr_len",
   "Eq.trans",
   "GetElem.getElem.congr_simp",
   "GetElem.getElem",
   "CellularAutomatas.FiniteStateTransducer.scanr_reduce",
   "congrArg",
   "Fin.val",
   "Eq.ndrec",
   "CellularAutomatas.FiniteStateTransducer.δ",
   "CellularAutomatas.Word",
   "List.drop",
   "Nat.lt_of_succ_lt_succ",
   "CellularAutomatas.FiniteStateTransducer.scanr",
   "OfNat.ofNat",
   "LT.lt",
   "HAdd.hAdd",
   "of_eq_true",
   "id",
   "Eq.mpr",
   "CellularAutomatas.FiniteStateTransducer.f",
   "List.length",
   "Fin.elim0",
   "CellularAutomatas.FiniteStateTransducer.scanr_cons"],
  "name": "CellularAutomatas.FiniteStateTransducer.scanr_get'_eq2",
  "constType":
  "∀ {α β : Type} {M : CellularAutomatas.FiniteStateTransducer α β} (w : CellularAutomatas.Word α)\n  (i : Fin (List.length w)), (M.scanr w)[i] = M.f (M.scanr_reduce w⟦↑i..*⟧)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CellularAutomatas.backwards_fsm.Params.mk",
  "constType":
  "{α β γ : Type} →\n  [inst1 : CellularAutomatas.Alphabet α] →\n    [inst2 : CellularAutomatas.Alphabet β] →\n      [inst3 : CellularAutomatas.Alphabet γ] →\n        CellularAutomatas.FiniteStateTransducer α β →\n          CellularAutomatas.CArtTransducer β γ → CellularAutomatas.backwards_fsm.Params",
  "constCategory": "Other"},
 {"references":
  ["HAdd.hAdd",
   "eq_self",
   "Eq.trans",
   "of_eq_true",
   "OfNat.ofNat",
   "congrArg",
   "List.length"],
  "name": "List.Perm.length_eq",
  "constType":
  "∀ {α : Type u_1} {l₁ l₂ : List α}, l₁.Perm l₂ → l₁.length = l₂.length",
  "constCategory": "Theorem"},
 {"references": ["LE.le", "Nat.zero_le", "eq_true", "OfNat.ofNat"],
  "name": "_private.Init.Data.List.Nat.Range.0.List.mem_range._simp_1_1",
  "constType": "∀ (n : ℕ), (0 ≤ n) = True",
  "constCategory": "Theorem"},
 {"references": ["Lean.Grind.AC.Var"],
  "name": "Lean.Grind.AC.Seq.below",
  "constType":
  "{motive : Grind.AC.Seq → Sort u} → Grind.AC.Seq → Sort (max 1 u)",
  "constCategory": "Definition"},
 {"references": ["Bool.not", "Bool.not_eq_eq_eq_not", "propext"],
  "name": "Bool.not_eq_eq_eq_not._simp_1",
  "constType": "∀ {a b : Bool}, ((!a) = b) = (a = !b)",
  "constCategory": "Theorem"},
 {"references": ["CellularAutomatas.apply_iterated"],
  "name": "CellularAutomatas.apply_iterated.eq_1",
  "constType":
  "∀ {α : Sort u_1} (f : α → α) (a : α) (k : ℕ), CellularAutomatas.apply_iterated f a k = f^[k] a",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "LT.lt",
   "CellularAutomatas.Word",
   "Nat.cast",
   "Neg.neg",
   "LE.le",
   "List.length",
   "setOf"],
  "name": "CellularAutomatas.Word.cone",
  "constType": "{α : Type u_1} → CellularAutomatas.Word α → ℕ → Set ℤ",
  "constCategory": "Definition"},
 {"references": ["OfNat.ofNat"],
  "name": "Int.Linear.hugeFuel",
  "constType": "ℕ",
  "constCategory": "Definition"},
 {"references": ["eq_iff_iff", "propext"],
  "name": "eq_iff_iff._simp_1",
  "constType": "∀ {a b : Prop}, (a = b) = (a ↔ b)",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "implies_congr",
   "imp_self._simp_1",
   "Eq.trans",
   "iff_true",
   "noConfusion_of_Nat",
   "eq_false'",
   "eq_iff_iff._simp_1",
   "iff_false",
   "congrArg",
   "beq_iff_eq._simp_1",
   "eq_self",
   "Bool.casesOn",
   "False.elim",
   "of_eq_true",
   "Int.beq'_eq",
   "congr",
   "Eq.symm",
   "not_true_eq_false",
   "Int.beq'",
   "BEq.beq",
   "Eq.ndrec",
   "Bool.ctorIdx"],
  "name": "Int.beq'_eq_beq",
  "constType": "∀ (a b : ℤ), a.beq' b = (a == b)",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons_ne_nil",
   "List.getLast",
   "List.getLast_eq_getElem._proof_3",
   "List.getLast_eq_getElem",
   "GetElem.getElem",
   "List.getElem_cons_length._proof_1",
   "Eq.casesOn",
   "OfNat.ofNat",
   "congrArg",
   "LT.lt",
   "eq_of_heq",
   "Eq.symm",
   "HSub.hSub",
   "id",
   "Eq.mpr",
   "Eq.ndrec",
   "List.length"],
  "name": "List.getElem_cons_length",
  "constType":
  "∀ {α : Type u_1} {x : α} {xs : List α} {i : ℕ} (h : i = xs.length), (x :: xs)[i] = (x :: xs).getLast ⋯",
  "constCategory": "Theorem"},
 {"references":
  ["Or.casesOn",
   "Not",
   "if_neg",
   "ite",
   "Eq.symm",
   "id",
   "Eq.mpr",
   "Decidable.em",
   "Eq.ndrec",
   "if_pos",
   "congrArg"],
  "name": "ite_congr",
  "constType":
  "∀ {α : Sort u_1} {b c : Prop} {x y u v : α} {s : Decidable b} [inst : Decidable c],\n  b = c → (c → x = u) → (¬c → y = v) → (if b then x else y) = if c then u else v",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "False.elim",
   "Nat.ctorIdx",
   "noConfusion_of_Nat",
   "Nat.le.casesOn",
   "Eq.ndrec",
   "Eq.casesOn",
   "OfNat.ofNat",
   "List.length"],
  "name":
  "_private.Init.Data.List.Lemmas.0.List.ne_nil_of_length_pos.match_1_1",
  "constType":
  "∀ {α : Type u_1} (motive : (l : List α) → 0 < l.length → l = [] → Prop) (l : List α) (x : 0 < l.length) (x_1 : l = []),\n  motive l x x_1",
  "constCategory": "Definition"},
 {"references":
  ["Monotone.strictMono_of_injective",
   "AddLeftMono",
   "Nat.cast_injective",
   "Nat.cast",
   "Nat.mono_cast"],
  "name": "Nat.strictMono_cast",
  "constType":
  "∀ {α : Type u_1} [inst : AddMonoidWithOne α] [inst_1 : PartialOrder α] [AddLeftMono α] [ZeroLEOneClass α] [CharZero α],\n  StrictMono Nat.cast",
  "constCategory": "Theorem"},
 {"references":
  ["_private.Init.Data.Int.Linear.0.Int.Linear.Poly.denote.match_1.congr_eq_2",
   "Int.Linear.Poly.denote.match_1",
   "congrArg",
   "HAdd.hAdd",
   "_private.Init.Data.Int.Linear.0.Int.Linear.Poly.denote.match_1.congr_eq_1",
   "Int.Linear.Poly.brecOn",
   "eq_of_heq",
   "Int.Linear.Poly.addConst.eq_def",
   "id",
   "Eq.mpr",
   "Int.Linear.Poly.addConst",
   "_private.Init.Data.Int.Linear.0.Int.Linear.Poly.denote.match_1.splitter",
   "Int.Linear.Var",
   "Int.Linear.Poly.below"],
  "name": "Int.Linear.Poly.addConst.induct_unfolding",
  "constType":
  "∀ (k : ℤ) (motive : Int.Linear.Poly → Int.Linear.Poly → Prop),\n  (∀ (k_1 : ℤ), motive (Int.Linear.Poly.num k_1) (Int.Linear.Poly.num (k + k_1))) →\n    (∀ (k_1 : ℤ) (v : Int.Linear.Var) (p : Int.Linear.Poly),\n        motive p (p.addConst k) → motive (Int.Linear.Poly.add k_1 v p) (Int.Linear.Poly.add k_1 v (p.addConst k))) →\n      ∀ (p : Int.Linear.Poly), motive p (p.addConst k)",
  "constCategory": "Theorem"},
 {"references": ["Lean.SourceInfo.getPos?", "Lean.Syntax.getHeadInfo"],
  "name": "Lean.Syntax.getPos?",
  "constType": "Syntax → optParam Bool false → Option String.Pos.Raw",
  "constCategory": "Definition"},
 {"references": ["LT.lt", "Nat.cast", "Iff.mpr", "Int.ofNat_lt"],
  "name": "Lean.Omega.Int.ofNat_lt_of_lt",
  "constType": "∀ {x y : ℕ}, x < y → ↑x < ↑y",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Lean.SMap.map₂",
  "constType":
  "{α : Type u} → {β : Type v} → [inst : BEq α] → [inst_1 : Hashable α] → SMap α β → PHashMap α β",
  "constCategory": "Definition"},
 {"references":
  ["And.right", "_private.Init.PropLemmas.0.forall_and.match_1_1", "And.left"],
  "name": "forall_and",
  "constType":
  "∀ {α : Sort u_1} {p q : α → Prop}, (∀ (x : α), p x ∧ q x) ↔ (∀ (x : α), p x) ∧ ∀ (x : α), q x",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "inferInstance",
  "constType": "{α : Sort u} → [i : α] → α",
  "constCategory": "Definition"},
 {"references": ["outParam"],
  "name": "LawfulGetElem.getElem?_def",
  "constType":
  "∀ {cont : Type u} {idx : Type v} {elem : outParam (Type w)} {dom : outParam (cont → idx → Prop)}\n  {ge : GetElem? cont idx elem dom} [self : LawfulGetElem cont idx elem dom] (c : cont) (i : idx)\n  [inst : Decidable (dom c i)], c[i]? = if h : dom c i then some c[i] else none",
  "constCategory": "Theorem"},
 {"references":
  ["Prod.casesOn",
   "CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "CellularAutomatas.CArtTransducer.toLCellAutomaton",
   "CellularAutomatas.backwards_fsm.Params.C",
   "CellularAutomatas.backwards_fsm.Params.β",
   "CellularAutomatas.backwards_fsm.Params.inst3",
   "CellularAutomatas.backwards_fsm.Params.M",
   "CellularAutomatas.FiniteStateTransducer.Q",
   "CellularAutomatas.CellAutomaton.Q",
   "CellularAutomatas.backwards_fsm.Params.inst2",
   "CellularAutomatas.backwards_fsm.Params.α",
   "CellularAutomatas.backwards_fsm.Params.γ"],
  "name": "CellularAutomatas.backwards_fsm.C'.match_1",
  "constType":
  "(e : CellularAutomatas.backwards_fsm.Params) →\n  (motive : Option e.α ⨉ (e.M.Q → e.C.Q) → Sort u_1) →\n    (x : Option e.α ⨉ (e.M.Q → e.C.Q)) → ((ar : Option e.α) → (fr : e.M.Q → e.C.Q) → motive (ar, fr)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["CellularAutomatas.Word",
   "CellularAutomatas.FiniteStateTransducer.scanr_foldr_state",
   "CellularAutomatas.FiniteStateTransducer.comp",
   "Eq.trans",
   "CellularAutomatas.FiniteStateTransducer.scanr_q",
   "CellularAutomatas.FiniteStateTransducer.Q",
   "and_true",
   "Prod.snd",
   "congrArg",
   "Prod.fst",
   "List.foldr",
   "CellularAutomatas.FiniteStateTransducer.scanr_reduce_q",
   "CellularAutomatas.FiniteStateTransducer.comp_scanr_reduce_q",
   "eq_self",
   "of_eq_true",
   "List.cons.injEq",
   "CellularAutomatas.FiniteStateTransducer.scanr_step",
   "id",
   "Eq.mpr",
   "CellularAutomatas.FiniteStateTransducer.f",
   "CellularAutomatas.FiniteStateTransducer.δ"],
  "name": "CellularAutomatas.FiniteStateTransducer.comp_scanr_q",
  "constType":
  "∀ {α β γ : Type} [CellularAutomatas.Alphabet α] [CellularAutomatas.Alphabet β] [CellularAutomatas.Alphabet γ]\n  {M2 : CellularAutomatas.FiniteStateTransducer β γ} {M1 : CellularAutomatas.FiniteStateTransducer α β} (q1 : M1.Q)\n  (q2 : M2.Q) (w : CellularAutomatas.Word α), (M2 ⊚ M1).scanr_q (q1, q2) w = M2.scanr_q q2 (M1.scanr_q q1 w)",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.simulation.Params.C_ctl",
   "CellularAutomatas.CellAutomaton.Q",
   "OfNat.ofNat"],
  "name": "CellularAutomatas.simulation.Q1.proxyType",
  "constType": "CellularAutomatas.simulation.Params → Type",
  "constCategory": "Definition"},
 {"references":
  ["Nat.cast",
   "Eq.trans",
   "le_of_le_of_eq",
   "Lean.Omega.LinearCombo.coordinate_eval_0",
   "Decidable.decide",
   "Lean.Omega.Coeffs.ofList",
   "Lean.Omega.tidy_sat",
   "HSub.hSub",
   "Eq.symm",
   "Lean.Omega.LinearCombo.add_eval",
   "Lean.Omega.Int.lt_of_not_le",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "Int.add_one_le_of_lt",
   "of_decide_eq_true",
   "Not",
   "Neg.neg",
   "Lean.Omega.Constraint.addInequality_sat",
   "Lean.Omega.Int.add_congr",
   "Lean.Omega.Constraint.isImpossible",
   "Lean.Omega.LinearCombo.coordinate",
   "OfNat.ofNat",
   "Int.sub_nonneg_of_le",
   "HAdd.hAdd",
   "Lean.Omega.LinearCombo.sub_eval",
   "LE.le",
   "id",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.Int.sub_congr"],
  "name": "CellularAutomatas.nextt_congr._proof_1_4",
  "constType": "∀ (i : ℤ), ¬i ≤ i + ↑0 → False",
  "constCategory": "Theorem"},
 {"references":
  ["Ne", "Nat.ne_of_beq_eq_false", "OfNat.ofNat", "Lean.ConstantInfo.ctorIdx"],
  "name":
  "_private.Lean.Util.FoldConsts.0.Lean.ConstantInfo.getUsedConstantsAsSet._sparseCasesOn_1",
  "constType":
  "{motive : ConstantInfo → Sort u} →\n  (t : ConstantInfo) →\n    ((val : InductiveVal) → motive (ConstantInfo.inductInfo val)) →\n      ((val : OpaqueVal) → motive (ConstantInfo.opaqueInfo val)) →\n        ((val : ConstructorVal) → motive (ConstantInfo.ctorInfo val)) →\n          ((val : RecursorVal) → motive (ConstantInfo.recInfo val)) →\n            (t.ctorIdx ≠ 5 → t.ctorIdx ≠ 3 → t.ctorIdx ≠ 6 → t.ctorIdx ≠ 7 → motive t) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["CellularAutomatas.Advice.f",
   "eq_self",
   "CellularAutomatas.Word",
   "Eq.trans",
   "of_eq_true",
   "CellularAutomatas.Advice.len",
   "congrArg",
   "List.length"],
  "name": "CellularAutomatas.advice_len",
  "constType":
  "∀ {α Γ : Type} (adv : CellularAutomatas.Advice α Γ) (w : CellularAutomatas.Word α),\n  List.length (adv.f w) = List.length w",
  "constCategory": "Theorem"},
 {"references": ["rfl", "HSub.hSub", "OfNat.ofNat"],
  "name": "Nat.sub_zero",
  "constType": "∀ (n : ℕ), n - 0 = n",
  "constCategory": "Theorem"},
 {"references": ["Array.mapM", "Pure.pure", "Id.run", "Id"],
  "name": "Array.map",
  "constType": "{α : Type u} → {β : Type v} → (α → β) → Array α → Array β",
  "constCategory": "Definition"},
 {"references": ["Lean.Omega.tidy", "Lean.Omega.Coeffs", "Prod.snd"],
  "name": "Lean.Omega.tidyCoeffs",
  "constType": "Omega.Constraint → Omega.Coeffs → Omega.Coeffs",
  "constCategory": "Definition"},
 {"references": ["Iff.mp", "trivial", "propext"],
  "name": "true_iff",
  "constType": "∀ (p : Prop), (True ↔ p) = p",
  "constCategory": "Theorem"},
 {"references":
  ["List.getElem_map",
   "Eq.trans",
   "List.getElem_range",
   "Membership.mem",
   "CellularAutomatas.CArtTransducer.f",
   "CellularAutomatas.advice_len",
   "Subtype.val",
   "CellularAutomatas.tCellAutomaton.toLCellAutomaton",
   "Set.Elem",
   "CellularAutomatas.LCellAutomaton.scan_temporal_rt",
   "CellularAutomatas.FiniteStateTransducer.M_id_advice_eq",
   "tsub_zero",
   "CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "Decidable.decide.congr_simp",
   "funext",
   "Eq.symm",
   "HSub.hSub",
   "CellularAutomatas.FiniteStateTransducer.advice",
   "Eq.ndrec",
   "HAppend.hAppend",
   "rfl",
   "CellularAutomatas.CArtTransducer.toLCellAutomaton",
   "CellularAutomatas.CArtTransducer.advice",
   "CellularAutomatas.LCellAutomaton.scan_temporal_independence",
   "List.drop",
   "CellularAutomatas.CA_rt_to_TwoStage_eq._proof_1_6",
   "And.right",
   "Bool.decide_eq_true",
   "List.map",
   "List.take_append_drop",
   "CellularAutomatas.LCellAutomaton.comp",
   "List.length_map",
   "List.length_take_le'",
   "Decidable.byContradiction",
   "List.ext_getElem",
   "id",
   "Eq.mpr",
   "CellularAutomatas.tCellAutomaton.L",
   "Trans.simple",
   "List.length",
   "CellularAutomatas.TwoStageAdvice.advice",
   "List.map_map",
   "GetElem.getElem.congr_simp",
   "CellularAutomatas.tCellAutomaton.t",
   "min_eq_left",
   "Eq.mp",
   "CellularAutomatas.LCellAutomaton.scan_temporal",
   "CellularAutomatas.CA_rt_to_TwoStage_eq._proof_1_8",
   "GetElem.getElem",
   "List.length_take",
   "Decidable.decide",
   "CellularAutomatas.Advice.prefixes_in_L",
   "congrArg",
   "CellularAutomatas.CA_rt_to_TwoStage_eq._proof_1_5",
   "CellularAutomatas.CA",
   "List.length_range",
   "congr",
   "Subtype.property",
   "CellularAutomatas.CellAutomaton.Q",
   "Nat.lt_of_lt_of_le",
   "add_tsub_cancel_right",
   "Not",
   "CellularAutomatas.Word",
   "List.extract",
   "CellularAutomatas.CA_rt_to_TwoStage_eq._proof_1_7",
   "Set",
   "Function.comp",
   "CellularAutomatas.CArtTransducer.advice._proof_3",
   "OfNat.ofNat",
   "CellularAutomatas.FiniteStateTransducer.M_id",
   "HAdd.hAdd",
   "CellularAutomatas.Advice.f",
   "List.range",
   "LT.lt",
   "eq_self",
   "of_eq_true",
   "Min.min",
   "List.take",
   "LE.le",
   "CellularAutomatas.CA_rt_to_TwoStage",
   "CellularAutomatas.CA_rt_to_TwoStage_eq._proof_1_4",
   "CellularAutomatas.CA_rt",
   "CellularAutomatas.tCellAutomaton.F_pos",
   "List.getElem_take"],
  "name": "CellularAutomatas.CA_rt_to_TwoStage_eq",
  "constType":
  "∀ {α : Type} [inst : CellularAutomatas.Alphabet α] (C : ↑(CellularAutomatas.CA_rt α)),\n  CellularAutomatas.TwoStageAdvice.advice.f = (CellularAutomatas.Advice.prefixes_in_L (↑C).L).f",
  "constCategory": "Theorem"},
 {"references": ["List.nodup_range"],
  "name": "Multiset.nodup_range",
  "constType": "∀ (n : ℕ), (Multiset.range n).Nodup",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Lean.Grind.Semiring.add_zero",
  "constType": "∀ {α : Type u} [self : Grind.Semiring α] (a : α), a + 0 = a",
  "constCategory": "Theorem"},
 {"references": ["Bool.and.match_1", "Unit"],
  "name": "Bool.and",
  "constType": "Bool → Bool → Bool",
  "constCategory": "Definition"},
 {"references":
  ["implies_congr",
   "Lean.Grind.OrderedAdd.add_le_left_iff",
   "Eq.mp",
   "Iff.mp",
   "Int.blt'",
   "Lean.Grind.Semiring.add_assoc",
   "Int.cast",
   "congrArg",
   "_private.Init.Grind.Order.0.Lean.Grind.Order.le_unsat_k._proof_1_1",
   "Lean.Grind.Semiring.add_zero",
   "Int.blt'_eq_true",
   "Lean.Grind.Ring.intCast_zero",
   "Eq.symm",
   "Lean.Grind.AddCommGroup.add_neg_cancel",
   "Lean.Grind.Semiring.add_comm",
   "Not",
   "Lean.Grind.Ring.intCast",
   "Neg.neg",
   "OfNat.ofNat",
   "Lean.Grind.OrderedRing.le_of_intCast_le_intCast",
   "LT.lt",
   "HAdd.hAdd",
   "LE.le",
   "id",
   "imp_false._simp_1",
   "Eq.mpr"],
  "name": "Lean.Grind.Order.le_unsat_k",
  "constType":
  "∀ {α : Type u_1} [inst : LE α] [inst_1 : LT α] [LawfulOrderLT α] [inst_3 : Std.IsPreorder α] [inst_4 : Grind.Ring α]\n  [Grind.OrderedRing α] {a : α} {k : ℤ}, k.blt' 0 = true → a ≤ a + ↑k → False",
  "constCategory": "Theorem"},
 {"references":
  ["Int.lt_iff_le_and_ne",
   "HAdd.hAdd",
   "LT.lt",
   "Int.add_left_cancel",
   "Eq.mp",
   "Int.add_le_add_left",
   "Iff.mpr",
   "Int.le_of_lt",
   "LE.le",
   "Int.lt_irrefl",
   "Ne",
   "congrArg"],
  "name": "Int.add_lt_add_left",
  "constType": "∀ {a b : ℤ}, a < b → ∀ (c : ℤ), c + a < c + b",
  "constCategory": "Theorem"},
 {"references":
  ["Int.add_assoc",
   "Eq.trans",
   "Lean.Omega.Coeffs",
   "congrArg",
   "HAdd.hAdd",
   "congr",
   "Lean.Omega.Coeffs.dot_distrib_left",
   "id",
   "Lean.Omega.LinearCombo.eval",
   "Eq.mpr",
   "Lean.Omega.LinearCombo.casesOn",
   "Int.add_left_comm",
   "Lean.Omega.Coeffs.dot"],
  "name": "Lean.Omega.LinearCombo.add_eval",
  "constType":
  "∀ (l₁ l₂ : Omega.LinearCombo) (v : Omega.Coeffs), (l₁ + l₂).eval v = l₁.eval v + l₂.eval v",
  "constCategory": "Theorem"},
 {"references":
  ["Classical.indefiniteDescription._proof_1", "Classical.choice"],
  "name": "Classical.indefiniteDescription",
  "constType": "{α : Sort u} → (p : α → Prop) → (∃ x, p x) → { x // p x }",
  "constCategory": "Definition"},
 {"references": ["Nat.casesOn", "List.casesOn", "OfNat.ofNat"],
  "name": "_private.Init.Data.List.TakeDrop.0.List.map_take.match_1_1",
  "constType":
  "∀ {α : Type u_1} (motive : List α → ℕ → Prop) (x : List α) (x_1 : ℕ),\n  (∀ (i : ℕ), motive [] i) →\n    (∀ (x : List α), motive x 0) → (∀ (head : α) (tl : List α) (n : ℕ), motive (head :: tl) n.succ) → motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["CellularAutomatas.CellAutomaton.δ",
   "forall_eq._simp_1",
   "Eq.trans",
   "Eq.mp",
   "Set",
   "Singleton.singleton",
   "Membership.mem",
   "Subtype.val",
   "Set.Elem",
   "congrArg",
   "eq_self",
   "of_eq_true",
   "congr",
   "Subtype.forall._simp_1",
   "forall_congr",
   "CellularAutomatas.CellAutomaton.quiescent",
   "id",
   "CellularAutomatas.CellAutomaton.Q",
   "Set.mem_singleton_iff._simp_1",
   "forall_prop_domain_congr"],
  "name": "CellularAutomatas.CellAutomaton.δδ_of_quiescent",
  "constType":
  "∀ {C : CellularAutomatas.CellAutomaton} {q : C.Q}, C.quiescent q → CellularAutomatas.δδ q = q",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Lean.Grind.Semiring.add_comm",
  "constType":
  "∀ {α : Type u} [self : Grind.Semiring α] (a b : α), a + b = b + a",
  "constCategory": "Theorem"},
 {"references": ["CellularAutomatas.CellAutomaton._sizeOf_1"],
  "name": "CellularAutomatas.CellAutomaton._sizeOf_inst",
  "constType": "SizeOf CellularAutomatas.CellAutomaton",
  "constCategory": "Definition"},
 {"references": ["outParam"],
  "name": "HAppend.hAppend",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → [self : HAppend α β γ] → α → β → γ",
  "constCategory": "Definition"},
 {"references": ["CellularAutomatas.tCellAutomaton._sizeOf_1"],
  "name": "CellularAutomatas.tCellAutomaton._sizeOf_inst",
  "constType":
  "(α : Type) → [SizeOf α] → SizeOf (CellularAutomatas.tCellAutomaton α)",
  "constCategory": "Definition"},
 {"references": ["Nat.ble"],
  "name": "Nat.blt",
  "constType": "ℕ → ℕ → Bool",
  "constCategory": "Definition"},
 {"references": ["Int.subNatNat"],
  "name": "Int.subNatNat.eq_1",
  "constType":
  "∀ (m n : ℕ),\n  Int.subNatNat m n =\n    match n - m with\n    | 0 => Int.ofNat (m - n)\n    | k.succ => Int.negSucc k",
  "constCategory": "Theorem"},
 {"references": ["List.below", "List.brecOn.go"],
  "name": "List.brecOn",
  "constType":
  "{α : Type u} → {motive : List α → Sort u_1} → (t : List α) → ((t : List α) → List.below t → motive t) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "of_eq_true",
   "CellularAutomatas.CellAutomaton.Q",
   "CellularAutomatas.Config"],
  "name": "CellularAutomatas.nextt0",
  "constType":
  "∀ (C : CellularAutomatas.CellAutomaton) (c : CellularAutomatas.Config C.Q), C.nextt c 0 = c",
  "constCategory": "Theorem"},
 {"references":
  ["Option.all", "LE.le", "Lean.Omega.LowerBound", "Decidable.decide"],
  "name": "Lean.Omega.LowerBound.sat",
  "constType": "Omega.LowerBound → ℤ → Bool",
  "constCategory": "Definition"},
 {"references": ["Std.TreeMap.unitOfList"],
  "name": "Std.TreeSet.ofList",
  "constType":
  "{α : Type u} → List α → (cmp : autoParam (α → α → Ordering) _auto✝) → TreeSet α cmp",
  "constCategory": "Definition"},
 {"references": ["Nat.cast_nonneg'"],
  "name": "Nat.cast_nonneg",
  "constType":
  "∀ {α : Type u_3} [inst : Semiring α] [inst_1 : PartialOrder α] [IsOrderedRing α] (n : ℕ), 0 ≤ ↑n",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.ndrec",
   "CellularAutomatas.tCellAutomatonWithAdvice.casesOn",
   "CellularAutomatas.tCellAutomatonWithAdvice.noConfusionType"],
  "name": "CellularAutomatas.tCellAutomatonWithAdvice.noConfusion",
  "constType":
  "{α : Type} →\n  {P : Sort u} →\n    {x1 x2 : CellularAutomatas.tCellAutomatonWithAdvice α} →\n      x1 = x2 → CellularAutomatas.tCellAutomatonWithAdvice.noConfusionType P x1 x2",
  "constCategory": "Definition"},
 {"references": ["Finset.val", "Multiset.toList"],
  "name": "Finset.toList",
  "constType": "{α : Type u_1} → Finset α → List α",
  "constCategory": "Definition"},
 {"references": ["outParam", "Language"],
  "name": "CellularAutomatas.DefinesLanguage.mk._flat_ctor",
  "constType":
  "{CA : Sort u_1} → {α : outParam Type} → (CA → Language α) → CellularAutomatas.DefinesLanguage CA α",
  "constCategory": "Definition"},
 {"references": ["CellularAutomatas.VerificationError.mk.noConfusion"],
  "name": "CellularAutomatas.VerificationError.mk.inj",
  "constType":
  "∀ {module : Name} {message : String} {details : List String} {module_1 : Name} {message_1 : String}\n  {details_1 : List String},\n  { module := module, message := message, details := details } =\n      { module := module_1, message := message_1, details := details_1 } →\n    module = module_1 ∧ message = message_1 ∧ details = details_1",
  "constCategory": "Theorem"},
 {"references": ["AddMonoidWithOne.natCast_zero"],
  "name": "Nat.cast_zero",
  "constType": "∀ {R : Type u_1} [inst : AddMonoidWithOne R], ↑0 = 0",
  "constCategory": "Theorem"},
 {"references": ["outParam"],
  "name": "HSMul.hSMul",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → [self : HSMul α β γ] → α → β → γ",
  "constCategory": "Definition"},
 {"references":
  ["List.take_range",
   "min_eq_left",
   "CellularAutomatas.marker_list",
   "List.map",
   "OfNat.ofNat",
   "congrArg",
   "HAdd.hAdd",
   "List.range",
   "List.map_take",
   "Min.min",
   "List.take",
   "LE.le",
   "id",
   "Eq.symm",
   "Eq.mpr",
   "BEq.beq"],
  "name": "CellularAutomatas.marker_list_take",
  "constType":
  "∀ {n m k : ℕ}, m ≤ n → List.take m (CellularAutomatas.marker_list n k) = CellularAutomatas.marker_list m k",
  "constCategory": "Theorem"},
 {"references": ["List.below", "List.brecOn", "List.zipWith.match_1"],
  "name": "List.zipWith",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : Type w} → (α → β → γ) → List α → List β → List γ",
  "constCategory": "Definition"},
 {"references": ["Lean.Omega.IntList.sdiv", "Lean.Omega.Coeffs"],
  "name": "Lean.Omega.Coeffs.sdiv",
  "constType": "Omega.Coeffs → ℤ → Omega.Coeffs",
  "constCategory": "Definition"},
 {"references": ["Lean.Name.quickCmp"],
  "name": "Lean.NameSet",
  "constType": "Type",
  "constCategory": "Definition"},
 {"references":
  ["LT.lt", "Finset.range", "Membership.mem", "Finset.mem_range", "propext"],
  "name": "Finset.mem_range._simp_1",
  "constType": "∀ {n m : ℕ}, (m ∈ Finset.range n) = (m < n)",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Grind.AC.Seq.contains_k",
   "Eq.trans",
   "Nat.beq_eq",
   "Bool.or",
   "congrArg",
   "beq_iff_eq._simp_1",
   "Lean.Grind.AC.Var",
   "Bool.or_eq_true",
   "Bool.or'",
   "iff_self",
   "Bool.eq_iff_iff",
   "of_eq_true",
   "congr",
   "Nat.beq",
   "id",
   "Eq.mpr",
   "BEq.beq",
   "Bool.or'_eq_or",
   "propext"],
  "name": "Lean.Grind.AC.Seq.contains_k_cons",
  "constType":
  "∀ (y x : Grind.AC.Var) (s : Grind.AC.Seq), (Grind.AC.Seq.cons y s).contains_k x = (x == y || s.contains_k x)",
  "constCategory": "Theorem"},
 {"references": ["HAdd.hAdd", "Int.add.match_1", "Int.subNatNat"],
  "name": "Int.add",
  "constType": "ℤ → ℤ → ℤ",
  "constCategory": "Definition"},
 {"references":
  ["CellularAutomatas.Advice.f",
   "CellularAutomatas.Word",
   "CellularAutomatas.TwoStageAdvice.C",
   "CellularAutomatas.CArtTransducer.advice",
   "CellularAutomatas.TwoStageAdvice.β",
   "CellularAutomatas.FiniteStateTransducer.advice",
   "Function.comp",
   "CellularAutomatas.TwoStageAdvice.advice._proof_1",
   "CellularAutomatas.TwoStageAdvice.M"],
  "name": "CellularAutomatas.TwoStageAdvice.advice",
  "constType":
  "{α Γ : Type} →\n  [inst : CellularAutomatas.Alphabet α] →\n    [inst_1 : CellularAutomatas.Alphabet Γ] →\n      {adv : CellularAutomatas.TwoStageAdvice α Γ} → CellularAutomatas.Advice α Γ",
  "constCategory": "Definition"},
 {"references":
  ["CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "Finset.univ",
   "CellularAutomatas.CALc",
   "CellularAutomatas.PrefixStableProof.M_prod",
   "Option.getD",
   "CellularAutomatas.CellAutomaton.Q",
   "List.head?",
   "CellularAutomatas.tCellAutomaton.F_pos",
   "Inhabited.default",
   "Finset.toList",
   "Finset.filter",
   "CellularAutomatas.Advice.rt_closed"],
  "name": "CellularAutomatas.PrefixStableProof.t_map",
  "constType":
  "{α : Type} →\n  [inst : CellularAutomatas.Alphabet α] →\n    {Γ : Type} →\n      [inst_1 : CellularAutomatas.Alphabet Γ] →\n        (adv : CellularAutomatas.Advice α Γ) →\n          (h1 : adv.rt_closed) → (CellularAutomatas.PrefixStableProof.M_prod adv h1).Q → Γ",
  "constCategory": "Definition"},
 {"references": ["Classical.indefiniteDescription.match_1"],
  "name": "Classical.indefiniteDescription._proof_1",
  "constType":
  "∀ {α : Sort u_1} (p : α → Prop), (∃ x, p x) → Nonempty { x // p x }",
  "constCategory": "Theorem"},
 {"references": ["List.mem_range"],
  "name": "Multiset.mem_range",
  "constType": "∀ {m n : ℕ}, m ∈ Multiset.range n ↔ m < n",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "CellularAutomatas.Advice.f",
   "HAdd.hAdd",
   "Lean.Grind.Nat.lt_eq",
   "Eq.substr",
   "LE.le",
   "OfNat.ofNat",
   "List.length"],
  "name": "CellularAutomatas.PrefixStableProof.f._proof_1_4",
  "constType":
  "∀ {α Γ : Type} (adv : CellularAutomatas.Advice α Γ) (w : List α) (i : ℕ),\n  i + 1 ≤ List.length (adv.f w) → i < List.length (adv.f w)",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "CellularAutomatas.CellAutomaton.δ",
   "DecidableEq",
   "CellularAutomatas.CellAutomaton.Q",
   "CellularAutomatas.LCellAutomaton.border",
   "CellularAutomatas.LCellAutomaton.embed"],
  "name": "CellularAutomatas.ProdCA",
  "constType":
  "(α β : Type) →\n  [DecidableEq β] → [Fintype β] → (β → CellularAutomatas.LCellAutomaton α) → CellularAutomatas.LCellAutomaton α",
  "constCategory": "Definition"},
 {"references": ["CellularAutomatas.Word", "List.length"],
  "name": "CellularAutomatas.Advice.recOn",
  "constType":
  "{α Γ : Type} →\n  {motive : CellularAutomatas.Advice α Γ → Sort u} →\n    (t : CellularAutomatas.Advice α Γ) →\n      ((f : CellularAutomatas.Word α → CellularAutomatas.Word Γ) →\n          (len : ∀ (w : CellularAutomatas.Word α), List.length (f w) = List.length w) → motive { f := f, len := len }) →\n        motive t",
  "constCategory": "Definition"},
 {"references": ["HAdd.hAdd", "rfl", "Neg.neg"],
  "name": "Int.add_neg_eq_sub",
  "constType": "∀ {a b : ℤ}, a + -b = a - b",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CellularAutomatas.backwards_fsm.Params.mk._flat_ctor",
  "constType":
  "{α β γ : Type} →\n  [inst1 : CellularAutomatas.Alphabet α] →\n    [inst2 : CellularAutomatas.Alphabet β] →\n      [inst3 : CellularAutomatas.Alphabet γ] →\n        CellularAutomatas.FiniteStateTransducer α β →\n          CellularAutomatas.CArtTransducer β γ → CellularAutomatas.backwards_fsm.Params",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CellularAutomatas.LCellAutomaton.rec",
  "constType":
  "{α : Type} →\n  {motive : CellularAutomatas.LCellAutomaton α → Sort u} →\n    ((toCellAutomaton : CellularAutomatas.CellAutomaton) →\n        (embed : α → toCellAutomaton.Q) →\n          (border : toCellAutomaton.Q) →\n            motive { toCellAutomaton := toCellAutomaton, embed := embed, border := border }) →\n      (t : CellularAutomatas.LCellAutomaton α) → motive t",
  "constCategory": "Other"},
 {"references": ["Eq.ndrec", "Lean.Grind.nestedProof"],
  "name": "Lean.Grind.nestedProof_congr",
  "constType": "∀ (p q : Prop), p = q → ∀ (hp : p) (hq : q), ⋯ ≍ ⋯",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Std.IsLinearPreorder.le_total",
  "constType":
  "∀ {α : Type u} {inst : LE α} [self : IsLinearPreorder α] (a b : α), a ≤ b ∨ b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["namedPattern",
   "_private.Lean.Data.Name.0.Lean.Name.isPrefixOf.match_1",
   "Lean.Name.brecOn",
   "Bool.or",
   "BEq.beq",
   "Lean.Name.below"],
  "name": "Lean.Name.isPrefixOf",
  "constType": "Name → Name → Bool",
  "constCategory": "Definition"},
 {"references":
  ["Or.elim",
   "Lean.Omega.LinearCombo.coordinate_eval_2",
   "Nat.cast",
   "Eq.trans",
   "le_of_le_of_eq",
   "Classical.propDecidable",
   "Lean.Omega.LinearCombo.coordinate_eval_0",
   "Lean.Omega.Constraint.combine_sat'",
   "Decidable.decide",
   "Lean.Omega.LinearCombo.neg_eval",
   "Lean.Omega.Coeffs.ofList",
   "Eq.symm",
   "HSub.hSub",
   "Lean.Omega.tidy_sat",
   "Lean.Omega.LinearCombo.add_eval",
   "Lean.Omega.Int.lt_of_not_le",
   "Decidable.not_or_of_imp",
   "Lean.Omega.Int.neg_congr",
   "Int.add_one_le_of_lt",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "of_decide_eq_true",
   "Not",
   "CellularAutomatas.Word",
   "Lean.Omega.combo_sat'",
   "Neg.neg",
   "Lean.Omega.Constraint.addInequality_sat",
   "Lean.Omega.Int.add_congr",
   "Lean.Omega.Constraint.isImpossible",
   "Lean.Omega.LinearCombo.coordinate",
   "Int.ofNat_nonneg",
   "OfNat.ofNat",
   "Int.sub_nonneg_of_le",
   "Lean.Omega.LinearCombo.coordinate_eval_1",
   "HAdd.hAdd",
   "LT.lt",
   "Lean.Omega.Int.ofNat_lt_of_lt",
   "Lean.Omega.LinearCombo.sub_eval",
   "LE.le",
   "id",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.Int.sub_congr",
   "List.length"],
  "name": "CellularAutomatas.Word.cone_succ_not._proof_1_2",
  "constType":
  "∀ {α : Type u_1} {w : CellularAutomatas.Word α} {t : ℕ} {i : ℤ},\n  0 < List.length w →\n    (-↑t ≤ i - 1 → ↑(List.length w) + ↑t ≤ i - 1) →\n      (-↑t ≤ i → ↑(List.length w) + ↑t ≤ i) →\n        (-↑t ≤ i + 1 → ↑(List.length w) + ↑t ≤ i + 1) → -1 + -↑t ≤ i → ¬↑(List.length w) + (↑t + 1) ≤ i → False",
  "constCategory": "Theorem"},
 {"references":
  ["List.range'",
   "Eq.mp",
   "Iff.mp",
   "List.getElem?_range'",
   "HMul.hMul",
   "GetElem.getElem",
   "List.getElem?_eq_some_iff",
   "congrArg",
   "LT.lt",
   "HAdd.hAdd",
   "GetElem?.getElem?",
   "List.length_range'",
   "List.length"],
  "name": "List.getElem_range'",
  "constType":
  "∀ {n m step i : ℕ} (H : i < (List.range' n m step).length), (List.range' n m step)[i] = n + step * i",
  "constCategory": "Theorem"},
 {"references": ["OfNat.ofNat"],
  "name": "CellularAutomatas.simulation.instInhabitedQ1.default._proof_1",
  "constType": "NeZero (2 + 1)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CellularAutomatas.CellAutomaton.Q",
  "constType": "CellularAutomatas.CellAutomaton → Type",
  "constCategory": "Definition"},
 {"references":
  ["Int.Linear.Poly.beq'",
   "Int.Linear.Poly.mul_k",
   "Neg.neg",
   "Bool.or",
   "Int.Linear.Poly.addConst_k",
   "Bool.and'",
   "OfNat.ofNat"],
  "name": "Int.Linear.le_of_le_diseq_cert",
  "constType": "Int.Linear.Poly → Int.Linear.Poly → Int.Linear.Poly → Bool",
  "constCategory": "Definition"},
 {"references":
  ["Not",
   "if_neg",
   "ite",
   "congr",
   "id",
   "Eq.mpr",
   "Option.map",
   "Decidable.casesOn",
   "if_pos",
   "congrArg"],
  "name": "Option.map_if",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {c : Prop} {a : α} {f : α → β} {x : Decidable c},\n  Option.map f (if c then some a else none) = if c then some (f a) else none",
  "constCategory": "Theorem"},
 {"references": ["LE.le", "propext", "Int.eq_iff_le_and_ge"],
  "name": "_private.Init.Data.Int.Linear.0.Int.Linear.eq_of_le_ge._simp_1_2",
  "constType": "∀ {x y : ℤ}, (x = y) = (x ≤ y ∧ y ≤ x)",
  "constCategory": "Theorem"},
 {"references": ["LE.le", "Nat.zero_le", "eq_true", "OfNat.ofNat"],
  "name": "Nat.zero_le._simp_1",
  "constType": "∀ (n : ℕ), (0 ≤ n) = True",
  "constCategory": "Theorem"},
 {"references": ["LT.lt", "Iff.mp", "Int.ne_iff_lt_or_gt", "Ne"],
  "name": "Int.lt_or_gt_of_ne",
  "constType": "∀ {a b : ℤ}, a ≠ b → a < b ∨ b < a",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans",
   "le_of_le_of_eq",
   "Lean.Omega.LinearCombo.coordinate_eval_3",
   "Membership.mem",
   "Lean.Omega.LinearCombo.coordinate_eval_4",
   "Subtype.val",
   "Lean.Omega.Int.ofNat_le_of_le",
   "Set.Elem",
   "CellularAutomatas.tCellAutomaton.toLCellAutomaton",
   "CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "CellularAutomatas.LCellAutomaton.scan_temporal_rt",
   "Lean.Omega.tidy_sat",
   "HSub.hSub",
   "Eq.symm",
   "Lean.Omega.LinearCombo.add_eval",
   "Int.add_one_le_of_lt",
   "CellularAutomatas.CArtTransducer.advice",
   "Lean.Omega.combo_sat'",
   "Neg.neg",
   "Lean.Omega.Constraint.addInequality_sat",
   "List.map",
   "Lean.Omega.LinearCombo.coordinate",
   "id",
   "Lean.Omega.Constraint.addEquality_sat",
   "CellularAutomatas.tCellAutomaton.L",
   "Lean.Omega.Int.sub_congr",
   "List.length",
   "Lean.Omega.LinearCombo.coordinate_eval_7",
   "Nat.cast",
   "CellularAutomatas.tCellAutomaton.t",
   "Lean.Omega.Constraint.combine_sat'",
   "Int.sub_eq_zero_of_eq",
   "Decidable.decide",
   "Lean.Omega.Coeffs.ofList",
   "CellularAutomatas.CellAutomaton.Q",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "of_decide_eq_true",
   "Not",
   "CellularAutomatas.Word",
   "List.extract",
   "Set",
   "Lean.Omega.Int.ofNat_congr",
   "Lean.Omega.Int.add_congr",
   "Lean.Omega.Constraint.isImpossible",
   "Function.comp",
   "Int.sub_nonneg_of_le",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "LT.lt",
   "CellularAutomatas.Advice.f",
   "List.range",
   "Lean.Omega.LinearCombo.coordinate_eval_1",
   "Nat.le_of_not_lt",
   "Lean.Omega.LinearCombo.coordinate_eval_6",
   "Lean.Omega.Int.ofNat_lt_of_lt",
   "Lean.Omega.LinearCombo.sub_eval",
   "List.take",
   "Int.natCast_add",
   "CellularAutomatas.CA_rt",
   "Lean.Omega.LinearCombo.eval",
   "CellularAutomatas.tCellAutomaton.F_pos",
   "Lean.Omega.LinearCombo.coordinate_eval_5"],
  "name": "CellularAutomatas.CA_rt_to_TwoStage_eq._proof_1_7",
  "constType":
  "∀ {α : Type} [CellularAutomatas.Alphabet α] (C : ↑(CellularAutomatas.CA_rt α)) (w : CellularAutomatas.Word α) (i : ℕ),\n  List.length ((↑C).scan_temporal_rt w) = List.length w →\n    i < List.length w →\n      (List.take (i + 1) w).length = i + 1 →\n        (↑C).t (i + 1) = i →\n          List.length ((↑C).scan_temporal_rt (List.take (i + 1) w)) = i + 1 →\n            ¬i < List.length ((↑C).scan_temporal_rt w) → False",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.CellAutomaton.Q",
   "CellularAutomatas.LCellAutomaton.mk.noConfusion"],
  "name": "CellularAutomatas.LCellAutomaton.mk.inj",
  "constType":
  "∀ {α : Type} {toCellAutomaton : CellularAutomatas.CellAutomaton} {embed : α → toCellAutomaton.Q}\n  {border : toCellAutomaton.Q} {toCellAutomaton_1 : CellularAutomatas.CellAutomaton} {embed_1 : α → toCellAutomaton_1.Q}\n  {border_1 : toCellAutomaton_1.Q},\n  { toCellAutomaton := toCellAutomaton, embed := embed, border := border } =\n      { toCellAutomaton := toCellAutomaton_1, embed := embed_1, border := border_1 } →\n    toCellAutomaton = toCellAutomaton_1 ∧ embed ≍ embed_1 ∧ border ≍ border_1",
  "constCategory": "Theorem"},
 {"references":
  ["rfl",
   "LT.lt",
   "Decidable.decide",
   "UInt64.size",
   "OfNat.ofNat",
   "of_decide_eq_true"],
  "name": "_private.Init.Prelude.0.Lean.Name.hash._proof_2",
  "constType": "17 < UInt64.size",
  "constCategory": "Theorem"},
 {"references":
  ["_private.Lean.Util.FoldConsts.0.Lean.ConstantInfo.getUsedConstantsAsSet._sparseCasesOn_1",
   "Ne",
   "OfNat.ofNat",
   "Lean.ConstantInfo.ctorIdx"],
  "name":
  "_private.Lean.Util.FoldConsts.0.Lean.ConstantInfo.getUsedConstantsAsSet.match_1",
  "constType":
  "(motive : ConstantInfo → Sort u_1) →\n  (c : ConstantInfo) →\n    ((val : InductiveVal) → motive (ConstantInfo.inductInfo val)) →\n      ((val : OpaqueVal) → motive (ConstantInfo.opaqueInfo val)) →\n        ((val : ConstructorVal) → motive (ConstantInfo.ctorInfo val)) →\n          ((val : RecursorVal) → motive (ConstantInfo.recInfo val)) → ((x : ConstantInfo) → motive x) → motive c",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Grind.AddCommGroup.sub_eq_zero_iff",
   "HSub.hSub",
   "OfNat.ofNat",
   "propext"],
  "name":
  "_private.Init.Grind.Ring.CommSolver.0.Lean.Grind.CommRing.Stepwise.imp_1eq._simp_1_3",
  "constType":
  "∀ {M : Type u} [inst : Grind.AddCommGroup M] {a b : M}, (a - b = 0) = (a = b)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Eq.casesOn",
  "constType":
  "{α : Sort u_1} →\n  {a : α} → {motive : (a_1 : α) → a = a_1 → Sort u} → {a_1 : α} → (t : a = a_1) → motive a ⋯ → motive a_1 t",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CellularAutomatas.tCellAutomatonWithAdvice.casesOn",
  "constType":
  "{α : Type} →\n  {motive : CellularAutomatas.tCellAutomatonWithAdvice α → Sort u} →\n    (t : CellularAutomatas.tCellAutomatonWithAdvice α) →\n      ((Γ : Type) →\n          [alphabetΓ : CellularAutomatas.Alphabet Γ] →\n            (adv : CellularAutomatas.Advice α Γ) →\n              (C : CellularAutomatas.tCellAutomaton (α ⨉ Γ)) →\n                motive { Γ := Γ, alphabetΓ := alphabetΓ, adv := adv, C := C }) →\n        motive t",
  "constCategory": "Definition"},
 {"references":
  ["Int.add_right_neg",
   "Int.add_le_add_right",
   "HAdd.hAdd",
   "Eq.mp",
   "Neg.neg",
   "LE.le",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Int.sub_nonneg_of_le",
  "constType": "∀ {a b : ℤ}, b ≤ a → 0 ≤ a - b",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "Lean.Grind.AC.Seq.insert",
   "Nat.blt",
   "Eq.trans",
   "Lean.Grind.AC.Var.denote",
   "Lean.Grind.AC.Context.op",
   "congrArg",
   "Lean.Grind.AC.Var",
   "eq_self",
   "Lean.Grind.AC.Seq.insert.induct_unfolding",
   "of_eq_true",
   "Std.Commutative.comm",
   "congr",
   "Eq.symm",
   "id",
   "Lean.Grind.AC.Seq.denote",
   "Eq.mpr",
   "Std.Associative.assoc"],
  "name": "Lean.Grind.AC.Seq.denote_insert",
  "constType":
  "∀ {α : Sort u_1} (ctx : Grind.AC.Context α) {inst₁ : Associative ctx.op} {inst₂ : Commutative ctx.op} (x : Grind.AC.Var)\n  (s : Grind.AC.Seq),\n  Grind.AC.Seq.denote ctx (Grind.AC.Seq.insert x s) = ctx.op (Grind.AC.Var.denote ctx x) (Grind.AC.Seq.denote ctx s)",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "implies_congr",
   "Eq.trans",
   "imp_self._simp_1",
   "Classical.propDecidable",
   "eq_true",
   "or_true",
   "congrArg",
   "implies_true",
   "eq_self",
   "or_false",
   "or_self",
   "not_false_eq_true",
   "of_eq_true",
   "eq_false",
   "congr",
   "not_true_eq_false",
   "imp_false._simp_1",
   "dite"],
  "name": "Lean.Grind.imp_eq",
  "constType": "∀ (p q : Prop), (p → q) = (¬p ∨ q)",
  "constCategory": "Theorem"},
 {"references": ["Nat.not_succ_le_zero"],
  "name": "Nat.not_lt_zero",
  "constType": "∀ (n : ℕ), ¬n < 0",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Omega.LinearCombo.neg_eval",
   "HAdd.hAdd",
   "eq_self",
   "Lean.Omega.LinearCombo.sub_eq_add_neg",
   "Eq.trans",
   "of_eq_true",
   "Neg.neg",
   "HSub.hSub",
   "Lean.Omega.LinearCombo.add_eval",
   "Lean.Omega.Coeffs",
   "Lean.Omega.LinearCombo.eval",
   "congrArg"],
  "name": "Lean.Omega.LinearCombo.sub_eval",
  "constType":
  "∀ (l₁ l₂ : Omega.LinearCombo) (v : Omega.Coeffs), (l₁ - l₂).eval v = l₁.eval v - l₂.eval v",
  "constCategory": "Theorem"},
 {"references": ["OfNat.ofNat"],
  "name": "Lean.Grind.AC.hugeFuel",
  "constType": "ℕ",
  "constCategory": "Definition"},
 {"references": ["Lean.Name.casesOn", "Unit.unit", "Unit"],
  "name": "_private.Init.Prelude.0.Lean.Name.hash.match_1",
  "constType":
  "(motive : Name → Sort u_1) →\n  (x : Name) →\n    (Unit → motive Name.anonymous) →\n      ((p : Name) → (s : String) → motive (p.str s)) → ((p : Name) → (v : ℕ) → motive (p.num v)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Units.val",
   "Units.val_inv",
   "Eq.symm",
   "HMul.hMul",
   "Units.inv",
   "Nat.eq_one_of_dvd_one",
   "OfNat.ofNat",
   "Units.ext"],
  "name": "Nat.units_eq_one",
  "constType": "∀ (u : ℕˣ), u = 1",
  "constCategory": "Theorem"},
 {"references": ["HAdd.hAdd", "rfl", "Nat.cast"],
  "name": "Int.natCast_add",
  "constType": "∀ (n m : ℕ), ↑(n + m) = ↑n + ↑m",
  "constCategory": "Theorem"},
 {"references": ["Eq.mp"],
  "name": "Lean.Grind.intro_with_eq",
  "constType": "(p p' : Prop) → (q : Sort u) → p = p' → (p' → q) → p → q",
  "constCategory": "Definition"},
 {"references":
  ["Eq.propIntro",
   "eq_of_heq",
   "CellularAutomatas.simulation.Params.mk.noConfusion",
   "Eq.symm",
   "CellularAutomatas.CellAutomaton.Q",
   "Eq.ndrec",
   "Eq.casesOn",
   "HEq.casesOn",
   "And.casesOn"],
  "name": "CellularAutomatas.simulation.Params.mk.injEq",
  "constType":
  "∀ (C_inr C_ctl : CellularAutomatas.CellAutomaton) (f : C_ctl.Q → Option C_inr.Q)\n  (C_inr_1 C_ctl_1 : CellularAutomatas.CellAutomaton) (f_1 : C_ctl_1.Q → Option C_inr_1.Q),\n  ({ C_inr := C_inr, C_ctl := C_ctl, f := f } = { C_inr := C_inr_1, C_ctl := C_ctl_1, f := f_1 }) =\n    (C_inr = C_inr_1 ∧ C_ctl = C_ctl_1 ∧ f ≍ f_1)",
  "constCategory": "Theorem"},
 {"references": ["Std.HashMap.inner", "Std.DHashMap.fold"],
  "name": "Std.HashMap.fold",
  "constType":
  "{α : Type u} → {β : Type v} → {x : BEq α} → {x_1 : Hashable α} → {γ : Type w} → (γ → α → β → γ) → γ → HashMap α β → γ",
  "constCategory": "Definition"},
 {"references": ["Int.ofNat_inj"],
  "name": "Int.natCast_inj",
  "constType": "∀ {m n : ℕ}, ↑m = ↑n ↔ m = n",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.Word",
   "Eq.trans",
   "List.map",
   "CellularAutomatas.LCellAutomaton.comp",
   "List.length_map",
   "OfNat.ofNat",
   "congrArg",
   "CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "List.range",
   "eq_self",
   "of_eq_true",
   "List.length_range",
   "CellularAutomatas.CellAutomaton.Q",
   "List.length"],
  "name": "CellularAutomatas.LCellAutomaton.scan_temporal_rt_len",
  "constType":
  "∀ {α : Type} {C : CellularAutomatas.LCellAutomaton α} {w : CellularAutomatas.Word α},\n  List.length (C.scan_temporal_rt w) = List.length w",
  "constCategory": "Theorem"},
 {"references": ["rfl"],
  "name": "implies_congr",
  "constType":
  "∀ {p₁ p₂ : Sort u} {q₁ q₂ : Sort v}, p₁ = p₂ → q₁ = q₂ → (p₁ → q₁) = (p₂ → q₂)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Monoid.npow_zero",
  "constType": "∀ {M : Type u} [self : Monoid M] (x : M), Monoid.npow 0 x = 1",
  "constCategory": "Theorem"},
 {"references": ["rfl", "Inv.inv", "Units.val", "IsUnit", "Classical.choose"],
  "name": "IsUnit.unit._proof_2",
  "constType":
  "∀ {M : Type u_1} [inst : Monoid M] {a : M} (h : IsUnit a), ↑(Classical.choose h)⁻¹ = ↑(Classical.choose h)⁻¹",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Lean.Import.module",
  "constType": "Import → Name",
  "constCategory": "Definition"},
 {"references":
  ["List.getElem?_eq_getElem",
   "Eq.trans",
   "noConfusion_of_Nat",
   "GetElem.getElem",
   "congrArg",
   "Option.ctorIdx",
   "GetElem?.getElem?",
   "False.elim",
   "iff_self",
   "congr",
   "Eq.symm",
   "Nat.le_zero_eq",
   "Eq.ndrec",
   "Nat.casesAuxOn",
   "Nat.zero_le._simp_1",
   "_private.Init.GetElem.0.List.getElem?_eq_none_iff._simp_1_3",
   "Nat.noConfusion",
   "List.brecOn",
   "iff_true",
   "eq_false'",
   "OfNat.ofNat",
   "Unit",
   "LT.lt",
   "HAdd.hAdd",
   "List.below",
   "of_eq_true",
   "_private.Init.GetElem.0.List.getElem?_eq_none_iff.match_1_1",
   "LE.le",
   "id",
   "Eq.mpr",
   "Nat.zero_lt_succ._simp_1",
   "List.length"],
  "name": "List.getElem?_eq_none_iff",
  "constType":
  "∀ {α : Type u_1} {l : List α} {i : ℕ}, l[i]? = none ↔ l.length ≤ i",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CellularAutomatas.CArtTransducer.f",
  "constType":
  "{α Γ : Type} →\n  [inst : CellularAutomatas.Alphabet α] →\n    [inst_1 : CellularAutomatas.Alphabet Γ] → (self : CellularAutomatas.CArtTransducer α Γ) → self.Q → Γ",
  "constCategory": "Definition"},
 {"references": ["List.casesOn", "Unit.unit", "Unit"],
  "name": "List.getLast?.match_1",
  "constType":
  "{α : Type u_1} →\n  (motive : List α → Sort u_2) →\n    (x : List α) → (Unit → motive []) → ((a : α) → (as : List α) → motive (a :: as)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["HAdd.hAdd",
   "List.replicate",
   "eq_self",
   "Eq.trans",
   "of_eq_true",
   "Nat.recAux",
   "OfNat.ofNat",
   "congrArg",
   "List.length"],
  "name": "List.length_replicate",
  "constType":
  "∀ {α : Type u} {n : ℕ} {a : α}, (List.replicate n a).length = n",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Grind.CommRing.Expr.brecOn.go", "Lean.Grind.CommRing.Expr.below"],
  "name": "Lean.Grind.CommRing.Expr.brecOn",
  "constType":
  "{motive : Grind.CommRing.Expr → Sort u} →\n  (t : Grind.CommRing.Expr) → ((t : Grind.CommRing.Expr) → Grind.CommRing.Expr.below t → motive t) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Name.mkStr4",
   "Bind.bind",
   "Lean.SyntaxNodeKind",
   "Lean.Name.mkStr1",
   "ite",
   "Lean.TSyntax.raw",
   "EStateM",
   "Lean.Name.mkStr3",
   "String.toRawSubstring'",
   "Lean.Syntax.isOfKind",
   "Lean.MonadQuotation.getCurrMacroScope",
   "Lean.MacroScope",
   "OfNat.ofNat",
   "Lean.MonadRef.mkInfoFromRefPos",
   "Pure.pure",
   "Lean.Syntax.getArg",
   "Lean.addMacroScope",
   "Lean.MonadQuotation.getContext",
   "Lean.MacroM",
   "MonadExcept.throw",
   "Lean.Syntax.node2"],
  "name":
  "CellularAutomatas.FiniteStateTransducer.«_aux_CellularAutomatas_proofs_finite_state_transducers___macroRules_CellularAutomatas_FiniteStateTransducer_term_⊚__1»",
  "constType": "Macro",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Preorder.le_refl",
  "constType": "∀ {α : Type u_2} [self : Preorder α] (a : α), a ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "Eq.trans",
   "Eq.mp",
   "Classical.propDecidable",
   "eq_true",
   "iff_true",
   "eq_iff_iff._simp_1",
   "iff_false",
   "congrArg",
   "not_false_eq_true",
   "False.elim",
   "congr",
   "eq_false",
   "not_true_eq_false",
   "dite"],
  "name": "Lean.Grind.false_of_not_eq_self",
  "constType": "∀ {a : Prop}, (¬a) = a → False",
  "constCategory": "Theorem"},
 {"references":
  ["Multiset.map",
   "Setoid.r",
   "Multiset.card",
   "Quot.inductionOn",
   "List.length_map",
   "Multiset"],
  "name": "Multiset.card_map",
  "constType":
  "∀ {α : Type u_1} {β : Type v} (f : α → β) (s : Multiset α), (Multiset.map f s).card = s.card",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "LT.lt",
   "lt_add_iff_pos_left",
   "AddRightStrictMono",
   "OfNat.ofNat",
   "propext",
   "AddRightReflectLT"],
  "name": "lt_add_iff_pos_left._simp_4",
  "constType":
  "∀ {α : Type u_1} [inst : AddZeroClass α] [inst_1 : LT α] [AddRightStrictMono α] [AddRightReflectLT α] (a : α) {b : α},\n  (a < b + a) = (0 < b)",
  "constCategory": "Theorem"},
 {"references": ["Int.casesOn"],
  "name": "Int.toNat.match_1",
  "constType":
  "(motive : ℤ → Sort u_1) → (x : ℤ) → ((n : ℕ) → motive (Int.ofNat n)) → ((a : ℕ) → motive (Int.negSucc a)) → motive x",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Nat.Linear.PolyCnstr.lhs",
  "constType": "Nat.Linear.PolyCnstr → Nat.Linear.Poly",
  "constCategory": "Definition"},
 {"references":
  ["LT.lt",
   "Lean.Grind.IntInterval.mem_co",
   "LE.le",
   "Membership.mem",
   "propext"],
  "name": "Lean.Grind.IntInterval.mem_co._simp_1",
  "constType":
  "∀ (lo hi x : ℤ), (x ∈ Grind.IntInterval.co lo hi) = (lo ≤ x ∧ x < hi)",
  "constCategory": "Theorem"},
 {"references": ["Lean.Omega.tidy", "Lean.Omega.Coeffs", "Prod.fst"],
  "name": "Lean.Omega.tidyConstraint",
  "constType": "Omega.Constraint → Omega.Coeffs → Omega.Constraint",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Iff.rfl",
   "CellularAutomatas.tCellAutomaton.L",
   "Language"],
  "name": "CellularAutomatas.tCellAutomaton.elem_L_iff",
  "constType":
  "∀ {α : Type} {w : List α} {C : CellularAutomatas.tCellAutomaton α}, w ∈ C.L ↔ C.F_pos (C.comp w (C.t w.length) 0) = true",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Environment.header",
   "Lean.Import.module",
   "Lean.EnvironmentHeader.modules",
   "Array.findIdx?",
   "BEq.beq",
   "Lean.EffectiveImport.toImport"],
  "name": "Lean.Environment.getModuleIdx?",
  "constType": "Environment → Name → Option ModuleIdx",
  "constCategory": "Definition"},
 {"references":
  ["CellularAutomatas.FiniteStateTransducer.scanr_reduce_q",
   "CellularAutomatas.FiniteStateTransducer.scanr_reduce_q.match_1",
   "CellularAutomatas.Word",
   "CellularAutomatas.FiniteStateTransducer.Q",
   "CellularAutomatas.FiniteStateTransducer.δ",
   "Unit"],
  "name": "CellularAutomatas.FiniteStateTransducer.scanr_reduce_q._sunfold",
  "constType":
  "{α β : Type} → (M : CellularAutomatas.FiniteStateTransducer α β) → M.Q → CellularAutomatas.Word α → M.Q",
  "constCategory": "Definition"},
 {"references": [],
  "name": "AddSemigroup.add_assoc",
  "constType":
  "∀ {G : Type u} [self : AddSemigroup G] (a b c : G), a + b + c = a + (b + c)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Units.val",
  "constType": "{α : Type u} → [inst : Monoid α] → αˣ → α",
  "constCategory": "Definition"},
 {"references": ["Option.casesOn", "Unit.unit", "Unit"],
  "name": "Option.getD.match_1",
  "constType":
  "{α : Type u_1} →\n  (motive : Option α → Sort u_2) → (opt : Option α) → ((x : α) → motive (some x)) → (Unit → motive none) → motive opt",
  "constCategory": "Definition"},
 {"references":
  ["HAppend.hAppend",
   "CellularAutomatas.Word",
   "CellularAutomatas.FiniteStateTransducer.scanr_q_len",
   "Eq.trans",
   "CellularAutomatas.FiniteStateTransducer.scanr_q",
   "List.take_left'",
   "CellularAutomatas.FiniteStateTransducer.scanr",
   "CellularAutomatas.FiniteStateTransducer.scanr_q_append",
   "CellularAutomatas.FiniteStateTransducer.scanr_reduce",
   "CellularAutomatas.FiniteStateTransducer.q0",
   "congrArg",
   "CellularAutomatas.FiniteStateTransducer.scanr_reduce_q",
   "eq_self",
   "of_eq_true",
   "List.take",
   "id",
   "Eq.mpr",
   "List.length"],
  "name": "CellularAutomatas.FiniteStateTransducer.scanr_append_take",
  "constType":
  "∀ {α β : Type} {M : CellularAutomatas.FiniteStateTransducer α β} (p s : CellularAutomatas.Word α),\n  List.take (List.length p) (M.scanr (p ++ s)) = M.scanr_q (M.scanr_reduce s) p",
  "constCategory": "Theorem"},
 {"references": ["Int.ofNat_inj", "Nat.cast", "propext"],
  "name": "Int.ofNat_inj._simp_1",
  "constType": "∀ {m n : ℕ}, (↑m = ↑n) = (m = n)",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans",
   "HMul.hMul",
   "Lean.Grind.CommRing.Poly.ofMon",
   "IntCast.intCast",
   "Lean.Grind.CommRing.Poly.denote_mul",
   "Lean.Grind.Ring.intCast_pow",
   "NatCast.natCast",
   "funext",
   "HSub.hSub",
   "Lean.Grind.CommRing.Poly.denote_ofVar",
   "Lean.Grind.CommRing.Poly.combine",
   "Lean.Grind.Ring.intCast",
   "Neg.neg",
   "Lean.Grind.CommRing.Mon.denote",
   "Lean.Grind.CommRing.Power.denote_eq",
   "Lean.Grind.CommRing.Power.x",
   "id",
   "Eq.mpr",
   "Lean.Grind.Ring.neg_mul",
   "Lean.Grind.CommRing.Poly.denote_ofMon",
   "Lean.Grind.CommRing.Context",
   "Lean.Grind.CommRing.Expr.toPoly",
   "Lean.Grind.CommRing.Poly.mulConst",
   "Nat.cast",
   "Eq.mp",
   "Lean.Grind.Ring.intCast_one",
   "Lean.Grind.Ring.intCast_natCast",
   "Lean.Grind.CommRing.Poly.mul",
   "Lean.Grind.CommRing.Poly.denote_combine",
   "Int.cast",
   "congrArg",
   "Lean.Grind.CommRing.Poly.ofVar",
   "congr",
   "Lean.Grind.CommRing.Power.denote",
   "Lean.Grind.CommRing.Poly.denote",
   "Lean.Grind.CommRing.Expr.toPoly.induct_unfolding",
   "Lean.Grind.CommRing.Poly.pow",
   "Lean.Grind.CommRing.Poly.denote_mulConst",
   "Lean.Grind.Ring.intCast_neg",
   "Lean.Grind.CommRing.Poly.denote_pow",
   "Lean.Grind.CommRing.Expr.denote",
   "Lean.Grind.CommRing.Power.k",
   "Lean.Grind.Semiring.pow_zero",
   "HPow.hPow",
   "Lean.Grind.AddCommGroup.sub_eq_add_neg",
   "Lean.Grind.Semiring.one_mul",
   "OfNat.ofNat",
   "Lean.Grind.CommRing.denoteInt",
   "HAdd.hAdd",
   "beq_iff_eq._simp_1",
   "Lean.Grind.Semiring.mul_one",
   "eq_self",
   "of_eq_true",
   "Lean.Grind.CommRing.Var.denote",
   "Lean.Grind.Semiring.natCast",
   "Lean.Grind.CommRing.denoteInt_eq",
   "Lean.Grind.CommRing.Var",
   "BEq.beq"],
  "name": "Lean.Grind.CommRing.Expr.denote_toPoly",
  "constType":
  "∀ {α : Type u_1} [inst : Grind.CommRing α] (ctx : Grind.CommRing.Context α) (e : Grind.CommRing.Expr),\n  Grind.CommRing.Poly.denote ctx e.toPoly = Grind.CommRing.Expr.denote ctx e",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.tCellAutomaton.t",
   "CellularAutomatas.LCellAutomaton.comp",
   "CellularAutomatas.tCellAutomaton.F_pos",
   "OfNat.ofNat",
   "CellularAutomatas.tCellAutomaton.toLCellAutomaton",
   "List.length"],
  "name": "CellularAutomatas.tCellAutomaton.L",
  "constType": "{α : Type} → CellularAutomatas.tCellAutomaton α → Language α",
  "constCategory": "Definition"},
 {"references": ["CellularAutomatas.Word", "CellularAutomatas.Word.fst"],
  "name": "CellularAutomatas.Word.fst.eq_1",
  "constType":
  "∀ {α β : Type} (w : CellularAutomatas.Word (α ⨉ β)), w.fst = List.map Prod.fst w",
  "constCategory": "Theorem"},
 {"references": ["HAdd.hAdd", "Eq.symm", "Nat.add_assoc"],
  "name": "_private.Init.Data.Nat.Basic.0.Nat.add_sub_add_right._simp_1_1",
  "constType": "∀ (n m k : ℕ), n + (m + k) = n + m + k",
  "constCategory": "Theorem"},
 {"references": ["Option.isSome.match_1", "Unit"],
  "name": "Option.all",
  "constType": "{α : Type u_1} → (α → Bool) → Option α → Bool",
  "constCategory": "Definition"},
 {"references": ["Not", "LT.lt", "Nat.findX", "DecidablePred", "Subtype.val"],
  "name": "Nat.find",
  "constType": "{p : ℕ → Prop} → [DecidablePred p] → (∃ n, p n) → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "Eq.trans",
   "of_eq_true",
   "List.map",
   "Function.comp",
   "congrArg"],
  "name": "List.map_map",
  "constType":
  "∀ {β : Type u_1} {γ : Type u_2} {α : Type u_3} {g : β → γ} {f : α → β} {l : List α},\n  List.map g (List.map f l) = List.map (g ∘ f) l",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.substr",
   "imp_self._simp_1",
   "Eq.trans",
   "Eq.mp",
   "eq_true",
   "GetElem.getElem",
   "congrArg",
   "LT.lt",
   "implies_true",
   "eq_self",
   "List.get",
   "of_eq_true",
   "List.ext_getElem",
   "forall_congr",
   "id",
   "Fin.isLt",
   "forall_prop_domain_congr",
   "List.length"],
  "name": "List.ext_get",
  "constType":
  "∀ {α : Type u_1} {l₁ l₂ : List α},\n  l₁.length = l₂.length →\n    (∀ (n : ℕ) (h₁ : n < l₁.length) (h₂ : n < l₂.length), l₁.get ⟨n, h₁⟩ = l₂.get ⟨n, h₂⟩) → l₁ = l₂",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Lean.Grind.Ring.sub_eq_add_neg",
  "constType": "∀ {α : Type u} [self : Grind.Ring α] (a b : α), a - b = a + -b",
  "constCategory": "Theorem"},
 {"references": ["Option.casesOn"],
  "name": "_private.Init.Prelude.0.Lean.replaceRef.match_1",
  "constType":
  "(motive : Option String.Pos.Raw → Sort u_1) →\n  (x : Option String.Pos.Raw) →\n    ((val : String.Pos.Raw) → motive (some val)) → ((x : Option String.Pos.Raw) → motive x) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Grind.CommRing.Expr.ctorIdx",
   "_private.Init.Grind.Ring.CommSolver.0.Lean.Grind.CommRing.Expr.toPoly_k_eq_toPoly._sparseCasesOn_1_16",
   "Ne",
   "Lean.Grind.CommRing.Var",
   "OfNat.ofNat"],
  "name":
  "_private.Init.Grind.Ring.CommSolver.0.Lean.Grind.CommRing.Expr.toPoly_k_eq_toPoly.match_1_16",
  "constType":
  "(motive : Grind.CommRing.Expr → Sort u_1) →\n  (a : Grind.CommRing.Expr) →\n    ((n : ℤ) → motive (Grind.CommRing.Expr.num n)) →\n      ((n : ℤ) → motive (Grind.CommRing.Expr.intCast n)) →\n        ((n : ℕ) → motive (Grind.CommRing.Expr.natCast n)) →\n          ((x : Grind.CommRing.Var) → motive (Grind.CommRing.Expr.var x)) →\n            ((x : Grind.CommRing.Expr) → motive x) → motive a",
  "constCategory": "Definition"},
 {"references":
  ["Function.Semiconj.comp_eq",
   "Nat.iterate",
   "Function.Commute.self_iterate",
   "Function.iterate_succ",
   "id",
   "Eq.mpr",
   "Function.comp",
   "congrArg"],
  "name": "Function.iterate_succ'",
  "constType": "∀ {α : Type u} (f : α → α) (n : ℕ), f^[n.succ] = f ∘ f^[n]",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CellularAutomatas.TwoStageAdvice.alphabetβ",
  "constType":
  "{α Γ : Type} →\n  [inst : CellularAutomatas.Alphabet α] →\n    [inst_1 : CellularAutomatas.Alphabet Γ] →\n      (self : CellularAutomatas.TwoStageAdvice α Γ) → CellularAutomatas.Alphabet self.β",
  "constCategory": "Definition"},
 {"references":
  ["CellularAutomatas.Advice.f",
   "CellularAutomatas.Word",
   "CellularAutomatas.TwoStageAdvice.advice",
   "CellularAutomatas.TwoStageAdvice.from_transducers"],
  "name": "CellularAutomatas.TwoStageAdvice.from_transducers_eq",
  "constType":
  "∀ {α γ β : Type} [inst : CellularAutomatas.Alphabet α] [inst_1 : CellularAutomatas.Alphabet β]\n  [inst_2 : CellularAutomatas.Alphabet γ] (M : CellularAutomatas.FiniteStateTransducer β γ)\n  (C : CellularAutomatas.CArtTransducer α β), CellularAutomatas.TwoStageAdvice.advice.f = M.advice.f ∘ C.advice.f",
  "constCategory": "Theorem"},
 {"references": ["Finset.univ", "Finset.card"],
  "name": "Fintype.card",
  "constType": "(α : Type u_4) → [Fintype α] → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["HAdd.hAdd",
   "LT.lt",
   "Nat.casesOn",
   "False.elim",
   "Nat.ctorIdx",
   "List.casesOn",
   "noConfusion_of_Nat",
   "Nat.le.casesOn",
   "OfNat.ofNat",
   "List.length"],
  "name": "_private.Init.GetElem.0.List.getElem_cons_drop.match_1_1",
  "constType":
  "∀ {α : Type u_1} (motive : (as : List α) → (i : ℕ) → i < as.length → Prop) (as : List α) (i : ℕ) (h : i < as.length),\n  (∀ (head : α) (tail : List α) (h : 0 < (head :: tail).length), motive (head :: tail) 0 h) →\n    (∀ (head : α) (tail : List α) (i : ℕ) (h : i + 1 < (head :: tail).length), motive (head :: tail) i.succ h) →\n      motive as i h",
  "constCategory": "Definition"},
 {"references": ["Option.or.match_1"],
  "name": "Option.or",
  "constType": "{α : Type u_1} → Option α → Option α → Option α",
  "constCategory": "Definition"},
 {"references":
  ["LT.lt",
   "List.below",
   "List.get.match_1",
   "List.brecOn",
   "List.get._proof_1",
   "OfNat.ofNat",
   "List.length"],
  "name": "List.get",
  "constType": "{α : Type u} → (as : List α) → Fin as.length → α",
  "constCategory": "Definition"},
 {"references": ["zero_le", "LE.le", "eq_true", "OfNat.ofNat"],
  "name": "zero_le._simp_4",
  "constType":
  "∀ {α : Type u} [inst : AddZeroClass α] [inst_1 : LE α] [CanonicallyOrderedAdd α] (a : α), (0 ≤ a) = True",
  "constCategory": "Theorem"},
 {"references":
  ["List.dedup",
   "Setoid.r",
   "DecidableEq",
   "LE.le",
   "List.dedup_sublist",
   "List.Sublist.subperm",
   "Multiset.dedup",
   "Quot.induction_on",
   "Multiset"],
  "name": "Multiset.dedup_le",
  "constType":
  "∀ {α : Type u_1} [inst : DecidableEq α] (s : Multiset α), s.dedup ≤ s",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "Iff.trans",
   "List.length_eq_zero_iff",
   "not_congr",
   "Nat.pos_iff_ne_zero",
   "Ne",
   "OfNat.ofNat",
   "List.length"],
  "name": "List.length_pos_iff",
  "constType": "∀ {α : Type u_1} {l : List α}, 0 < l.length ↔ l ≠ []",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Subtype.property",
  "constType": "∀ {α : Sort u} {p : α → Prop} (self : Subtype p), p ↑self",
  "constCategory": "Theorem"},
 {"references": ["Lean.Omega.Coeffs", "Lean.Omega.IntList.leading"],
  "name": "Lean.Omega.Coeffs.leading",
  "constType": "Omega.Coeffs → ℤ",
  "constCategory": "Definition"},
 {"references":
  ["CellularAutomatas.Word.get'",
   "CellularAutomatas.FiniteStateTransducer.scanr_reduce_cons",
   "Eq.trans",
   "CellularAutomatas.Word.range.eq_1",
   "Membership.mem",
   "GE.ge",
   "List.drop_eq_getElem_cons",
   "dif_pos",
   "CellularAutomatas.FiniteStateTransducer.scanr_reduce'?._proof_1_6",
   "CellularAutomatas.Word.range",
   "CellularAutomatas.Word.get'?",
   "Int.toNat_add",
   "dif_neg",
   "Eq.ndrec",
   "And.left",
   "CellularAutomatas.FiniteStateTransducer.scanr_reduce_empty",
   "CellularAutomatas.Word.get'?.eq_1",
   "List.drop",
   "And.right",
   "Decidable.byContradiction",
   "List.drop_eq_nil_of_le",
   "id",
   "Eq.mpr",
   "setOf",
   "List.length",
   "Int.toNat",
   "Nat.cast",
   "Eq.mp",
   "CellularAutomatas.FiniteStateTransducer.scanr_reduce'?._proof_1_2",
   "CellularAutomatas.FiniteStateTransducer.Q",
   "CellularAutomatas.FiniteStateTransducer.δ?",
   "GetElem.getElem",
   "CellularAutomatas.FiniteStateTransducer.scanr_reduce",
   "CellularAutomatas.FiniteStateTransducer.q0",
   "Decidable.decide",
   "congrArg",
   "CellularAutomatas.FiniteStateTransducer.scanr_reduce'?._proof_1_7",
   "congr",
   "propext",
   "CellularAutomatas.FiniteStateTransducer.δ",
   "of_decide_eq_true",
   "Not",
   "CellularAutomatas.Word",
   "Set",
   "OfNat.ofNat",
   "LT.lt",
   "HAdd.hAdd",
   "eq_self",
   "Int.toNat_of_nonpos",
   "of_eq_true",
   "le_of_lt",
   "LE.le",
   "Nat.add_left_cancel_iff._simp_1",
   "Int.toNat_lt",
   "dite"],
  "name": "CellularAutomatas.FiniteStateTransducer.scanr_reduce'?",
  "constType":
  "∀ {α β : Type} {M : CellularAutomatas.FiniteStateTransducer α β} (w : CellularAutomatas.Word α) (i : ℤ),\n  M.scanr_reduce w⟦i.toNat..*⟧ = M.δ? (M.scanr_reduce w⟦(i + 1).toNat..*⟧) (w.get'? i)",
  "constCategory": "Theorem"},
 {"references": ["outParam"],
  "name": "Lean.Grind.ToInt.toInt",
  "constType":
  "{α : Type u} → {range : outParam Grind.IntInterval} → [self : Grind.ToInt α range] → α → ℤ",
  "constCategory": "Definition"},
 {"references": ["EStateM", "ReaderT"],
  "name": "Lean.MacroM",
  "constType": "Type → Type",
  "constCategory": "Definition"},
 {"references": ["List.below", "List.append.match_1", "List.brecOn"],
  "name": "List.append",
  "constType": "{α : Type u_1} → List α → List α → List α",
  "constCategory": "Definition"},
 {"references": ["Int.ofNat.noConfusion"],
  "name": "Int.ofNat.inj",
  "constType": "∀ {a a_1 : ℕ}, Int.ofNat a = Int.ofNat a_1 → a = a_1",
  "constCategory": "Theorem"},
 {"references":
  ["Int.Linear.Poly.beq'", "Neg.neg", "OfNat.ofNat", "Int.Linear.Var"],
  "name": "Int.Linear.eq_def_cert",
  "constType": "Int.Linear.Var → Int.Linear.Poly → Int.Linear.Poly → Bool",
  "constCategory": "Definition"},
 {"references": ["Iff.mpr", "Iff.mp", "Function.comp"],
  "name": "Iff.trans",
  "constType": "∀ {a b c : Prop}, (a ↔ b) → (b ↔ c) → (a ↔ c)",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "SizeOf.sizeOf",
   "CellularAutomatas.CArtTransducer.toLCellAutomaton",
   "CellularAutomatas.CellAutomaton.Q",
   "OfNat.ofNat"],
  "name": "CellularAutomatas.composition.Params._sizeOf_1",
  "constType": "CellularAutomatas.composition.Params → ℕ",
  "constCategory": "Definition"},
 {"references": ["Fintype.elems"],
  "name": "Finset.univ",
  "constType": "{α : Type u_1} → [Fintype α] → Finset α",
  "constCategory": "Definition"},
 {"references":
  ["Lean.SyntaxNodeKind",
   "Lean.Name.mkSimple",
   "Lean.Name.mkStr1",
   "_private.Init.Prelude.0.Lean.Syntax.getKind.match_1",
   "Lean.identKind",
   "Unit"],
  "name": "Lean.Syntax.getKind",
  "constType": "Syntax → SyntaxNodeKind",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Lean.Name.mkStr1",
  "constType": "String → Name",
  "constCategory": "Definition"},
 {"references":
  ["Or.elim",
   "Lean.Omega.LinearCombo.coordinate_eval_2",
   "Nat.cast",
   "Eq.trans",
   "le_of_le_of_eq",
   "Classical.propDecidable",
   "Lean.Omega.LinearCombo.coordinate_eval_0",
   "Lean.Omega.Constraint.combine_sat'",
   "Decidable.decide",
   "Lean.Omega.Coeffs.ofList",
   "Eq.symm",
   "Lean.Omega.tidy_sat",
   "HSub.hSub",
   "Lean.Omega.LinearCombo.add_eval",
   "Lean.Omega.Int.lt_of_not_le",
   "Decidable.not_or_of_imp",
   "Int.add_one_le_of_lt",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "And.left",
   "of_decide_eq_true",
   "Not",
   "CellularAutomatas.Word",
   "Lean.Omega.combo_sat'",
   "Neg.neg",
   "And.right",
   "Lean.Omega.Constraint.addInequality_sat",
   "Lean.Omega.Int.add_congr",
   "Lean.Omega.Constraint.isImpossible",
   "Lean.Omega.LinearCombo.coordinate",
   "OfNat.ofNat",
   "Int.sub_nonneg_of_le",
   "Lean.Omega.LinearCombo.coordinate_eval_1",
   "HAdd.hAdd",
   "LT.lt",
   "Lean.Omega.Int.ofNat_lt_of_lt",
   "Lean.Omega.LinearCombo.sub_eval",
   "LE.le",
   "id",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.Int.sub_congr",
   "List.length"],
  "name":
  "CellularAutomatas.LCellAutomaton.scan_temporal_independence._proof_1_2",
  "constType":
  "∀ {α : Type} (p s : CellularAutomatas.Word α),\n  ∀ t < List.length p,\n    ∀ (j : ℤ),\n      -↑t ≤ j ∧ j ≤ ↑t → 0 ≤ j ∧ j < ↑(List.length p) + ↑(List.length s) → (0 ≤ j → ↑(List.length p) ≤ j) → False",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Finset.nodup",
  "constType": "∀ {α : Type u_4} (self : Finset α), self.val.Nodup",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Lean.Grind.Ring.intCast_neg",
  "constType": "∀ {α : Type u} [self : Grind.Ring α] (i : ℤ), ↑(-i) = -↑i",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.CellAutomaton.delta_closed_set",
   "Set",
   "CellularAutomatas.CellAutomaton.Q"],
  "name": "CellularAutomatas.CellAutomaton.delta_closed_set.eq_1",
  "constType":
  "∀ (C : CellularAutomatas.CellAutomaton) (Q : Set C.Q),\n  C.delta_closed_set Q = ∀ (a : C.Q) (b : ↑Q) (c : C.Q), C.δ a (↑b) c ∈ Q",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.mul.match_1", "Nat.below", "Nat.brecOn", "Nat.pred", "OfNat.ofNat"],
  "name": "Nat.sub",
  "constType": "ℕ → ℕ → ℕ",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CellularAutomatas.composition.Params.rec",
  "constType":
  "{motive : CellularAutomatas.composition.Params → Sort u} →\n  ((α β : Type) →\n      [_inst_α : CellularAutomatas.Alphabet α] →\n        [_inst_β : CellularAutomatas.Alphabet β] →\n          (C : CellularAutomatas.LCellAutomaton β) →\n            (C_adv : CellularAutomatas.CArtTransducer α β) →\n              (f : C_adv.Q → Option C.Q) →\n                motive { α := α, β := β, _inst_α := _inst_α, _inst_β := _inst_β, C := C, C_adv := C_adv, f := f }) →\n    (t : CellularAutomatas.composition.Params) → motive t",
  "constCategory": "Other"},
 {"references":
  ["Iff.trans",
   "Eq.trans",
   "le_inf_iff._simp_1",
   "true_and",
   "congrArg",
   "le_antisymm_iff",
   "of_eq_true",
   "iff_self",
   "Min.min",
   "congr",
   "LE.le",
   "inf_le_left._simp_1",
   "le_refl._simp_1"],
  "name": "inf_eq_left",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeInf α] {a b : α}, a ⊓ b = a ↔ a ≤ b",
  "constCategory": "Theorem"},
 {"references":
  ["Or.elim",
   "Lean.Omega.LinearCombo.coordinate_eval_2",
   "Nat.cast",
   "Eq.trans",
   "Lean.Omega.Decidable.or_not_not_of_not_and",
   "le_of_le_of_eq",
   "Classical.propDecidable",
   "Lean.Omega.LinearCombo.coordinate_eval_0",
   "Lean.Omega.Constraint.combine_sat'",
   "Decidable.decide",
   "Lean.Omega.LinearCombo.neg_eval",
   "Lean.Omega.Coeffs.ofList",
   "Eq.symm",
   "HSub.hSub",
   "Lean.Omega.tidy_sat",
   "Lean.Omega.LinearCombo.add_eval",
   "Lean.Omega.Int.lt_of_not_le",
   "Lean.Omega.Int.neg_congr",
   "Int.add_one_le_of_lt",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "And.left",
   "of_decide_eq_true",
   "Not",
   "CellularAutomatas.Word",
   "Neg.neg",
   "And.right",
   "Lean.Omega.Constraint.addInequality_sat",
   "Lean.Omega.Int.add_congr",
   "Lean.Omega.Constraint.isImpossible",
   "Lean.Omega.Int.le_of_not_lt",
   "Lean.Omega.LinearCombo.coordinate",
   "OfNat.ofNat",
   "Int.sub_nonneg_of_le",
   "Lean.Omega.LinearCombo.coordinate_eval_1",
   "HAdd.hAdd",
   "LT.lt",
   "Lean.Omega.LinearCombo.sub_eval",
   "LE.le",
   "id",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.Int.sub_congr",
   "List.length"],
  "name": "CellularAutomatas.Word.cone_succ._proof_1_2",
  "constType":
  "∀ {α : Type u_1} {w : CellularAutomatas.Word α} {t : ℕ} {i : ℤ},\n  -↑t ≤ i - 1 ∧ i - 1 < ↑(List.length w) + ↑t →\n    -↑t ≤ i + 1 ∧ i + 1 < ↑(List.length w) + ↑t → ¬(-1 + -↑t ≤ i ∧ i < ↑(List.length w) + (↑t + 1)) → False",
  "constCategory": "Theorem"},
 {"references":
  ["Int.mul_zero",
   "Int.add_right_neg",
   "HAdd.hAdd",
   "Int.mul_add",
   "Neg.neg",
   "Eq.symm",
   "id",
   "HMul.hMul",
   "Eq.mpr",
   "OfNat.ofNat",
   "Int.neg_eq_of_add_eq_zero",
   "congrArg"],
  "name": "Int.neg_mul_eq_mul_neg",
  "constType": "∀ (a b : ℤ), -(a * b) = a * -b",
  "constCategory": "Theorem"},
 {"references": ["setOf"],
  "name": "Set.univ",
  "constType": "{α : Type u} → Set α",
  "constCategory": "Definition"},
 {"references": ["List.range.loop"],
  "name": "List.range",
  "constType": "ℕ → List ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Int.add_left_cancel",
   "Int.add_assoc",
   "Nat.cast",
   "Eq.trans",
   "Eq.mp",
   "Int.add_zero",
   "Nat.eq_zero_of_add_eq_zero_left",
   "_private.Init.Data.Int.Order.0.Int.le_antisymm.match_1_3",
   "OfNat.ofNat",
   "_private.Init.Data.Int.Order.0.Int.le_antisymm.match_1_1",
   "congrArg",
   "HAdd.hAdd",
   "LE.le",
   "id",
   "Eq.symm",
   "Int.natCast_add",
   "Int.ofNat_zero",
   "Eq.mpr",
   "Int.le.dest",
   "Int.ofNat.inj"],
  "name": "Int.le_antisymm",
  "constType": "∀ {a b : ℤ}, a ≤ b → b ≤ a → a = b",
  "constCategory": "Theorem"},
 {"references":
  ["Function.Semiconj",
   "Function.semiconj_iff_comp_eq",
   "Iff.mp",
   "Function.comp"],
  "name": "Function.Semiconj.comp_eq",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {f : α → β} {ga : α → α} {gb : β → β}, Function.Semiconj f ga gb → f ∘ ga = gb ∘ f",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.TwoStageAdvice.advice",
   "Eq.trans",
   "Membership.mem",
   "CellularAutomatas.FiniteStateTransducer.Q",
   "CellularAutomatas.TwoStageAdvice.β",
   "Finset.mem_image._simp_1",
   "CellularAutomatas.FiniteStateTransducer.scanr_reduce",
   "CellularAutomatas.TwoStageAdvice.M",
   "congrArg",
   "CellularAutomatas.TwoStageAdvice.C",
   "funext",
   "HAppend.hAppend",
   "CellularAutomatas.Word",
   "Finset.univ",
   "CellularAutomatas.CArtTransducer.advice",
   "List.drop",
   "CellularAutomatas.FiniteStateTransducer.scanr_q",
   "true_and",
   "Finset.mem_univ._simp_1",
   "CellularAutomatas.possible_advice_prefixes",
   "CellularAutomatas.Advice.f",
   "CellularAutomatas.rel_repr",
   "CellularAutomatas.two_stage_rel_repr_eq",
   "of_eq_true",
   "Finset.image",
   "id",
   "Eq.mpr",
   "exists_apply_eq_apply._simp_1",
   "List.length"],
  "name": "CellularAutomatas.two_stage_advice_in_possible",
  "constType":
  "∀ {α : Type} [inst : CellularAutomatas.Alphabet α] {Γ : Type} [inst_1 : CellularAutomatas.Alphabet Γ]\n  (adv : CellularAutomatas.TwoStageAdvice α Γ) (p s : CellularAutomatas.Word α),\n  CellularAutomatas.rel_repr CellularAutomatas.TwoStageAdvice.advice p s ∈\n    CellularAutomatas.possible_advice_prefixes adv p",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.iterate.match_1", "Nat.below", "Nat.brecOn", "OfNat.ofNat"],
  "name": "Nat.iterate",
  "constType": "{α : Sort u} → (α → α) → ℕ → α → α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Nat.below",
  "constType": "{motive : ℕ → Sort u} → ℕ → Sort (max 1 u)",
  "constCategory": "Definition"},
 {"references": ["CellularAutomatas.CA", "CellularAutomatas.t_rt"],
  "name": "CellularAutomatas.CA_rt",
  "constType": "(α : Type) → Set (CellularAutomatas.tCellAutomaton α)",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Std.LawfulOrderLT.lt_iff",
  "constType":
  "∀ {α : Type u} {inst : LT α} {inst_1 : LE α} [self : LawfulOrderLT α] (a b : α), a < b ↔ a ≤ b ∧ ¬b ≤ a",
  "constCategory": "Theorem"},
 {"references": ["CellularAutomatas.backwards_fsm.Params.inst1"],
  "name": "CellularAutomatas.backwards_fsm.instAlphabetα",
  "constType":
  "(e : CellularAutomatas.backwards_fsm.Params) → CellularAutomatas.Alphabet e.α",
  "constCategory": "Definition"},
 {"references": ["Not"],
  "name": "Ne",
  "constType": "{α : Sort u} → α → α → Prop",
  "constCategory": "Definition"},
 {"references": ["Int.casesOn"],
  "name": "Int.neg.match_1",
  "constType":
  "(motive : ℤ → Sort u_1) → (n : ℤ) → ((n : ℕ) → motive (Int.ofNat n)) → ((n : ℕ) → motive (Int.negSucc n)) → motive n",
  "constCategory": "Definition"},
 {"references":
  ["List.range",
   "CellularAutomatas.Word",
   "List.map",
   "Nat.log2",
   "HPow.hPow",
   "BEq.beq",
   "CellularAutomatas.Advice.exp._proof_1",
   "OfNat.ofNat",
   "List.length"],
  "name": "CellularAutomatas.Advice.exp",
  "constType": "{α : Type} → CellularAutomatas.Advice α Bool",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CellularAutomatas.VerificationError.rec",
  "constType":
  "{motive : CellularAutomatas.VerificationError → Sort u} →\n  ((module : Name) →\n      (message : String) →\n        (details : List String) → motive { module := module, message := message, details := details }) →\n    (t : CellularAutomatas.VerificationError) → motive t",
  "constCategory": "Other"},
 {"references": [],
  "name": "CellularAutomatas.Advice.rec",
  "constType":
  "{α Γ : Type} →\n  {motive : CellularAutomatas.Advice α Γ → Sort u} →\n    ((f : CellularAutomatas.Word α → CellularAutomatas.Word Γ) →\n        (len : ∀ (w : CellularAutomatas.Word α), List.length (f w) = List.length w) → motive { f := f, len := len }) →\n      (t : CellularAutomatas.Advice α Γ) → motive t",
  "constCategory": "Other"},
 {"references": [],
  "name": "Preorder.le_trans",
  "constType":
  "∀ {α : Type u_2} [self : Preorder α] (a b c : α), a ≤ b → b ≤ c → a ≤ c",
  "constCategory": "Theorem"},
 {"references":
  ["Multiset.map", "Finset.map._proof_1", "Finset.val", "DFunLike.coe"],
  "name": "Finset.map",
  "constType":
  "{α : Type u_1} → {β : Type u_2} → (α ↪ β) → Finset α → Finset β",
  "constCategory": "Definition"},
 {"references":
  ["CellularAutomatas.simulation.C'",
   "sorryAx",
   "CellularAutomatas.simulation.Params.C_ctl",
   "CellularAutomatas.CellAutomaton.Q",
   "OfNat.ofNat"],
  "name": "CellularAutomatas.simulation.to_C'Q",
  "constType":
  "(e : CellularAutomatas.simulation.Params) → e.C_ctl.Q → (CellularAutomatas.simulation.C' e).Q",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Grind.AC.Seq.beq'_eq",
   "implies_congr",
   "imp_self._simp_1",
   "Bool.and'_eq_and",
   "Eq.trans",
   "and_imp._simp_1",
   "Lean.Grind.AC.Context.op",
   "Lean.Grind.AC.eq_norm_ac_cert",
   "Lean.Grind.AC.Expr.denote_toSeq",
   "Lean.Grind.AC.Seq.sort",
   "congrArg",
   "Bool.and",
   "of_eq_true",
   "congr",
   "Lean.Grind.AC.Expr.denote",
   "id",
   "Lean.Grind.AC.Seq.denote",
   "Bool.and_eq_true",
   "Eq.mpr",
   "Lean.Grind.AC.Seq.beq'",
   "Eq.ndrec",
   "Bool.and'",
   "Lean.Grind.AC.Seq.denote_sort",
   "Lean.Grind.AC.Expr.toSeq"],
  "name": "Lean.Grind.AC.eq_norm_ac",
  "constType":
  "∀ {α : Sort u_1} (ctx : Grind.AC.Context α) {x : Associative ctx.op} {x : Commutative ctx.op} (lhs rhs : Grind.AC.Expr)\n  (lhs' rhs' : Grind.AC.Seq),\n  Grind.AC.eq_norm_ac_cert lhs rhs lhs' rhs' = true →\n    Grind.AC.Expr.denote ctx lhs = Grind.AC.Expr.denote ctx rhs →\n      Grind.AC.Seq.denote ctx lhs' = Grind.AC.Seq.denote ctx rhs'",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.findX._proof_4",
   "Not",
   "_private.Mathlib.Data.Nat.Find.0.Nat.wf_lbp",
   "Nat.findX._proof_5",
   "Nat.findX._proof_1",
   "Nat.findX._proof_3",
   "DecidablePred",
   "OfNat.ofNat",
   "LT.lt",
   "HAdd.hAdd",
   "WellFounded.fix",
   "_private.Mathlib.Data.Nat.Find.0.Nat.lbp",
   "LE.le",
   "dite",
   "Nat.findX._proof_2"],
  "name": "Nat.findX",
  "constType":
  "{p : ℕ → Prop} → [DecidablePred p] → (∃ n, p n) → { n // p n ∧ ∀ m < n, ¬p m }",
  "constCategory": "Definition"},
 {"references":
  ["CellularAutomatas.tCellAutomaton.t",
   "Set",
   "Membership.mem",
   "HMul.hMul",
   "setOf"],
  "name": "CellularAutomatas.t_lt",
  "constType":
  "(α : Type) → Set (CellularAutomatas.tCellAutomaton α) → Set (CellularAutomatas.tCellAutomaton α)",
  "constCategory": "Definition"},
 {"references": ["rfl", "Option.getD"],
  "name": "Option.getD_some",
  "constType": "∀ {α : Type u_1} {a b : α}, (some a).getD b = a",
  "constCategory": "Theorem"},
 {"references": ["LT.lt", "Not", "LE.le", "Int.not_le", "propext"],
  "name": "Int.not_le._simp_1",
  "constType": "∀ {a b : ℤ}, (¬a ≤ b) = (b < a)",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "Eq.trans",
   "Classical.propDecidable",
   "iff_true",
   "eq_true",
   "eq_iff_iff._simp_1",
   "iff_false",
   "congrArg",
   "eq_self",
   "not_false_eq_true",
   "of_eq_true",
   "congr",
   "eq_false",
   "not_true_eq_false",
   "dite"],
  "name": "Lean.Grind.not_eq_prop",
  "constType": "∀ (p q : Prop), (¬p = q) = (p = ¬q)",
  "constCategory": "Theorem"},
 {"references": ["Nat.cast", "Int.ofNat_le", "Iff.mpr", "LE.le"],
  "name": "Lean.Omega.Int.ofNat_le_of_le",
  "constType": "∀ {x y : ℕ}, x ≤ y → ↑x ≤ ↑y",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "CellularAutomatas.Word",
   "Nat.cast",
   "Set",
   "Neg.neg",
   "Membership.mem",
   "CellularAutomatas.Word.cone",
   "neg_add_rev",
   "OfNat.ofNat",
   "CellularAutomatas.Word.cone_succ._proof_1_2",
   "congrArg",
   "HAdd.hAdd",
   "LT.lt",
   "Decidable.byContradiction",
   "funext",
   "LE.le",
   "id",
   "HSub.hSub",
   "Eq.mpr",
   "setOf",
   "List.length"],
  "name": "CellularAutomatas.Word.cone_succ",
  "constType":
  "∀ {α : Type u_1} {w : CellularAutomatas.Word α} {t : ℕ} {i : ℤ},\n  i - 1 ∈ w.cone t → i + 1 ∈ w.cone t → i ∈ w.cone (t + 1)",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans",
   "Array.getElem_push_eq",
   "GetElem?.getElem?",
   "dif_pos",
   "_private.Init.Data.List.MapIdx.0.List.getElem?_mapIdx_go._proof_1_9",
   "HSub.hSub",
   "Eq.symm",
   "dif_neg",
   "Eq.ndrec",
   "_private.Init.Data.List.MapIdx.0.List.getElem?_mapIdx_go._simp_1_7",
   "HAppend.hAppend",
   "getElem?_pos",
   "List.brecOn",
   "Option.some.injEq",
   "Array.size",
   "List.below",
   "Array.toList_push",
   "Decidable.byContradiction",
   "Array.push",
   "Classical.byContradiction",
   "id",
   "Eq.mpr",
   "_private.Init.Data.List.MapIdx.0.List.getElem?_mapIdx_go._proof_1_10",
   "Nat.zero_lt_succ._simp_1",
   "List.length",
   "GetElem.getElem.congr_simp",
   "_private.Init.Data.List.MapIdx.0.List.getElem?_mapIdx_go.match_1_1",
   "Nat.sub_self",
   "List.getElem_append_left",
   "GetElem.getElem",
   "Array.toList",
   "dite_congr",
   "congrArg",
   "Array.getElem_toList",
   "List.mapIdx.go",
   "congr",
   "Option.map",
   "dite_cond_eq_false",
   "Not",
   "List.mapIdx.go.eq_2",
   "Decidable.casesOn",
   "OfNat.ofNat",
   "Array.size_push",
   "Eq.mpr_prop",
   "LT.lt",
   "HAdd.hAdd",
   "eq_self",
   "_private.Init.Data.List.MapIdx.0.List.getElem?_mapIdx_go._proof_1_8",
   "of_eq_true",
   "LawfulGetElem.getElem?_def",
   "dite"],
  "name": "List.getElem?_mapIdx_go",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {f : ℕ → α → β} {l : List α} {acc : Array β} {i : ℕ},\n  (List.mapIdx.go f l acc)[i]? = if h : i < acc.size then some acc[i] else Option.map (f i) l[i - acc.size]?",
  "constCategory": "Theorem"},
 {"references":
  ["Int.add_right_neg",
   "HAdd.hAdd",
   "Neg.neg",
   "id",
   "HSub.hSub",
   "Eq.mpr",
   "Int.sub_eq_add_neg",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Int.sub_self",
  "constType": "∀ (a : ℤ), a - a = 0",
  "constCategory": "Theorem"},
 {"references": ["rfl", "Nat.iterate"],
  "name": "Function.iterate_succ",
  "constType": "∀ {α : Type u} (f : α → α) (n : ℕ), f^[n.succ] = f^[n] ∘ f",
  "constCategory": "Theorem"},
 {"references":
  ["Setoid.r",
   "Multiset.filter",
   "Multiset.Nodup",
   "DecidablePred",
   "Quot.induction_on",
   "Decidable.decide",
   "List.Nodup.filter",
   "Multiset"],
  "name": "Multiset.Nodup.filter",
  "constType":
  "∀ {α : Type u_1} (p : α → Prop) [inst : DecidablePred p] {s : Multiset α}, s.Nodup → (Multiset.filter p s).Nodup",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "HAdd.hAdd",
   "Lean.Grind.Nat.lt_eq",
   "Eq.substr",
   "LE.le",
   "OfNat.ofNat",
   "List.length"],
  "name": "CellularAutomatas.PrefixStableProof.getLastOfTake._proof_1_1",
  "constType":
  "∀ {i : ℕ} {α : Type u_1} {w : List α}, i + 1 ≤ w.length → i < w.length",
  "constCategory": "Theorem"},
 {"references": ["Lean.Omega.Coeffs", "Lean.Omega.Constraint.sat'"],
  "name": "Lean.Omega.Constraint.sat'.eq_1",
  "constType":
  "∀ (c : Omega.Constraint) (x y : Omega.Coeffs), c.sat' x y = c.sat (x.dot y)",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "List.mem_range._simp_1",
   "CellularAutomatas.ProdCA.zipMany",
   "List.getD",
   "Eq.trans",
   "CellularAutomatas.LCellAutomaton.scan_temporal",
   "Membership.mem",
   "CellularAutomatas.ProdCA",
   "Inhabited.default",
   "congrArg",
   "CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "GetElem?.getElem?",
   "List.length_range",
   "congr",
   "forall_congr",
   "funext",
   "CellularAutomatas.CellAutomaton.Q",
   "Option.map",
   "CellularAutomatas.Word",
   "CellularAutomatas.ProdCA.comp",
   "Option.getD",
   "List.map",
   "List.length_map",
   "CellularAutomatas.LCellAutomaton.comp",
   "List.map_inj_left._simp_1",
   "List.getElem?_map",
   "LT.lt",
   "List.range",
   "List.getD_eq_getElem?_getD",
   "id",
   "CellularAutomatas.ProdCA.scan_temporal._proof_1_4",
   "Eq.mpr",
   "List.length"],
  "name": "CellularAutomatas.ProdCA.scan_temporal",
  "constType":
  "∀ {α β : Type} [inst : CellularAutomatas.Alphabet β] {t : ℕ} {p : ℤ} (f : β → CellularAutomatas.LCellAutomaton α)\n  (w : CellularAutomatas.Word α),\n  (CellularAutomatas.ProdCA α β f).scan_temporal t p w =\n    CellularAutomatas.ProdCA.zipMany fun b => (f b).scan_temporal t p w",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Lean.Grind.Ring.neg_add_cancel",
  "constType": "∀ {α : Type u} [self : Grind.Ring α] (a : α), -a + a = 0",
  "constCategory": "Theorem"},
 {"references": ["DecidableEq"],
  "name": "CellularAutomatas.Alphabet.casesOn",
  "constType":
  "{α : Type} →\n  {motive : CellularAutomatas.Alphabet α → Sort u} →\n    (t : CellularAutomatas.Alphabet α) →\n      ([dec : DecidableEq α] →\n          [fin : Fintype α] → [inh : Inhabited α] → motive { dec := dec, fin := fin, inh := inh }) →\n        motive t",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CellularAutomatas.simulation.Params",
  "constType": "Type 1",
  "constCategory": "Other"},
 {"references": ["Nat.cast", "Monotone.map_min", "Nat.mono_cast"],
  "name": "Nat.cast_min",
  "constType":
  "∀ {α : Type u_3} [inst : Semiring α] [inst_1 : LinearOrder α] [IsStrictOrderedRing α] (m n : ℕ), ↑(min m n) = min ↑m ↑n",
  "constCategory": "Theorem"},
 {"references": ["CellularAutomatas.VerificationError.casesOn"],
  "name": "CellularAutomatas.VerificationError.noConfusionType",
  "constType":
  "Sort u → CellularAutomatas.VerificationError → CellularAutomatas.VerificationError → Sort u",
  "constCategory": "Definition"},
 {"references":
  ["Eq.trans",
   "Int.zero_add",
   "Int.Linear.Poly.denote",
   "HMul.hMul",
   "Int.Linear.Poly.norm",
   "Int.one_mul",
   "Int.Linear.Expr.toPoly'.go",
   "OfNat.ofNat",
   "congrArg",
   "HAdd.hAdd",
   "eq_self",
   "Int.Linear.Poly.denote_norm",
   "Int.Linear.Context",
   "of_eq_true",
   "Int.Linear.Expr.denote",
   "Int.add_comm",
   "Int.Linear.Expr.denote_toPoly'_go"],
  "name": "Int.Linear.Expr.denote_norm",
  "constType":
  "∀ (ctx : Int.Linear.Context) (e : Int.Linear.Expr), Int.Linear.Poly.denote ctx e.norm = Int.Linear.Expr.denote ctx e",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.speedup_factor_k.to_local_config",
   "CellularAutomatas.CellAutomaton.nextt",
   "CellularAutomatas.CellAutomaton.Q",
   "CellularAutomatas.speedup_factor_k.local_config"],
  "name": "CellularAutomatas.speedup_factor_k.C'",
  "constType":
  "(k : ℕ) → [NeZero k] → CellularAutomatas.CellAutomaton → CellularAutomatas.CellAutomaton",
  "constCategory": "Definition"},
 {"references":
  ["Not", "eq_self", "Eq.trans", "of_eq_true", "ite", "ite_congr", "congrArg"],
  "name": "ite_cond_eq_false",
  "constType":
  "∀ {α : Sort u} {c : Prop} {x : Decidable c} (a b : α), c = False → (if c then a else b) = b",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.FiniteStateTransducer.scanr_reduce_q.match_1",
   "CellularAutomatas.Word",
   "CellularAutomatas.FiniteStateTransducer.scanr_reduce_q._unsafe_rec",
   "CellularAutomatas.FiniteStateTransducer.Q",
   "CellularAutomatas.FiniteStateTransducer.δ",
   "Unit"],
  "name": "CellularAutomatas.FiniteStateTransducer.scanr_reduce_q._unsafe_rec",
  "constType":
  "{α β : Type} → (M : CellularAutomatas.FiniteStateTransducer α β) → M.Q → CellularAutomatas.Word α → M.Q",
  "constCategory": "Definition"},
 {"references": [],
  "name": "HasSubset.Subset",
  "constType": "{α : Type u} → [self : HasSubset α] → α → α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "CellularAutomatas.Word",
   "Eq.trans",
   "of_eq_true",
   "List.map",
   "List.length_map",
   "congrArg",
   "Prod.fst",
   "List.length"],
  "name": "CellularAutomatas.Word.fst_len",
  "constType":
  "∀ {α β : Type} (w : CellularAutomatas.Word (α ⨉ β)), List.length w.fst = List.length w",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "HAdd.hAdd",
   "Lean.Grind.Nat.lt_eq",
   "Int.toNat",
   "LE.le",
   "OfNat.ofNat",
   "Eq.mpr_prop",
   "List.length"],
  "name": "CellularAutomatas.FiniteStateTransducer.scanr_get'_eq._proof_1_2",
  "constType":
  "∀ {α : Type} (w : List α) (i : ℤ), i.toNat + 1 ≤ w.length → i.toNat < w.length",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CellularAutomatas.FunctionAlphabet",
  "constType":
  "{α β : Type} → [CellularAutomatas.Alphabet α] → [CellularAutomatas.Alphabet β] → CellularAutomatas.Alphabet (α → β)",
  "constCategory": "Definition"},
 {"references":
  ["Functor.map",
   "Bind.bind",
   "LawfulFunctor.id_map",
   "LawfulMonad.bind_pure_comp",
   "id",
   "Pure.pure",
   "Eq.mpr",
   "congrArg"],
  "name": "bind_pure",
  "constType":
  "∀ {m : Type u_1 → Type u_2} {α : Type u_1} [inst : Monad m] [LawfulMonad m] (x : m α), x >>= pure = x",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.middle_not_two_stage_advice._proof_1_1",
   "CellularAutomatas.TwoStageAdvice.advice",
   "Eq.trans",
   "Eq.mp",
   "le_trans",
   "Membership.mem",
   "CellularAutomatas.FiniteStateTransducer.Q",
   "CellularAutomatas.Advice.from_len_marker",
   "HMul.hMul",
   "CellularAutomatas.TwoStageAdvice.β",
   "List.length_replicate",
   "CellularAutomatas.middle_idx",
   "CellularAutomatas.reachable_markers",
   "GE.ge",
   "CellularAutomatas.TwoStageAdvice.M",
   "congrArg",
   "Inhabited.default",
   "Set.Subset.trans",
   "Fintype.card",
   "Eq.symm",
   "Eq.ndrec",
   "CellularAutomatas.Word",
   "Set",
   "Finset.card",
   "Function.comp",
   "CellularAutomatas.possible_advice_prefixes",
   "OfNat.ofNat",
   "CellularAutomatas.distinct_prefixes_from_markers",
   "List.replicate",
   "HAdd.hAdd",
   "Exists.casesOn",
   "CellularAutomatas.rel_repr",
   "eq_self",
   "CellularAutomatas.two_stage_restriction_cardinality",
   "CellularAutomatas.two_stage_advice_in_possible",
   "SetLike.coe",
   "of_eq_true",
   "HasSubset.Subset",
   "CellularAutomatas.Advice.middle",
   "Finset.card_le_card",
   "LE.le",
   "id",
   "Eq.mpr",
   "CellularAutomatas.Advice.is_two_stage_advice",
   "CellularAutomatas.middle_reachable_card",
   "And.casesOn",
   "setOf",
   "List.length"],
  "name": "CellularAutomatas.middle_not_two_stage_advice",
  "constType":
  "∀ {α : Type} [inst : CellularAutomatas.Alphabet α], ¬(CellularAutomatas.Advice.middle α).is_two_stage_advice",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "CellularAutomatas.Word",
   "Eq.trans",
   "of_eq_true",
   "List.map",
   "Prod.snd",
   "List.length_map",
   "congrArg",
   "List.length"],
  "name": "CellularAutomatas.Word.snd_len",
  "constType":
  "∀ {α β : Type} (w : CellularAutomatas.Word (α ⨉ β)), List.length w.snd = List.length w",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.tCellAutomaton.t",
   "id",
   "inferInstance",
   "CellularAutomatas.LCellAutomaton.comp",
   "CellularAutomatas.tCellAutomaton.F_pos",
   "CellularAutomatas.tCellAutomaton.L",
   "OfNat.ofNat",
   "CellularAutomatas.tCellAutomaton.toLCellAutomaton",
   "List.length"],
  "name": "CellularAutomatas.instDecidablePredListL",
  "constType":
  "{α : Type} → (C : CellularAutomatas.tCellAutomaton α) → DecidablePred C.L",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CellularAutomatas.CArtTransducer",
  "constType":
  "(α Γ : Type) → [CellularAutomatas.Alphabet α] → [CellularAutomatas.Alphabet Γ] → Type 1",
  "constCategory": "Other"},
 {"references": [],
  "name": "CellularAutomatas.backwards_fsm.Params.recOn",
  "constType":
  "{motive : CellularAutomatas.backwards_fsm.Params → Sort u} →\n  (t : CellularAutomatas.backwards_fsm.Params) →\n    ({α β γ : Type} →\n        [inst1 : CellularAutomatas.Alphabet α] →\n          [inst2 : CellularAutomatas.Alphabet β] →\n            [inst3 : CellularAutomatas.Alphabet γ] →\n              (M : CellularAutomatas.FiniteStateTransducer α β) →\n                (C : CellularAutomatas.CArtTransducer β γ) →\n                  motive { α := α, β := β, γ := γ, inst1 := inst1, inst2 := inst2, inst3 := inst3, M := M, C := C }) →\n      motive t",
  "constCategory": "Definition"},
 {"references": ["EStateM", "ReaderT", "Unit"],
  "name": "Lean.PrettyPrinter.UnexpandM",
  "constType": "Type → Type",
  "constCategory": "Definition"},
 {"references": ["Nat.casesOn", "Int.casesOn", "OfNat.ofNat"],
  "name":
  "_private.Init.Data.Int.DivMod.Bootstrap.0.Int.emod_add_mul_ediv.match_1_1",
  "constType":
  "∀ (motive : ℤ → ℤ → Prop) (x x_1 : ℤ),\n  (∀ (a a_1 : ℕ), motive (Int.ofNat a) (Int.ofNat a_1)) →\n    (∀ (m n : ℕ), motive (Int.ofNat m) (Int.negSucc n)) →\n      (∀ (a : ℕ), motive (Int.negSucc a) 0) →\n        (∀ (m n : ℕ), motive (Int.negSucc m) (Int.ofNat n.succ)) →\n          (∀ (m n : ℕ), motive (Int.negSucc m) (Int.negSucc n)) → motive x x_1",
  "constCategory": "Definition"},
 {"references": ["Equiv.bijective", "DFunLike.coe", "Fintype.ofBijective"],
  "name": "Fintype.ofEquiv",
  "constType":
  "{β : Type u_2} → (α : Type u_4) → [Fintype α] → α ≃ β → Fintype β",
  "constCategory": "Definition"},
 {"references":
  ["implies_congr",
   "Int.Linear.Poly.beq'",
   "Int.Linear.le_neg_cert",
   "Eq.trans",
   "Eq.mp",
   "Int.Linear.Poly.denote'_eq_denote",
   "Int.Linear.Poly.mul_k_eq_mul",
   "Int.Linear.Poly.addConst_k_eq_addConst",
   "Int.Linear.Poly.denote",
   "HMul.hMul",
   "Int.neg_one_mul",
   "Int.not_le._simp_1",
   "congrArg",
   "Int.neg_lt_neg",
   "Int.Linear.Poly.mul_k",
   "Eq.symm",
   "Int.Linear.Poly.denote'",
   "Int.Linear.Poly.addConst_k",
   "Eq.ndrec",
   "Not",
   "Neg.neg",
   "Int.Linear.Poly.mul",
   "OfNat.ofNat",
   "Int.Linear.Poly.denote_mul",
   "Int.Linear.Poly.denote_addConst",
   "HAdd.hAdd",
   "LT.lt",
   "Int.Linear.Context",
   "Int.add_comm",
   "LE.le",
   "id",
   "Int.Linear.Poly.beq'_eq",
   "Eq.mpr",
   "Int.Linear.Poly.addConst"],
  "name": "Int.Linear.le_neg",
  "constType":
  "∀ (ctx : Int.Linear.Context) (p₁ p₂ : Int.Linear.Poly),\n  Int.Linear.le_neg_cert p₁ p₂ = true → ¬Int.Linear.Poly.denote' ctx p₁ ≤ 0 → Int.Linear.Poly.denote' ctx p₂ ≤ 0",
  "constCategory": "Theorem"},
 {"references": ["HAdd.hAdd", "Int.add_le_add_left", "Int.add_comm", "LE.le"],
  "name": "Int.add_le_add_right",
  "constType": "∀ {a b : ℤ}, a ≤ b → ∀ (c : ℤ), a + c ≤ b + c",
  "constCategory": "Theorem"},
 {"references": ["SetLike.coe", "Set", "Membership.mem", "Iff.rfl"],
  "name": "SetLike.mem_coe",
  "constType":
  "∀ {A : Type u_1} {B : Type u_2} [i : SetLike A B] {p : A} {x : B}, x ∈ ↑p ↔ x ∈ p",
  "constCategory": "Theorem"},
 {"references": ["CellularAutomatas.CellAutomaton.Q"],
  "name": "CellularAutomatas.speedup_factor_k.Q'",
  "constType": "ℕ → CellularAutomatas.CellAutomaton → Type",
  "constCategory": "Definition"},
 {"references": ["AddMonoidWithOne.natCast_succ"],
  "name": "Nat.cast_succ",
  "constType":
  "∀ {R : Type u_1} [inst : AddMonoidWithOne R] (n : ℕ), ↑n.succ = ↑n + 1",
  "constCategory": "Theorem"},
 {"references": ["Membership.mem", "Lean.Grind.IntInterval.mem_ii", "propext"],
  "name": "Lean.Grind.IntInterval.mem_ii._simp_1",
  "constType": "∀ (x : ℤ), (x ∈ Grind.IntInterval.ii) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Omega.LinearCombo.coeffs",
   "Eq.symm",
   "Lean.Omega.Coeffs",
   "Lean.Omega.LinearCombo.const",
   "Eq.ndrec",
   "Lean.Omega.LinearCombo.casesOn"],
  "name": "Lean.Omega.LinearCombo.ext",
  "constType":
  "∀ {a b : Omega.LinearCombo}, a.const = b.const → a.coeffs = b.coeffs → a = b",
  "constCategory": "Theorem"},
 {"references": ["le_refl", "LE.le", "eq_true"],
  "name": "le_refl._simp_1",
  "constType": "∀ {α : Type u_1} [inst : Preorder α] (a : α), (a ≤ a) = True",
  "constCategory": "Theorem"},
 {"references":
  ["absurd",
   "Not",
   "_private.Init.Prelude.0.of_decide_eq_true.match_1_1",
   "decide_eq_false",
   "Decidable.decide",
   "ne_true_of_eq_false"],
  "name": "of_decide_eq_true",
  "constType": "∀ {p : Prop} [inst : Decidable p], decide p = true → p",
  "constCategory": "Theorem"},
 {"references": ["Nat.casesOn", "List.casesOn", "OfNat.ofNat"],
  "name": "_private.Init.Data.List.Lemmas.0.List.getElem?_map.match_1_1",
  "constType":
  "∀ {α : Type u_1} (motive : List α → ℕ → Prop) (x : List α) (x_1 : ℕ),\n  (∀ (x : ℕ), motive [] x) →\n    (∀ (head : α) (tail : List α), motive (head :: tail) 0) →\n      (∀ (head : α) (l : List α) (i : ℕ), motive (head :: l) i.succ) → motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["List.below",
   "List.filter.match_1",
   "List.brecOn",
   "List.getLast?.match_1",
   "Unit"],
  "name": "List.filter",
  "constType": "{α : Type u} → (α → Bool) → List α → List α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Inv.inv",
  "constType": "{α : Type u} → [self : Inv α] → α → α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Lean.Grind.AC.Context.vars",
  "constType": "{α : Sort u} → Grind.AC.Context α → RArray (PLift α)",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Grind.AddCommGroup.add_left_inj",
   "Lean.Grind.AddCommMonoid.add_assoc",
   "Neg.neg",
   "Lean.Grind.AddCommMonoid.add_comm",
   "Lean.Grind.AddCommGroup.neg_add_cancel",
   "OfNat.ofNat",
   "congrArg",
   "HAdd.hAdd",
   "Lean.Grind.AddCommMonoid.zero_add",
   "id",
   "Eq.symm",
   "Eq.mpr",
   "propext"],
  "name": "Lean.Grind.AddCommGroup.neg_add",
  "constType":
  "∀ {M : Type u} [inst : Grind.AddCommGroup M] (a b : M), -(a + b) = -a + -b",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Nat.Linear.PolyCnstr.rhs",
  "constType": "Nat.Linear.PolyCnstr → Nat.Linear.Poly",
  "constCategory": "Definition"},
 {"references": ["Units.val"],
  "name": "IsUnit",
  "constType": "{M : Type u_1} → [Monoid M] → M → Prop",
  "constCategory": "Definition"},
 {"references": ["Nat.ble", "Nat.div"],
  "name": "Nat.log2",
  "constType": "ℕ → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["CellularAutomatas.Word",
   "Set",
   "Membership.mem",
   "CellularAutomatas.Word.range",
   "CellularAutomatas.LCellAutomaton.embed_word_eq._proof_1_4"],
  "name": "CellularAutomatas.LCellAutomaton.embed_word_eq",
  "constType":
  "∀ {α : Type} (C : CellularAutomatas.LCellAutomaton α) {w : CellularAutomatas.Word α} {p : ℤ} (h : p ∈ w.range),\n  C.embed_word w p = C.embed (w.get' p h)",
  "constCategory": "Theorem"},
 {"references": ["Not", "False.elim", "Iff.mp", "propext"],
  "name": "iff_false",
  "constType": "∀ (p : Prop), (p ↔ False) = ¬p",
  "constCategory": "Theorem"},
 {"references": ["Lean.Name.casesOn"],
  "name": "Lean.Name.appendCore.match_1",
  "constType":
  "(motive : Name → Name → Sort u_1) →\n  (x x_1 : Name) →\n    ((n : Name) → motive n Name.anonymous) →\n      ((n p : Name) → (s : String) → motive n (p.str s)) → ((n p : Name) → (d : ℕ) → motive n (p.num d)) → motive x x_1",
  "constCategory": "Definition"},
 {"references": ["HAdd.hAdd", "Eq.symm", "Eq.ndrec"],
  "name": "Mathlib.Tactic.Ring.add_congr",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a a' b b' c : R}, a = a' → b = b' → a' + b' = c → a + b = c",
  "constCategory": "Theorem"},
 {"references":
  ["rfl",
   "LT.lt",
   "Decidable.decide",
   "UInt64.size",
   "OfNat.ofNat",
   "of_decide_eq_true"],
  "name": "_private.Init.Prelude.0.Lean.Name.hash._proof_1",
  "constType": "1723 < UInt64.size",
  "constCategory": "Theorem"},
 {"references":
  ["List.ctorIdx",
   "Eq.trans",
   "Eq.mp",
   "noConfusion_of_Nat",
   "GetElem.getElem",
   "congrArg",
   "_private.Init.Data.List.Lemmas.0.List.ext_getElem?.match_1_1",
   "Option.ctorIdx",
   "GetElem?.getElem?",
   "not_false_eq_true",
   "False.elim",
   "List.nil_eq._simp_1",
   "congr",
   "rfl",
   "Not",
   "Nat.lt_irrefl._simp_1",
   "getElem?_pos",
   "List.brecOn",
   "eq_false'",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "Option.some.injEq",
   "LT.lt",
   "eq_self",
   "List.below",
   "of_eq_true",
   "id",
   "Eq.mpr",
   "Option.some.noConfusion",
   "Nat.zero_lt_succ._simp_1",
   "getElem?_neg",
   "List.length"],
  "name": "List.ext_getElem?",
  "constType":
  "∀ {α : Type u_1} {l₁ l₂ : List α}, (∀ (i : ℕ), l₁[i]? = l₂[i]?) → l₁ = l₂",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "LT.lt",
  "constType": "{α : Type u} → [self : LT α] → α → α → Prop",
  "constCategory": "Definition"},
 {"references": ["Lean.SyntaxNodeKind"],
  "name": "Lean.Syntax.casesOn",
  "constType":
  "{motive_1 : Syntax → Sort u} →\n  (t : Syntax) →\n    motive_1 Syntax.missing →\n      ((info : SourceInfo) → (kind : SyntaxNodeKind) → (args : Array Syntax) → motive_1 (Syntax.node info kind args)) →\n        ((info : SourceInfo) → (val : String) → motive_1 (Syntax.atom info val)) →\n          ((info : SourceInfo) →\n              (rawVal : Substring.Raw) →\n                (val : Name) →\n                  (preresolved : List Syntax.Preresolved) → motive_1 (Syntax.ident info rawVal val preresolved)) →\n            motive_1 t",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Name.mkStr4",
   "Bind.bind",
   "Lean.SyntaxNodeKind",
   "Lean.Name.mkStr1",
   "ite",
   "Lean.TSyntax.raw",
   "Lean.PrettyPrinter.UnexpandM",
   "EStateM",
   "Lean.MonadQuotation.getCurrMacroScope",
   "Lean.Syntax.isOfKind",
   "Lean.Syntax.node3",
   "Lean.MacroScope",
   "Lean.Syntax.matchesNull",
   "OfNat.ofNat",
   "Unit",
   "Lean.MonadRef.mkInfoFromRefPos",
   "Pure.pure",
   "Lean.Syntax.getArg",
   "Lean.MonadQuotation.getContext",
   "Lean.Name.mkStr2",
   "Unit.unit",
   "MonadExcept.throw"],
  "name": "CellularAutomatas.unexpand_zip_words",
  "constType": "PrettyPrinter.Unexpander",
  "constCategory": "Definition"},
 {"references": ["LE.le", "ge_iff_le", "GE.ge", "propext"],
  "name": "CellularAutomatas.Word.get'._simp_2",
  "constType": "∀ {α : Type u_1} [inst : LE α] {x y : α}, (x ≥ y) = (y ≤ x)",
  "constCategory": "Theorem"},
 {"references": ["Lean.Omega.IntList.dot_distrib_left", "Lean.Omega.Coeffs"],
  "name": "Lean.Omega.Coeffs.dot_distrib_left",
  "constType":
  "∀ (xs ys zs : Omega.Coeffs), (xs + ys).dot zs = xs.dot zs + ys.dot zs",
  "constCategory": "Theorem"},
 {"references": ["Exists.casesOn", "Iff.mpr"],
  "name": "_private.Init.PropLemmas.0.exists_prop_congr.match_1_3",
  "constType":
  "∀ {p p' : Prop} {q' : p → Prop} (hp : p ↔ p') (motive : (∃ (h : p'), q' ⋯) → Prop) (x : ∃ (h : p'), q' ⋯),\n  (∀ (w : p') (h : q' ⋯), motive ⋯) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Eq.trans",
   "Eq.mp",
   "Membership.mem",
   "eq_true",
   "HMul.hMul",
   "eagerReduce",
   "IntCast.intCast",
   "CellularAutomatas.LcInRt.DiagonalShiftCA_comp_p0._proof_1_3",
   "Nat.ToInt.natCast_ofNat",
   "NatCast.natCast",
   "Eq.symm",
   "Set.mem_setOf_eq",
   "Neg.neg",
   "Set",
   "Lean.Grind.eq_true_of_and_eq_true_right",
   "Nat.ToInt.add_congr",
   "Lean.Grind.Order.le_eq_true_of_le_k",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "Nat.ToInt.le_eq",
   "of_eq_true",
   "LE.le",
   "id",
   "Lean.Grind.Order.eq_trans_true",
   "Lean.Grind.CommRing.le_norm_expr",
   "List.length",
   "setOf",
   "Lean.Grind.Order.eq_mp"],
  "name": "CellularAutomatas.LcInRt.DiagonalShiftCA_comp_p0._proof_1_4",
  "constType":
  "∀ {α : Type} {t : ℕ} (w : List α), ↑t ∈ {i | -1 * i ≤ 0 ∧ i + -1 * ↑w.length + 1 ≤ 0} → t < w.length",
  "constCategory": "Theorem"},
 {"references": ["Lean.Grind.AC.Var", "Lean.Grind.AC.Seq.casesOn"],
  "name": "Lean.Grind.AC.Seq.ctorIdx",
  "constType": "Grind.AC.Seq → ℕ",
  "constCategory": "Definition"},
 {"references": ["List.casesOn", "Unit.unit", "Unit"],
  "name":
  "_private.Init.Data.List.Lemmas.0.List.getLast?_eq_getElem?.match_1_1",
  "constType":
  "∀ {α : Type u_1} (motive : List α → Prop) (x : List α),\n  (∀ (a : Unit), motive []) → (∀ (a : α) (l : List α), motive (a :: l)) → motive x",
  "constCategory": "Definition"},
 {"references": [],
  "name": "trivial",
  "constType": "True",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Omega.LinearCombo.coordinate_eval_2",
   "Nat.cast",
   "Eq.trans",
   "le_of_le_of_eq",
   "CellularAutomatas.FiniteStateTransducer.Q",
   "CellularAutomatas.TwoStageAdvice.β",
   "HMul.hMul",
   "CellularAutomatas.middle_idx",
   "Lean.Omega.Constraint.combine_sat'",
   "CellularAutomatas.reachable_markers",
   "CellularAutomatas.TwoStageAdvice.M",
   "GE.ge",
   "Decidable.decide",
   "Lean.Omega.Int.ofNat_le_of_le",
   "Fintype.card",
   "Lean.Omega.Coeffs.ofList",
   "Eq.symm",
   "HSub.hSub",
   "Lean.Omega.tidy_sat",
   "Lean.Omega.LinearCombo.add_eval",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "of_decide_eq_true",
   "Neg.neg",
   "Finset.card",
   "Lean.Omega.Constraint.addInequality_sat",
   "Lean.Omega.Int.add_congr",
   "Function.comp",
   "Lean.Omega.Constraint.isImpossible",
   "Lean.Omega.LinearCombo.coordinate",
   "Int.sub_nonneg_of_le",
   "OfNat.ofNat",
   "Lean.Omega.LinearCombo.coordinate_eval_1",
   "HAdd.hAdd",
   "Lean.Omega.LinearCombo.sub_eval",
   "LE.le",
   "Int.natCast_add",
   "id",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.Int.sub_congr"],
  "name": "CellularAutomatas.middle_not_two_stage_advice._proof_1_1",
  "constType":
  "∀ {α : Type} [inst : CellularAutomatas.Alphabet α] (adv : CellularAutomatas.TwoStageAdvice α Bool)\n  (S : Finset (List Bool)),\n  (CellularAutomatas.reachable_markers (some ∘ CellularAutomatas.middle_idx) (2 * (Fintype.card adv.M.Q + 1))).card ≥\n      Fintype.card adv.M.Q + 1 →\n    (CellularAutomatas.reachable_markers (some ∘ CellularAutomatas.middle_idx) (2 * (Fintype.card adv.M.Q + 1))).card ≤\n        Fintype.card adv.M.Q →\n      False",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.propIntro",
   "eq_of_heq",
   "Eq.symm",
   "CellularAutomatas.CellAutomaton.Q",
   "CellularAutomatas.LCellAutomaton.mk.noConfusion",
   "Eq.ndrec",
   "Eq.casesOn",
   "HEq.casesOn",
   "And.casesOn"],
  "name": "CellularAutomatas.LCellAutomaton.mk.injEq",
  "constType":
  "∀ {α : Type} (toCellAutomaton : CellularAutomatas.CellAutomaton) (embed : α → toCellAutomaton.Q)\n  (border : toCellAutomaton.Q) (toCellAutomaton_1 : CellularAutomatas.CellAutomaton) (embed_1 : α → toCellAutomaton_1.Q)\n  (border_1 : toCellAutomaton_1.Q),\n  ({ toCellAutomaton := toCellAutomaton, embed := embed, border := border } =\n      { toCellAutomaton := toCellAutomaton_1, embed := embed_1, border := border_1 }) =\n    (toCellAutomaton = toCellAutomaton_1 ∧ embed ≍ embed_1 ∧ border ≍ border_1)",
  "constCategory": "Theorem"},
 {"references": ["List.below"],
  "name": "List.brecOn.go",
  "constType":
  "{α : Type u} →\n  {motive : List α → Sort u_1} → (t : List α) → ((t : List α) → List.below t → motive t) → motive t ×' List.below t",
  "constCategory": "Definition"},
 {"references":
  ["eq_self", "Eq.trans", "of_eq_true", "Eq.symm", "Eq.ndrec", "congrArg"],
  "name": "Lean.Grind.Order.eq_trans_false",
  "constType": "∀ {p q : Prop}, p = q → q = False → p = False",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "List.mapIdx.go",
   "eq_self",
   "Array.size",
   "List.toArray",
   "Eq.trans",
   "of_eq_true",
   "List.length_mapIdx_go",
   "List.size_toArray",
   "congrArg",
   "List.length"],
  "name": "List.length_mapIdx",
  "constType":
  "∀ {α : Type u_1} {α_1 : Type u_2} {f : ℕ → α → α_1} {l : List α}, (List.mapIdx f l).length = l.length",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd", "Fin.val", "Nat.cast", "HMul.hMul", "CellularAutomatas.Config"],
  "name": "CellularAutomatas.speedup_factor_k.compress",
  "constType":
  "{Q : Type} → (k : ℕ) → CellularAutomatas.Config Q → CellularAutomatas.Config (Fin k → Q)",
  "constCategory": "Definition"},
 {"references": ["Std.TreeSet.inner", "Std.TreeMap.keys", "Unit"],
  "name": "Std.TreeSet.toList",
  "constType":
  "{α : Type u} → {cmp : α → α → Ordering} → TreeSet α cmp → List α",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Grind.AC.Seq.beq'",
   "Bool.and'",
   "Lean.Grind.AC.Expr.toSeq",
   "Lean.Grind.AC.Seq.sort"],
  "name": "Lean.Grind.AC.eq_norm_ac_cert",
  "constType":
  "Grind.AC.Expr → Grind.AC.Expr → Grind.AC.Seq → Grind.AC.Seq → Bool",
  "constCategory": "Definition"},
 {"references":
  ["Set", "CellularAutomatas.tCellAutomatonWithAdvice.with_advice"],
  "name":
  "CellularAutomatas.instHAddSetTCellAutomatonProdAdviceTCellAutomatonWithAdviceOfAlphabet",
  "constType":
  "{α Γ : Type} →\n  [CellularAutomatas.Alphabet Γ] →\n    HAdd (Set (CellularAutomatas.tCellAutomaton (α ⨉ Γ))) (CellularAutomatas.Advice α Γ)\n      (Set (CellularAutomatas.tCellAutomatonWithAdvice α))",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Subtype.val",
  "constType": "{α : Sort u} → {p : α → Prop} → Subtype p → α",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "CellularAutomatas.CellAutomaton.δ",
   "Eq.trans",
   "of_eq_true",
   "CellularAutomatas.CellAutomaton.quiescent",
   "CellularAutomatas.CellAutomaton.Q",
   "CellularAutomatas.CellAutomaton.δ_of_quiescent",
   "congrArg"],
  "name": "CellularAutomatas.CellAutomaton.δδ_of_quiescent2",
  "constType":
  "∀ {C : CellularAutomatas.CellAutomaton} {q : C.Q}, C.quiescent q → CellularAutomatas.δδ q = q",
  "constCategory": "Theorem"},
 {"references": ["Nat.casesOn", "Unit.unit", "OfNat.ofNat", "Unit"],
  "name": "_private.Init.Data.Nat.Basic.0.Nat.zero_add.match_1_1",
  "constType":
  "∀ (motive : ℕ → Prop) (x : ℕ), (∀ (a : Unit), motive 0) → (∀ (n : ℕ), motive n.succ) → motive x",
  "constCategory": "Definition"},
 {"references": ["Nat.casesOn", "Unit.unit", "Unit"],
  "name": "_private.Init.Prelude.0.noConfusion_of_Nat.aux.match_1_1",
  "constType":
  "∀ (motive : ℕ → Prop) (x : ℕ), (∀ (a : Unit), motive Nat.zero) → (∀ (n : ℕ), motive n.succ) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Not",
   "CellularAutomatas.Word.get'",
   "CellularAutomatas.Word",
   "Set",
   "Membership.mem",
   "CellularAutomatas.Word.range",
   "dite"],
  "name": "CellularAutomatas.Word.get'?",
  "constType": "{α : Type u} → CellularAutomatas.Word α → ℤ → Option α",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Omega.LinearCombo.coordinate_eval_2",
   "Nat.cast",
   "Eq.trans",
   "Lean.Omega.LinearCombo.coordinate_eval_3",
   "le_of_le_of_eq",
   "Lean.Omega.LinearCombo.coordinate_eval_0",
   "Lean.Omega.Constraint.combine_sat'",
   "Int.sub_eq_zero_of_eq",
   "Decidable.decide",
   "Lean.Omega.Int.ofNat_le_of_le",
   "Inhabited.default",
   "Lean.Omega.Coeffs.ofList",
   "Lean.Omega.tidy_sat",
   "Eq.symm",
   "HSub.hSub",
   "Lean.Omega.LinearCombo.add_eval",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "Int.add_one_le_of_lt",
   "of_decide_eq_true",
   "Not",
   "HAppend.hAppend",
   "CellularAutomatas.Word",
   "Lean.Omega.combo_sat'",
   "Neg.neg",
   "Lean.Omega.Int.ofNat_congr",
   "Lean.Omega.Constraint.addInequality_sat",
   "Lean.Omega.Int.add_congr",
   "Lean.Omega.Constraint.isImpossible",
   "Lean.Omega.LinearCombo.coordinate",
   "OfNat.ofNat",
   "Int.sub_nonneg_of_le",
   "List.replicate",
   "HAdd.hAdd",
   "Lean.Omega.LinearCombo.sub_eval",
   "Lean.Omega.Int.ofNat_lt_of_lt",
   "Nat.lt_of_not_le",
   "LE.le",
   "Lean.Omega.Constraint.addEquality_sat",
   "id",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.Int.sub_congr",
   "List.length"],
  "name": "CellularAutomatas.distinct_prefixes_from_markers._proof_1_2",
  "constType":
  "∀ {α : Type} [inst : CellularAutomatas.Alphabet α] (p : CellularAutomatas.Word α) (pos n : ℕ),\n  List.length p ≤ n →\n    List.length (p ++ List.replicate (n - List.length p) default) = n →\n      ¬List.length p ≤ List.length (p ++ List.replicate (n - List.length p) default) → False",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Omega.LinearCombo.coordinate_eval_2",
   "Nat.cast",
   "Eq.trans",
   "le_of_le_of_eq",
   "Lean.Omega.LinearCombo.coordinate_eval_0",
   "Lean.Omega.Constraint.combine_sat'",
   "Int.sub_eq_zero_of_eq",
   "Decidable.decide",
   "GE.ge",
   "Lean.Omega.LinearCombo.neg_eval",
   "Lean.Omega.Coeffs.ofList",
   "HSub.hSub",
   "Lean.Omega.tidy_sat",
   "Eq.symm",
   "Lean.Omega.LinearCombo.add_eval",
   "Int.add_one_le_of_lt",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "Lean.Omega.Int.neg_congr",
   "of_decide_eq_true",
   "Not",
   "Lean.Omega.combo_sat'",
   "Neg.neg",
   "Lean.Omega.Constraint.addInequality_sat",
   "Lean.Omega.Int.add_congr",
   "Lean.Omega.Constraint.isImpossible",
   "Lean.Omega.LinearCombo.coordinate",
   "Int.sub_nonneg_of_le",
   "OfNat.ofNat",
   "Lean.Omega.LinearCombo.coordinate_eval_1",
   "HAdd.hAdd",
   "Lean.Omega.Int.ofNat_lt_of_lt",
   "Lean.Omega.LinearCombo.sub_eval",
   "Nat.lt_of_not_le",
   "id",
   "Lean.Omega.Constraint.addEquality_sat",
   "Int.natCast_add",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.Int.sub_congr"],
  "name":
  "_private.Init.Grind.Ring.Basic.0.Lean.Grind.Ring.intCast_add._proof_1_8",
  "constType":
  "∀ (x y : ℕ), ¬y ≥ x + 1 → -↑(x + 1) + ↑y = -↑(x + 1 - y) → ¬x + 1 ≥ y → False",
  "constCategory": "Theorem"},
 {"references":
  ["Int.Linear.Poly.beq'",
   "Nat.cast",
   "Int.Linear.Poly.combine_mul_k",
   "Int.Linear.Poly.leadCoeff",
   "Int.natAbs"],
  "name": "Int.Linear.le_combine_cert",
  "constType": "Int.Linear.Poly → Int.Linear.Poly → Int.Linear.Poly → Bool",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CellularAutomatas.Alphabet.mk",
  "constType":
  "{α : Type} → [dec : DecidableEq α] → [fin : Fintype α] → [inh : Inhabited α] → CellularAutomatas.Alphabet α",
  "constCategory": "Other"},
 {"references": ["NonemptyType", "Subtype.val"],
  "name": "NonemptyType.type",
  "constType": "NonemptyType → Type u",
  "constCategory": "Definition"},
 {"references":
  ["rfl",
   "HAdd.hAdd",
   "Nat.add",
   "Nat.below",
   "Nat.brecOn",
   "_private.Init.Data.Nat.Basic.0.Nat.succ_add.match_1_1",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Nat.succ_add",
  "constType": "∀ (n m : ℕ), n.succ + m = (n + m).succ",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.CellAutomaton.δ", "CellularAutomatas.CellAutomaton.Q"],
  "name": "CellularAutomatas.δδ",
  "constType": "{C : CellularAutomatas.CellAutomaton} → C.Q → C.Q",
  "constCategory": "Definition"},
 {"references":
  ["CellularAutomatas.FiniteStateTransducer.comp.match_1",
   "CellularAutomatas.FiniteStateTransducer.Q",
   "CellularAutomatas.FiniteStateTransducer.q0",
   "CellularAutomatas.FiniteStateTransducer.f",
   "CellularAutomatas.FiniteStateTransducer.δ"],
  "name": "CellularAutomatas.FiniteStateTransducer.comp",
  "constType":
  "{β γ α : Type} →\n  CellularAutomatas.FiniteStateTransducer β γ →\n    CellularAutomatas.FiniteStateTransducer α β → CellularAutomatas.FiniteStateTransducer α γ",
  "constCategory": "Definition"},
 {"references": ["Nat.casesOn", "Unit.unit", "OfNat.ofNat", "Unit"],
  "name": "Int.negOfNat.match_1",
  "constType":
  "(motive : ℕ → Sort u_1) → (x : ℕ) → (Unit → motive 0) → ((m : ℕ) → motive m.succ) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Option.ctorIdx", "Ne", "Nat.ne_of_beq_eq_false", "OfNat.ofNat"],
  "name":
  "_private.Lean.Environment.0.Lean.Kernel.Environment.Diagnostics.recordUnfold._sparseCasesOn_1",
  "constType":
  "{α : Type u} →\n  {motive : Option α → Sort u_1} →\n    (t : Option α) → ((val : α) → motive (some val)) → (t.ctorIdx ≠ 1 → motive t) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["Nat.cast",
   "Int.subNatNat",
   "Eq.trans",
   "Nat.add_comm",
   "Int.subNatNat_add_negSucc",
   "Nat.add_assoc",
   "OfNat.ofNat",
   "congrArg",
   "HAdd.hAdd",
   "eq_self",
   "of_eq_true",
   "congr",
   "Int.add_comm",
   "id",
   "Eq.mpr",
   "Nat.add_left_comm"],
  "name": "_private.Init.Data.Int.Lemmas.0.Int.add_assoc.aux2",
  "constType":
  "∀ (m n k : ℕ), Int.negSucc m + Int.negSucc n + ↑k = Int.negSucc m + (Int.negSucc n + ↑k)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CellularAutomatas.CArtTransducer.ctorIdx",
  "constType":
  "{α Γ : Type} →\n  {inst : CellularAutomatas.Alphabet α} →\n    {inst_1 : CellularAutomatas.Alphabet Γ} → CellularAutomatas.CArtTransducer α Γ → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["_private.Init.Data.List.Nat.TakeDrop.0.List.take_eq_take_iff.match_1_1",
   "List.ctorIdx",
   "Eq.trans",
   "Nat.succ_ne_self._simp_1",
   "Nat.min_eq_left",
   "noConfusion_of_Nat",
   "Nat.add_eq_zero_iff._simp_1",
   "List.take_nil",
   "congrArg",
   "Nat.min_eq_zero_iff._simp_1",
   "False.elim",
   "Nat.succ_min_succ",
   "Nat.add_right_cancel_iff._simp_1",
   "iff_self",
   "List.nil_eq._simp_1",
   "congr",
   "List.length_eq_zero_iff._simp_1",
   "propext",
   "Nat.zero_le._simp_1",
   "Nat.min_eq_right",
   "List.brecOn",
   "eq_false'",
   "true_and",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "eq_self",
   "List.below",
   "of_eq_true",
   "List.cons.injEq",
   "Min.min",
   "List.take",
   "LE.le",
   "Nat.right_eq_add._simp_1",
   "and_false",
   "List.length",
   "Nat.le_add_left._simp_1"],
  "name": "List.take_eq_take_iff",
  "constType":
  "∀ {α : Type u_1} {l : List α} {i j : ℕ}, List.take i l = List.take j l ↔ min i l.length = min j l.length",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "MulZeroClass.mul_zero",
  "constType": "∀ {M₀ : Type u} [self : MulZeroClass M₀] (a : M₀), a * 0 = 0",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Prod.snd",
  "constType": "{α : Type u} → {β : Type v} → α ⨉ β → β",
  "constCategory": "Definition"},
 {"references":
  ["HAdd.hAdd", "LE.le", "Iff.mp", "Lean.Grind.OrderedAdd.add_le_right_iff"],
  "name": "Lean.Grind.OrderedAdd.add_le_right",
  "constType":
  "∀ {M : Type u} [inst : LE M] [inst_1 : Std.IsPreorder M] [inst_2 : Grind.AddCommMonoid M] [Grind.OrderedAdd M] {a b : M}\n  (c : M), a ≤ b → c + a ≤ c + b",
  "constCategory": "Theorem"},
 {"references": ["_private.Init.SimpLemmas.0.or_self.match_1_1", "propext"],
  "name": "or_self",
  "constType": "∀ (p : Prop), (p ∨ p) = p",
  "constCategory": "Theorem"},
 {"references": ["CellularAutomatas.Advice.f", "List.getLast?", "setOf"],
  "name": "CellularAutomatas.L_c",
  "constType": "{α Γ : Type} → CellularAutomatas.Advice α Γ → Γ → Language α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Lean.Kernel.Environment.const2ModIdx",
  "constType": "Kernel.Environment → HashMap Name ModuleIdx",
  "constCategory": "Definition"},
 {"references": ["Nat.iterate"],
  "name": "CellularAutomatas.apply_iterated",
  "constType": "{α : Sort u_1} → (α → α) → α → ℕ → α",
  "constCategory": "Definition"},
 {"references":
  ["eq_self", "Eq.trans", "of_eq_true", "Eq.symm", "Eq.ndrec", "congrArg"],
  "name": "Lean.Grind.Order.eq_trans_false'",
  "constType": "∀ {p q : Prop}, p = q → p = False → q = False",
  "constCategory": "Theorem"},
 {"references": ["Monoid.npow_zero"],
  "name": "pow_zero",
  "constType": "∀ {M : Type u_2} [inst : Monoid M] (a : M), a ^ 0 = 1",
  "constCategory": "Theorem"},
 {"references": ["LT.lt", "Nat.cast", "Int.ofNat_lt", "propext"],
  "name": "Int.ofNat_lt._simp_1",
  "constType": "∀ {n m : ℕ}, (↑n < ↑m) = (n < m)",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "Lean.Grind.OrderedAdd.add_le_left_iff",
   "Eq.mp",
   "And.right",
   "Iff.mp",
   "LT.lt",
   "HAdd.hAdd",
   "Lean.Grind.OrderedAdd.add_lt_left",
   "Iff.mpr",
   "LE.le",
   "id",
   "_private.Init.Grind.Ordered.Module.0.Lean.Grind.OrderedAdd.add_lt_left_iff._simp_1_1",
   "Eq.mpr",
   "And.left"],
  "name": "Lean.Grind.OrderedAdd.add_lt_left_iff",
  "constType":
  "∀ {M : Type u} [inst : LE M] [inst_1 : Std.IsPreorder M] [inst_2 : Grind.AddCommMonoid M] [Grind.OrderedAdd M]\n  [inst_4 : LT M] [LawfulOrderLT M] {a b : M} (c : M), a < b ↔ a + c < b + c",
  "constCategory": "Theorem"},
 {"references": ["LT.lt", "Min.min", "lt_inf_iff", "propext"],
  "name": "lt_inf_iff._simp_1",
  "constType":
  "∀ {α : Type u} [inst : LinearOrder α] {a b c : α}, (a < min b c) = (a < b ∧ a < c)",
  "constCategory": "Theorem"},
 {"references": ["Exists.casesOn", "HAdd.hAdd", "Nat.cast"],
  "name": "_private.Init.Data.Int.Order.0.Int.le_of_lt.match_1_1",
  "constType":
  "∀ {a b : ℤ} (motive : (∃ n, a + ↑n.succ = b) → Prop) (x : ∃ n, a + ↑n.succ = b),\n  (∀ (w : ℕ) (hn : a + ↑w.succ = b), motive ⋯) → motive x",
  "constCategory": "Definition"},
 {"references": ["Pure.pure", "Lean.PersistentHashMap.foldlM", "Id.run", "Id"],
  "name": "Lean.PersistentHashMap.foldl",
  "constType":
  "{σ : Type w} →\n  {α : Type u_1} → {β : Type u_2} → {x : BEq α} → {x_1 : Hashable α} → PersistentHashMap α β → (σ → α → β → σ) → σ → σ",
  "constCategory": "Definition"},
 {"references": ["CellularAutomatas.Word", "CellularAutomatas.Advice.annotate"],
  "name": "CellularAutomatas.Advice.annotate.eq_1",
  "constType":
  "∀ {α Γ : Type} {adv : CellularAutomatas.Advice α Γ} (w : CellularAutomatas.Word α),\n  CellularAutomatas.Advice.annotate w = w ⊗ adv.f w",
  "constCategory": "Theorem"},
 {"references":
  ["EIO",
   "Bool.not",
   "Membership.mem",
   "Std.TreeSet.toList",
   "ToString.toString",
   "CellularAutomatas.getCellularAutomatasModules",
   "Decidable.decide",
   "List.find?",
   "Prod.fst",
   "List.isEmpty",
   "Unit.unit",
   "HAppend.hAppend",
   "Not",
   "Bind.bind",
   "List.filter",
   "ForIn.forIn",
   "CellularAutomatas.analyzeAndVerify.match_1",
   "ite",
   "List.map",
   "Unit",
   "CellularAutomatas.getModuleAxioms",
   "Pure.pure",
   "inferInstance",
   "IO",
   "BEq.beq",
   "CellularAutomatas.analyzeAndVerify.match_3",
   "Lean.Name.quickCmp"],
  "name": "CellularAutomatas.analyzeAndVerify",
  "constType":
  "Environment → List (Name ⨉ List Name) → IO (List CellularAutomatas.VerificationError)",
  "constCategory": "Definition"},
 {"references": ["Lean.Grind.Ring.intCast_ofNat", "OfNat.ofNat"],
  "name": "Lean.Grind.Ring.intCast_one",
  "constType": "∀ {α : Type u} [inst : Grind.Ring α], ↑1 = 1",
  "constCategory": "Theorem"},
 {"references":
  ["Finset.image",
   "DecidableEq",
   "Membership.mem",
   "Finset.mem_image",
   "propext"],
  "name": "Finset.mem_image._simp_1",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} [inst : DecidableEq β] {f : α → β} {s : Finset α} {b : β},\n  (b ∈ Finset.image f s) = ∃ a ∈ s, f a = b",
  "constCategory": "Theorem"},
 {"references": ["HAdd.hAdd", "SizeOf.sizeOf", "OfNat.ofNat"],
  "name": "CellularAutomatas.FiniteStateTransducer.mk.sizeOf_spec",
  "constType":
  "∀ {α β : Type} [inst : SizeOf α] [inst_1 : SizeOf β] (Q : Type) [alphabetQ : CellularAutomatas.Alphabet Q]\n  (δ : Q → α → Q) (q0 : Q) (f : Q → β),\n  sizeOf { Q := Q, alphabetQ := alphabetQ, δ := δ, q0 := q0, f := f } = 1 + sizeOf Q + sizeOf alphabetQ + sizeOf q0",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Fintype.elems",
  "constType": "{α : Type u_4} → [self : Fintype α] → Finset α",
  "constCategory": "Definition"},
 {"references":
  ["CellularAutomatas.Advice.f",
   "implies_true",
   "eq_self",
   "CellularAutomatas.Word",
   "Eq.trans",
   "of_eq_true",
   "CellularAutomatas.Advice.len",
   "forall_congr",
   "congrArg",
   "List.length"],
  "name": "CellularAutomatas.Advice.compose._proof_1",
  "constType":
  "∀ {α Γ₁ Γ₂ : Type} (adv1 : CellularAutomatas.Advice α Γ₁) (adv2 : CellularAutomatas.Advice Γ₁ Γ₂)\n  (a : CellularAutomatas.Word α), List.length (adv2.f (adv1.f a)) = List.length a",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.PrettyPrinter.UnexpandM",
   "Lean.TSyntax.raw",
   "EStateM",
   "Lean.Name.mkStr3",
   "Lean.Syntax.isOfKind",
   "Lean.MonadQuotation.getCurrMacroScope",
   "Lean.MacroScope",
   "Lean.Syntax.matchesNull",
   "Lean.MonadRef.mkInfoFromRefPos",
   "Lean.MonadQuotation.getContext",
   "Unit.unit",
   "MonadExcept.throw",
   "Lean.Name.mkStr4",
   "Bind.bind",
   "Lean.SyntaxNodeKind",
   "Lean.Name.mkStr1",
   "ite",
   "Bool.or",
   "cond",
   "OfNat.ofNat",
   "Unit",
   "Lean.Syntax.node6",
   "Lean.Syntax.getArg",
   "Pure.pure",
   "Lean.withRef"],
  "name":
  "CellularAutomatas.Word._aux_CellularAutomatas_defs___unexpand_List_extract_1",
  "constType": "PrettyPrinter.Unexpander",
  "constCategory": "Definition"},
 {"references":
  ["List.below",
   "List.filter.match_1",
   "List.brecOn",
   "List.getLast?.match_1",
   "Unit"],
  "name": "List.find?",
  "constType": "{α : Type u} → (α → Bool) → List α → Option α",
  "constCategory": "Definition"},
 {"references": ["Nat.Linear.Var"],
  "name": "Nat.Linear.Poly",
  "constType": "Type",
  "constCategory": "Definition"},
 {"references":
  ["Int.Linear.Poly.isUnsatEq.match_1",
   "GT.gt",
   "Decidable.decide",
   "OfNat.ofNat"],
  "name": "Int.Linear.Poly.isUnsatLe",
  "constType": "Int.Linear.Poly → Bool",
  "constCategory": "Definition"},
 {"references": ["Int.Linear.Poly.brecOn.go", "Int.Linear.Poly.below"],
  "name": "Int.Linear.Poly.brecOn",
  "constType":
  "{motive : Int.Linear.Poly → Sort u} →\n  (t : Int.Linear.Poly) → ((t : Int.Linear.Poly) → Int.Linear.Poly.below t → motive t) → motive t",
  "constCategory": "Definition"},
 {"references": ["Int.mul_zero", "Int.mul_comm", "HMul.hMul", "OfNat.ofNat"],
  "name": "Int.zero_mul",
  "constType": "∀ (a : ℤ), 0 * a = 0",
  "constCategory": "Theorem"},
 {"references": ["CellularAutomatas.backwards_fsm.Params.casesOn"],
  "name": "CellularAutomatas.backwards_fsm.Params.noConfusionType",
  "constType":
  "Sort u → CellularAutomatas.backwards_fsm.Params → CellularAutomatas.backwards_fsm.Params → Sort u",
  "constCategory": "Definition"},
 {"references":
  ["Nat.Linear.Context",
   "Eq.trans",
   "Nat.zero_add",
   "List.brecOn",
   "HMul.hMul",
   "Nat.add_comm",
   "Nat.Linear.Poly.denote_insert",
   "_private.Init.Data.Nat.Linear.0.Nat.Linear.Poly.denote_norm_go.match_1_1",
   "Nat.Linear.Var",
   "OfNat.ofNat",
   "congrArg",
   "Nat.Linear.Poly",
   "Unit",
   "HAdd.hAdd",
   "eq_self",
   "List.below",
   "Nat.Linear.Poly.norm.go",
   "of_eq_true",
   "Nat.Linear.Var.denote",
   "congr",
   "Nat.Linear.Poly.insert",
   "Nat.Linear.Poly.denote",
   "Nat.add_left_comm"],
  "name": "Nat.Linear.Poly.denote_norm_go",
  "constType":
  "∀ (ctx : Nat.Linear.Context) (p r : Nat.Linear.Poly),\n  Nat.Linear.Poly.denote ctx (Nat.Linear.Poly.norm.go p r) = Nat.Linear.Poly.denote ctx p + Nat.Linear.Poly.denote ctx r",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "_private.Lean.Environment.0.Lean.VisibilityMap.public",
  "constType": "{α : Type} → Lean.VisibilityMap✝ α → α",
  "constCategory": "Definition"},
 {"references":
  ["Eq.trans",
   "Neg.neg",
   "List.casesOn",
   "HMul.hMul",
   "congrArg",
   "eq_self",
   "Lean.Omega.IntList",
   "of_eq_true",
   "congr",
   "Lean.Omega.IntList.mul_nil_right",
   "Eq.symm",
   "Int.neg_mul",
   "Eq.ndrec"],
  "name": "Lean.Omega.IntList.mul_neg_left",
  "constType": "∀ (xs ys : Omega.IntList), -xs * ys = -(xs * ys)",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "Int.Linear.Poly.beq'",
   "Eq.trans",
   "Int.Linear.Poly.denote'_eq_denote",
   "Int.Linear.Poly.denote",
   "HMul.hMul",
   "Int.Linear.Poly.denote_combine_mul_k",
   "Int.add_neg_eq_sub",
   "Int.neg_one_mul",
   "Int.one_mul",
   "congrArg",
   "congr",
   "Int.sub_self",
   "Eq.symm",
   "HSub.hSub",
   "Int.Linear.Poly.denote'",
   "Eq.ndrec",
   "Neg.neg",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "Int.Linear.Poly.combine_mul_k",
   "Int.Linear.Context",
   "Int.Linear.Poly.beq'_eq",
   "id",
   "Int.Linear.eq_of_core_cert",
   "Eq.mpr"],
  "name": "Int.Linear.eq_of_core",
  "constType":
  "∀ (ctx : Int.Linear.Context) (p₁ p₂ p₃ : Int.Linear.Poly),\n  Int.Linear.eq_of_core_cert p₁ p₂ p₃ = true →\n    Int.Linear.Poly.denote' ctx p₁ = Int.Linear.Poly.denote' ctx p₂ → Int.Linear.Poly.denote' ctx p₃ = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Grind.AC.Seq.var.injEq",
   "Lean.Grind.AC.Seq.casesOn",
   "Eq.trans",
   "Nat.beq_eq",
   "noConfusion_of_Nat",
   "Bool.coe_iff_coe._simp_1",
   "Bool.false_eq_true",
   "congrArg",
   "Lean.Grind.AC.Var",
   "_private.Init.Grind.AC.0.Lean.Grind.AC.Seq.beq'_eq._simp_1_2",
   "Bool.and",
   "False.elim",
   "congr",
   "Nat.beq",
   "funext",
   "Eq.symm",
   "and_congr_right_iff._simp_1",
   "Eq.ndrec",
   "Bool.and'_eq_and",
   "eq_false'",
   "eq_iff_iff._simp_1",
   "eq_self",
   "of_eq_true",
   "Lean.Grind.AC.Seq.cons.injEq",
   "id",
   "Lean.Grind.AC.Seq.beq'",
   "Lean.Grind.AC.Seq.ctorIdx",
   "Eq.mpr",
   "Bool.and_eq_true",
   "Bool.and'"],
  "name": "Lean.Grind.AC.Seq.beq'_eq",
  "constType": "∀ (s₁ s₂ : Grind.AC.Seq), (s₁.beq' s₂ = true) = (s₁ = s₂)",
  "constCategory": "Theorem"},
 {"references": ["EquivLike.bijective"],
  "name": "Equiv.bijective",
  "constType": "∀ {α : Sort u} {β : Sort v} (e : α ≃ β), Function.Bijective ⇑e",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Grind.AC.Var",
   "Lean.Grind.AC.Seq.brecOn",
   "Lean.Grind.AC.Seq.below",
   "Nat.blt",
   "ite",
   "Lean.Grind.AC.Seq.erase0.match_1"],
  "name": "Lean.Grind.AC.Seq.insert",
  "constType": "Grind.AC.Var → Grind.AC.Seq → Grind.AC.Seq",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CellularAutomatas.TwoStageAdvice.casesOn",
  "constType":
  "{α Γ : Type} →\n  [inst : CellularAutomatas.Alphabet α] →\n    [inst_1 : CellularAutomatas.Alphabet Γ] →\n      {motive : CellularAutomatas.TwoStageAdvice α Γ → Sort u} →\n        (t : CellularAutomatas.TwoStageAdvice α Γ) →\n          ((β : Type) →\n              [alphabetβ : CellularAutomatas.Alphabet β] →\n                (C : CellularAutomatas.CArtTransducer α β) →\n                  (M : CellularAutomatas.FiniteStateTransducer β Γ) →\n                    motive { β := β, alphabetβ := alphabetβ, C := C, M := M }) →\n            motive t",
  "constCategory": "Definition"},
 {"references": ["List.drop", "List.take", "HSub.hSub"],
  "name": "List.extract",
  "constType":
  "{α : Type u} → (l : List α) → optParam ℕ 0 → optParam ℕ l.length → List α",
  "constCategory": "Definition"},
 {"references": ["Preorder.lt_iff_le_not_ge"],
  "name": "lt_iff_le_not_ge",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] {a b : α}, a < b ↔ a ≤ b ∧ ¬b ≤ a",
  "constCategory": "Theorem"},
 {"references": ["CellularAutomatas.OCA", "CellularAutomatas.t_lt"],
  "name": "CellularAutomatas.OCA_lt",
  "constType": "(α : Type) → Set (CellularAutomatas.tCellAutomaton α)",
  "constCategory": "Definition"},
 {"references": ["Not", "Decidable.casesOn"],
  "name": "_private.Init.Core.0.decide_true.match_1_1",
  "constType":
  "∀ (motive : Decidable True → Prop) (h : Decidable True),\n  (∀ (h : True), motive (isTrue h)) → (∀ (h : ¬True), motive (isFalse h)) → motive h",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Int.casesOn",
  "constType":
  "{motive : ℤ → Sort u} → (t : ℤ) → ((a : ℕ) → motive (Int.ofNat a)) → ((a : ℕ) → motive (Int.negSucc a)) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["Int.ofNat_inj", "Fin.val", "Nat.cast", "Iff.mp", "Fin.eq_of_val_eq"],
  "name": "Lean.Grind.instToIntFinCoOfNatIntCast._proof_2",
  "constType": "∀ {n : ℕ} (x y : Fin n), ↑↑x = ↑↑y → x = y",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CellularAutomatas.VerificationError.recOn",
  "constType":
  "{motive : CellularAutomatas.VerificationError → Sort u} →\n  (t : CellularAutomatas.VerificationError) →\n    ((module : Name) →\n        (message : String) →\n          (details : List String) → motive { module := module, message := message, details := details }) →\n      motive t",
  "constCategory": "Definition"},
 {"references": ["Lean.Name.mkStr1", "Lean.Name.mkStr2", "OfNat.ofNat"],
  "name": "CellularAutomatas.«term_⨉_»",
  "constType": "TrailingParserDescr",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Lean.Grind.Ring.intCast_ofNat",
  "constType":
  "∀ {α : Type u} [self : Grind.Ring α] (n : ℕ), ↑(OfNat.ofNat n) = OfNat.ofNat n",
  "constCategory": "Theorem"},
 {"references":
  ["Sigma.casesOn",
   "CellularAutomatas.simulation.Params.C_ctl",
   "CellularAutomatas.CellAutomaton.Q",
   "OfNat.ofNat"],
  "name": "CellularAutomatas.simulation.instFintypeQ1.match_3",
  "constType":
  "(e : CellularAutomatas.simulation.Params) →\n  (motive : (_ : e.C_ctl.Q) × Fin 3 → Sort u_1) →\n    (x : (_ : e.C_ctl.Q) × Fin 3) → ((a : e.C_ctl.Q) → (a_1 : Fin 3) → motive ⟨a, a_1⟩) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Omega.IntList.mul_distrib_left",
   "HAdd.hAdd",
   "eq_self",
   "Eq.trans",
   "of_eq_true",
   "Lean.Omega.IntList",
   "HMul.hMul",
   "Lean.Omega.IntList.sum",
   "Lean.Omega.IntList.sum_add",
   "congrArg"],
  "name": "Lean.Omega.IntList.dot_distrib_left",
  "constType":
  "∀ (xs ys zs : Omega.IntList), (xs + ys).dot zs = xs.dot zs + ys.dot zs",
  "constCategory": "Theorem"},
 {"references": ["Nat.below", "Nat.brecOn", "List.take.match_1", "OfNat.ofNat"],
  "name": "List.take",
  "constType": "{α : Type u} → ℕ → List α → List α",
  "constCategory": "Definition"},
 {"references": ["List.mapIdx.go", "List.toArray"],
  "name": "List.mapIdx",
  "constType":
  "{α : Type u_1} → {β : Type u_2} → (ℕ → α → β) → List α → List β",
  "constCategory": "Definition"},
 {"references":
  ["ENat", "Cardinal.toENat", "Cardinal", "DFunLike.coe", "Cardinal.mk"],
  "name": "ENat.card",
  "constType": "Type u_3 → ℕ∞",
  "constCategory": "Definition"},
 {"references":
  ["Int.eq_of_sub_eq_zero",
   "HSub.hSub",
   "Int.sub_eq_zero_of_eq",
   "OfNat.ofNat"],
  "name": "Int.sub_eq_zero",
  "constType": "∀ {a b : ℤ}, a - b = 0 ↔ a = b",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "LT.lt",
   "Nat.add_sub_cancel_left",
   "Eq.mp",
   "Nat.succ_le_of_lt",
   "LE.le",
   "HSub.hSub",
   "Nat.sub_le_sub_right",
   "Nat.succ_sub",
   "congrArg"],
  "name": "Nat.sub_lt_left_of_lt_add",
  "constType": "∀ {n k m : ℕ}, n ≤ k → k < n + m → k - n < m",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "LawfulBEq.eq_of_beq",
  "constType":
  "∀ {α : Type u} {inst : BEq α} [self : LawfulBEq α] {a b : α}, (a == b) = true → a = b",
  "constCategory": "Theorem"},
 {"references": ["Membership.mem", "Iff.rfl"],
  "name": "Lean.Grind.IntInterval.mem_ii",
  "constType": "∀ (x : ℤ), x ∈ Grind.IntInterval.ii ↔ True",
  "constCategory": "Theorem"},
 {"references":
  ["SetLike.coe", "SetLike.coe_injective", "Membership.mem", "Set.ext"],
  "name": "SetLike.ext",
  "constType":
  "∀ {A : Type u_1} {B : Type u_2} [i : SetLike A B] {p q : A}, (∀ (x : B), x ∈ p ↔ x ∈ q) → p = q",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.Advice.f",
   "CellularAutomatas.Word",
   "CellularAutomatas.TwoStageAdvice.advice",
   "sorryAx",
   "Function.comp",
   "OfNat.ofNat"],
  "name":
  "CellularAutomatas.results_unproven.advice_two_stage_closed_under_composition",
  "constType":
  "∀ {α : Type} [inst : CellularAutomatas.Alphabet α] {Γ : Type} [inst_1 : CellularAutomatas.Alphabet Γ] {O' : Type}\n  [inst_2 : CellularAutomatas.Alphabet O'] (a1 : CellularAutomatas.TwoStageAdvice α O')\n  (a2 : CellularAutomatas.TwoStageAdvice O' Γ),\n  ∃ a,\n    CellularAutomatas.TwoStageAdvice.advice.f =\n      CellularAutomatas.TwoStageAdvice.advice.f ∘ CellularAutomatas.TwoStageAdvice.advice.f",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CellularAutomatas.tCellAutomaton.F_pos",
  "constType":
  "{α : Type} → (self : CellularAutomatas.tCellAutomaton α) → self.Q → Bool",
  "constCategory": "Definition"},
 {"references":
  ["Singleton.singleton",
   "Multiset.coe_singleton",
   "Iff.rfl",
   "Multiset.ofList",
   "Multiset",
   "congrArg",
   "Multiset.coe_toList",
   "List.perm_singleton",
   "Multiset.coe_eq_coe",
   "id",
   "Eq.symm",
   "Eq.mpr",
   "propext",
   "Multiset.toList"],
  "name": "Multiset.toList_eq_singleton_iff",
  "constType":
  "∀ {α : Type u_1} {a : α} {m : Multiset α}, m.toList = [a] ↔ m = {a}",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "CellularAutomatas.tCellAutomaton.noConfusionType",
   "CellularAutomatas.tCellAutomaton.casesOn",
   "CellularAutomatas.CellAutomaton.Q",
   "Eq.ndrec"],
  "name": "CellularAutomatas.tCellAutomaton.noConfusion",
  "constType":
  "{α : Type} →\n  {P : Sort u} →\n    {x1 x2 : CellularAutomatas.tCellAutomaton α} → x1 = x2 → CellularAutomatas.tCellAutomaton.noConfusionType P x1 x2",
  "constCategory": "Definition"},
 {"references": ["Lean.Name.mkStr1", "Lean.Name.mkStr3", "OfNat.ofNat"],
  "name": "CellularAutomatas.Word.«term_⟦_..*⟧»",
  "constType": "TrailingParserDescr",
  "constCategory": "Definition"},
 {"references": ["List.casesOn", "Lean.MacroScope", "Unit.unit", "Unit"],
  "name": "_private.Init.Prelude.0.Lean.MacroScopesView.review.match_1",
  "constType":
  "(motive : List MacroScope → Sort u_1) →\n  (x : List MacroScope) →\n    (Unit → motive []) → ((head : MacroScope) → (tail : List MacroScope) → motive (head :: tail)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Int.Linear.instBEqPoly.beq._sparseCasesOn_1",
   "Ne",
   "OfNat.ofNat",
   "Int.Linear.Poly.ctorIdx"],
  "name": "Int.Linear.Poly.isUnsatEq.match_1",
  "constType":
  "(motive : Int.Linear.Poly → Sort u_1) →\n  (p : Int.Linear.Poly) → ((k : ℤ) → motive (Int.Linear.Poly.num k)) → ((x : Int.Linear.Poly) → motive x) → motive p",
  "constCategory": "Definition"},
 {"references":
  ["Nat.left_distrib",
   "Int.subNatNat",
   "Nat.cast",
   "Eq.trans",
   "HMul.hMul",
   "congrArg",
   "_private.Init.Data.Int.Lemmas.0.Int.mul_add.match_1_1",
   "Int.negOfNat_add",
   "congr",
   "Int.ofNat_mul_subNatNat",
   "Int.negOfNat_eq_subNatNat_zero",
   "Int.negSucc_mul_subNatNat",
   "Eq.symm",
   "_private.Init.Data.Int.Lemmas.0.Int.mul_add._simp_1_3",
   "Nat.mul_comm",
   "Int.subNatNat_add",
   "Nat.add_assoc",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "eq_self",
   "of_eq_true",
   "Int.add_comm",
   "id",
   "Int.negOfNat",
   "Eq.mpr",
   "Nat.right_distrib",
   "Nat.add_left_comm"],
  "name": "Int.mul_add",
  "constType": "∀ (a b c : ℤ), a * (b + c) = a * b + a * c",
  "constCategory": "Theorem"},
 {"references": ["HAdd.hAdd", "Eq.symm", "Lean.Grind.Semiring.add_assoc"],
  "name":
  "_private.Init.Grind.Order.0.Lean.Grind.Order.lt_le_trans_k._simp_1_1",
  "constType":
  "∀ {α : Type u} [self : Grind.Semiring α] (a b c : α), a + (b + c) = a + b + c",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CellularAutomatas.backwards_fsm.Params.inst3",
  "constType":
  "(self : CellularAutomatas.backwards_fsm.Params) → CellularAutomatas.Alphabet self.γ",
  "constCategory": "Definition"},
 {"references":
  ["Eq.trans",
   "Lean.Omega.IntList.get",
   "Lean.Omega.LinearCombo.coordinate",
   "OfNat.ofNat",
   "congrArg",
   "HAdd.hAdd",
   "eq_self",
   "Lean.Omega.LinearCombo.coordinate_eval",
   "of_eq_true",
   "Lean.Omega.Coeffs.ofList",
   "Lean.Omega.IntList.get_cons_succ",
   "Lean.Omega.Coeffs.get",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.IntList.get_cons_zero"],
  "name": "Lean.Omega.LinearCombo.coordinate_eval_3",
  "constType":
  "∀ {a0 a1 a2 a3 : ℤ} {t : List ℤ},\n  (Omega.LinearCombo.coordinate 3).eval (Omega.Coeffs.ofList (a0 :: a1 :: a2 :: a3 :: t)) = a3",
  "constCategory": "Theorem"},
 {"references":
  ["List.range",
   "HAdd.hAdd",
   "CellularAutomatas.Word",
   "CellularAutomatas.Advice.from_len_marker._proof_1",
   "List.map",
   "BEq.beq",
   "OfNat.ofNat",
   "List.length"],
  "name": "CellularAutomatas.Advice.from_len_marker",
  "constType": "{α : Type} → (ℕ → Option ℕ) → CellularAutomatas.Advice α Bool",
  "constCategory": "Definition"},
 {"references": ["CellularAutomatas.FiniteStateTransducer.M_id"],
  "name": "CellularAutomatas.FiniteStateTransducer.M_id.eq_1",
  "constType":
  "∀ (α : Type) [inst : CellularAutomatas.Alphabet α],\n  CellularAutomatas.FiniteStateTransducer.M_id α =\n    { Q := α, alphabetQ := inst, δ := fun x a => a, q0 := default, f := id }",
  "constCategory": "Theorem"},
 {"references": ["outParam"],
  "name": "HMul.hMul",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → [self : HMul α β γ] → α → β → γ",
  "constCategory": "Definition"},
 {"references": ["outParam"],
  "name": "CharP.cast_eq_zero_iff",
  "constType":
  "∀ (R : Type u_2) {inst : AddMonoidWithOne R} (p : outParam ℕ) [self : CharP R p] (x : ℕ), ↑x = 0 ↔ p ∣ x",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.cast", "LE.le", "eq_true", "OfNat.ofNat", "Nat.cast_nonneg"],
  "name": "Nat.cast_nonneg._simp_1",
  "constType":
  "∀ {α : Type u_3} [inst : Semiring α] [inst_1 : PartialOrder α] [IsOrderedRing α] (n : ℕ), (0 ≤ ↑n) = True",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Lean.Grind.AC.Var",
  "constType": "Type",
  "constCategory": "Definition"},
 {"references":
  ["_private.Init.Grind.Ring.Basic.0.Lean.Grind.Ring.intCast_add._proof_1_7",
   "Nat.cast",
   "Lean.Grind.Ring.intCast_natCast",
   "Lean.Grind.AddCommMonoid.add_comm",
   "Lean.Grind.Ring.sub_eq_add_neg",
   "Int.cast",
   "GE.ge",
   "_private.Init.Grind.Ring.Basic.0.Lean.Grind.Ring.intCast_add._proof_1_5",
   "congrArg",
   "_private.Init.Grind.Ring.Basic.0.Lean.Grind.Ring.intCast_add._proof_1_3",
   "Eq.symm",
   "HSub.hSub",
   "_private.Init.Grind.Ring.Basic.0.Lean.Grind.Ring.intCast_add._proof_1_8",
   "Not",
   "Lean.Grind.Ring.intCast",
   "Lean.Grind.AddCommGroup.neg_add",
   "Neg.neg",
   "Lean.Grind.Ring.intCast_neg",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "Decidable.byContradiction",
   "Lean.Grind.AddCommGroup.neg_sub",
   "_private.Init.Grind.Ring.Basic.0.Lean.Grind.Ring.intCast_add._proof_1_4",
   "Int.neg_add",
   "id",
   "Lean.Grind.Ring.intCast_nat_add",
   "_private.Init.Grind.Ring.Basic.0.Lean.Grind.Ring.intCast_add.match_1_1",
   "Eq.mpr",
   "Lean.Grind.Semiring.natCast",
   "dite",
   "_private.Init.Grind.Ring.Basic.0.Lean.Grind.Ring.intCast_add._proof_1_6",
   "Lean.Grind.Ring.intCast_nat_sub"],
  "name": "Lean.Grind.Ring.intCast_add",
  "constType":
  "∀ {α : Type u} [inst : Grind.Ring α] (x y : ℤ), ↑(x + y) = ↑x + ↑y",
  "constCategory": "Theorem"},
 {"references": ["CellularAutomatas.CellAutomaton.Q"],
  "name": "CellularAutomatas.LCellAutomaton.casesOn",
  "constType":
  "{α : Type} →\n  {motive : CellularAutomatas.LCellAutomaton α → Sort u} →\n    (t : CellularAutomatas.LCellAutomaton α) →\n      ((toCellAutomaton : CellularAutomatas.CellAutomaton) →\n          (embed : α → toCellAutomaton.Q) →\n            (border : toCellAutomaton.Q) →\n              motive { toCellAutomaton := toCellAutomaton, embed := embed, border := border }) →\n        motive t",
  "constCategory": "Definition"},
 {"references": ["CellularAutomatas.t_rt", "CellularAutomatas.OCAr"],
  "name": "CellularAutomatas.OCAr_rt",
  "constType": "(α : Type) → Set (CellularAutomatas.tCellAutomaton α)",
  "constCategory": "Definition"},
 {"references":
  ["List.getElem_map",
   "CellularAutomatas.Word.get'",
   "Eq.trans",
   "List.getElem_range",
   "Membership.mem",
   "Iff.mp",
   "CellularAutomatas.scan_temporal_length",
   "ite_cond_eq_true",
   "or_true",
   "GT.gt",
   "CellularAutomatas.tCellAutomaton.toLCellAutomaton",
   "List.getLast?",
   "CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "CellularAutomatas.LCellAutomaton.scan_temporal_rt",
   "HSub.hSub",
   "Eq.symm",
   "CellularAutomatas.Word.range",
   "Option.some_eq_ite_none_left._simp_1",
   "Eq.ndrec",
   "Nat.casesAuxOn",
   "List.getLast",
   "List.getLast_eq_getElem",
   "lt_add_iff_pos_left._simp_4",
   "List.getLast?_eq_some_getLast",
   "List.map",
   "List.length_map",
   "CellularAutomatas.LCellAutomaton.comp",
   "add_pos_iff._simp_4",
   "Option.some.injEq",
   "gt_iff_lt._simp_1",
   "id",
   "Eq.mpr",
   "List.ne_nil_of_length_pos",
   "List.length",
   "List.getLast_eq_getElem._proof_3",
   "GetElem.getElem.congr_simp",
   "CellularAutomatas.LCellAutomaton.scan_temporal",
   "GetElem.getElem",
   "congrArg",
   "CellularAutomatas.LCellAutomaton.embed",
   "List.length_range",
   "congr",
   "CellularAutomatas.LCellAutomaton.embed_word",
   "CellularAutomatas.CellAutomaton.Q",
   "Option.map",
   "CellularAutomatas.LCellAutomaton.border",
   "zero_lt_one._simp_1",
   "add_tsub_cancel_right",
   "Not",
   "CellularAutomatas.Word",
   "ite",
   "Set",
   "CellularAutomatas.CellAutomaton.nextt",
   "OfNat.ofNat",
   "ite_congr",
   "List.range",
   "HAdd.hAdd",
   "LT.lt",
   "eq_self",
   "List.length_eq_zero_iff",
   "zero_tsub",
   "of_eq_true",
   "CellularAutomatas.LcInRt.scan_temporal_get_last._proof_1_1",
   "LE.le",
   "dite",
   "List.getLast?_map"],
  "name": "CellularAutomatas.LcInRt.scan_temporal_get_last",
  "constType":
  "∀ {α : Type} [inst : CellularAutomatas.Alphabet α] {C : CellularAutomatas.tCellAutomaton α}\n  (w : CellularAutomatas.Word α),\n  List.getLast? (C.scan_temporal_rt w) = if w = [] then none else some (C.comp w (List.length w - 1) 0)",
  "constCategory": "Theorem"},
 {"references": ["Lean.Grind.AC.Expr.brecOn.go", "Lean.Grind.AC.Expr.below"],
  "name": "Lean.Grind.AC.Expr.brecOn",
  "constType":
  "{motive : Grind.AC.Expr → Sort u} →\n  (t : Grind.AC.Expr) → ((t : Grind.AC.Expr) → Grind.AC.Expr.below t → motive t) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["Eq.trans",
   "Bool.of_not_eq_true",
   "Nat.Linear.ExprCnstr.casesOn",
   "Prod.fst",
   "Nat.Linear.Poly",
   "congrArg",
   "iff_self",
   "Nat.Linear.Poly.norm.go",
   "Nat.Linear.ExprCnstr.toNormPoly",
   "congr",
   "Eq.symm",
   "Nat.Linear.Poly.denote_eq",
   "Nat.Linear.Poly.denote_norm_go",
   "Eq.ndrec",
   "Not",
   "Nat.Linear.Context",
   "Nat.Linear.Poly.denote_le_cancel_eq",
   "Nat.Linear.Expr.toPoly",
   "Nat.zero_add",
   "Nat.Linear.PolyCnstr.denote",
   "Nat.add_comm",
   "Nat.Linear.Poly.cancel",
   "Prod.snd",
   "eq_iff_iff._simp_1",
   "cond",
   "Nat.Linear.ExprCnstr.denote",
   "Nat.Linear.Expr.denote_toPoly",
   "OfNat.ofNat",
   "Nat.Linear.Var",
   "HAdd.hAdd",
   "Nat.Linear.Expr.toNormPoly",
   "Nat.Linear.Poly.denote_eq_cancel_eq",
   "Nat.Linear.Expr.denote",
   "of_eq_true",
   "LE.le",
   "id",
   "Nat.Linear.Poly.denote",
   "Nat.Linear.Poly.denote_le",
   "Eq.mpr",
   "dite"],
  "name": "Nat.Linear.ExprCnstr.denote_toNormPoly",
  "constType":
  "∀ (ctx : Nat.Linear.Context) (c : Nat.Linear.ExprCnstr),\n  Nat.Linear.PolyCnstr.denote ctx c.toNormPoly = Nat.Linear.ExprCnstr.denote ctx c",
  "constCategory": "Theorem"},
 {"references": ["HAdd.hAdd", "SizeOf.sizeOf", "OfNat.ofNat"],
  "name": "CellularAutomatas.tCellAutomatonWithAdvice._sizeOf_1",
  "constType":
  "{α : Type} → [SizeOf α] → CellularAutomatas.tCellAutomatonWithAdvice α → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "Lean.Grind.AC.Seq.unionFuel_k_eq_unionFuel",
   "Lean.Grind.AC.Seq.unionFuel_k",
   "Eq.trans",
   "of_eq_true",
   "Lean.Grind.AC.hugeFuel",
   "Lean.Grind.AC.Seq.unionFuel",
   "congrArg"],
  "name": "Lean.Grind.AC.Seq.union_k_eq_union",
  "constType": "∀ (s₁ s₂ : Grind.AC.Seq), s₁.union_k s₂ = s₁.union s₂",
  "constCategory": "Theorem"},
 {"references": ["Nat.succ_sub_succ_eq_sub"],
  "name": "Nat.succ_sub_succ",
  "constType": "∀ (n m : ℕ), n.succ - m.succ = n - m",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "Neg.neg",
   "id",
   "Lean.Grind.AddCommMonoid.add_comm",
   "Eq.mpr",
   "Lean.Grind.AddCommGroup.neg_add_cancel",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Lean.Grind.AddCommGroup.add_neg_cancel",
  "constType":
  "∀ {M : Type u} [inst : Grind.AddCommGroup M] (a : M), a + -a = 0",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "HDiv.hDiv",
   "HMod.hMod",
   "Int.emod_add_mul_ediv",
   "Eq.symm",
   "id",
   "HSub.hSub",
   "HMul.hMul",
   "Int.add_sub_cancel",
   "Eq.mpr",
   "congrArg"],
  "name": "Int.emod_def",
  "constType": "∀ (a b : ℤ), a % b = a - b * (a / b)",
  "constCategory": "Theorem"},
 {"references": ["AddCommMagma.add_comm"],
  "name": "add_comm",
  "constType":
  "∀ {G : Type u_1} [inst : AddCommMagma G] (a b : G), a + b = b + a",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "CellularAutomatas.FiniteStateTransducer.scanr_len",
   "Eq.trans",
   "Eq.mp",
   "eq_false",
   "Classical.byContradiction",
   "Eq.symm",
   "id",
   "CellularAutomatas.FiniteStateTransducer.scanr",
   "eq_true",
   "List.length"],
  "name": "CellularAutomatas.FiniteStateTransducer.advice._proof_1",
  "constType":
  "∀ {α β : Type} (M : CellularAutomatas.FiniteStateTransducer α β) (w : CellularAutomatas.Word α),\n  List.length ((fun w => M.scanr w) w) = List.length w",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "rfl",
   "Nat.mul_succ",
   "_private.Init.Data.Nat.Basic.0.Nat.mul_comm.match_1_1",
   "Nat.below",
   "Eq.symm",
   "HMul.hMul",
   "Nat.succ_mul",
   "Nat.zero_mul",
   "Nat.brecOn",
   "Nat.mul_zero",
   "OfNat.ofNat"],
  "name": "Nat.mul_comm",
  "constType": "∀ (n m : ℕ), n * m = m * n",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.FiniteStateTransducer.scanr_reduce_q",
   "eq_self",
   "Eq.trans",
   "of_eq_true",
   "CellularAutomatas.FiniteStateTransducer.Q",
   "CellularAutomatas.FiniteStateTransducer.scanr_reduce_q_empty",
   "CellularAutomatas.FiniteStateTransducer.q0",
   "congrArg"],
  "name": "CellularAutomatas.FiniteStateTransducer.scanr_reduce_empty",
  "constType":
  "∀ {α β : Type} {M : CellularAutomatas.FiniteStateTransducer α β}, M.scanr_reduce [] = M.q0",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.FiniteStateTransducer.scanr_reduce_cons",
   "Fin.is_lt._simp_1",
   "CellularAutomatas.FiniteStateTransducer.scanr_len",
   "Eq.trans",
   "CellularAutomatas.FiniteStateTransducer.Q",
   "eq_true",
   "GetElem.getElem",
   "CellularAutomatas.FiniteStateTransducer.scanr_reduce",
   "CellularAutomatas.FiniteStateTransducer.q0",
   "congrArg",
   "Fin.val",
   "congr",
   "eq_of_heq",
   "Eq.symm",
   "CellularAutomatas.FiniteStateTransducer.scanr_get'_eq2",
   "Eq.ndrec",
   "CellularAutomatas.FiniteStateTransducer.δ",
   "CellularAutomatas.Word",
   "CellularAutomatas.FiniteStateTransducer.scanr_reduce_empty",
   "List.drop",
   "CellularAutomatas.FiniteStateTransducer.scanr",
   "Eq.casesOn",
   "LT.lt",
   "eq_self",
   "of_eq_true",
   "CellularAutomatas.FiniteStateTransducer.M_projQ",
   "id",
   "Eq.mpr",
   "List.length",
   "CellularAutomatas.FiniteStateTransducer.f"],
  "name": "CellularAutomatas.FiniteStateTransducer.M_projQ_scanr",
  "constType":
  "∀ {α β : Type} {M : CellularAutomatas.FiniteStateTransducer α β} {w : CellularAutomatas.Word α} (i : ℕ)\n  (h : i < List.length w), (M.M_projQ.scanr w)[i] = M.scanr_reduce w⟦i..*⟧",
  "constCategory": "Theorem"},
 {"references":
  ["Subsingleton.elim", "DecidablePred", "Eq.ndrec", "Finset.filter"],
  "name": "Finset.filter.congr_simp",
  "constType":
  "∀ {α : Type u_1} (p p_1 : α → Prop),\n  p = p_1 →\n    ∀ {inst : DecidablePred p} [inst_1 : DecidablePred p_1] (s s_1 : Finset α),\n      s = s_1 → Finset.filter p s = Finset.filter p_1 s_1",
  "constCategory": "Theorem"},
 {"references":
  ["rfl",
   "HAdd.hAdd",
   "_private.Init.Data.Nat.Basic.0.Nat.zero_add.match_1_1",
   "Nat.add",
   "Nat.below",
   "Nat.brecOn",
   "OfNat.ofNat",
   "congrArg",
   "Unit"],
  "name": "Nat.zero_add",
  "constType": "∀ (n : ℕ), 0 + n = n",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "LawfulMonad.bind_assoc",
  "constType":
  "∀ {m : Type u → Type v} {inst : Monad m} [self : LawfulMonad m] {α β γ : Type u} (x : m α) (f : α → m β) (g : β → m γ),\n  x >>= f >>= g = x >>= fun x => f x >>= g",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "Int.le_of_add_le_add_left",
   "Int.add_comm",
   "LE.le",
   "id",
   "Eq.mpr",
   "congrArg"],
  "name": "Int.le_of_add_le_add_right",
  "constType": "∀ {a b c : ℤ}, a + b ≤ c + b → a ≤ c",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.uniform_config", "CellularAutomatas.CellAutomaton.Q"],
  "name": "CellularAutomatas.uniform_config.eq_1",
  "constType":
  "∀ {C : CellularAutomatas.CellAutomaton} (q : C.Q) (x : ℤ), CellularAutomatas.uniform_config q x = q",
  "constCategory": "Theorem"},
 {"references": ["LT.lt", "Not", "Int.not_lt", "LE.le", "Iff.mp"],
  "name": "Lean.Omega.Int.le_of_not_lt",
  "constType": "∀ {x y : ℤ}, ¬x < y → y ≤ x",
  "constCategory": "Theorem"},
 {"references": ["Not"],
  "name": "mt",
  "constType": "∀ {a b : Prop}, (a → b) → ¬b → ¬a",
  "constCategory": "Theorem"},
 {"references": ["Set", "Membership.mem", "setOf"],
  "name": "Set.image",
  "constType": "{α : Type u} → {β : Type v} → (α → β) → Set α → Set β",
  "constCategory": "Definition"},
 {"references": ["Nat.below"],
  "name": "Nat.brecOn.go",
  "constType":
  "{motive : ℕ → Sort u} → (t : ℕ) → ((t : ℕ) → Nat.below t → motive t) → motive t ×' Nat.below t",
  "constCategory": "Definition"},
 {"references":
  ["Multiset.dedup_le",
   "Finset.val",
   "DecidableEq",
   "Multiset.card_le_card",
   "Multiset.toFinset",
   "Multiset"],
  "name": "Multiset.toFinset_card_le",
  "constType":
  "∀ {α : Type u_1} [inst : DecidableEq α] (m : Multiset α), m.toFinset.card ≤ m.card",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Std.Commutative.comm",
  "constType":
  "∀ {α : Sort u} {op : α → α → α} [self : Commutative op] (a b : α), op a b = op b a",
  "constCategory": "Theorem"},
 {"references":
  ["Int.add_right_neg",
   "HAdd.hAdd",
   "Int.add_mul",
   "Int.zero_mul",
   "Neg.neg",
   "Eq.symm",
   "id",
   "HMul.hMul",
   "Eq.mpr",
   "OfNat.ofNat",
   "Int.neg_eq_of_add_eq_zero",
   "congrArg"],
  "name": "Int.neg_mul_eq_neg_mul",
  "constType": "∀ (a b : ℤ), -(a * b) = -a * b",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CellularAutomatas.simulation.Q1",
  "constType": "CellularAutomatas.simulation.Params → Type",
  "constCategory": "Other"},
 {"references": ["Nat.lt_of_lt_of_le", "Fin.val", "LE.le", "Fin.isLt"],
  "name": "Fin.val_lt_of_le",
  "constType": "∀ {n b : ℕ} (i : Fin b), b ≤ n → ↑i < n",
  "constCategory": "Theorem"},
 {"references": ["CellularAutomatas.zip_words"],
  "name": "CellularAutomatas.zip_words.eq_1",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} (w : List α) (a : List β), w ⊗ a = List.zipWith (fun x1 x2 => (x1, x2)) w a",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "Lean.Grind.CommRing.norm_cnstr_cert",
   "Eq.trans",
   "Eq.mp",
   "congrArg",
   "Lean.Grind.CommRing.Expr.toPoly_k_eq_toPoly",
   "congr",
   "Lean.Grind.CommRing.Poly.denote",
   "HSub.hSub",
   "Eq.symm",
   "Lean.Grind.CommRing.Poly.beq'",
   "propext",
   "Lean.Grind.CommRing.Expr.toPoly_k",
   "Lean.Grind.CommRing.Poly.beq'_eq",
   "Lean.Grind.CommRing.Expr.denote",
   "eq_iff_iff._simp_1",
   "Iff.rfl",
   "OfNat.ofNat",
   "LT.lt",
   "id",
   "Lean.Grind.OrderedAdd.sub_pos_iff",
   "Eq.mpr",
   "Lean.Grind.CommRing.Expr.denote_toPoly",
   "Lean.Grind.CommRing.Context",
   "Lean.Grind.CommRing.Expr.toPoly"],
  "name": "Lean.Grind.CommRing.lt_norm_expr",
  "constType":
  "∀ {α : Type u_1} [inst : Grind.CommRing α] [inst_1 : LE α] [inst_2 : LT α] [LawfulOrderLT α] [inst_4 : Std.IsPreorder α]\n  [Grind.OrderedRing α] (ctx : Grind.CommRing.Context α) (lhs rhs lhs' rhs' : Grind.CommRing.Expr),\n  Grind.CommRing.norm_cnstr_cert lhs rhs lhs' rhs' = true →\n    (Grind.CommRing.Expr.denote ctx lhs < Grind.CommRing.Expr.denote ctx rhs) =\n      (Grind.CommRing.Expr.denote ctx lhs' < Grind.CommRing.Expr.denote ctx rhs')",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "_private.Init.Data.Int.Order.0.Int.le_trans.match_1_1",
   "Int.add_assoc",
   "Nat.cast",
   "Int.le.intro",
   "LE.le",
   "Int.natCast_add",
   "Eq.symm",
   "id",
   "Eq.mpr",
   "Int.le.dest",
   "congrArg"],
  "name": "Int.le_trans",
  "constType": "∀ {a b c : ℤ}, a ≤ b → b ≤ c → a ≤ c",
  "constCategory": "Theorem"},
 {"references": ["Lean.Omega.Coeffs", "Lean.Omega.IntList.dot"],
  "name": "Lean.Omega.Coeffs.dot",
  "constType": "Omega.Coeffs → Omega.Coeffs → ℤ",
  "constCategory": "Definition"},
 {"references": ["Or.casesOn", "LT.lt", "GE.ge"],
  "name": "_private.Init.Prelude.0.Nat.lt_or_ge.match_1_3",
  "constType":
  "∀ (n m : ℕ) (motive : n < m ∨ n ≥ m → Prop) (x : n < m ∨ n ≥ m),\n  (∀ (h : n < m), motive ⋯) → (∀ (h : n ≥ m), motive ⋯) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Not",
   "Bool.noConfusion",
   "_private.Init.Prelude.0.ne_true_of_eq_false.match_1_1"],
  "name": "ne_true_of_eq_false",
  "constType": "∀ {b : Bool}, b = false → ¬b = true",
  "constCategory": "Theorem"},
 {"references": ["HAdd.hAdd", "Nat.le_add_left", "LE.le", "eq_true"],
  "name": "Nat.le_add_left._simp_1",
  "constType": "∀ (n m : ℕ), (n ≤ m + n) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Neg.neg", "LE.le", "OfNat.ofNat", "propext", "Int.neg_le_zero_iff"],
  "name": "Int.neg_le_zero_iff._simp_1",
  "constType": "∀ {a : ℤ}, (-a ≤ 0) = (0 ≤ a)",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.FiniteStateTransducer.δ?.match_1",
   "CellularAutomatas.FiniteStateTransducer.Q",
   "CellularAutomatas.FiniteStateTransducer.δ"],
  "name": "CellularAutomatas.FiniteStateTransducer.δ?",
  "constType":
  "{α β : Type} → (M : CellularAutomatas.FiniteStateTransducer α β) → M.Q → Option α → M.Q",
  "constCategory": "Definition"},
 {"references": ["Ne.symm", "NeZero.out", "OfNat.ofNat"],
  "name": "NeZero.ne'",
  "constType": "∀ {R : Type u_1} [inst : Zero R] (n : R) [h : NeZero n], 0 ≠ n",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "AddLeftMono",
   "Nat.cast",
   "LE.le",
   "zero_le_one",
   "id",
   "Eq.mpr",
   "monotone_nat_of_le_succ",
   "Nat.cast_succ",
   "le_add_of_nonneg_right",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Nat.mono_cast",
  "constType":
  "∀ {α : Type u_1} [inst : AddMonoidWithOne α] [inst_1 : PartialOrder α] [AddLeftMono α] [ZeroLEOneClass α],\n  Monotone Nat.cast",
  "constCategory": "Theorem"},
 {"references": ["rfl"],
  "name": "congrArg",
  "constType":
  "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "AddLeftMono",
   "le_add_iff_nonneg_right",
   "LE.le",
   "AddLeftReflectLE",
   "OfNat.ofNat",
   "propext"],
  "name": "le_add_iff_nonneg_right._simp_4",
  "constType":
  "∀ {α : Type u_1} [inst : AddZeroClass α] [inst_1 : LE α] [AddLeftMono α] [AddLeftReflectLE α] (a : α) {b : α},\n  (a ≤ a + b) = (0 ≤ b)",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.LCellAutomaton.casesOn",
   "CellularAutomatas.CellAutomaton.Q",
   "Eq.ndrec",
   "CellularAutomatas.LCellAutomaton.noConfusionType"],
  "name": "CellularAutomatas.LCellAutomaton.noConfusion",
  "constType":
  "{α : Type} →\n  {P : Sort u} →\n    {x1 x2 : CellularAutomatas.LCellAutomaton α} → x1 = x2 → CellularAutomatas.LCellAutomaton.noConfusionType P x1 x2",
  "constCategory": "Definition"},
 {"references": ["inferInstance"],
  "name": "Mathlib.Tactic.Ring.instCommSemiringNat",
  "constType": "CommSemiring ℕ",
  "constCategory": "Definition"},
 {"references": ["Nat.beq.match_1", "Nat.below", "Nat.brecOn", "Unit"],
  "name": "Nat.beq",
  "constType": "ℕ → ℕ → Bool",
  "constCategory": "Definition"},
 {"references":
  ["HAdd.hAdd",
   "SizeOf.sizeOf",
   "CellularAutomatas.CellAutomaton.Q",
   "OfNat.ofNat"],
  "name": "CellularAutomatas.simulation.Params.mk.sizeOf_spec",
  "constType":
  "∀ (C_inr C_ctl : CellularAutomatas.CellAutomaton) (f : C_ctl.Q → Option C_inr.Q),\n  sizeOf { C_inr := C_inr, C_ctl := C_ctl, f := f } = 1 + sizeOf C_inr + sizeOf C_ctl",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "Lean.Grind.Semiring.ofNat_eq_natCast",
   "Lean.Grind.Ring.intCast",
   "Nat.cast",
   "Eq.mp",
   "_private.Init.Grind.Ordered.Ring.0.Lean.Grind.OrderedRing.nonneg_intCast_of_nonneg._proof_1_1",
   "Int.ofNat_eq_natCast",
   "Lean.Grind.Ring.intCast_natCast",
   "Int.casesOn",
   "GE.ge",
   "Int.cast",
   "OfNat.ofNat",
   "congrArg",
   "Lean.Grind.OrderedRing.ofNat_nonneg",
   "Classical.byContradiction",
   "LE.le",
   "Eq.symm",
   "id",
   "Eq.mpr",
   "Lean.Grind.Semiring.natCast",
   "Eq.ndrec"],
  "name": "Lean.Grind.OrderedRing.nonneg_intCast_of_nonneg",
  "constType":
  "∀ {R : Type u} [inst : Grind.Ring R] [inst_1 : LE R] [inst_2 : LT R] [LawfulOrderLT R] [inst_4 : Std.IsPreorder R]\n  [Grind.OrderedRing R] (a : ℤ), 0 ≤ a → 0 ≤ ↑a",
  "constCategory": "Theorem"},
 {"references": ["Eq.symm"],
  "name": "Eq.comm",
  "constType": "∀ {α : Sort u_1} {a b : α}, a = b ↔ b = a",
  "constCategory": "Theorem"},
 {"references":
  ["beq_iff_eq._simp_1",
   "eq_self",
   "Eq.trans",
   "of_eq_true",
   "BEq.beq",
   "congrArg"],
  "name": "Nat.beq_eq_true_eq",
  "constType": "∀ (a b : ℕ), ((a == b) = true) = (a = b)",
  "constCategory": "Theorem"},
 {"references": ["CellularAutomatas.L_c", "Language"],
  "name": "CellularAutomatas.L_c.eq_1",
  "constType":
  "∀ {α Γ : Type} (adv : CellularAutomatas.Advice α Γ) (c : Γ),\n  CellularAutomatas.L_c adv c = {w | List.getLast? (adv.f w) = some c}",
  "constCategory": "Theorem"},
 {"references": ["Array.emptyWithCapacity", "Array.push", "OfNat.ofNat"],
  "name": "Array.mkArray6",
  "constType": "{α : Type u} → α → α → α → α → α → α → Array α",
  "constCategory": "Definition"},
 {"references":
  ["Not",
   "CellularAutomatas.simulation.Params.C_ctl",
   "CellularAutomatas.CellAutomaton.Q",
   "CellularAutomatas.simulation.Q1.mk.noConfusion",
   "OfNat.ofNat"],
  "name": "CellularAutomatas.simulation.instDecidableEqQ1.decEq._proof_3",
  "constType":
  "∀ {e : CellularAutomatas.simulation.Params} (a : e.C_ctl.Q) (a_1 : Fin 3) (b : e.C_ctl.Q) (b_1 : Fin 3),\n  ¬a = b → { state := a, counter := a_1 } = { state := b, counter := b_1 } → False",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CellularAutomatas.CellAutomaton",
  "constType": "Type 1",
  "constCategory": "Other"},
 {"references": [],
  "name": "Lean.Grind.alreadyNorm",
  "constType": "Prop → Prop",
  "constCategory": "Definition"},
 {"references": ["Multiset.card", "Finset.val"],
  "name": "Finset.card",
  "constType": "{α : Type u_1} → Finset α → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Nat.Linear.Context",
   "Nat.Linear.Expr.toPoly.go",
   "Eq.trans",
   "Nat.zero_add",
   "HMul.hMul",
   "Nat.Linear.Expr.denote_toPoly_go",
   "Nat.add_comm",
   "OfNat.ofNat",
   "Nat.Linear.Var",
   "congrArg",
   "HAdd.hAdd",
   "eq_self",
   "Nat.one_mul",
   "Nat.Linear.Expr.denote",
   "of_eq_true",
   "Nat.Linear.Poly.denote"],
  "name": "Nat.Linear.Expr.denote_toPoly",
  "constType":
  "∀ (ctx : Nat.Linear.Context) (e : Nat.Linear.Expr), Nat.Linear.Poly.denote ctx e.toPoly = Nat.Linear.Expr.denote ctx e",
  "constCategory": "Theorem"},
 {"references":
  ["_private.Mathlib.Order.Defs.PartialOrder.0.le_antisymm_iff.match_1_1",
   "le_of_eq",
   "LE.le",
   "Eq.symm",
   "le_antisymm"],
  "name": "le_antisymm_iff",
  "constType":
  "∀ {α : Type u_1} [inst : PartialOrder α] {a b : α}, a = b ↔ a ≤ b ∧ b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd", "HSub.hSub", "HMul.hMul", "Lean.Omega.LinearCombo.const"],
  "name": "Lean.Omega.LinearCombo.mul",
  "constType": "Omega.LinearCombo → Omega.LinearCombo → Omega.LinearCombo",
  "constCategory": "Definition"},
 {"references": [],
  "name": "LE.le",
  "constType": "{α : Type u} → [self : LE α] → α → α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["LT.lt",
   "Nat.lt_or_ge",
   "LE.le",
   "_private.Init.Data.Nat.Basic.0.Nat.le_total.match_1_1",
   "GE.ge",
   "Nat.le_of_lt"],
  "name": "Nat.le_total",
  "constType": "∀ (m n : ℕ), m ≤ n ∨ n ≤ m",
  "constCategory": "Theorem"},
 {"references": ["Std.DTreeMap.keysArray", "Std.TreeMap.inner"],
  "name": "Std.TreeMap.keysArray",
  "constType":
  "{α : Type u} → {β : Type v} → {cmp : α → α → Ordering} → TreeMap α β cmp → Array α",
  "constCategory": "Definition"},
 {"references":
  ["Int.Linear.norm_le",
   "Int.Linear.natCast_sub",
   "Eq.trans",
   "Eq.mp",
   "eq_true",
   "HMul.hMul",
   "eagerReduce",
   "ite_cond_eq_true",
   "IntCast.intCast",
   "Int.Linear.Expr.eq_of_norm_eq",
   "Nat.ToInt.natCast_ofNat",
   "congrArg",
   "Lean.Grind.nestedDecidable",
   "NatCast.natCast",
   "CellularAutomatas.PrefixStableProof.getLastOfTake._proof_1_3",
   "Eq.symm",
   "HSub.hSub",
   "Not",
   "List.drop",
   "Neg.neg",
   "ite",
   "Lean.Grind.Order.le_of_eq_2_k",
   "Lean.Grind.Order.le_of_offset_eq_1_k",
   "Nat.ToInt.add_congr",
   "Lean.Grind.Order.le_eq_true_of_le_k",
   "OfNat.ofNat",
   "ite_congr",
   "HAdd.hAdd",
   "Nat.ToInt.le_eq",
   "of_eq_true",
   "Lean.Grind.CommRing.Expr.eq_of_toPoly_eq",
   "List.take",
   "LE.le",
   "id",
   "Lean.Grind.Order.le_trans_k",
   "Lean.Grind.Semiring.natCast",
   "Lean.Grind.Order.eq_trans_true",
   "Lean.Grind.CommRing.le_norm_expr",
   "Lean.Grind.Semiring.natCast_eq_ofNat",
   "List.length"],
  "name": "CellularAutomatas.PrefixStableProof.getLastOfTake._proof_1_5",
  "constType":
  "∀ {i : ℕ} {α : Type u_1} {w : List α},\n  -1 * ↑(List.take 1 w⟦i..*⟧).length + 1 ≤ 0 → (List.take 1 w⟦i..*⟧).length - 1 < (List.take 1 w⟦i..*⟧).length",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.simulation.Params.casesOn",
   "CellularAutomatas.CellAutomaton.Q"],
  "name": "CellularAutomatas.simulation.Params.noConfusionType",
  "constType":
  "Sort u → CellularAutomatas.simulation.Params → CellularAutomatas.simulation.Params → Sort u",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CellularAutomatas.composition.Params.C",
  "constType":
  "(self : CellularAutomatas.composition.Params) → CellularAutomatas.LCellAutomaton self.β",
  "constCategory": "Definition"},
 {"references":
  ["CellularAutomatas.DefinesLanguage.noConfusionType",
   "CellularAutomatas.DefinesLanguage.casesOn",
   "Language",
   "Eq.ndrec"],
  "name": "CellularAutomatas.DefinesLanguage.noConfusion",
  "constType":
  "{CA : Sort u_1} →\n  {α : Type} →\n    {P : Sort u} →\n      {x1 x2 : CellularAutomatas.DefinesLanguage CA α} →\n        x1 = x2 → CellularAutomatas.DefinesLanguage.noConfusionType P x1 x2",
  "constCategory": "Definition"},
 {"references":
  ["CellularAutomatas.simulation.Params.C_ctl",
   "CellularAutomatas.CellAutomaton.Q",
   "CellularAutomatas.simulation.Q1.casesOn",
   "Eq.ndrec",
   "CellularAutomatas.simulation.Q1.noConfusionType",
   "OfNat.ofNat"],
  "name": "CellularAutomatas.simulation.Q1.noConfusion",
  "constType":
  "{e : CellularAutomatas.simulation.Params} →\n  {P : Sort u} →\n    {x1 x2 : CellularAutomatas.simulation.Q1 e} → x1 = x2 → CellularAutomatas.simulation.Q1.noConfusionType P x1 x2",
  "constCategory": "Definition"},
 {"references":
  ["Int.toNat_of_nonneg",
   "Int.toNat",
   "Nat.cast",
   "Int.ofNat_le",
   "LE.le",
   "Eq.symm",
   "id",
   "Eq.mpr",
   "Iff.rfl",
   "propext",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Int.le_toNat",
  "constType": "∀ {n : ℕ} {z : ℤ}, 0 ≤ z → (n ≤ z.toNat ↔ ↑n ≤ z)",
  "constCategory": "Theorem"},
 {"references": ["CellularAutomatas.TwoStageAdvice._sizeOf_1"],
  "name": "CellularAutomatas.TwoStageAdvice._sizeOf_inst",
  "constType":
  "(α Γ : Type) →\n  {inst : CellularAutomatas.Alphabet α} →\n    {inst_1 : CellularAutomatas.Alphabet Γ} → [SizeOf α] → [SizeOf Γ] → SizeOf (CellularAutomatas.TwoStageAdvice α Γ)",
  "constCategory": "Definition"},
 {"references": ["eq_self", "of_eq_true"],
  "name": "CellularAutomatas.apply_iterated_zero",
  "constType":
  "∀ {α : Type u} {m : α} {f : α → α}, CellularAutomatas.apply_iterated f m 0 = m",
  "constCategory": "Theorem"},
 {"references":
  ["Setoid.r",
   "DecidableEq",
   "Multiset.Nodup",
   "List.nodup_dedup",
   "Multiset.dedup",
   "Quot.induction_on",
   "Multiset"],
  "name": "Multiset.nodup_dedup",
  "constType":
  "∀ {α : Type u_1} [inst : DecidableEq α] (s : Multiset α), s.dedup.Nodup",
  "constCategory": "Theorem"},
 {"references":
  ["Set", "Membership.mem", "Iff.rfl", "EmptyCollection.emptyCollection"],
  "name": "Set.mem_empty_iff_false",
  "constType": "∀ {α : Type u} (x : α), x ∈ ∅ ↔ False",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.LCellAutomaton.noConfusion",
   "id",
   "CellularAutomatas.CellAutomaton.Q"],
  "name": "CellularAutomatas.LCellAutomaton.mk.noConfusion",
  "constType":
  "{α : Type} →\n  (P : Sort u) →\n    (toCellAutomaton : CellularAutomatas.CellAutomaton) →\n      (embed : α → toCellAutomaton.Q) →\n        (border : toCellAutomaton.Q) →\n          (toCellAutomaton' : CellularAutomatas.CellAutomaton) →\n            (embed' : α → toCellAutomaton'.Q) →\n              (border' : toCellAutomaton'.Q) →\n                { toCellAutomaton := toCellAutomaton, embed := embed, border := border } =\n                    { toCellAutomaton := toCellAutomaton', embed := embed', border := border' } →\n                  (toCellAutomaton = toCellAutomaton' → embed ≍ embed' → border ≍ border' → P) → P",
  "constCategory": "Definition"},
 {"references": ["Multiset.le_iff_subset", "Finset.val", "Finset.nodup"],
  "name": "Finset.val_le_iff",
  "constType": "∀ {α : Type u_1} {s₁ s₂ : Finset α}, s₁.val ≤ s₂.val ↔ s₁ ⊆ s₂",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CellularAutomatas.tCellAutomaton.toLCellAutomaton",
  "constType":
  "{α : Type} → CellularAutomatas.tCellAutomaton α → CellularAutomatas.LCellAutomaton α",
  "constCategory": "Definition"},
 {"references": ["List.casesOn"],
  "name": "List.foldl.match_1",
  "constType":
  "{α : Type u_3} →\n  {β : Type u_1} →\n    (motive : α → List β → Sort u_2) →\n      (x : α) →\n        (x_1 : List β) → ((a : α) → motive a []) → ((a : α) → (b : β) → (l : List β) → motive a (b :: l)) → motive x x_1",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Std.IsPartialOrder.le_antisymm",
  "constType":
  "∀ {α : Type u} {inst : LE α} [self : Std.IsPartialOrder α] (a b : α), a ≤ b → b ≤ a → a = b",
  "constCategory": "Theorem"},
 {"references": ["CellularAutomatas.ca_id"],
  "name": "CellularAutomatas.ca_id.eq_1",
  "constType":
  "∀ (α : Type) [inst : CellularAutomatas.Alphabet α],\n  CellularAutomatas.ca_id α =\n    { Q := α, alphabetQ := inst, δ := fun x x_1 r => r, embed := id, border := default, f := id }",
  "constCategory": "Theorem"},
 {"references": ["CellularAutomatas.tCellAutomatonWithAdvice.L"],
  "name":
  "CellularAutomatas.instDefinesLanguageTCellAutomatonWithAdviceOfAlphabet",
  "constType":
  "{α : Type} →\n  [CellularAutomatas.Alphabet α] → CellularAutomatas.DefinesLanguage (CellularAutomatas.tCellAutomatonWithAdvice α) α",
  "constCategory": "Definition"},
 {"references": ["outParam"],
  "name": "GetElem?.getElem?",
  "constType":
  "{coll : Type u} →\n  {idx : Type v} →\n    {elem : outParam (Type w)} →\n      {valid : outParam (coll → idx → Prop)} → [self : GetElem? coll idx elem valid] → coll → idx → Option elem",
  "constCategory": "Definition"},
 {"references": [],
  "name": "ReflBEq.rfl",
  "constType":
  "∀ {α : Type u_1} {inst : BEq α} [self : ReflBEq α] {a : α}, (a == a) = true",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd", "zero_add", "LE.le.trans_eq", "le_self_add", "OfNat.ofNat"],
  "name": "zero_le",
  "constType":
  "∀ {α : Type u} [inst : AddZeroClass α] [inst_1 : LE α] [CanonicallyOrderedAdd α] (a : α), 0 ≤ a",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "NatCast.natCast",
  "constType": "{R : Type u} → [self : NatCast R] → ℕ → R",
  "constCategory": "Definition"},
 {"references": ["CellularAutomatas.LcInRt.AdvCALc"],
  "name": "CellularAutomatas.LcInRt.AdvCALc.eq_1",
  "constType":
  "∀ {α : Type} [inst : CellularAutomatas.Alphabet α] {Γ : Type} [inst_1 : CellularAutomatas.Alphabet Γ] (c : Γ),\n  CellularAutomatas.LcInRt.AdvCALc c =\n    { toLCellAutomaton := CellularAutomatas.LcInRt.DiagonalShiftCA (α ⨉ Γ), t := fun n => n - 1, p := fun x => 0,\n      F_pos := fun q =>\n        match q with\n        | some (fst, g) => g == c\n        | none => false }",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.tCellAutomaton.p",
   "CellularAutomatas.tCellAutomaton.t",
   "CellularAutomatas.tCellAutomaton.L",
   "Language"],
  "name": "CellularAutomatas.tCellAutomaton.similar",
  "constType":
  "{α : Type} →\n  [CellularAutomatas.Alphabet α] → CellularAutomatas.tCellAutomaton α → CellularAutomatas.tCellAutomaton α → Prop",
  "constCategory": "Definition"},
 {"references": ["isUnit_one", "eq_true", "IsUnit", "OfNat.ofNat"],
  "name": "isAddUnit_zero._simp_3",
  "constType": "∀ {M : Type u_1} [inst : Monoid M], IsUnit 1 = True",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.FiniteStateTransducer.δ?",
   "CellularAutomatas.FiniteStateTransducer.Q"],
  "name": "CellularAutomatas.FiniteStateTransducer.δ?.eq_2",
  "constType":
  "∀ {α β : Type} (M : CellularAutomatas.FiniteStateTransducer α β) (x : M.Q) (a : α), M.δ? x (some a) = M.δ x a",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "CellularAutomatas.CArtTransducer.toLCellAutomaton",
   "CellularAutomatas.CellAutomaton.Q",
   "CellularAutomatas.composition.Params.mk.noConfusion"],
  "name": "CellularAutomatas.composition.Params.mk.inj",
  "constType":
  "∀ {α β : Type} {_inst_α : CellularAutomatas.Alphabet α} {_inst_β : CellularAutomatas.Alphabet β}\n  {C : CellularAutomatas.LCellAutomaton β} {C_adv : CellularAutomatas.CArtTransducer α β} {f : C_adv.Q → Option C.Q}\n  {α_1 β_1 : Type} {_inst_α_1 : CellularAutomatas.Alphabet α_1} {_inst_β_1 : CellularAutomatas.Alphabet β_1}\n  {C_1 : CellularAutomatas.LCellAutomaton β_1} {C_adv_1 : CellularAutomatas.CArtTransducer α_1 β_1}\n  {f_1 : C_adv_1.Q → Option C_1.Q},\n  { α := α, β := β, _inst_α := _inst_α, _inst_β := _inst_β, C := C, C_adv := C_adv, f := f } =\n      { α := α_1, β := β_1, _inst_α := _inst_α_1, _inst_β := _inst_β_1, C := C_1, C_adv := C_adv_1, f := f_1 } →\n    α = α_1 ∧ β = β_1 ∧ _inst_α ≍ _inst_α_1 ∧ _inst_β ≍ _inst_β_1 ∧ C ≍ C_1 ∧ C_adv ≍ C_adv_1 ∧ f ≍ f_1",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Omega.IntList.gcd_eq_zero",
   "Lean.Omega.IntList",
   "Membership.mem",
   "Lean.Omega.IntList.gcd",
   "OfNat.ofNat",
   "propext"],
  "name": "_private.Init.Omega.Constraint.0.Lean.Omega.normalize_sat._simp_1_1",
  "constType": "∀ {xs : Omega.IntList}, (xs.gcd = 0) = ∀ x ∈ xs, x = 0",
  "constCategory": "Theorem"},
 {"references":
  ["rfl",
   "Nat.one_mul",
   "Nat.cast",
   "Neg.neg",
   "_private.Init.Data.Int.Lemmas.0.Int.neg_eq_neg_one_mul.match_1_1",
   "id",
   "HMul.hMul",
   "Eq.mpr",
   "OfNat.ofNat",
   "congrArg",
   "Unit"],
  "name": "Int.neg_eq_neg_one_mul",
  "constType": "∀ (a : ℤ), -a = -1 * a",
  "constCategory": "Theorem"},
 {"references":
  ["Prod.casesOn", "Option.casesOn", "Lean.Omega.Coeffs", "Unit.unit", "Unit"],
  "name": "Lean.Omega.tidy?.match_1",
  "constType":
  "(motive : Option (Omega.Constraint ⨉ Omega.Coeffs) → Sort u_1) →\n  (x : Option (Omega.Constraint ⨉ Omega.Coeffs)) →\n    (Unit → motive none) → ((s' : Omega.Constraint) → (x' : Omega.Coeffs) → motive (some (s', x'))) → motive x",
  "constCategory": "Definition"},
 {"references": ["CellularAutomatas.δδt", "CellularAutomatas.CellAutomaton.Q"],
  "name": "CellularAutomatas.δδt.eq_1",
  "constType":
  "∀ {C : CellularAutomatas.CellAutomaton} (q : C.Q),\n  CellularAutomatas.δδt q = CellularAutomatas.apply_iterated CellularAutomatas.δδ q",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Nat.le.brecOn",
  "constType":
  "∀ {n : ℕ} {motive : (a : ℕ) → n.le a → Prop} {a : ℕ} (t : n.le a),\n  (∀ (a : ℕ) (t : n.le a), Nat.le.below t → motive a t) → motive a t",
  "constCategory": "Theorem"},
 {"references": ["DecidableEq"],
  "name": "CellularAutomatas.Alphabet.recOn",
  "constType":
  "{α : Type} →\n  {motive : CellularAutomatas.Alphabet α → Sort u} →\n    (t : CellularAutomatas.Alphabet α) →\n      ([dec : DecidableEq α] →\n          [fin : Fintype α] → [inh : Inhabited α] → motive { dec := dec, fin := fin, inh := inh }) →\n        motive t",
  "constCategory": "Definition"},
 {"references":
  ["_private.Lean.Environment.0.Lean.Environment.findAsyncConst?",
   "Option.map",
   "_private.Lean.Environment.0.Lean.AsyncConst.constInfo"],
  "name": "_private.Lean.Environment.0.Lean.Environment.findAsyncCore?",
  "constType":
  "Environment → Name → optParam Bool false → Option AsyncConstantInfo",
  "constCategory": "Definition"},
 {"references": ["List.range", "Multiset.ofList"],
  "name": "Multiset.range",
  "constType": "ℕ → Multiset ℕ",
  "constCategory": "Definition"},
 {"references":
  ["HAppend.hAppend",
   "CellularAutomatas.Advice.f",
   "CellularAutomatas.Word",
   "List.take",
   "List.length"],
  "name": "CellularAutomatas.rel_repr",
  "constType":
  "{α Γ : Type} → CellularAutomatas.Advice α Γ → CellularAutomatas.Word α → CellularAutomatas.Word α → List Γ",
  "constCategory": "Definition"},
 {"references": ["Array.toList", "List.length"],
  "name": "Array.size",
  "constType": "{α : Type u} → Array α → ℕ",
  "constCategory": "Definition"},
 {"references": ["Prod.mk.noConfusion"],
  "name": "Prod.mk.inj",
  "constType":
  "∀ {α : Type u} {β : Type v} {fst : α} {snd : β} {fst_1 : α} {snd_1 : β},\n  (fst, snd) = (fst_1, snd_1) → fst = fst_1 ∧ snd = snd_1",
  "constCategory": "Theorem"},
 {"references": ["outParam"],
  "name": "SetLike.coe",
  "constType":
  "{A : Type u_1} → {B : outParam (Type u_2)} → [self : SetLike A B] → A → Set B",
  "constCategory": "Definition"},
 {"references":
  ["Eq.trans",
   "Bool.of_not_eq_true",
   "Nat.Linear.ExprCnstr.casesOn",
   "Nat.Linear.Poly",
   "congrArg",
   "iff_self",
   "congr",
   "Eq.symm",
   "Nat.Linear.Poly.denote_eq",
   "Eq.ndrec",
   "Nat.Linear.Context",
   "Not",
   "Nat.Linear.Expr.toPoly",
   "Nat.Linear.PolyCnstr.denote",
   "Nat.Linear.ExprCnstr.toPoly",
   "eq_iff_iff._simp_1",
   "cond",
   "Nat.Linear.ExprCnstr.denote",
   "Nat.Linear.Expr.denote_toPoly",
   "Nat.Linear.Expr.denote",
   "of_eq_true",
   "LE.le",
   "id",
   "Nat.Linear.Poly.denote",
   "Nat.Linear.Poly.denote_le",
   "Eq.mpr",
   "dite"],
  "name": "Nat.Linear.ExprCnstr.denote_toPoly",
  "constType":
  "∀ (ctx : Nat.Linear.Context) (c : Nat.Linear.ExprCnstr),\n  Nat.Linear.PolyCnstr.denote ctx c.toPoly = Nat.Linear.ExprCnstr.denote ctx c",
  "constCategory": "Theorem"},
 {"references":
  ["Or.elim",
   "Lean.Omega.LinearCombo.coordinate_eval_2",
   "Nat.cast",
   "Eq.trans",
   "le_of_le_of_eq",
   "Lean.Omega.LinearCombo.coordinate_eval_0",
   "Lean.Omega.Constraint.combine_sat'",
   "Int.sub_eq_zero_of_eq",
   "GT.gt",
   "Decidable.decide",
   "Lean.Omega.Int.ofNat_le_of_le",
   "Lean.Omega.Coeffs.ofList",
   "Lean.Omega.Int.ofNat_sub_dichotomy",
   "HSub.hSub",
   "Lean.Omega.tidy_sat",
   "Eq.symm",
   "Lean.Omega.LinearCombo.add_eval",
   "Int.add_one_le_of_lt",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "And.left",
   "of_decide_eq_true",
   "Not",
   "Lean.Omega.combo_sat'",
   "Neg.neg",
   "And.right",
   "Lean.Omega.Constraint.addInequality_sat",
   "Lean.Omega.Int.add_congr",
   "Lean.Omega.Constraint.isImpossible",
   "Lean.Omega.LinearCombo.coordinate",
   "Int.sub_nonneg_of_le",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "Lean.Omega.LinearCombo.coordinate_eval_1",
   "LT.lt",
   "Nat.le_of_not_lt",
   "Lean.Omega.Int.ofNat_lt_of_lt",
   "Lean.Omega.LinearCombo.sub_eval",
   "LE.le",
   "id",
   "Lean.Omega.Constraint.addEquality_sat",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.Int.sub_congr"],
  "name": "CellularAutomatas.marker_list_inj._proof_1_1",
  "constType": "∀ {n k1 : ℕ}, k1 ≤ n → k1 > 0 → ¬k1 - 1 < n → False",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Omega.Constraint.upperBound",
   "Lean.Omega.Int.add_le_zero_iff_le_neg'",
   "Eq.trans",
   "Eq.mp",
   "Lean.Omega.Coeffs",
   "Decidable.decide",
   "congrArg",
   "Int.eq_iff_le_and_ge",
   "Lean.Omega.Int.add_nonneg_iff_neg_le'",
   "Decidable.decide.congr_simp",
   "congr",
   "Lean.Omega.Constraint.lowerBound",
   "decide_eq_true_eq",
   "propext",
   "Neg.neg",
   "Lean.Omega.UpperBound.sat",
   "Lean.Omega.LowerBound.sat",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "LE.le",
   "id",
   "Eq.mpr",
   "Lean.Omega.Coeffs.dot",
   "and_comm",
   "Lean.Omega.Constraint.sat'"],
  "name": "Lean.Omega.Constraint.addEquality_sat",
  "constType":
  "∀ {c : ℤ} {x y : Omega.Coeffs}, c + x.dot y = 0 → { lowerBound := some (-c), upperBound := some (-c) }.sat' x y = true",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Grind.AC.Var",
   "Lean.Grind.AC.Expr.toSeq'.match_1",
   "Lean.Grind.AC.Expr.brecOn",
   "Lean.Grind.AC.Expr.below"],
  "name": "Lean.Grind.AC.Expr.toSeq'",
  "constType": "Grind.AC.Expr → Grind.AC.Seq → Grind.AC.Seq",
  "constCategory": "Definition"},
 {"references": ["exists_apply_eq_apply", "eq_true"],
  "name": "exists_apply_eq_apply._simp_1",
  "constType":
  "∀ {α : Sort u_2} {β : Sort u_1} (f : α → β) (a' : α), (∃ a, f a = f a') = True",
  "constCategory": "Theorem"},
 {"references":
  ["Multiset.map",
   "Eq.trans",
   "Finset.val",
   "DecidableEq",
   "Membership.mem",
   "Multiset",
   "congrArg",
   "iff_self",
   "of_eq_true",
   "Finset.image",
   "congr",
   "funext",
   "_private.Mathlib.Data.Finset.Image.0.Finset.mem_image._simp_1_3",
   "_private.Mathlib.Data.Finset.Image.0.Finset.mem_image._simp_1_1",
   "Multiset.dedup",
   "_private.Mathlib.Data.Finset.Image.0.Finset.mem_image._simp_1_2"],
  "name": "Finset.mem_image",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} [inst : DecidableEq β] {f : α → β} {s : Finset α} {b : β},\n  b ∈ Finset.image f s ↔ ∃ a ∈ s, f a = b",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "Lean.Grind.AC.Seq.contains_k_cons",
   "Eq.trans",
   "Eq.mp",
   "Lean.Grind.AC.Seq.contains_k_var",
   "congrArg",
   "Lean.Grind.AC.Var",
   "Bool.or_eq_true",
   "Eq.symm",
   "Lean.Grind.AC.Seq.denote",
   "Eq.ndrec",
   "Std.Associative.assoc",
   "Lean.Grind.AC.Seq.insert",
   "Lean.Grind.AC.Seq.contains_k",
   "Lean.Grind.AC.Var.denote",
   "Bool.or",
   "Lean.Grind.AC.Context.op",
   "beq_iff_eq._simp_1",
   "Or.casesOn",
   "Lean.Grind.AC.Seq.denote_insert",
   "Std.Commutative.comm",
   "id",
   "Eq.mpr",
   "BEq.beq",
   "Std.IdempotentOp.idempotent"],
  "name": "Lean.Grind.AC.Seq.denote_insert_of_contains",
  "constType":
  "∀ {α : Sort u_1} (ctx : Grind.AC.Context α) [inst₁ : Associative ctx.op] [inst₂ : Commutative ctx.op]\n  [inst₃ : IdempotentOp ctx.op] (s : Grind.AC.Seq) (x : Grind.AC.Var),\n  s.contains_k x = true → Grind.AC.Seq.denote ctx (Grind.AC.Seq.insert x s) = Grind.AC.Seq.denote ctx s",
  "constCategory": "Theorem"},
 {"references":
  ["Fin.is_lt._simp_1",
   "Nat.cast",
   "Eq.trans",
   "Membership.mem",
   "Lean.Grind.IntInterval.mem_co._simp_1",
   "OfNat.ofNat",
   "congrArg",
   "LT.lt",
   "implies_true",
   "and_self",
   "Fin.val",
   "of_eq_true",
   "Int.natCast_nonneg._simp_1",
   "congr",
   "forall_congr",
   "LE.le",
   "Int.ofNat_lt._simp_1"],
  "name": "Lean.Grind.instToIntFinCoOfNatIntCast._proof_1",
  "constType": "∀ {n : ℕ} (a : Fin n), ↑↑a ∈ Grind.IntInterval.co 0 ↑n",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.FiniteStateTransducer.scanr_reduce_q",
   "eq_self",
   "CellularAutomatas.Word",
   "of_eq_true",
   "CellularAutomatas.FiniteStateTransducer.scanr_step",
   "id",
   "CellularAutomatas.FiniteStateTransducer.Q",
   "Eq.mpr",
   "congrArg",
   "CellularAutomatas.FiniteStateTransducer.δ",
   "List.foldr",
   "Prod.fst"],
  "name": "CellularAutomatas.FiniteStateTransducer.scanr_foldr_state",
  "constType":
  "∀ {α β : Type} {M : CellularAutomatas.FiniteStateTransducer α β} (p : CellularAutomatas.Word α) (q : M.Q)\n  (tail : List β), (List.foldr M.scanr_step (q, tail) p).1 = M.scanr_reduce_q q p",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.Word",
   "CellularAutomatas.Advice.mk.noConfusion",
   "List.length"],
  "name": "CellularAutomatas.Advice.mk.inj",
  "constType":
  "∀ {α Γ : Type} {f : CellularAutomatas.Word α → CellularAutomatas.Word Γ}\n  {len : ∀ (w : CellularAutomatas.Word α), List.length (f w) = List.length w}\n  {f_1 : CellularAutomatas.Word α → CellularAutomatas.Word Γ}\n  {len_1 : ∀ (w : CellularAutomatas.Word α), List.length (f_1 w) = List.length w},\n  { f := f, len := len } = { f := f_1, len := len_1 } → f = f_1",
  "constCategory": "Theorem"},
 {"references":
  ["rfl",
   "List.zip",
   "eq_self",
   "List.below",
   "Eq.trans",
   "of_eq_true",
   "_private.Init.Data.List.Zip.0.List.zip_eq_zipWith.match_1_1",
   "List.brecOn",
   "List.zipWith",
   "congrArg"],
  "name": "List.zip_eq_zipWith",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {l₁ : List α} {l₂ : List β}, l₁.zip l₂ = List.zipWith Prod.mk l₁ l₂",
  "constCategory": "Theorem"},
 {"references": ["GetElem.getElem", "Eq.ndrec"],
  "name": "GetElem.getElem.congr_simp",
  "constType":
  "∀ {coll : Type u} {idx : Type v} {elem : Type w} {valid : coll → idx → Prop} [self : GetElem coll idx elem valid]\n  (xs xs_1 : coll) (e_xs : xs = xs_1) (i i_1 : idx) (e_i : i = i_1) (h : valid xs i), xs[i] = xs_1[i_1]",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.backwards_fsm.C'",
   "CellularAutomatas.backwards_fsm.Params.C",
   "Eq.trans",
   "Eq.mp",
   "CellularAutomatas.backwards_fsm.Params.inst3",
   "CellularAutomatas.FiniteStateTransducer.Q",
   "eq_true",
   "CellularAutomatas.backwards_fsm.Params.γ",
   "CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "CellularAutomatas.backwards_fsm.spec_",
   "Eq.symm",
   "CellularAutomatas.CellAutomaton.Q",
   "CellularAutomatas.FiniteStateTransducer.advice",
   "CellularAutomatas.backwards_fsm.Params.α",
   "Not",
   "CellularAutomatas.Word",
   "CellularAutomatas.CArtTransducer.toLCellAutomaton",
   "CellularAutomatas.CArtTransducer.advice",
   "CellularAutomatas.backwards_fsm.Params.β",
   "CellularAutomatas.backwards_fsm.Params.M",
   "Function.comp",
   "CellularAutomatas.backwards_fsm.Params.inst2",
   "CellularAutomatas.Advice.f",
   "eq_false",
   "Classical.byContradiction",
   "id",
   "CellularAutomatas.backwards_fsm.M'"],
  "name": "CellularAutomatas.backwards_fsm.spec._proof_1_1",
  "constType":
  "∀ {α β γ : Type} [inst : CellularAutomatas.Alphabet α] [inst_1 : CellularAutomatas.Alphabet β]\n  [inst_2 : CellularAutomatas.Alphabet γ] {M : CellularAutomatas.FiniteStateTransducer α β}\n  {C : CellularAutomatas.CArtTransducer β γ},\n  C.advice.f ∘ M.advice.f =\n    (CellularAutomatas.backwards_fsm.M'\n            { α := α, β := β, γ := γ, inst1 := inst, inst2 := inst_1, inst3 := inst_2, M := M, C := C }).advice.f ∘\n      (CellularAutomatas.backwards_fsm.C'\n            { α := α, β := β, γ := γ, inst1 := inst, inst2 := inst_1, inst3 := inst_2, M := M, C := C }).advice.f",
  "constCategory": "Theorem"},
 {"references":
  ["HAppend.hAppend",
   "Nat.ctorIdx",
   "noConfusion_of_Nat",
   "GetElem.getElem",
   "Nat.le.casesOn",
   "OfNat.ofNat",
   "LT.lt",
   "HAdd.hAdd",
   "False.elim",
   "List.get._proof_1",
   "Eq.symm",
   "List.append",
   "Eq.ndrec",
   "List.length",
   "Nat.casesAuxOn"],
  "name": "List.getElem_append_left",
  "constType":
  "∀ {α : Type u_1} {i : ℕ} {as bs : List α} (h : i < as.length) {h' : i < (as ++ bs).length}, (as ++ bs)[i] = as[i]",
  "constCategory": "Theorem"},
 {"references":
  ["rfl",
   "HAppend.hAppend",
   "List.below",
   "_private.Init.Data.List.TakeDrop.0.List.take_left.match_1_1",
   "List.take",
   "List.brecOn",
   "List.append",
   "congrArg",
   "List.length"],
  "name": "List.take_left",
  "constType":
  "∀ {α : Type u_1} {l₁ l₂ : List α}, List.take l₁.length (l₁ ++ l₂) = l₁",
  "constCategory": "Theorem"},
 {"references":
  ["_private.Init.Prelude.0.noConfusion_of_Nat.aux", "Nat.beq", "congrArg"],
  "name": "noConfusion_of_Nat",
  "constType":
  "∀ {α : Sort u} (f : α → ℕ) {a b : α}, a = b → Bool.rec False True ((f a).beq (f b))",
  "constCategory": "Theorem"},
 {"references":
  ["Neg.neg",
   "id",
   "HMul.hMul",
   "Int.neg_mul",
   "Eq.mpr",
   "Int.one_mul",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Int.neg_one_mul",
  "constType": "∀ (a : ℤ), -1 * a = -a",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CellularAutomatas.FiniteStateTransducer.q0",
  "constType":
  "{α β : Type} → (self : CellularAutomatas.FiniteStateTransducer α β) → self.Q",
  "constCategory": "Definition"},
 {"references":
  ["LT.lt",
   "HAdd.hAdd",
   "Lean.Grind.Nat.lt_eq",
   "Eq.substr",
   "LE.le",
   "OfNat.ofNat",
   "List.length"],
  "name": "CellularAutomatas.LcInRt.DiagonalShiftCA_comp_p0._proof_1_3",
  "constType":
  "∀ {α : Type} {t : ℕ} (w : List α), t + 1 ≤ w.length → t < w.length",
  "constCategory": "Theorem"},
 {"references": ["Int.natAbs"],
  "name": "Int.natAbs.eq_def",
  "constType":
  "∀ (m : ℤ),\n  m.natAbs =\n    match m with\n    | Int.ofNat m => m\n    | Int.negSucc m => m.succ",
  "constCategory": "Theorem"},
 {"references": ["WellFounded.fixF", "WellFounded.apply"],
  "name": "WellFounded.fix",
  "constType":
  "{α : Sort u} →\n  {C : α → Sort v} → {r : α → α → Prop} → WellFounded r → ((x : α) → ((y : α) → r y x → C y) → C x) → (x : α) → C x",
  "constCategory": "Definition"},
 {"references": ["Fin.isLt", "List.length"],
  "name":
  "CellularAutomatas.FiniteStateTransducer.scanr_reduce_drop._proof_1_1",
  "constType": "∀ {α : Type} (w : List α) (i : Fin w.length), ↑i < w.length",
  "constCategory": "Theorem"},
 {"references": ["Nat.lt_add_one"],
  "name": "Nat.lt_succ_self",
  "constType": "∀ (n : ℕ), n < n.succ",
  "constCategory": "Theorem"},
 {"references":
  ["Int.ofNat_inj",
   "False.elim",
   "Nat.cast",
   "Eq.mp",
   "NatCast.natCast",
   "Eq.symm",
   "Iff.mp",
   "Ne",
   "congrArg"],
  "name": "Nat.ToInt.of_diseq",
  "constType": "∀ {a b : ℕ} {a' b' : ℤ}, ↑a = a' → ↑b = b' → a ≠ b → a' ≠ b'",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.ℒ",
   "CellularAutomatas.L_dvd_k",
   "sorryAx",
   "Set",
   "Membership.mem",
   "CellularAutomatas.CA_rt",
   "Language",
   "OfNat.ofNat"],
  "name": "CellularAutomatas.L_in_RT_iff_L_dvd_k_in_RT",
  "constType":
  "∀ {α : Type} (k : ℕ) (L : Language α),\n  L ∈ CellularAutomatas.ℒ (CellularAutomatas.CA_rt α) ↔\n    CellularAutomatas.L_dvd_k k L ∈ CellularAutomatas.ℒ (CellularAutomatas.CA_rt (Option α))",
  "constCategory": "Theorem"},
 {"references": ["Int.beq'", "Bool.and'", "Lean.Grind.CommRing.Mon.beq'"],
  "name": "Lean.Grind.CommRing.Poly.beq'",
  "constType": "Grind.CommRing.Poly → Grind.CommRing.Poly → Bool",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Lean.EffectiveImport.toImport",
  "constType": "EffectiveImport → Import",
  "constCategory": "Definition"},
 {"references": ["LT.lt", "LE.le", "Lean.Grind.Preorder.lt_of_lt_of_le"],
  "name": "Lean.Grind.Order.lt_le_trans",
  "constType":
  "∀ {α : Type u_1} [inst : LE α] [inst_1 : LT α] [LawfulOrderLT α] [Std.IsPreorder α] {a b c : α}, a < b → b ≤ c → a < c",
  "constCategory": "Theorem"},
 {"references":
  ["Set",
   "CellularAutomatas.CellAutomaton.Q",
   "CellularAutomatas.CellAutomaton.quiescent_set"],
  "name": "CellularAutomatas.CellAutomaton.quiescent_set.eq_1",
  "constType":
  "∀ (C : CellularAutomatas.CellAutomaton) (Q : Set C.Q), C.quiescent_set Q = ∀ (a b c : ↑Q), C.δ ↑a ↑b ↑c = ↑b",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Finset.val",
  "constType": "{α : Type u_4} → Finset α → Multiset α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Set",
  "constType": "Type u → Type u",
  "constCategory": "Definition"},
 {"references":
  ["CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "CellularAutomatas.CellAutomaton.Q"],
  "name": "CellularAutomatas.CArtTransducer.casesOn",
  "constType":
  "{α Γ : Type} →\n  [inst : CellularAutomatas.Alphabet α] →\n    [inst_1 : CellularAutomatas.Alphabet Γ] →\n      {motive : CellularAutomatas.CArtTransducer α Γ → Sort u} →\n        (t : CellularAutomatas.CArtTransducer α Γ) →\n          ((toLCellAutomaton : CellularAutomatas.LCellAutomaton α) →\n              (f : toLCellAutomaton.Q → Γ) → motive { toLCellAutomaton := toLCellAutomaton, f := f }) →\n            motive t",
  "constCategory": "Definition"},
 {"references":
  ["List.length_eq_zero_iff",
   "Nat.sub_eq_zero_of_le",
   "List.drop",
   "LE.le",
   "Eq.symm",
   "HSub.hSub",
   "Iff.mp",
   "List.length_drop",
   "OfNat.ofNat",
   "List.length"],
  "name": "List.drop_of_length_le",
  "constType":
  "∀ {α : Type u_1} {i : ℕ} {l : List α}, l.length ≤ i → l⟦i..*⟧ = []",
  "constCategory": "Theorem"},
 {"references": ["Not"],
  "name": "Decidable.casesOn",
  "constType":
  "{p : Prop} →\n  {motive : Decidable p → Sort u} →\n    (t : Decidable p) → ((h : ¬p) → motive (isFalse h)) → ((h : p) → motive (isTrue h)) → motive t",
  "constCategory": "Definition"},
 {"references": ["Lean.SyntaxNodeKind", "Array.mkArray3"],
  "name": "Lean.Syntax.node3",
  "constType":
  "SourceInfo → SyntaxNodeKind → Syntax → Syntax → Syntax → Syntax",
  "constCategory": "Definition"},
 {"references": ["Nat.casesOn", "OfNat.ofNat"],
  "name": "_private.Init.Data.Nat.Basic.0.Nat.succ_add.match_1_1",
  "constType":
  "∀ (motive : ℕ → ℕ → Prop) (x x_1 : ℕ), (∀ (x : ℕ), motive x 0) → (∀ (n m : ℕ), motive n m.succ) → motive x x_1",
  "constCategory": "Definition"},
 {"references": ["outParam"],
  "name": "HPow.hPow",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → [self : HPow α β γ] → α → β → γ",
  "constCategory": "Definition"},
 {"references": ["LT.lt", "Nat.succ_lt_succ_iff", "propext"],
  "name":
  "_private.Init.Data.List.Lemmas.0.List.getElem?_eq_some_iff._simp_1_5",
  "constType": "∀ {a b : ℕ}, (a.succ < b.succ) = (a < b)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CellularAutomatas.Advice.f",
  "constType":
  "{α Γ : Type} → CellularAutomatas.Advice α Γ → CellularAutomatas.Word α → CellularAutomatas.Word Γ",
  "constCategory": "Definition"},
 {"references":
  ["Function.Bijective",
   "Function.Surjective",
   "Function.Injective",
   "And.left"],
  "name": "Fintype.ofBijective._proof_1",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} (f : α → β), Function.Bijective f → Function.Injective f",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "eq_self",
   "Eq.trans",
   "of_eq_true",
   "Eq.mpr_not",
   "dite",
   "dite_congr",
   "congrArg",
   "Eq.mpr_prop"],
  "name": "dite_cond_eq_true",
  "constType":
  "∀ {α : Sort u} {c : Prop} {x : Decidable c} {t : c → α} {e : ¬c → α} (h : c = True), dite c t e = t ⋯",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Environment.toKernelEnv", "Lean.Kernel.Environment.constants"],
  "name": "Lean.Environment.constants",
  "constType": "Environment → ConstMap",
  "constCategory": "Definition"},
 {"references": ["Not", "False.elim", "Iff.mpr", "propext"],
  "name": "false_iff",
  "constType": "∀ (p : Prop), (False ↔ p) = ¬p",
  "constCategory": "Theorem"},
 {"references":
  ["List.zip",
   "CellularAutomatas.FiniteStateTransducer.compose_spec2",
   "CellularAutomatas.Word",
   "CellularAutomatas.FiniteStateTransducer.comp",
   "List.zip_eq_zipWith",
   "Eq.trans",
   "List.map_zipWith",
   "CellularAutomatas.FiniteStateTransducer.scanr",
   "List.map",
   "Prod.snd",
   "Function.comp",
   "Prod.fst",
   "congrArg",
   "eq_self",
   "CellularAutomatas.FiniteStateTransducer.M_prod",
   "CellularAutomatas.FiniteStateTransducer.M_map_scanr",
   "of_eq_true",
   "congrFun",
   "congr",
   "CellularAutomatas.FiniteStateTransducer.M_map",
   "funext",
   "CellularAutomatas.FiniteStateTransducer.M_prod_spec",
   "List.zipWith"],
  "name": "CellularAutomatas.backwards_fsm.M_join_spec",
  "constType":
  "∀ {α β : Type} (γ : Type) [inst : CellularAutomatas.Alphabet α] [inst_1 : CellularAutomatas.Alphabet β]\n  [inst_2 : CellularAutomatas.Alphabet γ] (M : CellularAutomatas.FiniteStateTransducer α β)\n  (w : CellularAutomatas.Word (α ⨉ (β → γ))),\n  (CellularAutomatas.backwards_fsm.M_join M).scanr w = List.zipWith (fun x1 x2 => x1 x2) w.snd (M.scanr w.fst)",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.CellAutomaton.δ",
   "forall_eq._simp_1",
   "Eq.trans",
   "Eq.mp",
   "Set",
   "Singleton.singleton",
   "CellularAutomatas.CellAutomaton.dead",
   "Membership.mem",
   "Subtype.val",
   "Set.Elem",
   "congrArg",
   "eq_self",
   "of_eq_true",
   "Subtype.forall._simp_1",
   "forall_congr",
   "id",
   "CellularAutomatas.CellAutomaton.Q",
   "Set.mem_singleton_iff._simp_1",
   "forall_prop_domain_congr"],
  "name": "CellularAutomatas.CellAutomaton.delta_of_dead",
  "constType":
  "∀ {C : CellularAutomatas.CellAutomaton} {b : C.Q}, C.dead b → ∀ (a c : C.Q), C.δ a b c = b",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans", "Lean.Grind.AC.Expr.denote", "Lean.Grind.AC.Seq.denote"],
  "name": "Lean.Grind.AC.eq_expr_seq_seq",
  "constType":
  "∀ {α : Sort u_1} (ctx : Grind.AC.Context α) (e : Grind.AC.Expr) (s₁ s₂ : Grind.AC.Seq),\n  Grind.AC.Expr.denote ctx e = Grind.AC.Seq.denote ctx s₁ →\n    Grind.AC.Seq.denote ctx s₁ = Grind.AC.Seq.denote ctx s₂ → Grind.AC.Expr.denote ctx e = Grind.AC.Seq.denote ctx s₂",
  "constCategory": "Theorem"},
 {"references": ["CellularAutomatas.CA", "CellularAutomatas.t_lt"],
  "name": "CellularAutomatas.CA_lt",
  "constType": "(α : Type) → Set (CellularAutomatas.tCellAutomaton α)",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Lean.Grind.Semiring.natCast",
  "constType": "{α : Type u} → [self : Grind.Semiring α] → NatCast α",
  "constCategory": "Definition"},
 {"references": ["Nat.casesOn"],
  "name": "Nat.ble.match_1",
  "constType":
  "(motive : ℕ → ℕ → Sort u_1) →\n  (x x_1 : ℕ) →\n    ((x : ℕ) → motive Nat.zero x) →\n      ((n : ℕ) → motive n.succ Nat.zero) → ((n m : ℕ) → motive n.succ m.succ) → motive x x_1",
  "constCategory": "Definition"},
 {"references": ["Option.casesOn"],
  "name": "_private.Init.Prelude.0.Lean.SourceInfo.fromRef.match_1",
  "constType":
  "(motive : Option String.Pos.Raw → Option String.Pos.Raw → Sort u_1) →\n  (x x_1 : Option String.Pos.Raw) →\n    ((pos tailPos : String.Pos.Raw) → motive (some pos) (some tailPos)) →\n      ((x x_2 : Option String.Pos.Raw) → motive x x_2) → motive x x_1",
  "constCategory": "Definition"},
 {"references": ["Exists.casesOn", "Nat.cast"],
  "name": "_private.Init.Data.Int.Order.0.Int.negSucc_lt_zero.match_1_3",
  "constType":
  "∀ (n : ℕ) (motive : (∃ n_1, Int.negSucc n = ↑n_1) → Prop) (x : ∃ n_1, Int.negSucc n = ↑n_1),\n  (∀ (w : ℕ) (h : Int.negSucc n = ↑w), motive ⋯) → motive x",
  "constCategory": "Definition"},
 {"references": ["Lean.SyntaxNodeKinds"],
  "name": "Lean.TSyntax.raw",
  "constType": "{ks : SyntaxNodeKinds} → TSyntax ks → Syntax",
  "constCategory": "Definition"},
 {"references":
  ["HAdd.hAdd",
   "Int.zero_sub",
   "Neg.neg",
   "Lean.Omega.Int.le_add_iff_sub_le",
   "LE.le",
   "id",
   "HSub.hSub",
   "Eq.mpr",
   "Iff.rfl",
   "propext",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Lean.Omega.Int.add_nonneg_iff_neg_le",
  "constType": "∀ {a b : ℤ}, 0 ≤ a + b ↔ -b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.Advice.f",
   "CellularAutomatas.Word",
   "CellularAutomatas.Advice.compose._proof_1"],
  "name": "CellularAutomatas.Advice.compose",
  "constType":
  "{α Γ₁ Γ₂ : Type} → CellularAutomatas.Advice α Γ₁ → CellularAutomatas.Advice Γ₁ Γ₂ → CellularAutomatas.Advice α Γ₂",
  "constCategory": "Definition"},
 {"references":
  ["HAdd.hAdd",
   "List.range'",
   "Eq.trans",
   "Nat.zero_add",
   "List.range_loop_range'",
   "id",
   "Eq.mpr",
   "List.range.loop",
   "OfNat.ofNat",
   "congrArg"],
  "name": "List.range_eq_range'",
  "constType": "∀ {n : ℕ}, List.range n = List.range' 0 n",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.Word",
   "Eq.trans",
   "CellularAutomatas.LCellAutomaton.scan_temporal",
   "List.map",
   "List.length_map",
   "CellularAutomatas.LCellAutomaton.comp",
   "OfNat.ofNat",
   "congrArg",
   "CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "CellularAutomatas.LCellAutomaton.scan_temporal_rt",
   "List.range",
   "eq_self",
   "List.length_range",
   "of_eq_true",
   "id",
   "CellularAutomatas.CellAutomaton.Q",
   "List.length"],
  "name": "CellularAutomatas.scan_temporal_length",
  "constType":
  "∀ {α : Type} {C : CellularAutomatas.LCellAutomaton α} (w : CellularAutomatas.Word α),\n  List.length (C.scan_temporal_rt w) = List.length w",
  "constCategory": "Theorem"},
 {"references": ["LE.le"],
  "name": "GE.ge",
  "constType": "{α : Type u} → [LE α] → α → α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Grind.Ring.intCast",
   "Std.IsPreorder.le_refl",
   "Lean.Grind.Ring.neg_add_cancel",
   "Neg.neg",
   "Lean.Grind.Ring.intCast_neg",
   "Lean.Grind.Semiring.add_assoc",
   "Int.cast",
   "OfNat.ofNat",
   "congrArg",
   "HAdd.hAdd",
   "Lean.Grind.Semiring.add_zero",
   "LE.le",
   "Eq.symm",
   "id",
   "Eq.mpr",
   "Eq.ndrec",
   "Lean.Grind.Semiring.add_comm"],
  "name": "Lean.Grind.Order.le_of_offset_eq_2_k",
  "constType":
  "∀ {α : Type u_1} [inst : LE α] [inst_1 : LT α] [LawfulOrderLT α] [inst_3 : Std.IsPreorder α] [inst_4 : Grind.Ring α]\n  [Grind.OrderedRing α] {a b : α} {k : ℤ}, a = b + ↑k → b ≤ a + ↑(-k)",
  "constCategory": "Theorem"},
 {"references": ["Int.neg_inj", "OfNat.ofNat"],
  "name": "Int.neg_eq_zero",
  "constType": "∀ {a : ℤ}, -a = 0 ↔ a = 0",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Int.toNat",
   "Max.max",
   "Nat.cast",
   "Eq.trans",
   "of_eq_true",
   "ite",
   "LE.le",
   "OfNat.ofNat",
   "Int.ofNat_toNat",
   "congrArg"],
  "name": "Nat.ToInt.ofNat_toNat",
  "constType": "∀ (a : ℤ), ↑a.toNat = if a ≤ 0 then 0 else a",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "LT.lt",
   "Int.add_lt_add_right",
   "Eq.mp",
   "Neg.neg",
   "Int.add_left_neg",
   "Int.zero_add",
   "Int.add_lt_add_left",
   "OfNat.ofNat",
   "Int.add_neg_cancel_right",
   "congrArg"],
  "name": "Int.neg_lt_neg",
  "constType": "∀ {a b : ℤ}, a < b → -b < -a",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.simulation.Params.C_ctl",
   "CellularAutomatas.CellAutomaton.Q",
   "OfNat.ofNat"],
  "name": "CellularAutomatas.simulation.Q1.recOn",
  "constType":
  "{e : CellularAutomatas.simulation.Params} →\n  {motive : CellularAutomatas.simulation.Q1 e → Sort u} →\n    (t : CellularAutomatas.simulation.Q1 e) →\n      ((state : e.C_ctl.Q) → (counter : Fin 3) → motive { state := state, counter := counter }) → motive t",
  "constCategory": "Definition"},
 {"references": ["rfl", "cast"],
  "name": "eq_of_heq",
  "constType": "∀ {α : Sort u} {a a' : α}, a ≍ a' → a = a'",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "CellularAutomatas.Word",
   "Nat.cast",
   "GE.ge",
   "OfNat.ofNat",
   "List.length",
   "setOf"],
  "name": "CellularAutomatas.Word.range",
  "constType": "{α : Type u} → CellularAutomatas.Word α → Set ℤ",
  "constCategory": "Definition"},
 {"references":
  ["tsub_eq_zero_iff_le", "Iff.mpr", "LE.le", "HSub.hSub", "OfNat.ofNat"],
  "name": "tsub_eq_zero_of_le",
  "constType":
  "∀ {α : Type u_1} [inst : AddCommMonoid α] [inst_1 : PartialOrder α] [CanonicallyOrderedAdd α] [inst_3 : Sub α]\n  [OrderedSub α] {a b : α}, a ≤ b → a - b = 0",
  "constCategory": "Theorem"},
 {"references": ["Lean.Omega.IntList", "HMul.hMul", "Lean.Omega.IntList.sum"],
  "name": "Lean.Omega.IntList.dot",
  "constType": "Omega.IntList → Omega.IntList → ℤ",
  "constCategory": "Definition"},
 {"references": ["CellularAutomatas.CellAutomaton.mk.noConfusion"],
  "name": "CellularAutomatas.CellAutomaton.mk.inj",
  "constType":
  "∀ {Q : Type} {alphabetQ : CellularAutomatas.Alphabet Q} {δ : Q → Q → Q → Q} {Q_1 : Type}\n  {alphabetQ_1 : CellularAutomatas.Alphabet Q_1} {δ_1 : Q_1 → Q_1 → Q_1 → Q_1},\n  { Q := Q, alphabetQ := alphabetQ, δ := δ } = { Q := Q_1, alphabetQ := alphabetQ_1, δ := δ_1 } →\n    Q = Q_1 ∧ alphabetQ ≍ alphabetQ_1 ∧ δ ≍ δ_1",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Lean.Name.mkStr4",
  "constType": "String → String → String → String → Name",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Lean.SyntaxNodeKind",
  "constType": "Type",
  "constCategory": "Definition"},
 {"references":
  ["Not",
   "Bool.not_eq_true",
   "Int.beq'_eq",
   "Eq.symm",
   "id",
   "Int.beq'",
   "Ne.eq_1",
   "Ne",
   "Eq.mpr",
   "congrArg"],
  "name": "Int.beq'_ne",
  "constType": "∀ (a b : ℤ), (a.beq' b = false) = (a ≠ b)",
  "constCategory": "Theorem"},
 {"references":
  ["_private.Init.Prelude.0.Lean.extractMacroScopesAux.match_1",
   "_private.Init.Prelude.0.Lean.extractMainModule",
   "Lean.Name.brecOn",
   "panic",
   "Lean.MacroScope",
   "Lean.Name.below"],
  "name": "_private.Init.Prelude.0.Lean.extractMacroScopesAux",
  "constType": "Name → List MacroScope → MacroScopesView",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Grind.CommRing.Mon.below",
   "Lean.Grind.CommRing.Power.denote",
   "HMul.hMul",
   "Lean.Grind.CommRing.Mon.brecOn",
   "Lean.Grind.CommRing.Mon.denote.match_1",
   "OfNat.ofNat",
   "Lean.Grind.CommRing.Context",
   "Unit"],
  "name": "Lean.Grind.CommRing.Mon.denote",
  "constType":
  "{α : Type u_1} → [Grind.Semiring α] → Grind.CommRing.Context α → Grind.CommRing.Mon → α",
  "constCategory": "Definition"},
 {"references":
  ["Not", "LT.lt", "LE.le", "propext", "Std.lt_iff_le_and_not_ge"],
  "name":
  "_private.Init.Grind.Ordered.Module.0.Lean.Grind.OrderedAdd.add_lt_left._simp_1_1",
  "constType":
  "∀ {α : Type u} [inst : LT α] [inst_1 : LE α] [LawfulOrderLT α] {a b : α}, (a < b) = (a ≤ b ∧ ¬b ≤ a)",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt", "Not", "Int.lt_of_not_ge", "LE.le", "Int.not_le_of_gt"],
  "name": "Int.not_le",
  "constType": "∀ {a b : ℤ}, ¬a ≤ b ↔ b < a",
  "constCategory": "Theorem"},
 {"references": ["CellularAutomatas.FiniteStateTransducer.map_output"],
  "name": "CellularAutomatas.FiniteStateTransducer.map_output.eq_1",
  "constType":
  "∀ {α β γ : Type} [inst : CellularAutomatas.Alphabet α] [inst_1 : CellularAutomatas.Alphabet β]\n  [inst_2 : CellularAutomatas.Alphabet γ] (M : CellularAutomatas.FiniteStateTransducer α β) (g : β → γ),\n  M.map_output g = CellularAutomatas.FiniteStateTransducer.M_map g ⊚ M",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CellularAutomatas.LCellAutomaton",
  "constType": "Type → Type 1",
  "constCategory": "Other"},
 {"references": [],
  "name": "Lean.Grind.nestedProof",
  "constType": "∀ (p : Prop) {h : p}, p",
  "constCategory": "Definition"},
 {"references": ["Int.casesOn"],
  "name": "_private.Init.Data.Int.Lemmas.0.Int.add_assoc.match_1_1",
  "constType":
  "∀ (motive : ℤ → ℤ → ℤ → Prop) (x x_1 x_2 : ℤ),\n  (∀ (m n : ℕ) (x : ℤ), motive (Int.ofNat m) (Int.ofNat n) x) →\n    (∀ (m : ℕ) (b : ℤ) (k : ℕ), motive (Int.ofNat m) b (Int.ofNat k)) →\n      (∀ (a : ℤ) (n k : ℕ), motive a (Int.ofNat n) (Int.ofNat k)) →\n        (∀ (a a_1 k : ℕ), motive (Int.negSucc a) (Int.negSucc a_1) (Int.ofNat k)) →\n          (∀ (m n k : ℕ), motive (Int.negSucc m) (Int.ofNat n) (Int.negSucc k)) →\n            (∀ (m n k : ℕ), motive (Int.ofNat m) (Int.negSucc n) (Int.negSucc k)) →\n              (∀ (m n k : ℕ), motive (Int.negSucc m) (Int.negSucc n) (Int.negSucc k)) → motive x x_1 x_2",
  "constCategory": "Definition"},
 {"references":
  ["HAdd.hAdd",
   "SizeOf.sizeOf",
   "CellularAutomatas.simulation.Params.C_ctl",
   "CellularAutomatas.CellAutomaton.Q",
   "OfNat.ofNat"],
  "name": "CellularAutomatas.simulation.Q1.mk.sizeOf_spec",
  "constType":
  "∀ {e : CellularAutomatas.simulation.Params} (state : e.C_ctl.Q) (counter : Fin 3),\n  sizeOf { state := state, counter := counter } = 1 + sizeOf state + sizeOf counter",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.cast",
   "Eq.trans",
   "le_of_le_of_eq",
   "Lean.Omega.LinearCombo.coordinate_eval_0",
   "Decidable.decide",
   "Lean.Omega.Coeffs.ofList",
   "Lean.Omega.tidy_sat",
   "HSub.hSub",
   "Eq.symm",
   "Lean.Omega.LinearCombo.add_eval",
   "Lean.Omega.Int.lt_of_not_le",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "Int.add_one_le_of_lt",
   "of_decide_eq_true",
   "Not",
   "Neg.neg",
   "Lean.Omega.Constraint.addInequality_sat",
   "Lean.Omega.Int.add_congr",
   "Lean.Omega.Constraint.isImpossible",
   "Lean.Omega.LinearCombo.coordinate",
   "OfNat.ofNat",
   "Int.sub_nonneg_of_le",
   "HAdd.hAdd",
   "Lean.Omega.LinearCombo.sub_eval",
   "LE.le",
   "id",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.Int.sub_congr"],
  "name": "CellularAutomatas.nextt_congr._proof_1_3",
  "constType": "∀ (i : ℤ), ¬i - ↑0 ≤ i → False",
  "constCategory": "Theorem"},
 {"references":
  ["List.drop",
   "Eq.trans",
   "Eq.mp",
   "Nat.noConfusion",
   "_private.Init.Data.List.Basic.0.List.drop_eq_nil_of_le.match_1_1",
   "List.brecOn",
   "eq_false'",
   "List.drop_nil",
   "OfNat.ofNat",
   "congrArg",
   "HAdd.hAdd",
   "List.below",
   "eq_self",
   "False.elim",
   "of_eq_true",
   "Nat.le_of_succ_le_succ",
   "LE.le",
   "Nat.le_zero_eq",
   "List.length"],
  "name": "List.drop_eq_nil_of_le",
  "constType":
  "∀ {α : Type u} {as : List α} {i : ℕ}, as.length ≤ i → as⟦i..*⟧ = []",
  "constCategory": "Theorem"},
 {"references": ["Iff.rfl"],
  "name": "Iff.of_eq",
  "constType": "∀ {a b : Prop}, a = b → (a ↔ b)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CellularAutomatas.simulation.Q1.counter",
  "constType":
  "{e : CellularAutomatas.simulation.Params} → CellularAutomatas.simulation.Q1 e → Fin 3",
  "constCategory": "Definition"},
 {"references":
  ["implies_congr",
   "Eq.trans",
   "Eq.mpr_not",
   "Lean.Grind.Order.of_nat_eq",
   "eq_true",
   "HMul.hMul",
   "eagerReduce",
   "ite_cond_eq_true",
   "IntCast.intCast",
   "List.getLast?_append",
   "Nat.ToInt.natCast_ofNat",
   "List.getLast?",
   "Lean.Grind.Order.int_lt",
   "GetElem?.getElem?",
   "Nat.sub_sub",
   "False.elim",
   "NatCast.natCast",
   "Lean.Grind.eq_false_of_imp_eq_true",
   "Eq.symm",
   "HSub.hSub",
   "forall_prop_domain_congr",
   "Lean.Grind.forall_propagator",
   "HAppend.hAppend",
   "of_eq_false",
   "List.drop",
   "getElem?_pos",
   "Neg.neg",
   "Lean.Grind.Order.le_of_eq_2_k",
   "Lean.Grind.Order.le_of_offset_eq_1_k",
   "List.take_add",
   "Nat.Linear.Expr.eq_of_toNormPoly_eq",
   "List.length_append",
   "Lean.Grind.nestedProof",
   "List.getElem_append._proof_1",
   "CellularAutomatas.PrefixStableProof.getLastOfTake._proof_1_7",
   "eq_false",
   "Lean.Grind.CommRing.lt_norm_expr",
   "id",
   "Lean.Grind.Order.le_trans_k",
   "Lean.Grind.Order.eq_trans_false'",
   "Lean.Grind.Order.lt_eq_true_of_le_k",
   "Lean.Grind.Order.eq_trans_true",
   "getElem?_neg",
   "List.length",
   "Int.Linear.norm_le",
   "Eq.substr",
   "Option.some_or",
   "Int.Linear.natCast_sub",
   "Eq.mp",
   "noConfusion_of_Nat",
   "GetElem.getElem",
   "Nat.Linear.ExprCnstr.eq_of_toNormPoly_eq",
   "List.length_take",
   "Int.Linear.Expr.eq_of_norm_eq",
   "min_def",
   "congrArg",
   "Option.or",
   "Lean.Grind.Nat.lt_eq",
   "Nat.not_le_eq",
   "Lean.Grind.nestedDecidable",
   "CellularAutomatas.PrefixStableProof.getLastOfTake._proof_1_3",
   "List.getLast?_eq_getElem?",
   "Lean.Grind.Order.lt_of_not_le_k",
   "cast",
   "Not",
   "Nat.ToInt.lt_eq",
   "ite",
   "Lean.Grind.Order.le_eq_true_of_le_k",
   "Nat.ToInt.add_congr",
   "Lean.Grind.Order.eq_mp_not",
   "OfNat.ofNat",
   "ite_congr",
   "HAdd.hAdd",
   "LT.lt",
   "Nat.ToInt.le_eq",
   "of_eq_true",
   "Min.min",
   "Lean.Grind.CommRing.Expr.eq_of_toPoly_eq",
   "List.take",
   "LE.le",
   "Lean.Grind.Semiring.natCast",
   "CellularAutomatas.PrefixStableProof.getLastOfTake._proof_1_5",
   "Lean.Grind.CommRing.le_norm_expr",
   "Lean.Grind.Semiring.natCast_eq_ofNat"],
  "name": "CellularAutomatas.PrefixStableProof.getLastOfTake._proof_1_17",
  "constType":
  "∀ {i : ℕ} {α : Type u_1} {w : List α},\n  i + 1 ≤ w.length →\n    -1 * ↑(List.take 1 w⟦i..*⟧).length + 1 ≤ 0 →\n      ¬(List.take (i + 1) w).length - 1 + 1 ≤ (List.take (List.take i w).length w).length →\n        (List.take (i + 1) w).length - ((List.take (List.take i w).length w).length + 1) <\n          (List.take (List.take 1 w⟦i..*⟧).length w⟦(List.take i w).length..*⟧).length",
  "constCategory": "Theorem"},
 {"references":
  ["Set.image", "Set", "Membership.mem", "Set.mem_image", "propext"],
  "name": "_private.Mathlib.Data.Finset.Image.0.Finset.coe_image._simp_1_2",
  "constType":
  "∀ {α : Type u} {β : Type v} (f : α → β) (s : Set α) (y : β), (y ∈ f '' s) = ∃ x ∈ s, f x = y",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt",
   "Nat.blt",
   "Nat.le_of_ble_eq_true",
   "Nat.ble_eq_true_of_le",
   "propext"],
  "name": "Nat.blt_eq",
  "constType": "∀ {x y : ℕ}, (x.blt y = true) = (x < y)",
  "constCategory": "Theorem"},
 {"references": ["Nat.not_lt", "LT.lt", "Not", "LE.le", "propext"],
  "name": "Nat.not_lt._simp_1",
  "constType": "∀ {a b : ℕ}, (¬a < b) = (b ≤ a)",
  "constCategory": "Theorem"},
 {"references":
  ["implies_true",
   "eq_self",
   "Eq.trans",
   "of_eq_true",
   "Lean.Grind.AC.Seq.denote",
   "implies_congr_ctx",
   "congrArg"],
  "name": "Lean.Grind.AC.eq_orient",
  "constType":
  "∀ {α : Sort u_1} (ctx : Grind.AC.Context α) (lhs rhs : Grind.AC.Seq),\n  Grind.AC.Seq.denote ctx lhs = Grind.AC.Seq.denote ctx rhs → Grind.AC.Seq.denote ctx rhs = Grind.AC.Seq.denote ctx lhs",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "NegZeroClass.neg_zero",
  "constType": "∀ {G : Type u_2} [self : NegZeroClass G], -0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans",
   "getElem?_pos",
   "Option.getD",
   "GetElem.getElem",
   "OfNat.ofNat",
   "congrArg",
   "LT.lt",
   "GetElem?.getElem?",
   "eq_self",
   "of_eq_true",
   "Lean.Omega.IntList",
   "Nat.zero_lt_succ._simp_1",
   "List.length"],
  "name": "Lean.Omega.IntList.get_cons_zero",
  "constType": "∀ {x : ℤ} {xs : List ℤ}, Omega.IntList.get (x :: xs) 0 = x",
  "constCategory": "Theorem"},
 {"references": ["CellularAutomatas.backwards_fsm.Params.noConfusion", "id"],
  "name": "CellularAutomatas.backwards_fsm.Params.mk.noConfusion",
  "constType":
  "(P : Sort u) →\n  {α β γ : Type} →\n    [inst1 : CellularAutomatas.Alphabet α] →\n      [inst2 : CellularAutomatas.Alphabet β] →\n        [inst3 : CellularAutomatas.Alphabet γ] →\n          (M : CellularAutomatas.FiniteStateTransducer α β) →\n            (C : CellularAutomatas.CArtTransducer β γ) →\n              (α' β' γ' : Type) →\n                (inst1' : CellularAutomatas.Alphabet α') →\n                  (inst2' : CellularAutomatas.Alphabet β') →\n                    (inst3' : CellularAutomatas.Alphabet γ') →\n                      (M' : CellularAutomatas.FiniteStateTransducer α' β') →\n                        (C' : CellularAutomatas.CArtTransducer β' γ') →\n                          { α := α, β := β, γ := γ, inst1 := inst1, inst2 := inst2, inst3 := inst3, M := M, C := C } =\n                              { α := α', β := β', γ := γ', inst1 := inst1', inst2 := inst2', inst3 := inst3', M := M',\n                                C := C' } →\n                            (α = α' →\n                                β = β' →\n                                  γ = γ' → inst1 ≍ inst1' → inst2 ≍ inst2' → inst3 ≍ inst3' → M ≍ M' → C ≍ C' → P) →\n                              P",
  "constCategory": "Definition"},
 {"references": ["Nat.casesOn", "LE.le", "OfNat.ofNat"],
  "name": "_private.Init.Data.Int.Lemmas.0.Int.ofNat_sub.match_1_1",
  "constType":
  "∀ {n : ℕ} (motive : (m : ℕ) → m ≤ n → Prop) (m : ℕ) (h : m ≤ n),\n  (∀ (h : 0 ≤ n), motive 0 h) → (∀ (m : ℕ) (h : m.succ ≤ n), motive m.succ h) → motive m h",
  "constCategory": "Definition"},
 {"references": ["id"],
  "name": "not_false",
  "constType": "¬False",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Name.hash",
   "Lean.Name.quickCmpAux",
   "Ord.compare",
   "_private.Lean.Data.Name.0.Lean.Name.cmp.match_1",
   "Unit"],
  "name": "Lean.Name.quickCmp",
  "constType": "Name → Name → Ordering",
  "constCategory": "Definition"},
 {"references":
  ["HAdd.hAdd",
   "LT.lt",
   "Not",
   "Nat.le_of_succ_le_succ",
   "LE.le",
   "OfNat.ofNat"],
  "name": "Nat.findX._proof_4",
  "constType": "∀ {p : ℕ → Prop} (m : ℕ), (∀ n ≤ m, ¬p n) → ∀ n < m + 1, ¬p n",
  "constCategory": "Theorem"},
 {"references": ["CellularAutomatas.tCellAutomatonWithAdvice.mk.noConfusion"],
  "name": "CellularAutomatas.tCellAutomatonWithAdvice.mk.inj",
  "constType":
  "∀ {α Γ : Type} {alphabetΓ : CellularAutomatas.Alphabet Γ} {adv : CellularAutomatas.Advice α Γ}\n  {C : CellularAutomatas.tCellAutomaton (α ⨉ Γ)} {Γ_1 : Type} {alphabetΓ_1 : CellularAutomatas.Alphabet Γ_1}\n  {adv_1 : CellularAutomatas.Advice α Γ_1} {C_1 : CellularAutomatas.tCellAutomaton (α ⨉ Γ_1)},\n  { Γ := Γ, alphabetΓ := alphabetΓ, adv := adv, C := C } =\n      { Γ := Γ_1, alphabetΓ := alphabetΓ_1, adv := adv_1, C := C_1 } →\n    Γ = Γ_1 ∧ alphabetΓ ≍ alphabetΓ_1 ∧ adv ≍ adv_1 ∧ C ≍ C_1",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Subsingleton.allEq",
  "constType": "∀ {α : Sort u} [self : Subsingleton α] (a b : α), a = b",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "id",
   "HSub.hSub",
   "Nat.recAux",
   "Eq.mpr",
   "Nat.pred",
   "Decidable.decide",
   "OfNat.ofNat",
   "of_decide_eq_true",
   "congrArg"],
  "name": "Nat.zero_sub",
  "constType": "∀ (n : ℕ), 0 - n = 0",
  "constCategory": "Theorem"},
 {"references": ["Lean.Omega.Coeffs", "Lean.Omega.IntList.dot_smul_left"],
  "name": "Lean.Omega.Coeffs.dot_smul_left",
  "constType":
  "∀ (xs ys : Omega.Coeffs) (i : ℤ), Omega.Coeffs.dot (i * xs) ys = i * xs.dot ys",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Lean.Omega.LinearCombo.coordinate_eval",
   "Eq.trans",
   "Lean.Omega.Coeffs.ofList",
   "of_eq_true",
   "Lean.Omega.Coeffs.get",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.IntList.get_cons_zero",
   "Lean.Omega.LinearCombo.coordinate",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Lean.Omega.LinearCombo.coordinate_eval_0",
  "constType":
  "∀ {a0 : ℤ} {t : List ℤ}, (Omega.LinearCombo.coordinate 0).eval (Omega.Coeffs.ofList (a0 :: t)) = a0",
  "constCategory": "Theorem"},
 {"references": ["outParam"],
  "name": "DFunLike.coe",
  "constType":
  "{F : Sort u_1} → {α : outParam (Sort u_2)} → {β : outParam (α → Sort u_3)} → [self : DFunLike F α β] → F → (a : α) → β a",
  "constCategory": "Definition"},
 {"references":
  ["Not",
   "CellularAutomatas.CArtTransducer.advice",
   "Eq.trans",
   "Eq.mp",
   "Function.comp_apply",
   "eq_true",
   "CellularAutomatas.TwoStageAdvice.β",
   "Function.comp",
   "CellularAutomatas.TwoStageAdvice.M",
   "congrArg",
   "CellularAutomatas.Advice.f",
   "CellularAutomatas.TwoStageAdvice.C",
   "eq_false",
   "CellularAutomatas.Advice.len",
   "Classical.byContradiction",
   "Eq.symm",
   "id",
   "CellularAutomatas.FiniteStateTransducer.advice",
   "Lean.Grind.intro_with_eq",
   "List.length"],
  "name": "CellularAutomatas.TwoStageAdvice.advice._proof_1",
  "constType":
  "∀ {α Γ : Type} [inst : CellularAutomatas.Alphabet α] [inst_1 : CellularAutomatas.Alphabet Γ]\n  {adv : CellularAutomatas.TwoStageAdvice α Γ} (w : CellularAutomatas.Word α),\n  List.length ((adv.M.advice.f ∘ adv.C.advice.f) w) = List.length w",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.Advice.f", "CellularAutomatas.Word", "List.take"],
  "name": "CellularAutomatas.Advice.prefix_stable",
  "constType": "{α Γ : Type} → {adv : CellularAutomatas.Advice α Γ} → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Not",
   "eq_self",
   "of_eq_false",
   "Eq.trans",
   "of_eq_true",
   "dite_cond_eq_false",
   "dite",
   "congrArg"],
  "name": "Lean.Grind.dite_cond_eq_false'",
  "constType":
  "∀ {α : Sort u} {c : Prop} {x : Decidable c} {a : c → α} {b : ¬c → α} {r : α} (h₁ : c = False), b ⋯ = r → dite c a b = r",
  "constCategory": "Theorem"},
 {"references":
  ["Not",
   "Lean.Grind.AC.Seq.insert",
   "Nat.blt",
   "Eq.trans",
   "Lean.Grind.AC.Var.denote",
   "Lean.Grind.AC.Context.op",
   "Lean.Grind.AC.Seq.unionFuel",
   "congrArg",
   "Lean.Grind.AC.Var",
   "Lean.Grind.AC.Seq.denote_insert",
   "eq_self",
   "Lean.Grind.AC.Seq.unionFuel.induct_unfolding",
   "of_eq_true",
   "Std.Commutative.comm",
   "congr",
   "Eq.symm",
   "id",
   "Lean.Grind.AC.Seq.denote",
   "Lean.Grind.AC.Seq.concat",
   "Eq.mpr",
   "Lean.Grind.AC.Seq.denote_concat",
   "Std.Associative.assoc"],
  "name": "Lean.Grind.AC.Seq.denote_unionFuel",
  "constType":
  "∀ {α : Sort u_1} (ctx : Grind.AC.Context α) {inst₁ : Associative ctx.op} {inst₂ : Commutative ctx.op} (fuel : ℕ)\n  (s₁ s₂ : Grind.AC.Seq),\n  Grind.AC.Seq.denote ctx (Grind.AC.Seq.unionFuel fuel s₁ s₂) =\n    ctx.op (Grind.AC.Seq.denote ctx s₁) (Grind.AC.Seq.denote ctx s₂)",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Syntax.getPos?",
   "cond.match_1",
   "_private.Init.Prelude.0.Lean.SourceInfo.fromRef.match_1",
   "Unit"],
  "name": "Lean.SourceInfo.fromRef",
  "constType": "Syntax → optParam Bool false → SourceInfo",
  "constCategory": "Definition"},
 {"references": ["Option.casesOn", "Unit.unit", "Unit"],
  "name":
  "_private.Lean.Util.FoldConsts.0.Lean.ConstantInfo.getUsedConstantsAsSet.match_4",
  "constType":
  "(motive : Option Expr → Sort u_1) → (x : Option Expr) → ((v : Expr) → motive (some v)) → (Unit → motive none) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Not",
   "Lean.Grind.OrderedAdd.add_le_left_iff",
   "Eq.mp",
   "And.right",
   "_private.Init.Grind.Ordered.Module.0.Lean.Grind.OrderedAdd.add_lt_left._simp_1_1",
   "LT.lt",
   "HAdd.hAdd",
   "Iff.mpr",
   "LE.le",
   "id",
   "Eq.mpr",
   "Lean.Grind.OrderedAdd.add_le_left",
   "And.left"],
  "name": "Lean.Grind.OrderedAdd.add_lt_left",
  "constType":
  "∀ {M : Type u} [inst : LE M] [inst_1 : Std.IsPreorder M] [inst_2 : Grind.AddCommMonoid M] [Grind.OrderedAdd M]\n  [inst_4 : LT M] [LawfulOrderLT M] {a b : M}, a < b → ∀ (c : M), a + c < b + c",
  "constCategory": "Theorem"},
 {"references":
  ["Int.mul_add",
   "Eq.trans",
   "Lean.Omega.IntList.dot_of_left_zero",
   "Lean.Omega.LinearCombo.coeffs",
   "Int.mul_comm",
   "HMul.hMul",
   "Lean.Omega.Coeffs",
   "Int.add_zero",
   "Lean.Omega.LinearCombo.const",
   "congrArg",
   "Lean.Omega.IntList",
   "congr",
   "HSub.hSub",
   "Int.add_sub_cancel",
   "Lean.Omega.IntList.dot",
   "Neg.neg",
   "Lean.Omega.IntList.dot_smul_left",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "Int.mul_zero",
   "eq_self",
   "of_eq_true",
   "Lean.Omega.Coeffs.isZero",
   "Lean.Omega.Coeffs.dot_distrib_left",
   "Lean.Omega.IntList.add_nil",
   "Lean.Omega.Coeffs.sub_eq_add_neg",
   "Lean.Omega.Coeffs.dot"],
  "name": "Lean.Omega.LinearCombo.mul_eval_of_const_right",
  "constType":
  "∀ (l₁ l₂ : Omega.LinearCombo) (v : Omega.Coeffs), l₂.coeffs.isZero → (l₁.mul l₂).eval v = l₁.eval v * l₂.eval v",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "Nat.le.dest",
   "LE.le",
   "Eq.symm",
   "id",
   "HSub.hSub",
   "Nat.sub_self_add",
   "Eq.mpr",
   "OfNat.ofNat",
   "_private.Init.Data.Nat.Basic.0.Nat.sub_eq_zero_of_le.match_1_1",
   "congrArg"],
  "name": "Nat.sub_eq_zero_of_le",
  "constType": "∀ {n m : ℕ}, n ≤ m → n - m = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Ord.compare",
   "_private.Lean.Data.Name.0.Lean.Name.cmp.match_1",
   "Lean.Name.brecOn",
   "Lean.Name.below",
   "_private.Lean.Data.Name.0.Lean.Name.cmp.match_4",
   "Unit"],
  "name": "Lean.Name.quickCmpAux",
  "constType": "Name → Name → Ordering",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CellularAutomatas.tCellAutomaton.rec",
  "constType":
  "{α : Type} →\n  {motive : CellularAutomatas.tCellAutomaton α → Sort u} →\n    ((toLCellAutomaton : CellularAutomatas.LCellAutomaton α) →\n        (t p : ℕ → ℕ) →\n          (F_pos : toLCellAutomaton.Q → Bool) →\n            motive { toLCellAutomaton := toLCellAutomaton, t := t, p := p, F_pos := F_pos }) →\n      (t : CellularAutomatas.tCellAutomaton α) → motive t",
  "constCategory": "Other"},
 {"references": [],
  "name": "False.casesOn",
  "constType": "(motive : False → Sort u) → (t : False) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Grind.Ring.intCast_ofNat",
   "Lean.Grind.Ring.intCast",
   "id",
   "Eq.mpr",
   "Int.cast",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Lean.Grind.Ring.intCast_zero",
  "constType": "∀ {α : Type u} [inst : Grind.Ring α], ↑0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.FiniteStateTransducer.scanr_reduce_q",
   "CellularAutomatas.FiniteStateTransducer.Q"],
  "name": "CellularAutomatas.FiniteStateTransducer.scanr_reduce_q.eq_1",
  "constType":
  "∀ {α β : Type} (M : CellularAutomatas.FiniteStateTransducer α β) (q : M.Q), M.scanr_reduce_q q [] = q",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.MacroScopesView.imported",
   "Lean.MacroScopesView.review",
   "Lean.MacroScopesView.ctx",
   "cond.match_1",
   "Lean.MacroScope",
   "Lean.Name.mkStr",
   "Unit",
   "Lean.MacroScopesView.name",
   "Lean.Name.hasMacroScopes",
   "Lean.extractMacroScopes",
   "Lean.Name.appendCore",
   "Lean.Name.mkNum",
   "Lean.MacroScopesView.scopes",
   "List.foldl",
   "BEq.beq"],
  "name": "Lean.addMacroScope",
  "constType": "Name → Name → MacroScope → Name",
  "constCategory": "Definition"},
 {"references":
  ["HAdd.hAdd",
   "Int.add_assoc",
   "Int.add_comm",
   "Eq.symm",
   "id",
   "Eq.mpr",
   "congrArg"],
  "name": "Int.add_left_comm",
  "constType": "∀ (a b c : ℤ), a + (b + c) = b + (a + c)",
  "constCategory": "Theorem"},
 {"references":
  ["Set", "CellularAutomatas.tCellAutomatonWithAdvice.with_advice"],
  "name": "CellularAutomatas.tCellAutomatonWithAdvice.with_advice.eq_1",
  "constType":
  "∀ {α Γ : Type} [inst : CellularAutomatas.Alphabet Γ] (S : Set (CellularAutomatas.tCellAutomaton (α ⨉ Γ)))\n  (adv : CellularAutomatas.Advice α Γ),\n  CellularAutomatas.tCellAutomatonWithAdvice.with_advice S adv =\n    {x | ∃ C ∈ S, { Γ := Γ, alphabetΓ := inst, adv := adv, C := C } = x}",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans",
   "CellularAutomatas.backwards_fsm.Params.inst3",
   "eq_true",
   "eagerReduce",
   "CellularAutomatas.Config",
   "CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "NatCast.natCast",
   "funext",
   "HSub.hSub",
   "Eq.symm",
   "CellularAutomatas.Word.get'?",
   "CellularAutomatas.backwards_fsm.Params.α",
   "CellularAutomatas.CellAutomaton.δ",
   "CellularAutomatas.CArtTransducer.toLCellAutomaton",
   "List.drop",
   "CellularAutomatas.backwards_fsm.Params.β",
   "Neg.neg",
   "CellularAutomatas.backwards_fsm.Params.M",
   "CellularAutomatas.FiniteStateTransducer.scanr",
   "Prod.snd",
   "CellularAutomatas.backwards_fsm.Params.inst2",
   "CellularAutomatas.LCellAutomaton.comp",
   "eq_false",
   "Classical.byContradiction",
   "id",
   "Int.toNat",
   "Nat.cast",
   "CellularAutomatas.backwards_fsm.C'",
   "CellularAutomatas.backwards_fsm.Params.C",
   "Eq.mp",
   "CellularAutomatas.FiniteStateTransducer.Q",
   "CellularAutomatas.FiniteStateTransducer.δ?",
   "CellularAutomatas.FiniteStateTransducer.scanr_reduce",
   "CellularAutomatas.backwards_fsm.Params.γ",
   "Int.Linear.Expr.eq_of_norm_eq",
   "Prod.fst",
   "congrArg",
   "congr",
   "CellularAutomatas.CellAutomaton.Q",
   "Lean.Grind.forall_and",
   "Not",
   "CellularAutomatas.Word",
   "Lean.Grind.Semiring.natCast_add",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "eq_self",
   "True.casesOn",
   "Lean.Grind.intro_with_eq",
   "Lean.Grind.Semiring.natCast",
   "Lean.Grind.Semiring.natCast_eq_ofNat",
   "And.casesOn"],
  "name": "CellularAutomatas.backwards_fsm.inv._proof_1_8",
  "constType":
  "∀ (e : CellularAutomatas.backwards_fsm.Params) (w : CellularAutomatas.Word e.α) (t : ℕ) (p : ℤ),\n  (∀ (p : ℤ),\n      let c' := (CellularAutomatas.backwards_fsm.C' e).comp w t p;\n      let q := e.M.scanr_reduce w⟦(p + ↑t).toNat..*⟧;\n      c'.2 q = e.C.comp (e.M.scanr w) t p ∧ c'.1 = w.get'? (p + ↑t)) →\n    (CellularAutomatas.backwards_fsm.C' e).comp w t = (CellularAutomatas.backwards_fsm.C' e).comp w t →\n      (CellularAutomatas.backwards_fsm.C' e).comp w t (p - 1) =\n          (CellularAutomatas.backwards_fsm.C' e).comp w t (p - 1) →\n        (CellularAutomatas.backwards_fsm.C' e).comp w t p = (CellularAutomatas.backwards_fsm.C' e).comp w t p →\n          (CellularAutomatas.backwards_fsm.C' e).comp w (t + 1) p =\n              (((CellularAutomatas.backwards_fsm.C' e).comp w t (p + 1)).1, fun q =>\n                e.C.δ\n                  (((CellularAutomatas.backwards_fsm.C' e).comp w t (p - 1)).2\n                    (e.M.δ? (e.M.δ? q ((CellularAutomatas.backwards_fsm.C' e).comp w t p).1)\n                      ((CellularAutomatas.backwards_fsm.C' e).comp w t (p - 1)).1))\n                  (((CellularAutomatas.backwards_fsm.C' e).comp w t p).2\n                    (e.M.δ? q ((CellularAutomatas.backwards_fsm.C' e).comp w t p).1))\n                  (((CellularAutomatas.backwards_fsm.C' e).comp w t (p + 1)).2 q)) →\n            (CellularAutomatas.backwards_fsm.C' e).comp w t (p + 1) =\n                (CellularAutomatas.backwards_fsm.C' e).comp w t (p + 1) →\n              e.M.scanr_reduce w⟦(p + ↑(t + 1)).toNat..*⟧ = e.M.scanr_reduce w⟦(p + ↑(t + 1)).toNat..*⟧ →\n                (((CellularAutomatas.backwards_fsm.C' e).comp w (t + 1) p).2\n                      (e.M.scanr_reduce w⟦(p + ↑(t + 1)).toNat..*⟧) =\n                    let q_right :=\n                      e.M.δ? (e.M.scanr_reduce w⟦(p + ↑(t + 1)).toNat..*⟧)\n                        ((CellularAutomatas.backwards_fsm.C' e).comp w t p).1;\n                    let q_center := e.M.δ? q_right ((CellularAutomatas.backwards_fsm.C' e).comp w t (p - 1)).1;\n                    e.C.δ (((CellularAutomatas.backwards_fsm.C' e).comp w t (p - 1)).2 q_center)\n                      (((CellularAutomatas.backwards_fsm.C' e).comp w t p).2 q_right)\n                      (((CellularAutomatas.backwards_fsm.C' e).comp w t (p + 1)).2\n                        (e.M.scanr_reduce w⟦(p + ↑(t + 1)).toNat..*⟧))) →\n                  (let c' := (CellularAutomatas.backwards_fsm.C' e).comp w t (p + 1);\n                    let q := e.M.scanr_reduce w⟦(p + 1 + ↑t).toNat..*⟧;\n                    c'.2 q = e.C.comp (e.M.scanr w) t (p + 1) ∧ c'.1 = w.get'? (p + 1 + ↑t)) →\n                    ((CellularAutomatas.backwards_fsm.C' e).comp w t (p + 1)).2\n                            (e.M.scanr_reduce w⟦(p + ↑(t + 1)).toNat..*⟧) =\n                          e.C.comp (e.M.scanr w) t (p + 1) ∧\n                        ((CellularAutomatas.backwards_fsm.C' e).comp w t (p + 1)).1 = w.get'? (p + ↑t + 1) →\n                      ((CellularAutomatas.backwards_fsm.C' e).comp w t p).1 = w.get'? (p + ↑t) →\n                        e.M.δ? (e.M.scanr_reduce w⟦(p + ↑(t + 1)).toNat..*⟧)\n                              ((CellularAutomatas.backwards_fsm.C' e).comp w t p).1 =\n                            e.M.scanr_reduce w⟦(p + ↑t).toNat..*⟧ →\n                          ((CellularAutomatas.backwards_fsm.C' e).comp w t p).2\n                                (e.M.δ? (e.M.scanr_reduce w⟦(p + ↑(t + 1)).toNat..*⟧)\n                                  ((CellularAutomatas.backwards_fsm.C' e).comp w t p).1) =\n                              e.C.comp (e.M.scanr w) t p →\n                            (let c' := (CellularAutomatas.backwards_fsm.C' e).comp w t (p - 1);\n                              let q := e.M.scanr_reduce w⟦(p - 1 + ↑t).toNat..*⟧;\n                              c'.2 q = e.C.comp (e.M.scanr w) t (p - 1) ∧ c'.1 = w.get'? (p - 1 + ↑t)) →\n                              ((CellularAutomatas.backwards_fsm.C' e).comp w t (p - 1)).1 = w.get'? (p + ↑t - 1)",
  "constCategory": "Theorem"},
 {"references": ["HAdd.hAdd", "SizeOf.sizeOf", "OfNat.ofNat"],
  "name": "CellularAutomatas.backwards_fsm.Params.mk.sizeOf_spec",
  "constType":
  "∀ {α β γ : Type} [inst1 : CellularAutomatas.Alphabet α] [inst2 : CellularAutomatas.Alphabet β]\n  [inst3 : CellularAutomatas.Alphabet γ] (M : CellularAutomatas.FiniteStateTransducer α β)\n  (C : CellularAutomatas.CArtTransducer β γ),\n  sizeOf { α := α, β := β, γ := γ, inst1 := inst1, inst2 := inst2, inst3 := inst3, M := M, C := C } =\n    1 + sizeOf α + sizeOf β + sizeOf γ + sizeOf inst1 + sizeOf inst2 + sizeOf inst3 + sizeOf M + sizeOf C",
  "constCategory": "Theorem"},
 {"references": ["Units.val_inv"],
  "name": "Units.mul_inv",
  "constType": "∀ {α : Type u} [inst : Monoid α] (a : αˣ), ↑a * ↑a⁻¹ = 1",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans",
   "CellularAutomatas.FiniteStateTransducer.scanr_len",
   "List.length_mapIdx",
   "Eq.mp",
   "List.ext_get",
   "CellularAutomatas.FiniteStateTransducer.Q",
   "eq_true",
   "GetElem.getElem",
   "CellularAutomatas.FiniteStateTransducer.scanr_reduce",
   "congrArg",
   "List.get",
   "congr",
   "Eq.symm",
   "CellularAutomatas.Word",
   "List.drop",
   "CellularAutomatas.FiniteStateTransducer.M_projQ_scanr",
   "CellularAutomatas.FiniteStateTransducer.scanr",
   "LT.lt",
   "eq_self",
   "of_eq_true",
   "List.mapIdx",
   "CellularAutomatas.FiniteStateTransducer.M_projQ",
   "id",
   "List.getElem_mapIdx",
   "Eq.mpr",
   "Fin.isLt",
   "List.length"],
  "name": "CellularAutomatas.FiniteStateTransducer.M_projQ_scanr2",
  "constType":
  "∀ {α β : Type} {M : CellularAutomatas.FiniteStateTransducer α β} {w : CellularAutomatas.Word α},\n  M.M_projQ.scanr w = List.mapIdx (fun i x => M.scanr_reduce w⟦i..*⟧) w",
  "constCategory": "Theorem"},
 {"references": ["Lean.Omega.IntList.combo", "Lean.Omega.Coeffs"],
  "name": "Lean.Omega.Coeffs.combo",
  "constType": "ℤ → Omega.Coeffs → ℤ → Omega.Coeffs → Omega.Coeffs",
  "constCategory": "Definition"},
 {"references": ["CellularAutomatas.FiniteStateTransducer.mk.noConfusion"],
  "name": "CellularAutomatas.FiniteStateTransducer.mk.inj",
  "constType":
  "∀ {α β Q : Type} {alphabetQ : CellularAutomatas.Alphabet Q} {δ : Q → α → Q} {q0 : Q} {f : Q → β} {Q_1 : Type}\n  {alphabetQ_1 : CellularAutomatas.Alphabet Q_1} {δ_1 : Q_1 → α → Q_1} {q0_1 : Q_1} {f_1 : Q_1 → β},\n  { Q := Q, alphabetQ := alphabetQ, δ := δ, q0 := q0, f := f } =\n      { Q := Q_1, alphabetQ := alphabetQ_1, δ := δ_1, q0 := q0_1, f := f_1 } →\n    Q = Q_1 ∧ alphabetQ ≍ alphabetQ_1 ∧ δ ≍ δ_1 ∧ q0 ≍ q0_1 ∧ f ≍ f_1",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "CellularAutomatas.CellAutomaton.Q"],
  "name": "CellularAutomatas.CArtTransducer.recOn",
  "constType":
  "{α Γ : Type} →\n  [inst : CellularAutomatas.Alphabet α] →\n    [inst_1 : CellularAutomatas.Alphabet Γ] →\n      {motive : CellularAutomatas.CArtTransducer α Γ → Sort u} →\n        (t : CellularAutomatas.CArtTransducer α Γ) →\n          ((toLCellAutomaton : CellularAutomatas.LCellAutomaton α) →\n              (f : toLCellAutomaton.Q → Γ) → motive { toLCellAutomaton := toLCellAutomaton, f := f }) →\n            motive t",
  "constCategory": "Definition"},
 {"references":
  ["sorryAx",
   "CellularAutomatas.CellAutomaton.nextt",
   "CellularAutomatas.speedup_factor_k.compress",
   "HMul.hMul",
   "CellularAutomatas.CellAutomaton.Q",
   "CellularAutomatas.Config",
   "CellularAutomatas.speedup_factor_k.C'",
   "OfNat.ofNat"],
  "name": "CellularAutomatas.speedup_factor_k.spec",
  "constType":
  "∀ (k : ℕ) [inst : NeZero k] (C : CellularAutomatas.CellAutomaton) (c : CellularAutomatas.Config C.Q) (t : ℕ),\n  (CellularAutomatas.speedup_factor_k.C' k C).nextt (CellularAutomatas.speedup_factor_k.compress k c) t =\n    CellularAutomatas.speedup_factor_k.compress k (C.nextt c (k * t))",
  "constCategory": "Theorem"},
 {"references": ["LE.le.lt_of_ne", "zero_le_one", "NeZero.ne'", "OfNat.ofNat"],
  "name": "zero_lt_one",
  "constType":
  "∀ {α : Type u_1} [inst : Zero α] [inst_1 : One α] [inst_2 : PartialOrder α] [ZeroLEOneClass α] [NeZero 1], 0 < 1",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CellularAutomatas.TwoStageAdvice.mk",
  "constType":
  "{α Γ : Type} →\n  [inst : CellularAutomatas.Alphabet α] →\n    [inst_1 : CellularAutomatas.Alphabet Γ] →\n      (β : Type) →\n        [alphabetβ : CellularAutomatas.Alphabet β] →\n          CellularAutomatas.CArtTransducer α β →\n            CellularAutomatas.FiniteStateTransducer β Γ → CellularAutomatas.TwoStageAdvice α Γ",
  "constCategory": "Other"},
 {"references":
  ["Nat.cast_one",
   "eq_self",
   "Nat.cast",
   "Eq.trans",
   "of_eq_true",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Mathlib.Tactic.RingNF.nat_rawCast_1",
  "constType": "∀ {R : Type u_1} [inst : CommSemiring R], Nat.rawCast 1 = 1",
  "constCategory": "Theorem"},
 {"references":
  ["implies_congr",
   "Nat.cast",
   "Lean.Grind.Semiring.natCast_zero",
   "Eq.trans",
   "Eq.mp",
   "Lean.Grind.Ring.intCast_one",
   "Iff.mp",
   "Lean.Grind.Ring.intCast_natCast",
   "Int.cast",
   "congrArg",
   "Lean.Grind.Ring.intCast_add",
   "HSub.hSub",
   "Eq.symm",
   "_private.Init.Grind.Ordered.Ring.0.Lean.Grind.OrderedRing.le_of_intCast_le_intCast._proof_1_2",
   "Eq.ndrec",
   "Lean.Grind.OrderedAdd.neg_nonneg_iff",
   "Not",
   "Lean.Grind.Ring.intCast",
   "Neg.neg",
   "_private.Init.Grind.Ordered.Ring.0.Lean.Grind.OrderedRing.le_of_intCast_le_intCast._proof_1_1",
   "Lean.Grind.OrderedRing.le_of_natCast_le_natCast",
   "Lean.Grind.Ring.intCast_neg",
   "Lean.Grind.Semiring.natCast_add",
   "Int.casesOn",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "implies_true",
   "Decidable.byContradiction",
   "of_eq_true",
   "Int.natCast_nonneg._simp_1",
   "Lean.Grind.Ring.intCast_sub",
   "Iff.mpr",
   "LE.le",
   "id",
   "Eq.mpr",
   "Lean.Grind.Semiring.natCast",
   "Int.zero_le_neg_iff._simp_1",
   "Lean.Grind.OrderedAdd.sub_nonneg_iff",
   "Lean.Grind.Semiring.natCast_one"],
  "name": "Lean.Grind.OrderedRing.le_of_intCast_le_intCast",
  "constType":
  "∀ {R : Type u} [inst : Grind.Ring R] [inst_1 : LE R] [inst_2 : LT R] [LawfulOrderLT R] [inst_4 : Std.IsPreorder R]\n  [Grind.OrderedRing R] (a b : ℤ), ↑a ≤ ↑b → a ≤ b",
  "constCategory": "Theorem"},
 {"references":
  ["SetLike.coe",
   "Finset.mem_filter",
   "Membership.mem",
   "Set.ext",
   "DecidablePred",
   "setOf",
   "Finset.filter"],
  "name": "Finset.coe_filter",
  "constType":
  "∀ {α : Type u_1} (p : α → Prop) [inst : DecidablePred p] (s : Finset α), ↑(Finset.filter p s) = {x | x ∈ s ∧ p x}",
  "constCategory": "Theorem"},
 {"references": ["id", "Inhabited.default"],
  "name": "CellularAutomatas.FiniteStateTransducer.M_id",
  "constType":
  "(α : Type) → [CellularAutomatas.Alphabet α] → CellularAutomatas.FiniteStateTransducer α α",
  "constCategory": "Definition"},
 {"references":
  ["Not",
   "Nat.find",
   "Eq.trans",
   "Set",
   "Membership.mem",
   "eq_true",
   "OfNat.ofNat",
   "congrArg",
   "Option.some.injEq",
   "Classical.dec",
   "dite_cond_eq_true",
   "of_eq_true",
   "CellularAutomatas.min_nat",
   "Nat.find_eq_zero._simp_1",
   "id",
   "dite",
   "setOf"],
  "name": "CellularAutomatas.min_nat_of_set",
  "constType":
  "∀ {p : ℕ → Prop}, p 0 → CellularAutomatas.min_nat {t | p t} = some 0",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans",
   "Membership.mem",
   "CellularAutomatas.Advice.from_len_marker",
   "Classical.propDecidable",
   "CellularAutomatas.from_len_marker_eq_marker_list",
   "List.length_replicate",
   "CellularAutomatas.reachable_markers",
   "GT.gt",
   "GE.ge",
   "Inhabited.default",
   "funext",
   "HSub.hSub",
   "CellularAutomatas.distinct_prefixes_from_markers._proof_1_2",
   "Eq.ndrec",
   "Finset.filter",
   "HAppend.hAppend",
   "Finset.filter.congr_simp",
   "List.length_append",
   "Exists.casesOn",
   "CellularAutomatas.rel_repr",
   "Set.image",
   "Decidable.byContradiction",
   "SetLike.coe",
   "HasSubset.Subset",
   "Nat.le_of_lt_succ",
   "CellularAutomatas.marker_list_take",
   "gt_iff_lt._simp_1",
   "Finset.coe_image",
   "id",
   "Eq.mpr",
   "List.length",
   "setOf",
   "Finset.mem_range._simp_1",
   "Set.mem_image._simp_1",
   "Eq.mp",
   "CellularAutomatas.marker_list_inj",
   "congrArg",
   "congr",
   "CellularAutomatas.distinct_prefixes_from_markers._proof_1_1",
   "ge_iff_le._simp_1",
   "Not",
   "CellularAutomatas.Word",
   "Finset.range",
   "Set",
   "CellularAutomatas.marker_list",
   "Finset.card",
   "Finset.coe_filter",
   "OfNat.ofNat",
   "CellularAutomatas.Advice.f",
   "LT.lt",
   "HAdd.hAdd",
   "List.replicate",
   "SetLike.mem_coe._simp_1",
   "Set.InjOn",
   "List.take",
   "Finset.image",
   "LE.le",
   "Finset.mem_filter._simp_1",
   "Finset.card_image_of_injOn",
   "And.casesOn"],
  "name": "CellularAutomatas.distinct_prefixes_from_markers",
  "constType":
  "∀ {α : Type} [CellularAutomatas.Alphabet α] (f : ℕ → Option ℕ) (p : CellularAutomatas.Word α),\n  ∃ S,\n    ↑S ⊆ {l | ∃ s, l = CellularAutomatas.rel_repr (CellularAutomatas.Advice.from_len_marker f) p s} ∧\n      S.card = (CellularAutomatas.reachable_markers f (List.length p)).card",
  "constCategory": "Theorem"},
 {"references":
  ["Array.size",
   "Lean.NameSet.empty",
   "Lean.NameSet.insert",
   "CellularAutomatas.collectAxiomsFromEnv",
   "Array.foldl",
   "Std.TreeSet.toArray",
   "CellularAutomatas.getModuleConstants",
   "OfNat.ofNat",
   "Lean.NameSet",
   "Lean.Name.quickCmp"],
  "name": "CellularAutomatas.getModuleAxioms",
  "constType": "Environment → Name → NameSet",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Lean.Grind.Semiring.mul_one",
  "constType": "∀ {α : Type u} [self : Grind.Semiring α] (a : α), a * 1 = a",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.CArtTransducer.advice",
   "sorryAx",
   "OfNat.ofNat",
   "CellularAutomatas.Advice.rt_closed"],
  "name": "CellularAutomatas.CArtTransducer.rt_closed",
  "constType":
  "∀ {α β γ : Type} [CellularAutomatas.Alphabet α] [inst : CellularAutomatas.Alphabet β]\n  [inst_1 : CellularAutomatas.Alphabet γ] (t : CellularAutomatas.CArtTransducer β γ), t.advice.rt_closed",
  "constCategory": "Definition"},
 {"references":
  ["LT.lt",
   "HAdd.hAdd",
   "Lean.Grind.Nat.lt_eq",
   "Eq.substr",
   "List.take",
   "LE.le",
   "HSub.hSub",
   "OfNat.ofNat",
   "List.length"],
  "name": "CellularAutomatas.PrefixStableProof.getLastOfTake._proof_1_4",
  "constType":
  "∀ {i : ℕ} {α : Type u_1} {w : List α},\n  (List.take i w).length - 1 + 1 ≤ (List.take i w).length → (List.take i w).length - 1 < (List.take i w).length",
  "constCategory": "Theorem"},
 {"references": ["Nat.add.match_1", "Nat.below", "Nat.brecOn"],
  "name": "Nat.add",
  "constType": "ℕ → ℕ → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["CellularAutomatas.PrefixStableProof.ts_adv",
   "Eq.ndrec",
   "CellularAutomatas.Advice.rt_closed"],
  "name": "CellularAutomatas.PrefixStableProof.ts_adv.congr_simp",
  "constType":
  "∀ {α : Type} [inst : CellularAutomatas.Alphabet α] {Γ : Type} [inst_1 : CellularAutomatas.Alphabet Γ]\n  (adv adv_1 : CellularAutomatas.Advice α Γ) (e_adv : adv = adv_1) (h1 : adv.rt_closed),\n  CellularAutomatas.PrefixStableProof.ts_adv adv h1 = CellularAutomatas.PrefixStableProof.ts_adv adv_1 ⋯",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "CellularAutomatas.Word",
   "CellularAutomatas.LCellAutomaton.scan_temporal",
   "CellularAutomatas.CellAutomaton.Q"],
  "name": "CellularAutomatas.LCellAutomaton.scan_temporal.eq_1",
  "constType":
  "∀ {α : Type} (C : CellularAutomatas.LCellAutomaton α) (t : ℕ) (p : ℤ) (w : CellularAutomatas.Word α),\n  C.scan_temporal t p w = List.map (fun x => C.comp w x p) (List.range t)",
  "constCategory": "Theorem"},
 {"references":
  ["Not", "LT.lt", "Int.lt_iff_le_not_le", "LE.le", "And.right", "Iff.mp"],
  "name": "Int.not_le_of_gt",
  "constType": "∀ {a b : ℤ}, b < a → ¬a ≤ b",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CellularAutomatas.TwoStageAdvice.ctorIdx",
  "constType":
  "{α Γ : Type} →\n  {inst : CellularAutomatas.Alphabet α} →\n    {inst_1 : CellularAutomatas.Alphabet Γ} → CellularAutomatas.TwoStageAdvice α Γ → ℕ",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Task.get",
  "constType": "{α : Type u} → Task α → α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Lean.ModuleIdx",
  "constType": "Type",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CellularAutomatas.FiniteStateTransducer.f",
  "constType":
  "{α β : Type} → (self : CellularAutomatas.FiniteStateTransducer α β) → self.Q → β",
  "constCategory": "Definition"},
 {"references": ["HAdd.hAdd", "LE.le"],
  "name": "AddLeftMono",
  "constType": "(M : Type u_1) → [Add M] → [LE M] → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Grind.CommRing.Expr.toPoly_k", "Lean.Grind.CommRing.Poly.beq'"],
  "name": "Lean.Grind.CommRing.norm_cnstr_cert",
  "constType":
  "Grind.CommRing.Expr → Grind.CommRing.Expr → Grind.CommRing.Expr → Grind.CommRing.Expr → Bool",
  "constCategory": "Definition"},
 {"references": ["CellularAutomatas.backwards_fsm.Params.inst2"],
  "name": "CellularAutomatas.backwards_fsm.instAlphabetβ",
  "constType":
  "(e : CellularAutomatas.backwards_fsm.Params) → CellularAutomatas.Alphabet e.β",
  "constCategory": "Definition"},
 {"references":
  ["Int.Linear.Poly.beq'",
   "Int.Linear.Poly.mul_k",
   "Neg.neg",
   "Int.Linear.Poly.addConst_k",
   "OfNat.ofNat"],
  "name": "Int.Linear.le_neg_cert",
  "constType": "Int.Linear.Poly → Int.Linear.Poly → Bool",
  "constCategory": "Definition"},
 {"references":
  ["implies_congr",
   "Int.Linear.Poly.isUnsatEq.match_1",
   "imp_self._simp_1",
   "Eq.trans",
   "Int.Linear.Poly.denote'_eq_denote",
   "_private.Init.Data.Int.Linear.0.Int.Linear.Poly.isUnsatEq.match_1.eq_2",
   "Int.Linear.Poly.denote",
   "GT.gt",
   "Bool.false_eq_true",
   "Decidable.decide",
   "Int.not_le._simp_1",
   "congrArg",
   "Int.Linear.Poly.isUnsatLe",
   "Decidable.decide.congr_simp",
   "funext",
   "Eq.symm",
   "false_implies",
   "Int.Linear.Poly.denote'",
   "Eq.ndrec",
   "decide_eq_true_eq",
   "Not",
   "_private.Init.Data.Int.Linear.0.Int.Linear.Poly.isUnsatEq.match_1.splitter",
   "OfNat.ofNat",
   "LT.lt",
   "Int.Linear.Context",
   "of_eq_true",
   "LE.le",
   "gt_iff_lt._simp_1",
   "id",
   "Eq.mpr",
   "imp_false._simp_1"],
  "name": "Int.Linear.le_unsat",
  "constType":
  "∀ (ctx : Int.Linear.Context) (p : Int.Linear.Poly), p.isUnsatLe = true → Int.Linear.Poly.denote' ctx p ≤ 0 → False",
  "constCategory": "Theorem"},
 {"references":
  ["rfl",
   "Singleton.singleton",
   "Iff.mpr",
   "Multiset.toList_eq_singleton_iff",
   "Multiset",
   "Multiset.toList"],
  "name": "Multiset.toList_singleton",
  "constType": "∀ {α : Type u_1} (a : α), {a}.toList = [a]",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.lt_of_lt_of_le",
   "List.drop",
   "Neg.neg",
   "CellularAutomatas.PrefixStableProof.getLastOfTake._proof_1_11",
   "HMul.hMul",
   "List.length_take_le'",
   "OfNat.ofNat",
   "Lean.Grind.nestedProof",
   "HAdd.hAdd",
   "LT.lt",
   "NatCast.natCast",
   "List.take",
   "LE.le",
   "HSub.hSub",
   "List.length"],
  "name": "CellularAutomatas.PrefixStableProof.getLastOfTake._proof_1_22",
  "constType":
  "∀ {i : ℕ} {α : Type u_1} {w : List α},\n  i + 1 ≤ w.length →\n    -1 * ↑(List.take 1 w⟦i..*⟧).length + 1 ≤ 0 →\n      (List.take (List.take 1 w⟦i..*⟧).length w⟦(List.take i w).length..*⟧).length - 1 <\n        w⟦(List.take i w).length..*⟧.length",
  "constCategory": "Theorem"},
 {"references":
  ["And.right",
   "CellularAutomatas.is_two_stage_of_rt_closed_and_prefix_stable",
   "CellularAutomatas.Advice.prefix_stable",
   "And.left",
   "CellularAutomatas.Advice.rt_closed"],
  "name":
  "CellularAutomatas.results.result_is_two_stage_of_rt_closed_and_prefix_stable",
  "constType":
  "∀ {α : Type} [inst : CellularAutomatas.Alphabet α] {Γ : Type} [inst_1 : CellularAutomatas.Alphabet Γ]\n  (adv : CellularAutomatas.Advice α Γ), adv.rt_closed ∧ CellularAutomatas.Advice.prefix_stable → adv.is_two_stage_advice",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans",
   "le_of_le_of_eq",
   "Lean.Omega.LinearCombo.coordinate_eval_0",
   "Lean.Omega.Constraint.combine_sat'",
   "Decidable.decide",
   "Lean.Omega.Coeffs.ofList",
   "Lean.Omega.tidy_sat",
   "HSub.hSub",
   "Eq.symm",
   "Lean.Omega.LinearCombo.add_eval",
   "Lean.Omega.Int.lt_of_not_le",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "Int.add_one_le_of_lt",
   "of_decide_eq_true",
   "Not",
   "Neg.neg",
   "Lean.Omega.Constraint.addInequality_sat",
   "Lean.Omega.Int.add_congr",
   "Lean.Omega.Constraint.isImpossible",
   "Lean.Omega.LinearCombo.coordinate",
   "OfNat.ofNat",
   "Int.sub_nonneg_of_le",
   "Lean.Omega.LinearCombo.coordinate_eval_1",
   "HAdd.hAdd",
   "Lean.Omega.LinearCombo.sub_eval",
   "LE.le",
   "id",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.Int.sub_congr"],
  "name":
  "_private.Init.Grind.Order.0.Lean.Grind.Order.lt_eq_true_of_lt_k._proof_1_1",
  "constType": "∀ {k₁ k₂ : ℤ}, k₁ ≤ k₂ → ¬0 ≤ k₂ - k₁ → False",
  "constCategory": "Theorem"},
 {"references": ["Or.casesOn", "Ne"],
  "name": "_private.Init.Classical.0.Classical.em.match_1_3",
  "constType":
  "∀ (p u v : Prop) (motive : u ≠ v ∨ p → Prop) (not_uv_or_p : u ≠ v ∨ p),\n  (∀ (hne : u ≠ v), motive ⋯) → (∀ (h : p), motive ⋯) → motive not_uv_or_p",
  "constCategory": "Definition"},
 {"references":
  ["CellularAutomatas.Word",
   "CellularAutomatas.FiniteStateTransducer.scanr_q_len",
   "Nat.cast",
   "Eq.trans",
   "Set",
   "CellularAutomatas.FiniteStateTransducer.scanr_q",
   "CellularAutomatas.FiniteStateTransducer.Q",
   "GE.ge",
   "OfNat.ofNat",
   "congrArg",
   "LT.lt",
   "eq_self",
   "of_eq_true",
   "congr",
   "funext",
   "LE.le",
   "ge_iff_le._simp_1",
   "setOf",
   "List.length"],
  "name": "CellularAutomatas.FiniteStateTransducer.range_of_scanr_q",
  "constType":
  "∀ {α β : Type} {M : CellularAutomatas.FiniteStateTransducer α β} {q0 : M.Q} {w : CellularAutomatas.Word α},\n  (M.scanr_q q0 w).range = w.range",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Lean.MacroScope",
  "constType": "Type",
  "constCategory": "Definition"},
 {"references":
  ["HAdd.hAdd",
   "List.take",
   "Eq.symm",
   "Eq.ndrec",
   "OfNat.ofNat",
   "Nat.casesAuxOn"],
  "name": "List.take_nil",
  "constType": "∀ {α : Type u} {i : ℕ}, List.take i [] = []",
  "constCategory": "Theorem"},
 {"references":
  ["eq_of_heq", "Eq.symm", "Eq.ndrec", "Eq.casesOn", "Unit.unit", "Unit"],
  "name": "_private.Init.Data.Nat.Lemmas.0.Nat.add_left_cancel_iff.match_1_1",
  "constType":
  "∀ {m : ℕ} (motive : (k : ℕ) → m = k → Prop) (k : ℕ) (x : m = k), (∀ (a : Unit), motive m ⋯) → motive k x",
  "constCategory": "Definition"},
 {"references":
  ["CellularAutomatas.CellAutomaton.δ",
   "Set",
   "Membership.mem",
   "CellularAutomatas.CellAutomaton.Q",
   "Subtype.val",
   "Set.Elem"],
  "name": "CellularAutomatas.CellAutomaton.delta_closed_set",
  "constType": "(C : CellularAutomatas.CellAutomaton) → Set C.Q → Prop",
  "constCategory": "Definition"},
 {"references":
  ["HAdd.hAdd",
   "Eq.symm",
   "eq_zero_of_add_right",
   "eq_zero_of_add_left",
   "add_zero",
   "Eq.ndrec",
   "OfNat.ofNat",
   "And.casesOn"],
  "name": "add_eq_zero",
  "constType":
  "∀ {α : Type u} [inst : AddCommMonoid α] [Subsingleton (AddUnits α)] {a b : α}, a + b = 0 ↔ a = 0 ∧ b = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Grind.CommRing.Expr.casesOn",
   "Lean.Grind.CommRing.Poly.mulConst_k_eq_mulConst",
   "Nat.cast",
   "Eq.trans",
   "Eq.mp",
   "Nat.beq_eq",
   "Lean.Grind.CommRing.Poly.mul",
   "Lean.Grind.CommRing.Poly.ofMon",
   "_private.Init.Grind.Ring.CommSolver.0.Lean.Grind.CommRing.Expr.toPoly_k_eq_toPoly.match_1_16",
   "congrArg",
   "Lean.Grind.CommRing.Poly.ofVar",
   "Nat.beq",
   "Eq.symm",
   "Bool.cond_eq_ite",
   "Eq.ndrec",
   "Nat.beq_eq_true_eq",
   "Not",
   "Lean.Grind.CommRing.Poly.pow",
   "Lean.Grind.CommRing.Poly.combine",
   "ite",
   "Neg.neg",
   "Lean.Grind.CommRing.Expr.toPoly_k",
   "Lean.Grind.CommRing.Expr.toPoly.match_1",
   "Decidable.casesOn",
   "HPow.hPow",
   "cond",
   "OfNat.ofNat",
   "Lean.Grind.CommRing.Poly.mulConst_k",
   "Lean.Grind.CommRing.Poly.combine_k",
   "eq_self",
   "Bool.not_eq_true",
   "if_neg",
   "of_eq_true",
   "id",
   "Eq.mpr",
   "Lean.Grind.CommRing.Poly.combine_k_eq_combine",
   "BEq.beq",
   "Lean.Grind.CommRing.Var",
   "if_pos",
   "Lean.Grind.CommRing.Expr.toPoly",
   "Lean.Grind.CommRing.Poly.mulConst"],
  "name": "Lean.Grind.CommRing.Expr.toPoly_k_eq_toPoly",
  "constType": "∀ (e : Grind.CommRing.Expr), e.toPoly_k = e.toPoly",
  "constCategory": "Theorem"},
 {"references": ["LT.lt", "Not", "Int.not_lt", "LE.le", "propext"],
  "name": "Int.not_lt._simp_1",
  "constType": "∀ {a b : ℤ}, (¬a < b) = (b ≤ a)",
  "constCategory": "Theorem"},
 {"references": ["CellularAutomatas.simulation.instInhabitedQ1.default"],
  "name": "CellularAutomatas.simulation.instInhabitedQ1",
  "constType":
  "{a : CellularAutomatas.simulation.Params} → Inhabited (CellularAutomatas.simulation.Q1 a)",
  "constCategory": "Definition"},
 {"references":
  ["CellularAutomatas.Word",
   "Set",
   "Membership.mem",
   "CellularAutomatas.Word.get_cone_0",
   "CellularAutomatas.Word.cone",
   "OfNat.ofNat"],
  "name": "CellularAutomatas.Word.get_cone_0.eq_1",
  "constType":
  "∀ {α : Type u_1} {w : CellularAutomatas.Word α} {i : ℤ} (h : i ∈ w.cone 0),\n  CellularAutomatas.Word.get_cone_0 h = w.get' i ⋯",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.TwoStageAdvice.casesOn",
   "CellularAutomatas.TwoStageAdvice.noConfusionType",
   "Eq.ndrec"],
  "name": "CellularAutomatas.TwoStageAdvice.noConfusion",
  "constType":
  "{α Γ : Type} →\n  [inst : CellularAutomatas.Alphabet α] →\n    [inst_1 : CellularAutomatas.Alphabet Γ] →\n      {P : Sort u} →\n        {x1 x2 : CellularAutomatas.TwoStageAdvice α Γ} →\n          x1 = x2 → CellularAutomatas.TwoStageAdvice.noConfusionType P x1 x2",
  "constCategory": "Definition"},
 {"references": ["Nat.cast", "Int.ofNat.inj", "congrArg"],
  "name": "Int.ofNat_inj",
  "constType": "∀ {m n : ℕ}, ↑m = ↑n ↔ m = n",
  "constCategory": "Theorem"},
 {"references":
  ["LE.le", "_private.Init.Prelude.0.Nat.le_trans.match_1_6", "Nat.le.brecOn"],
  "name": "Nat.le_trans",
  "constType": "∀ {n m k : ℕ}, n ≤ m → m ≤ k → n ≤ k",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.cast",
   "Lean.Omega.Constraint.trivial",
   "ite",
   "Lean.Omega.Constraint.sat",
   "Lean.Omega.Coeffs",
   "Lean.Omega.Constraint.impossible",
   "Lean.Omega.normalize?.match_1",
   "Lean.Omega.Coeffs.sdiv",
   "OfNat.ofNat",
   "Lean.Omega.Constraint.div",
   "Lean.Omega.Coeffs.gcd"],
  "name": "Lean.Omega.normalize?",
  "constType":
  "Omega.Constraint ⨉ Omega.Coeffs → Option (Omega.Constraint ⨉ Omega.Coeffs)",
  "constCategory": "Definition"},
 {"references": ["Min.min", "LE.le", "inf_eq_left", "propext"],
  "name": "inf_eq_left._simp_1",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeInf α] {a b : α}, (a ⊓ b = a) = (a ≤ b)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CellularAutomatas.composition.Params",
  "constType": "Type 1",
  "constCategory": "Other"},
 {"references":
  ["implies_congr",
   "Eq.trans",
   "List.getElem_range",
   "Lean.Grind.Order.of_nat_eq",
   "eagerReduce",
   "eq_true",
   "ite_cond_eq_true",
   "IntCast.intCast",
   "Nat.ToInt.natCast_ofNat",
   "Lean.Grind.Order.int_lt",
   "Inhabited.default",
   "CellularAutomatas.ProdCA.zipMany_get?._proof_1_2",
   "GetElem?.getElem?",
   "NatCast.natCast",
   "Lean.Grind.forall_imp_eq_or",
   "funext",
   "Eq.symm",
   "forall_prop_domain_congr",
   "Lean.Grind.forall_propagator",
   "of_eq_false",
   "Neg.neg",
   "getElem?_pos",
   "Option.map_some",
   "Option.getD",
   "ite_cond_eq_false",
   "Lean.Grind.nestedProof",
   "Exists.casesOn",
   "eq_false",
   "Classical.byContradiction",
   "Option.map_none",
   "id",
   "Lean.Grind.Order.le_trans_k",
   "Lean.Grind.Order.eq_trans_false'",
   "Lean.Grind.Order.eq_trans_true",
   "getElem?_neg",
   "List.length",
   "Eq.substr",
   "Eq.mp",
   "GetElem.getElem",
   "Nat.Linear.ExprCnstr.eq_of_toNormPoly_eq",
   "Lean.Grind.Order.le_of_eq_1_k",
   "congrArg",
   "Lean.Grind.imp_eq_of_eq_true_left",
   "Lean.Grind.Nat.lt_eq",
   "Nat.not_le_eq",
   "or_false",
   "Lean.Grind.nestedDecidable",
   "List.length_range",
   "Option.map",
   "Lean.Grind.Order.lt_of_not_le_k",
   "Not",
   "CellularAutomatas.Word",
   "Lean.Grind.em",
   "Lean.Grind.alreadyNorm",
   "ite",
   "CellularAutomatas.ProdCA.zipMany_get?._proof_1_3",
   "Nat.ToInt.add_congr",
   "Lean.Grind.Order.le_eq_true_of_le_k",
   "Lean.Grind.Order.eq_mp_not",
   "OfNat.ofNat",
   "ite_congr",
   "Or.casesOn",
   "HAdd.hAdd",
   "LT.lt",
   "List.range",
   "Nat.ToInt.le_eq",
   "of_eq_true",
   "LE.le",
   "Lean.Grind.intro_with_eq",
   "Lean.Grind.CommRing.le_norm_expr"],
  "name": "CellularAutomatas.ProdCA.zipMany_get?._proof_1_4",
  "constType":
  "∀ {β : Type} [inst : CellularAutomatas.Alphabet β] {γ : β → Type u_1} [inst_1 : (b : β) → Inhabited (γ b)]\n  (f : (b : β) → CellularAutomatas.Word (γ b)) (i : ℕ),\n  Option.map (fun i b => (f b)[i]?.getD default) (List.range (List.length (f default)))[i]? =\n    if i < List.length (f default) then some fun b => (f b)[i]?.getD default else none",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CellularAutomatas.TwoStageAdvice.rec",
  "constType":
  "{α Γ : Type} →\n  [inst : CellularAutomatas.Alphabet α] →\n    [inst_1 : CellularAutomatas.Alphabet Γ] →\n      {motive : CellularAutomatas.TwoStageAdvice α Γ → Sort u} →\n        ((β : Type) →\n            [alphabetβ : CellularAutomatas.Alphabet β] →\n              (C : CellularAutomatas.CArtTransducer α β) →\n                (M : CellularAutomatas.FiniteStateTransducer β Γ) →\n                  motive { β := β, alphabetβ := alphabetβ, C := C, M := M }) →\n          (t : CellularAutomatas.TwoStageAdvice α Γ) → motive t",
  "constCategory": "Other"},
 {"references":
  ["Eq.trans",
   "noConfusion_of_Nat",
   "decide_true",
   "eq_false'",
   "Decidable.decide",
   "congrArg",
   "decide_false",
   "eq_self",
   "Bool.casesOn",
   "Decidable.decide.congr_simp",
   "False.elim",
   "of_eq_true",
   "Eq.symm",
   "Eq.ndrec",
   "Bool.ctorIdx"],
  "name": "Bool.decide_eq_true",
  "constType":
  "∀ {b : Bool} [inst : Decidable (b = true)], decide (b = true) = b",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Lean.Grind.AC.Context.op",
  "constType": "{α : Sort u} → Grind.AC.Context α → α → α → α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Lean.Name.mkStr",
  "constType": "Name → String → Name",
  "constCategory": "Definition"},
 {"references":
  ["Eq.trans",
   "Eq.mp",
   "List.length_drop",
   "List.length_take",
   "_private.Init.Data.List.Nat.TakeDrop.0.List.take_add._proof_1_1",
   "congrArg",
   "List.take_append",
   "List.take_eq_take_iff._simp_1",
   "congr",
   "HSub.hSub",
   "propext",
   "HAppend.hAppend",
   "Not",
   "Nat.le_trans",
   "List.drop",
   "List.take_append_drop",
   "List.length_take_le",
   "List.append_right_inj",
   "HAdd.hAdd",
   "Decidable.byContradiction",
   "Min.min",
   "List.take",
   "id",
   "List.take_of_length_le",
   "Eq.mpr",
   "Nat.le_add_right",
   "List.length"],
  "name": "List.take_add",
  "constType":
  "∀ {α : Type u_1} {l : List α} {i j : ℕ}, List.take (i + j) l = List.take i l ++ List.take j l⟦i..*⟧",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Lean.Grind.CommRing.Power.x",
  "constType": "Grind.CommRing.Power → Grind.CommRing.Var",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Bool.or'",
  "constType": "Bool → Bool → Bool",
  "constCategory": "Definition"},
 {"references":
  ["Nat.Linear.Context",
   "Nat.Linear.fixedVar",
   "Nat.beq",
   "Lean.RArray.get",
   "OfNat.ofNat",
   "Nat.Linear.Var"],
  "name": "Nat.Linear.Var.denote",
  "constType": "Nat.Linear.Context → Nat.Linear.Var → ℕ",
  "constCategory": "Definition"},
 {"references": ["List.concat", "Array.toList"],
  "name": "Array.push",
  "constType": "{α : Type u} → Array α → α → Array α",
  "constCategory": "Definition"},
 {"references": ["Finset.val", "Multiset.mem_filter", "DecidablePred"],
  "name": "Finset.mem_filter",
  "constType":
  "∀ {α : Type u_1} {p : α → Prop} [inst : DecidablePred p] {s : Finset α} {a : α}, a ∈ Finset.filter p s ↔ a ∈ s ∧ p a",
  "constCategory": "Theorem"},
 {"references": ["Int.casesOn"],
  "name":
  "_private.Init.Grind.Ring.Basic.0.Lean.Grind.Ring.intCast_add.match_1_1",
  "constType":
  "∀ (motive : ℤ → ℤ → Prop) (x y : ℤ),\n  (∀ (x y : ℕ), motive (Int.ofNat x) (Int.ofNat y)) →\n    (∀ (x y : ℕ), motive (Int.ofNat x) (Int.negSucc y)) →\n      (∀ (x y : ℕ), motive (Int.negSucc x) (Int.ofNat y)) →\n        (∀ (x y : ℕ), motive (Int.negSucc x) (Int.negSucc y)) → motive x y",
  "constCategory": "Definition"},
 {"references": [],
  "name": "_private.Lean.Environment.0.Lean.VisibilityMap.private",
  "constType": "{α : Type} → Lean.VisibilityMap✝ α → α",
  "constCategory": "Definition"},
 {"references": ["Option.noConfusion", "id"],
  "name": "Option.some.noConfusion",
  "constType":
  "{α : Type u} → (P : Sort u_1) → (val val' : α) → some val = some val' → (val = val' → P) → P",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Lean.Grind.CommRing.Context",
  "constType": "Type u → Type u",
  "constCategory": "Definition"},
 {"references":
  ["Eq.trans",
   "Eq.mp",
   "Int.Linear.Poly.denote'_eq_denote",
   "Int.Linear.Poly.denote",
   "Int.sub_nonpos_of_le",
   "eq_iff_iff._simp_1",
   "Int.Linear.Expr.denote_norm",
   "OfNat.ofNat",
   "congrArg",
   "Int.Linear.norm_eq_cert",
   "Int.Linear.Expr.norm",
   "Int.Linear.Context",
   "Int.Linear.Expr.denote",
   "LE.le",
   "Int.Linear.Poly.beq'_eq",
   "Eq.symm",
   "HSub.hSub",
   "id",
   "Int.Linear.Poly.denote'",
   "Eq.mpr",
   "Int.le_of_sub_nonpos",
   "Eq.ndrec"],
  "name": "Int.Linear.norm_le",
  "constType":
  "∀ (ctx : Int.Linear.Context) (lhs rhs : Int.Linear.Expr) (p : Int.Linear.Poly),\n  Int.Linear.norm_eq_cert lhs rhs p = true →\n    (Int.Linear.Expr.denote ctx lhs ≤ Int.Linear.Expr.denote ctx rhs) = (Int.Linear.Poly.denote' ctx p ≤ 0)",
  "constCategory": "Theorem"},
 {"references":
  ["HAppend.hAppend", "And.right", "List.append_inj", "List.length"],
  "name": "List.append_inj_right",
  "constType":
  "∀ {α : Type u_1} {s₁ t₁ s₂ t₂ : List α}, s₁ ++ t₁ = s₂ ++ t₂ → s₁.length = s₂.length → t₁ = t₂",
  "constCategory": "Theorem"},
 {"references": ["le_of_le_of_eq"],
  "name": "LE.le.trans_eq",
  "constType":
  "∀ {α : Type u_1} {a b c : α} [inst : LE α], a ≤ b → b = c → a ≤ c",
  "constCategory": "Theorem"},
 {"references":
  ["Set",
   "CellularAutomatas.L_c",
   "Membership.mem",
   "CellularAutomatas.CA_rt",
   "CellularAutomatas.L_c_in_rt",
   "CellularAutomatas.tCellAutomaton.L",
   "Language",
   "Classical.choose",
   "CellularAutomatas.Advice.rt_closed"],
  "name": "CellularAutomatas.CALc",
  "constType":
  "{α : Type} →\n  [inst : CellularAutomatas.Alphabet α] →\n    {Γ : Type} →\n      [inst_1 : CellularAutomatas.Alphabet Γ] →\n        (adv : CellularAutomatas.Advice α Γ) → adv.rt_closed → Γ → CellularAutomatas.tCellAutomaton α",
  "constCategory": "Definition"},
 {"references":
  ["CellularAutomatas.Word",
   "sorryAx",
   "CellularAutomatas.Advice.shift_left_advice",
   "CellularAutomatas.Advice.is_two_stage_advice",
   "OfNat.ofNat"],
  "name": "CellularAutomatas.results_unproven.advice_shift_left_rt",
  "constType":
  "∀ {α : Type} [inst : CellularAutomatas.Alphabet α] {Γ : Type} [inst_1 : CellularAutomatas.Alphabet Γ]\n  (extension : CellularAutomatas.Word α) (adv : CellularAutomatas.Advice α Γ),\n  adv.is_two_stage_advice → (CellularAutomatas.Advice.shift_left_advice extension).is_two_stage_advice",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CellularAutomatas.tCellAutomaton.t",
  "constType": "{α : Type} → CellularAutomatas.tCellAutomaton α → ℕ → ℕ",
  "constCategory": "Definition"},
 {"references": ["CellularAutomatas.CellAutomaton.Q"],
  "name": "CellularAutomatas.simulation.Params.casesOn",
  "constType":
  "{motive : CellularAutomatas.simulation.Params → Sort u} →\n  (t : CellularAutomatas.simulation.Params) →\n    ((C_inr C_ctl : CellularAutomatas.CellAutomaton) →\n        (f : C_ctl.Q → Option C_inr.Q) → motive { C_inr := C_inr, C_ctl := C_ctl, f := f }) →\n      motive t",
  "constCategory": "Definition"},
 {"references":
  ["implies_congr",
   "Int.Linear.le_unsat",
   "Eq.trans",
   "eq_true",
   "eagerReduce",
   "ite_cond_eq_true",
   "heq_of_eq",
   "IntCast.intCast",
   "Nat.ToInt.natCast_ofNat",
   "Fin.mk.congr_simp",
   "Lean.Grind.Order.int_lt",
   "GetElem?.getElem?",
   "NatCast.natCast",
   "Eq.symm",
   "Eq.ndrec",
   "Lean.Grind.forall_propagator",
   "getElem?_pos",
   "Int.Linear.eq_diseq_subst",
   "CellularAutomatas.LcInRt.DiagonalShiftCA_comp_p0._proof_1_2",
   "eq_false",
   "Classical.byContradiction",
   "Int.Linear.not_eq_norm_expr",
   "Lean.Grind.Order.eq_trans_false'",
   "Lean.Grind.Order.eq_trans_true",
   "Int.Linear.eq_of_le_ge",
   "setOf",
   "Int.Linear.norm_le",
   "Lean.Grind.and_eq_of_eq_true_right",
   "GetElem.getElem",
   "Nat.Linear.ExprCnstr.eq_of_toNormPoly_eq",
   "CellularAutomatas.LcInRt.DiagonalShiftCA_comp_p0._proof_1_3",
   "Lean.Grind.Nat.lt_eq",
   "Lean.Grind.nestedDecidable",
   "List.get",
   "congr",
   "Nat.ToInt.of_diseq",
   "Lean.Grind.Order.lt_of_not_le_k",
   "Int.Linear.eq_of_core",
   "Set",
   "ite",
   "Lean.Grind.Order.le_eq_true_of_le_k",
   "List.get_eq_getElem",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "Lean.Grind.eq_congr'",
   "dite",
   "Lean.Grind.CommRing.le_norm_expr",
   "Fin.isLt",
   "Membership.mem",
   "HMul.hMul",
   "Nat.ToInt.ofNat_toNat",
   "Fin.val",
   "funext",
   "eq_of_heq",
   "Lean.Grind.eq_false_of_imp_eq_true",
   "forall_prop_domain_congr",
   "of_eq_false",
   "Neg.neg",
   "GetElem.getElem.hcongr_8",
   "Int.Linear.diseq_unsat",
   "Lean.Grind.eq_true_of_and_eq_true_right",
   "Lean.Grind.Int.lt_eq",
   "Lean.Grind.nestedProof",
   "ite_cond_eq_false",
   "id",
   "getElem?_neg",
   "List.length",
   "CellularAutomatas.Word.get'._proof_1",
   "Int.toNat",
   "Eq.substr",
   "Eq.mp",
   "Lean.Grind.nestedProof_congr",
   "Int.Linear.Expr.eq_of_norm_eq",
   "Lean.Grind.dite_cond_eq_false'",
   "Int.Linear.le_neg",
   "dite_congr",
   "congrArg",
   "Nat.not_le_eq",
   "Lean.Grind.dite_cond_eq_true'",
   "Not",
   "CellularAutomatas.Word",
   "Lean.Grind.em",
   "Set.mem_setOf_eq",
   "Lean.Grind.alreadyNorm",
   "CellularAutomatas.LcInRt.DiagonalShiftCA_comp_p0._proof_1_5",
   "Nat.ToInt.add_congr",
   "Lean.Grind.Order.eq_mp_not",
   "Eq.mpr_prop",
   "Or.casesOn",
   "LT.lt",
   "Nat.ToInt.le_eq",
   "of_eq_true",
   "Nat.ToInt.toNat_nonneg",
   "LE.le",
   "CellularAutomatas.LcInRt.DiagonalShiftCA_comp_p0._proof_1_4",
   "Lean.Grind.intro_with_eq",
   "Int.Linear.le_combine",
   "Lean.Grind.Order.eq_mp"],
  "name": "CellularAutomatas.LcInRt.DiagonalShiftCA_comp_p0._proof_1_7",
  "constType":
  "∀ {α : Type} {t : ℕ} (w : CellularAutomatas.Word α),\n  (if h : 0 + ↑t ∈ {i | i ≥ 0 ∧ i < ↑(List.length w)} then some (List.get w ⟨(0 + ↑t).toNat, ⋯⟩) else none) = w[t]?",
  "constCategory": "Theorem"},
 {"references":
  ["HAppend.hAppend",
   "List.take",
   "List.take_left",
   "Eq.symm",
   "id",
   "Eq.mpr",
   "congrArg",
   "List.length"],
  "name": "List.take_left'",
  "constType":
  "∀ {α : Type u_1} {l₁ l₂ : List α} {i : ℕ}, l₁.length = i → List.take i (l₁ ++ l₂) = l₁",
  "constCategory": "Theorem"},
 {"references": ["String.toRawSubstring"],
  "name": "String.toRawSubstring'",
  "constType": "String → Substring.Raw",
  "constCategory": "Definition"},
 {"references":
  ["List.range",
   "HAdd.hAdd",
   "eq_self",
   "List.length_range",
   "Eq.trans",
   "of_eq_true",
   "List.map",
   "List.length_map",
   "BEq.beq",
   "OfNat.ofNat",
   "congrArg",
   "List.length"],
  "name": "CellularAutomatas.marker_list_len",
  "constType":
  "∀ (n pos : ℕ), (CellularAutomatas.marker_list n pos).length = n",
  "constCategory": "Theorem"},
 {"references": ["Equiv.refl", "OrderDual"],
  "name": "OrderDual.ofDual",
  "constType": "{α : Type u_1} → αᵒᵈ ≃ α",
  "constCategory": "Definition"},
 {"references":
  ["LT.lt",
   "False.elim",
   "_private.Init.Data.Nat.Basic.0.Nat.lt_or_gt_of_ne.match_1_1",
   "Nat.lt_trichotomy",
   "Ne",
   "GT.gt"],
  "name": "Nat.lt_or_gt_of_ne",
  "constType": "∀ {a b : ℕ}, a ≠ b → a < b ∨ a > b",
  "constCategory": "Theorem"},
 {"references": ["_private.Init.SimpLemmas.0.or_false.match_1_1", "propext"],
  "name": "or_false",
  "constType": "∀ (p : Prop), (p ∨ False) = p",
  "constCategory": "Theorem"},
 {"references":
  ["_private.Init.Data.List.Nat.Range.0.List.mem_range'_1.match_1_2",
   "List.range'",
   "Nat.add_sub_cancel'",
   "_private.Init.Data.List.Nat.Range.0.List.mem_range'_1.match_1_4",
   "Eq.trans",
   "Membership.mem",
   "HMul.hMul",
   "OfNat.ofNat",
   "congrArg",
   "LT.lt",
   "HAdd.hAdd",
   "Nat.one_mul",
   "LE.le",
   "funext",
   "HSub.hSub",
   "Eq.symm",
   "id",
   "Nat.sub_lt_left_of_lt_add",
   "Eq.mpr",
   "_private.Init.Data.List.Nat.Range.0.List.mem_range'_1._simp_1_1",
   "Nat.le_add_right",
   "Nat.add_lt_add_left"],
  "name": "List.mem_range'_1",
  "constType": "∀ {s n m : ℕ}, m ∈ List.range' s n ↔ s ≤ m ∧ m < s + n",
  "constCategory": "Theorem"},
 {"references": ["Exists.casesOn", "HAdd.hAdd"],
  "name": "_private.Init.Data.Int.Order.0.Int.ofNat_le.match_1_3",
  "constType":
  "∀ {m n : ℕ} (motive : (∃ k, m + k = n) → Prop) (x : ∃ k, m + k = n), (∀ (k : ℕ) (hk : m + k = n), motive ⋯) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Grind.CommRing.Expr.toPoly_k",
   "Lean.Grind.CommRing.Poly.beq'",
   "Bool.and'",
   "OfNat.ofNat"],
  "name": "Lean.Grind.CommRing.Stepwise.imp_1eq_cert",
  "constType":
  "Grind.CommRing.Expr → Grind.CommRing.Expr → Grind.CommRing.Poly → Grind.CommRing.Poly → Bool",
  "constCategory": "Definition"},
 {"references":
  ["_private.Init.Data.List.Nat.TakeDrop.0.List.lt_length_right_of_zipWith._proof_1_1",
   "Not",
   "LT.lt",
   "Decidable.byContradiction",
   "List.length_zipWith",
   "Min.min",
   "Eq.mp",
   "List.zipWith",
   "congrArg",
   "List.length"],
  "name": "List.lt_length_right_of_zipWith",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} {f : α → β → γ} {i : ℕ} {l : List α} {l' : List β},\n  i < (List.zipWith f l l').length → i < l'.length",
  "constCategory": "Theorem"},
 {"references": ["Nat.Linear.Expr.toPoly.go", "Nat.Linear.Var", "OfNat.ofNat"],
  "name": "Nat.Linear.Expr.toPoly",
  "constType": "Nat.Linear.Expr → Nat.Linear.Poly",
  "constCategory": "Definition"},
 {"references":
  ["CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "CellularAutomatas.CArtTransducer.toLCellAutomaton",
   "CellularAutomatas.composition.Params.casesOn",
   "CellularAutomatas.CellAutomaton.Q"],
  "name": "CellularAutomatas.composition.Params.noConfusionType",
  "constType":
  "Sort u → CellularAutomatas.composition.Params → CellularAutomatas.composition.Params → Sort u",
  "constCategory": "Definition"},
 {"references":
  ["Not",
   "List.getElem?_take_of_lt",
   "ite",
   "Decidable.casesOn",
   "congrArg",
   "LT.lt",
   "GetElem?.getElem?",
   "Nat.le_of_not_lt",
   "if_neg",
   "List.take",
   "id",
   "List.getElem?_take_eq_none",
   "Eq.mpr",
   "if_pos",
   "List.length"],
  "name": "List.getElem?_take",
  "constType":
  "∀ {α : Type u_1} {l : List α} {i j : ℕ}, (List.take i l)[j]? = if j < i then l[j]? else none",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.Word.get'",
   "CellularAutomatas.CellAutomaton.next",
   "Membership.mem",
   "CellularAutomatas.ProdCA",
   "CellularAutomatas.Config",
   "CellularAutomatas.LCellAutomaton.embed",
   "congrArg",
   "CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "dif_pos",
   "congr",
   "CellularAutomatas.LCellAutomaton.embed_word",
   "Function.iterate_succ",
   "funext",
   "HSub.hSub",
   "CellularAutomatas.Word.range",
   "CellularAutomatas.CellAutomaton.Q",
   "dif_neg",
   "CellularAutomatas.LCellAutomaton.border",
   "Not",
   "CellularAutomatas.Word",
   "CellularAutomatas.CellAutomaton.δ",
   "Set",
   "CellularAutomatas.CellAutomaton.nextt",
   "congr_arg",
   "Nat.recAux",
   "Function.comp",
   "CellularAutomatas.LCellAutomaton.comp",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "Nat.iterate",
   "id",
   "CellularAutomatas.apply_iterated",
   "Eq.mpr",
   "dite"],
  "name": "CellularAutomatas.ProdCA.comp",
  "constType":
  "∀ {α β : Type} [inst : CellularAutomatas.Alphabet β] (f : β → CellularAutomatas.LCellAutomaton α)\n  (w : CellularAutomatas.Word α) (t : ℕ) (i : ℤ),\n  (CellularAutomatas.ProdCA α β f).comp w t i = fun b => (f b).comp w t i",
  "constCategory": "Theorem"},
 {"references": ["CellularAutomatas.DefinesLanguage.casesOn", "Language"],
  "name": "CellularAutomatas.DefinesLanguage.noConfusionType",
  "constType":
  "{CA : Sort u_1} →\n  {α : Type} → Sort u → CellularAutomatas.DefinesLanguage CA α → CellularAutomatas.DefinesLanguage CA α → Sort u",
  "constCategory": "Definition"},
 {"references": ["List.casesOn", "Unit.unit", "Unit"],
  "name": "List.length.match_1",
  "constType":
  "{α : Type u_1} →\n  (motive : List α → Sort u_2) →\n    (x : List α) → (Unit → motive []) → ((head : α) → (as : List α) → motive (head :: as)) → motive x",
  "constCategory": "Definition"},
 {"references": ["CellularAutomatas.composition.Params._sizeOf_1"],
  "name": "CellularAutomatas.composition.Params._sizeOf_inst",
  "constType": "SizeOf CellularAutomatas.composition.Params",
  "constCategory": "Definition"},
 {"references":
  ["Int.Linear.norm_le",
   "CellularAutomatas.Word.get'._proof_1",
   "Int.toNat",
   "Eq.trans",
   "Set",
   "Neg.neg",
   "Membership.mem",
   "eagerReduce",
   "HMul.hMul",
   "Int.Linear.Expr.eq_of_norm_eq",
   "Lean.Grind.Int.lt_eq",
   "OfNat.ofNat",
   "congrArg",
   "Eq.mpr_prop",
   "HAdd.hAdd",
   "LT.lt",
   "NatCast.natCast",
   "congr",
   "funext",
   "LE.le",
   "id",
   "setOf",
   "List.length"],
  "name": "CellularAutomatas.ca_id_comp_p0._proof_1_5",
  "constType":
  "∀ {t : ℕ} {α : Type} {w : List α}, ↑t ∈ {i | -1 * i ≤ 0 ∧ i + -1 * ↑w.length + 1 ≤ 0} → (↑t).toNat < w.length",
  "constCategory": "Theorem"},
 {"references": ["outParam"],
  "name": "HAdd.hAdd",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → [self : HAdd α β γ] → α → β → γ",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "Lean.Omega.IntList.sum_neg",
   "Eq.trans",
   "of_eq_true",
   "Lean.Omega.IntList",
   "Neg.neg",
   "HMul.hMul",
   "Lean.Omega.IntList.sum",
   "Lean.Omega.IntList.mul_neg_left",
   "congrArg"],
  "name": "Lean.Omega.IntList.dot_neg_left",
  "constType": "∀ (xs ys : Omega.IntList), (-xs).dot ys = -xs.dot ys",
  "constCategory": "Theorem"},
 {"references": ["HAdd.hAdd", "Nat.add_left_cancel_iff", "propext"],
  "name": "Nat.add_left_cancel_iff._simp_1",
  "constType": "∀ {m k n : ℕ}, (n + m = n + k) = (m = k)",
  "constCategory": "Theorem"},
 {"references":
  ["HAppend.hAppend",
   "Lean.ConstantVal.name",
   "Lean.ConstructorVal.toConstantVal",
   "Lean.ConstantInfo.type",
   "Lean.Expr.getUsedConstantsAsSet",
   "_private.Lean.Util.FoldConsts.0.Lean.ConstantInfo.getUsedConstantsAsSet.match_1",
   "Lean.NameSet.ofList",
   "EmptyCollection.emptyCollection",
   "Unit",
   "Lean.RecursorVal.all",
   "_private.Lean.Util.FoldConsts.0.Lean.ConstantInfo.getUsedConstantsAsSet.match_4",
   "Lean.OpaqueVal.value",
   "Lean.NameSet.insert",
   "Lean.InductiveVal.ctors",
   "Lean.ConstantInfo.value?",
   "Lean.NameSet"],
  "name": "Lean.ConstantInfo.getUsedConstantsAsSet",
  "constType": "ConstantInfo → NameSet",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CellularAutomatas.Alphabet.ctorIdx",
  "constType": "{α : Type} → CellularAutomatas.Alphabet α → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Eq.trans",
   "Lean.Omega.IntList.get",
   "Lean.Omega.LinearCombo.coordinate",
   "OfNat.ofNat",
   "congrArg",
   "HAdd.hAdd",
   "eq_self",
   "Lean.Omega.LinearCombo.coordinate_eval",
   "of_eq_true",
   "Lean.Omega.Coeffs.ofList",
   "Lean.Omega.IntList.get_cons_succ",
   "Lean.Omega.Coeffs.get",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.IntList.get_cons_zero"],
  "name": "Lean.Omega.LinearCombo.coordinate_eval_5",
  "constType":
  "∀ {a0 a1 a2 a3 a4 a5 : ℤ} {t : List ℤ},\n  (Omega.LinearCombo.coordinate 5).eval (Omega.Coeffs.ofList (a0 :: a1 :: a2 :: a3 :: a4 :: a5 :: t)) = a5",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "zero_add",
   "Nat.cast",
   "Nat.cast_zero",
   "id",
   "Eq.mpr",
   "Nat.cast_succ",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Nat.cast_one",
  "constType": "∀ {R : Type u_1} [inst : AddMonoidWithOne R], ↑1 = 1",
  "constCategory": "Theorem"},
 {"references": ["Preorder.le_refl"],
  "name": "le_refl",
  "constType": "∀ {α : Type u_1} [inst : Preorder α] (a : α), a ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans",
   "CellularAutomatas.FiniteStateTransducer.scanr_q",
   "CellularAutomatas.FiniteStateTransducer.Q",
   "Prod.snd",
   "OfNat.ofNat",
   "List.foldr",
   "congrArg",
   "HAdd.hAdd",
   "eq_self",
   "of_eq_true",
   "Nat.add_left_cancel_iff._simp_1",
   "CellularAutomatas.FiniteStateTransducer.scanr_step",
   "id",
   "List.length"],
  "name": "CellularAutomatas.FiniteStateTransducer.scanr_q_len",
  "constType":
  "∀ {α β : Type} (M : CellularAutomatas.FiniteStateTransducer α β) (q : M.Q) (w : List α),\n  List.length (M.scanr_q q w) = w.length",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Lean.Grind.OrderedAdd.add_le_left_iff",
  "constType":
  "∀ {M : Type u} {inst : HAdd M M M} {inst_1 : LE M} {inst_2 : Std.IsPreorder M} [self : Grind.OrderedAdd M] {a b : M}\n  (c : M), a ≤ b ↔ a + c ≤ b + c",
  "constCategory": "Theorem"},
 {"references":
  ["Fin.is_lt._simp_1",
   "Int.Linear.le_unsat",
   "Lean.Grind.Order.eq_trans_false",
   "CellularAutomatas.FiniteStateTransducer.scanr_len",
   "Eq.trans",
   "Int.Linear.eq_def",
   "eq_true",
   "HMul.hMul",
   "eagerReduce",
   "Lean.Grind.intro_with_eq'",
   "ite_cond_eq_true",
   "IntCast.intCast",
   "Nat.ToInt.natCast_ofNat",
   "Nat.ToInt.ofNat_toNat",
   "Fin.val",
   "CellularAutomatas.FiniteStateTransducer.scanr_get'_eq._proof_1_3",
   "NatCast.natCast",
   "Eq.symm",
   "CellularAutomatas.FiniteStateTransducer.scanr_get'_eq._proof_1_4",
   "List.drop",
   "Neg.neg",
   "Int.Linear.diseq_unsat",
   "CellularAutomatas.FiniteStateTransducer.scanr",
   "Int.Linear.eq_diseq_subst",
   "Lean.Grind.Int.lt_eq",
   "ite_cond_eq_false",
   "CellularAutomatas.FiniteStateTransducer.scanr_get'_eq1._proof_1",
   "Lean.Grind.nestedProof",
   "Decidable.byContradiction",
   "eq_false",
   "Fin.val_lt_of_le",
   "Classical.byContradiction",
   "Int.Linear.not_eq_norm_expr",
   "id",
   "CellularAutomatas.FiniteStateTransducer.scanr_get'_eq._proof_1_2",
   "Lean.Grind.Order.le_eq_false_of_le_k",
   "Int.Linear.le_of_le_diseq",
   "Int.Linear.eq_of_le_ge",
   "List.length",
   "Int.Linear.norm_le",
   "Int.toNat",
   "Nat.cast",
   "GetElem.getElem",
   "CellularAutomatas.FiniteStateTransducer.scanr_reduce",
   "Int.Linear.eq_eq_subst'",
   "congrArg",
   "Lean.Grind.Nat.lt_eq",
   "Lean.Grind.nestedDecidable",
   "Nat.ToInt.of_diseq",
   "CellularAutomatas.FiniteStateTransducer.δ",
   "Int.Linear.eq_of_core",
   "Not",
   "CellularAutomatas.Word",
   "Lean.Grind.em",
   "Lean.Grind.alreadyNorm",
   "ite",
   "Nat.ToInt.add_congr",
   "OfNat.ofNat",
   "Eq.mpr_prop",
   "HAdd.hAdd",
   "LT.lt",
   "Or.casesOn",
   "Nat.ToInt.toNat_nonneg",
   "of_eq_true",
   "LE.le",
   "Int.Linear.eq_le_subst_nonneg",
   "Lean.Grind.intro_with_eq",
   "Lean.Grind.CommRing.le_norm_expr",
   "Lean.Grind.Order.eq_mp",
   "CellularAutomatas.FiniteStateTransducer.f"],
  "name": "CellularAutomatas.FiniteStateTransducer.scanr_get'_eq._proof_1_8",
  "constType":
  "∀ {α β : Type} {M : CellularAutomatas.FiniteStateTransducer α β} (w : CellularAutomatas.Word α) (i : ℤ),\n  0 ≤ i →\n    i < ↑(List.length w) →\n      ∀ (h_nat_lt : i.toNat < List.length w),\n        (M.scanr w)[⟨i.toNat, h_nat_lt⟩] =\n            M.f (M.δ (M.scanr_reduce w⟦↑⟨i.toNat, h_nat_lt⟩ + 1..*⟧) w[⟨i.toNat, h_nat_lt⟩]) →\n          (i + 1).toNat = ↑⟨i.toNat, h_nat_lt⟩ + 1",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Iff.mp",
  "constType": "∀ {a b : Prop}, (a ↔ b) → a → b",
  "constCategory": "Theorem"},
 {"references": ["Int.ofNat_inj"],
  "name": "Int.ofNat_eq_zero",
  "constType": "∀ {n : ℕ}, ↑n = 0 ↔ n = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Name.isPrefixOf",
   "List.filter",
   "Lean.Environment.header",
   "Lean.Name.mkStr1",
   "Lean.EnvironmentHeader.moduleNames",
   "Array.toList"],
  "name": "CellularAutomatas.getCellularAutomatasModules",
  "constType": "Environment → List Name",
  "constCategory": "Definition"},
 {"references": ["Monoid.npow_succ"],
  "name": "pow_succ",
  "constType":
  "∀ {M : Type u_2} [inst : Monoid M] (a : M) (n : ℕ), a ^ (n + 1) = a ^ n * a",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.Word.get'",
   "Fin.is_lt._simp_1",
   "Eq.trans",
   "CellularAutomatas.FiniteStateTransducer.scanr_len",
   "Membership.mem",
   "CellularAutomatas.FiniteStateTransducer.scanr_get'_eq._proof_1_8",
   "eq_true",
   "GE.ge",
   "Fin.val",
   "funext",
   "eq_of_heq",
   "Eq.symm",
   "CellularAutomatas.Word.range",
   "Eq.ndrec",
   "And.left",
   "List.drop",
   "And.right",
   "CellularAutomatas.FiniteStateTransducer.scanr",
   "CellularAutomatas.FiniteStateTransducer.scanr_get'_eq1._proof_1",
   "CellularAutomatas.Word.get'.eq_1",
   "Decidable.byContradiction",
   "Fin.val_lt_of_le",
   "id",
   "Eq.mpr",
   "List.length",
   "setOf",
   "CellularAutomatas.Word.get'._proof_1",
   "Int.toNat",
   "Nat.cast",
   "Eq.mp",
   "CellularAutomatas.FiniteStateTransducer.Q",
   "GetElem.getElem",
   "CellularAutomatas.FiniteStateTransducer.scanr_reduce",
   "congrArg",
   "CellularAutomatas.FiniteStateTransducer.scanr_get'_eq1",
   "List.get",
   "ge_iff_le._simp_1",
   "propext",
   "CellularAutomatas.FiniteStateTransducer.δ",
   "Not",
   "CellularAutomatas.Word",
   "Set",
   "Eq.casesOn",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "LT.lt",
   "CellularAutomatas.FiniteStateTransducer.range_of_scanr",
   "of_eq_true",
   "LE.le",
   "Int.toNat_lt",
   "CellularAutomatas.FiniteStateTransducer.f"],
  "name": "CellularAutomatas.FiniteStateTransducer.scanr_get'_eq",
  "constType":
  "∀ {α β : Type} {M : CellularAutomatas.FiniteStateTransducer α β} (w : CellularAutomatas.Word α) (i : ℤ)\n  (h : i ∈ w.range), (M.scanr w).get' i ⋯ = M.f (M.δ (M.scanr_reduce w⟦(i + 1).toNat..*⟧) (w.get' i h))",
  "constCategory": "Theorem"},
 {"references": ["and_congr_right_iff", "propext"],
  "name": "and_congr_right_iff._simp_1",
  "constType": "∀ {a b c : Prop}, (a ∧ b ↔ a ∧ c) = (a → (b ↔ c))",
  "constCategory": "Theorem"},
 {"references": ["Not", "if_neg", "ite", "dite", "if_pos"],
  "name": "Lean.Omega.ite_disjunction",
  "constType":
  "∀ {α : Type u} {P : Prop} [inst : Decidable P] {a b : α}, P ∧ (if P then a else b) = a ∨ ¬P ∧ (if P then a else b) = b",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.cast",
   "Eq.trans",
   "le_of_le_of_eq",
   "Lean.Omega.LinearCombo.coordinate_eval_0",
   "Lean.Omega.Constraint.combine_sat'",
   "GT.gt",
   "Decidable.decide",
   "Lean.Omega.Coeffs.ofList",
   "Eq.symm",
   "Lean.Omega.tidy_sat",
   "HSub.hSub",
   "Lean.Omega.LinearCombo.add_eval",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "Int.add_one_le_of_lt",
   "of_decide_eq_true",
   "Not",
   "CellularAutomatas.Word",
   "Lean.Omega.combo_sat'",
   "Neg.neg",
   "Lean.Omega.Constraint.addInequality_sat",
   "Lean.Omega.Int.add_congr",
   "Lean.Omega.Constraint.isImpossible",
   "Lean.Omega.Int.le_of_not_lt",
   "Lean.Omega.LinearCombo.coordinate",
   "Int.ofNat_nonneg",
   "OfNat.ofNat",
   "Int.sub_nonneg_of_le",
   "Lean.Omega.LinearCombo.coordinate_eval_1",
   "HAdd.hAdd",
   "LT.lt",
   "Lean.Omega.LinearCombo.sub_eval",
   "Lean.Omega.Int.ofNat_lt_of_lt",
   "id",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.Int.sub_congr",
   "List.length"],
  "name": "CellularAutomatas.Word.zero_mem_cone._proof_1_2",
  "constType":
  "∀ {α : Type u_1} {w : CellularAutomatas.Word α}, List.length w > 0 → ∀ (t : ℕ), ¬0 < ↑(List.length w) + ↑t → False",
  "constCategory": "Theorem"},
 {"references": ["Int.add", "Int.Linear.Var"],
  "name": "Int.Linear.Poly.addConst_k",
  "constType": "Int.Linear.Poly → ℤ → Int.Linear.Poly",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "Eq.substr",
   "Eq.trans",
   "of_eq_true",
   "forall_congr",
   "Eq.symm",
   "congrArg"],
  "name": "forall_prop_domain_congr",
  "constType":
  "∀ {p₁ p₂ : Prop} {q₁ : p₁ → Prop} {q₂ : p₂ → Prop} (h₁ : p₁ = p₂),\n  (∀ (a : p₂), q₁ ⋯ = q₂ a) → (∀ (a : p₁), q₁ a) = ∀ (a : p₂), q₂ a",
  "constCategory": "Theorem"},
 {"references": ["Nat.cast", "OfNat.ofNat"],
  "name": "Lean.Grind.instToIntFinCoOfNatIntCast.eq_1",
  "constType":
  "∀ {n : ℕ}, Grind.instToIntFinCoOfNatIntCast = { toInt := fun x => ↑↑x, toInt_inj := ⋯, toInt_mem := ⋯ }",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.Word",
   "CellularAutomatas.FiniteStateTransducer.scanr_q",
   "CellularAutomatas.FiniteStateTransducer.q0"],
  "name": "CellularAutomatas.FiniteStateTransducer.scanr",
  "constType":
  "{α β : Type} → CellularAutomatas.FiniteStateTransducer α β → CellularAutomatas.Word α → CellularAutomatas.Word β",
  "constCategory": "Definition"},
 {"references":
  ["CellularAutomatas.uniform_config", "CellularAutomatas.CellAutomaton.Q"],
  "name": "CellularAutomatas.uniform_config_at_eq",
  "constType":
  "∀ {C : CellularAutomatas.CellAutomaton} (q : C.Q) (i : ℤ), CellularAutomatas.uniform_config q i = q",
  "constCategory": "Theorem"},
 {"references": ["CellularAutomatas.backwards_fsm.Params.inst3"],
  "name": "CellularAutomatas.backwards_fsm.instAlphabetγ",
  "constType":
  "(e : CellularAutomatas.backwards_fsm.Params) → CellularAutomatas.Alphabet e.γ",
  "constCategory": "Definition"},
 {"references":
  ["LT.lt", "Not", "Nat.lt_or_ge", "LE.le", "Or.resolve_right", "GE.ge"],
  "name": "Nat.gt_of_not_le",
  "constType": "∀ {n m : ℕ}, ¬n ≤ m → n > m",
  "constCategory": "Theorem"},
 {"references": ["CellularAutomatas.Advice._sizeOf_1"],
  "name": "CellularAutomatas.Advice._sizeOf_inst",
  "constType":
  "(α Γ : Type) → [SizeOf α] → [SizeOf Γ] → SizeOf (CellularAutomatas.Advice α Γ)",
  "constCategory": "Definition"},
 {"references": ["Not", "False.elim", "Decidable.byCases", "id"],
  "name": "Decidable.byContradiction",
  "constType": "∀ {p : Prop} [dec : Decidable p], (¬p → False) → p",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.simulation.instFintypeQ1.match_3",
   "CellularAutomatas.simulation.instFintypeQ1.match_5",
   "CellularAutomatas.simulation.Params.C_ctl",
   "Eq.symm",
   "CellularAutomatas.CellAutomaton.Q",
   "CellularAutomatas.simulation.Q1.casesOn",
   "Eq.ndrec",
   "OfNat.ofNat"],
  "name": "CellularAutomatas.simulation.Q1.proxyTypeEquiv",
  "constType":
  "(e : CellularAutomatas.simulation.Params) → (_ : e.C_ctl.Q) × Fin 3 ≃ CellularAutomatas.simulation.Q1 e",
  "constCategory": "Definition"},
 {"references": ["False.elim", "eq_true"],
  "name": "forall_false",
  "constType": "∀ (p : False → Prop), (∀ (h : False), p h) = True",
  "constCategory": "Theorem"},
 {"references": ["Not", "HAdd.hAdd", "LE.le", "OfNat.ofNat"],
  "name": "_private.Mathlib.Data.Nat.Find.0.Nat.lbp",
  "constType": "{p : ℕ → Prop} → ℕ → ℕ → Prop",
  "constCategory": "Definition"},
 {"references":
  ["HDiv.hDiv", "Nat.cast", "Fin.intCast", "CellularAutomatas.Config"],
  "name": "CellularAutomatas.speedup_factor_k.decompress",
  "constType":
  "{Q : Type} → (k : ℕ) → [NeZero k] → CellularAutomatas.Config (Fin k → Q) → CellularAutomatas.Config Q",
  "constCategory": "Definition"},
 {"references":
  ["eq_self", "of_eq_true", "CellularAutomatas.FiniteStateTransducer.Q"],
  "name": "CellularAutomatas.FiniteStateTransducer.scanr_reduce_q_empty",
  "constType":
  "∀ {α β : Type} {M : CellularAutomatas.FiniteStateTransducer α β} (q : M.Q), M.scanr_reduce_q q [] = q",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.cast",
   "Eq.trans",
   "le_of_le_of_eq",
   "Lean.Omega.LinearCombo.coordinate_eval_0",
   "Decidable.decide",
   "Lean.Omega.Coeffs.ofList",
   "Eq.symm",
   "Lean.Omega.tidy_sat",
   "HSub.hSub",
   "Lean.Omega.LinearCombo.add_eval",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "Int.add_one_le_of_lt",
   "of_decide_eq_true",
   "Not",
   "CellularAutomatas.Word",
   "Neg.neg",
   "Lean.Omega.Constraint.addInequality_sat",
   "Lean.Omega.Int.add_congr",
   "Lean.Omega.Constraint.isImpossible",
   "Lean.Omega.LinearCombo.coordinate",
   "OfNat.ofNat",
   "Int.sub_nonneg_of_le",
   "HAdd.hAdd",
   "Lean.Omega.LinearCombo.sub_eval",
   "Lean.Omega.Int.ofNat_lt_of_lt",
   "LE.le",
   "Nat.lt_of_not_le",
   "id",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.Int.sub_congr",
   "List.length"],
  "name": "CellularAutomatas.Word.get_fst._proof_1",
  "constType":
  "∀ {α β : Type} (w : CellularAutomatas.Word (α ⨉ β)), ¬List.length w ≤ List.length w → False",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "CellularAutomatas.Word",
   "CellularAutomatas.CellAutomaton.Q",
   "CellularAutomatas.LCellAutomaton.comp",
   "CellularAutomatas.Config",
   "OfNat.ofNat"],
  "name": "CellularAutomatas.LCellAutomaton.comp_zero",
  "constType":
  "∀ {α : Type} {C : CellularAutomatas.LCellAutomaton α} {w : CellularAutomatas.Word α}, C.comp w 0 = C.embed_word w",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Grind.AC.Seq.casesOn",
   "Lean.Grind.AC.Var.denote",
   "Lean.Grind.AC.Context.op",
   "Lean.Grind.AC.Seq.sort",
   "congrArg",
   "Lean.Grind.AC.Var",
   "eq_self",
   "of_eq_true",
   "Std.Commutative.comm",
   "Eq.symm",
   "id",
   "Lean.Grind.AC.Seq.denote",
   "Lean.Grind.AC.Seq.sort'",
   "Eq.mpr",
   "Eq.ndrec",
   "Lean.Grind.AC.Seq.denote_sort'"],
  "name": "Lean.Grind.AC.Seq.denote_sort",
  "constType":
  "∀ {α : Sort u_1} (ctx : Grind.AC.Context α) {inst₁ : Associative ctx.op} {inst₂ : Commutative ctx.op}\n  (s : Grind.AC.Seq), Grind.AC.Seq.denote ctx s.sort = Grind.AC.Seq.denote ctx s",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.CArtTransducer.toLCellAutomaton",
   "CellularAutomatas.FiniteStateTransducer.comp",
   "CellularAutomatas.backwards_fsm.Params.β",
   "CellularAutomatas.backwards_fsm.Params.C",
   "CellularAutomatas.backwards_fsm.Params.inst3",
   "CellularAutomatas.backwards_fsm.Params.M",
   "CellularAutomatas.FiniteStateTransducer.Q",
   "CellularAutomatas.CArtTransducer.f",
   "CellularAutomatas.backwards_fsm.Params.inst2",
   "CellularAutomatas.backwards_fsm.Params.γ",
   "CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "CellularAutomatas.FiniteStateTransducer.M_projQ",
   "CellularAutomatas.FiniteStateTransducer.M_map",
   "CellularAutomatas.CellAutomaton.Q",
   "CellularAutomatas.backwards_fsm.M_join",
   "CellularAutomatas.backwards_fsm.Params.α"],
  "name": "CellularAutomatas.backwards_fsm.M'",
  "constType":
  "(e : CellularAutomatas.backwards_fsm.Params) → CellularAutomatas.FiniteStateTransducer (e.α ⨉ (e.M.Q → e.C.Q)) e.γ",
  "constCategory": "Definition"},
 {"references": ["id", "Prod.noConfusion"],
  "name": "Prod.mk.noConfusion",
  "constType":
  "{α : Type u} →\n  {β : Type v} →\n    (P : Sort u_1) →\n      (fst : α) → (snd : β) → (fst' : α) → (snd' : β) → (fst, snd) = (fst', snd') → (fst = fst' → snd = snd' → P) → P",
  "constCategory": "Definition"},
 {"references": ["Trans.trans"],
  "name": "Trans.simple",
  "constType":
  "{α : Sort u_1} → {a b c : α} → {r : α → α → Sort u_2} → [Trans r r r] → r a b → r b c → r a c",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Grind.AC.Seq.var.noConfusion",
   "Lean.Grind.AC.Var",
   "Eq.propIntro",
   "Eq.symm",
   "Eq.ndrec",
   "Eq.casesOn"],
  "name": "Lean.Grind.AC.Seq.var.injEq",
  "constType":
  "∀ (x x_1 : Grind.AC.Var), (Grind.AC.Seq.var x = Grind.AC.Seq.var x_1) = (x = x_1)",
  "constCategory": "Theorem"},
 {"references":
  ["sorryAx",
   "CellularAutomatas.simulation.C'.match_1",
   "CellularAutomatas.simulation.Q1.counter",
   "ite",
   "CellularAutomatas.simulation.instInhabitedQ1.default._proof_1",
   "CellularAutomatas.CellAutomaton.Q",
   "OfNat.ofNat",
   "CellularAutomatas.simulation.Params.C_inr"],
  "name": "CellularAutomatas.simulation.C'",
  "constType":
  "CellularAutomatas.simulation.Params → CellularAutomatas.CellAutomaton",
  "constCategory": "Definition"},
 {"references":
  ["Nat.cast",
   "Eq.mp",
   "HMul.hMul",
   "Int.sub_nonpos_of_le",
   "Int.one_mul",
   "congrArg",
   "False.elim",
   "NatCast.natCast",
   "HSub.hSub",
   "Eq.symm",
   "Lean.Omega.Int.ofNat_sub_eq_zero",
   "Int.neg_mul",
   "Int.sub_eq_add_neg",
   "Int.le_of_sub_nonpos",
   "propext",
   "Not",
   "Neg.neg",
   "ite",
   "Int.ofNat_le",
   "Decidable.casesOn",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "if_neg",
   "LE.le",
   "id",
   "Int.ofNat_sub",
   "Eq.mpr",
   "if_pos"],
  "name": "Int.Linear.natCast_sub",
  "constType":
  "∀ (x y : ℕ), ↑(x - y) = if ↑y + -1 * ↑x ≤ 0 then ↑x + -1 * ↑y else 0",
  "constCategory": "Theorem"},
 {"references": ["dvd_refl"],
  "name": "dvd_rfl",
  "constType": "∀ {α : Type u_1} [inst : Monoid α] {a : α}, a ∣ a",
  "constCategory": "Theorem"},
 {"references": ["Nat.casesOn", "List.casesOn", "OfNat.ofNat"],
  "name": "_private.Init.Data.List.TakeDrop.0.List.length_drop.match_1_1",
  "constType":
  "∀ {α : Type u_1} (motive : ℕ → List α → Prop) (x : ℕ) (x_1 : List α),\n  (∀ (x : List α), motive 0 x) →\n    (∀ (i : ℕ), motive i.succ []) → (∀ (i : ℕ) (x : α) (l : List α), motive i.succ (x :: l)) → motive x x_1",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CellularAutomatas.Alphabet.inh",
  "constType":
  "{α : Type} → [self : CellularAutomatas.Alphabet α] → Inhabited α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CellularAutomatas.TwoStageAdvice.from_transducers",
  "constType":
  "{α γ β : Type} →\n  [inst : CellularAutomatas.Alphabet α] →\n    [inst_1 : CellularAutomatas.Alphabet β] →\n      [inst_2 : CellularAutomatas.Alphabet γ] →\n        CellularAutomatas.FiniteStateTransducer β γ →\n          CellularAutomatas.CArtTransducer α β → CellularAutomatas.TwoStageAdvice α γ",
  "constCategory": "Definition"},
 {"references":
  ["CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "CellularAutomatas.tCellAutomaton.mk.noConfusion",
   "CellularAutomatas.CellAutomaton.Q"],
  "name": "CellularAutomatas.tCellAutomaton.mk.inj",
  "constType":
  "∀ {α : Type} {toLCellAutomaton : CellularAutomatas.LCellAutomaton α} {t p : ℕ → ℕ} {F_pos : toLCellAutomaton.Q → Bool}\n  {toLCellAutomaton_1 : CellularAutomatas.LCellAutomaton α} {t_1 p_1 : ℕ → ℕ} {F_pos_1 : toLCellAutomaton_1.Q → Bool},\n  { toLCellAutomaton := toLCellAutomaton, t := t, p := p, F_pos := F_pos } =\n      { toLCellAutomaton := toLCellAutomaton_1, t := t_1, p := p_1, F_pos := F_pos_1 } →\n    toLCellAutomaton = toLCellAutomaton_1 ∧ t = t_1 ∧ p = p_1 ∧ F_pos ≍ F_pos_1",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.zero_le._simp_1",
   "Nat.min_eq_right",
   "Eq.trans",
   "Nat.min_eq_left",
   "Nat.brecOn",
   "List.take_nil",
   "OfNat.ofNat",
   "congrArg",
   "HAdd.hAdd",
   "eq_self",
   "_private.Init.Data.List.Nat.TakeDrop.0.List.length_take.match_1_1",
   "Nat.succ_min_succ",
   "of_eq_true",
   "Min.min",
   "congr",
   "List.take",
   "Nat.add_left_cancel_iff._simp_1",
   "Nat.below",
   "LE.le",
   "Nat.le_add_left._simp_1",
   "List.length"],
  "name": "List.length_take",
  "constType":
  "∀ {α : Type u_1} {i : ℕ} {l : List α}, (List.take i l).length = min i l.length",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "False.elim",
   "Eq.trans",
   "of_eq_true",
   "noConfusion_of_Nat",
   "eq_false'",
   "Bool.ctorIdx",
   "congrArg"],
  "name": "Bool.false_eq_true",
  "constType": "(false = true) = False",
  "constCategory": "Theorem"},
 {"references": ["Bool.coe_iff_coe", "propext"],
  "name": "Bool.coe_iff_coe._simp_1",
  "constType": "∀ {a b : Bool}, (a = true ↔ b = true) = (a = b)",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.Word",
   "Nat.cast",
   "Eq.trans",
   "Set",
   "Neg.neg",
   "add_zero",
   "GE.ge",
   "OfNat.ofNat",
   "congrArg",
   "LT.lt",
   "HAdd.hAdd",
   "eq_self",
   "of_eq_true",
   "congr",
   "funext",
   "LE.le",
   "neg_zero",
   "ge_iff_le._simp_1",
   "setOf",
   "List.length"],
  "name": "CellularAutomatas.Word.cone_zero_eq_range",
  "constType":
  "∀ {α : Type u_1} {w : CellularAutomatas.Word α}, w.cone 0 = w.range",
  "constCategory": "Theorem"},
 {"references": ["Not", "Decidable.casesOn"],
  "name": "_private.Init.Prelude.0.decide_eq_false.match_1_1",
  "constType":
  "∀ {p : Prop} (motive : Decidable p → ¬p → Prop) (x : Decidable p) (x_1 : ¬p),\n  (∀ (h₁ : p) (h₂ : ¬p), motive (isTrue h₁) h₂) → (∀ (h x : ¬p), motive (isFalse h) x) → motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["Nat.Linear.Expr.toNormPoly",
   "Nat.Linear.ExprCnstr.lhs",
   "Nat.Linear.Poly.cancel",
   "Nat.Linear.ExprCnstr.eq",
   "Nat.Linear.PolyCnstr.norm.match_1",
   "Nat.Linear.ExprCnstr.rhs",
   "Nat.Linear.Poly"],
  "name": "Nat.Linear.ExprCnstr.toNormPoly",
  "constType": "Nat.Linear.ExprCnstr → Nat.Linear.PolyCnstr",
  "constCategory": "Definition"},
 {"references":
  ["List.range",
   "eq_self",
   "List.length_range'",
   "List.range'",
   "Eq.trans",
   "of_eq_true",
   "List.range_eq_range'",
   "OfNat.ofNat",
   "congrArg",
   "List.length"],
  "name": "List.length_range",
  "constType": "∀ {n : ℕ}, (List.range n).length = n",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "_private.Init.Data.Int.Order.0.Int.add_le_add_left.match_1_1",
   "Int.add_assoc",
   "Nat.cast",
   "Int.le.intro",
   "LE.le",
   "id",
   "Eq.mpr",
   "Int.le.dest",
   "congrArg"],
  "name": "Int.add_le_add_left",
  "constType": "∀ {a b : ℤ}, a ≤ b → ∀ (c : ℤ), c + a ≤ c + b",
  "constCategory": "Theorem"},
 {"references":
  ["CellularAutomatas.Word.get'",
   "Nat.cast_one",
   "Mathlib.Tactic.RingNF.add_assoc_rev",
   "Eq.trans",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "CellularAutomatas.CellAutomaton.next",
   "Membership.mem",
   "CellularAutomatas.ca_id",
   "HMul.hMul",
   "CellularAutomatas.Config",
   "Inhabited.default",
   "CellularAutomatas.LCellAutomaton.toCellAutomaton",
   "funext",
   "Eq.symm",
   "CellularAutomatas.Word.range",
   "CellularAutomatas.CArtTransducer.toLCellAutomaton",
   "CellularAutomatas.CellAutomaton.nextt.eq_1",
   "CellularAutomatas.ca_id_comp_p0._proof_1_8",
   "Nat.recAux",
   "add_zero",
   "CellularAutomatas.LCellAutomaton.comp",
   "Mathlib.Tactic.Ring.atom_pf",
   "Nat.cast_zero",
   "id",
   "CellularAutomatas.apply_iterated",
   "Eq.mpr",
   "Nat.rawCast",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "List.length",
   "CellularAutomatas.Word.get'._proof_1",
   "Int.toNat",
   "Nat.cast",
   "GetElem.getElem",
   "CellularAutomatas.LCellAutomaton.embed",
   "congrArg",
   "pow_one",
   "List.get",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "congr",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "CellularAutomatas.LCellAutomaton.embed_word",
   "CellularAutomatas.CellAutomaton.Q",
   "CellularAutomatas.LCellAutomaton.border",
   "Not",
   "CellularAutomatas.Word",
   "CellularAutomatas.apply_iterated.eq_1",
   "Set",
   "CellularAutomatas.CellAutomaton.nextt",
   "Mathlib.Tactic.Ring.cast_pos",
   "mul_one",
   "HPow.hPow",
   "Mathlib.Tactic.Ring.add_congr",
   "Mathlib.Tactic.RingNF.nat_rawCast_1",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "LT.lt",
   "Nat.cast_add",
   "eq_self",
   "Nat.iterate",
   "of_eq_true",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "dite"],
  "name": "CellularAutomatas.ca_id_comp_p0",
  "constType":
  "∀ {t : ℕ} {α : Type} [inst : CellularAutomatas.Alphabet α] {w : CellularAutomatas.Word α} (h : t < List.length w),\n  (CellularAutomatas.ca_id α).comp w t 0 = w[t]",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CellularAutomatas.tCellAutomatonWithAdvice.C",
  "constType":
  "{α : Type} → (self : CellularAutomatas.tCellAutomatonWithAdvice α) → CellularAutomatas.tCellAutomaton (α ⨉ self.Γ)",
  "constCategory": "Definition"},
 {"references": ["Lean.Name.mkStr1", "Lean.Name.mkStr2"],
  "name": "CellularAutomatas.verifyConfig",
  "constType": "List (Name ⨉ List Name)",
  "constCategory": "Definition"},
 {"references":
  ["Eq.trans",
   "le_of_le_of_eq",
   "Lean.Omega.LinearCombo.coordinate_eval_3",
   "Classical.propDecidable",
   "Lean.Omega.LinearCombo.coordinate_eval_4",
   "Lean.Omega.Int.ofNat_le_of_le",
   "Lean.Omega.LinearCombo.neg_eval",
   "HSub.hSub",
   "Lean.Omega.tidy_sat",
   "Eq.symm",
   "Lean.Omega.ite_disjunction",
   "Lean.Omega.LinearCombo.add_eval",
   "Lean.Omega.Int.lt_of_not_le",
   "Decidable.not_or_of_imp",
   "Lean.Omega.Int.neg_congr",
   "Int.add_one_le_of_lt",
   "And.left",
   "Lean.Omega.combo_sat'",
   "Neg.neg",
   "And.right",
   "Lean.Omega.Constraint.addInequality_sat",
   "Lean.Omega.LinearCombo.coordinate",
   "id",
   "Lean.Omega.Constraint.addEquality_sat",
   "Lean.Omega.Int.sub_congr",
   "List.length",
   "Lean.Omega.Int.ofNat_natAbs",
   "Or.elim",
   "Nat.cast",
   "Lean.Omega.LinearCombo.coordinate_eval_2",
   "Lean.Omega.Constraint.combine_sat'",
   "Lean.Omega.LinearCombo.coordinate_eval_0",
   "Int.sub_eq_zero_of_eq",
   "Decidable.decide",
   "Lean.Omega.Coeffs.ofList",
   "Int.natAbs",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "of_decide_eq_true",
   "Not",
   "CellularAutomatas.Word",
   "ite",
   "Lean.Omega.Int.add_congr",
   "Lean.Omega.Constraint.isImpossible",
   "OfNat.ofNat",
   "Int.sub_nonneg_of_le",
   "HAdd.hAdd",
   "Lean.Omega.LinearCombo.coordinate_eval_1",
   "Lean.Omega.LinearCombo.sub_eval",
   "LE.le",
   "Lean.Omega.LinearCombo.eval"],
  "name": "CellularAutomatas.Word.cone_prop._proof_1_2",
  "constType":
  "∀ {α : Type u_1} {w : CellularAutomatas.Word α} {t : ℕ} {i : ℤ} (d : ℤ),\n  (-1 + -↑t ≤ i → ↑(List.length w) + (↑t + 1) ≤ i) → d.natAbs ≤ 1 → -↑t ≤ i + d → ¬↑(List.length w) + ↑t ≤ i + d → False",
  "constCategory": "Theorem"},
 {"references":
  ["DecidablePred", "Language", "CellularAutomatas.Advice.prefixes_in_L"],
  "name": "CellularAutomatas.Advice.prefixes_in_L.eq_1",
  "constType":
  "∀ {α : Type} (L : Language α) [h : DecidablePred L],\n  CellularAutomatas.Advice.prefixes_in_L L =\n    { f := fun w => List.map (fun i => decide (L w⟦0..i + 1⟧)) (List.range (List.length w)), len := ⋯ }",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Omega.LinearCombo.coordinate_eval_2",
   "Nat.cast",
   "Eq.trans",
   "le_of_le_of_eq",
   "Lean.Omega.Constraint.combine_sat'",
   "Lean.Omega.LinearCombo.coordinate_eval_0",
   "Decidable.decide",
   "Lean.Omega.Coeffs.ofList",
   "Lean.Omega.tidy_sat",
   "HSub.hSub",
   "Eq.symm",
   "Lean.Omega.LinearCombo.add_eval",
   "Lean.Omega.Int.lt_of_not_le",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "Int.add_one_le_of_lt",
   "of_decide_eq_true",
   "Not",
   "Neg.neg",
   "And.right",
   "Lean.Omega.Constraint.addInequality_sat",
   "Lean.Omega.Int.add_congr",
   "Lean.Omega.Constraint.isImpossible",
   "Lean.Omega.LinearCombo.coordinate",
   "OfNat.ofNat",
   "Int.sub_nonneg_of_le",
   "Lean.Omega.LinearCombo.coordinate_eval_1",
   "HAdd.hAdd",
   "Lean.Omega.LinearCombo.sub_eval",
   "LE.le",
   "Int.natCast_add",
   "id",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.Int.sub_congr"],
  "name": "CellularAutomatas.nextt_congr._proof_1_6",
  "constType":
  "∀ (t : ℕ) (i j : ℤ), i - ↑t ≤ j ∧ j ≤ i + ↑t → ¬j - 1 ≤ i + ↑(t + 1) → False",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Lean.Omega.Constraint.trivial",
  "constType": "Omega.Constraint",
  "constCategory": "Definition"},
 {"references": ["Int.Linear.Poly.mul'", "ite", "BEq.beq", "OfNat.ofNat"],
  "name": "Int.Linear.Poly.mul",
  "constType": "Int.Linear.Poly → ℤ → Int.Linear.Poly",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Grind.CommRing.Expr.ctorIdx",
   "Lean.Grind.CommRing.Expr.toPoly._sparseCasesOn_1",
   "Ne",
   "Lean.Grind.CommRing.Var",
   "OfNat.ofNat"],
  "name": "Lean.Grind.CommRing.Expr.toPoly.match_1",
  "constType":
  "(motive : Grind.CommRing.Expr → Sort u_1) →\n  (a : Grind.CommRing.Expr) →\n    ((n : ℤ) → motive (Grind.CommRing.Expr.num n)) →\n      ((n : ℤ) → motive (Grind.CommRing.Expr.intCast n)) →\n        ((n : ℕ) → motive (Grind.CommRing.Expr.natCast n)) →\n          ((x : Grind.CommRing.Var) → motive (Grind.CommRing.Expr.var x)) →\n            ((x : Grind.CommRing.Expr) → motive x) → motive a",
  "constCategory": "Definition"},
 {"references":
  ["HAdd.hAdd", "Lean.Omega.IntList", "OfNat.ofNat", "List.foldr"],
  "name": "Lean.Omega.IntList.sum",
  "constType": "Omega.IntList → ℤ",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CellularAutomatas.simulation.Params.ctorIdx",
  "constType": "CellularAutomatas.simulation.Params → ℕ",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CellularAutomatas.CellAutomaton.recOn",
  "constType":
  "{motive : CellularAutomatas.CellAutomaton → Sort u} →\n  (t : CellularAutomatas.CellAutomaton) →\n    ((Q : Type) →\n        [alphabetQ : CellularAutomatas.Alphabet Q] →\n          (δ : Q → Q → Q → Q) → motive { Q := Q, alphabetQ := alphabetQ, δ := δ }) →\n      motive t",
  "constCategory": "Definition"},
 {"references": ["LocallyFiniteOrder.finsetIcc"],
  "name": "Finset.Icc",
  "constType":
  "{α : Type u_1} → [inst : Preorder α] → [LocallyFiniteOrder α] → α → α → Finset α",
  "constCategory": "Definition"},
 {"references":
  ["CellularAutomatas.Word",
   "CellularAutomatas.Advice.casesOn",
   "CellularAutomatas.Advice.noConfusionType",
   "Eq.ndrec",
   "List.length"],
  "name": "CellularAutomatas.Advice.noConfusion",
  "constType":
  "{α Γ : Type} →\n  {P : Sort u} → {x1 x2 : CellularAutomatas.Advice α Γ} → x1 = x2 → CellularAutomatas.Advice.noConfusionType P x1 x2",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Lean.Grind.Semiring.one_mul",
  "constType": "∀ {α : Type u} [self : Grind.Semiring α] (a : α), 1 * a = a",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "eq_self",
   "CellularAutomatas.δδ",
   "Eq.trans",
   "of_eq_true",
   "CellularAutomatas.apply_iterated_succ_apply'",
   "CellularAutomatas.apply_iterated",
   "CellularAutomatas.CellAutomaton.Q",
   "OfNat.ofNat",
   "congrArg"],
  "name": "CellularAutomatas.δδt_succ",
  "constType":
  "∀ {C : CellularAutomatas.CellAutomaton} {q : C.Q} {t : ℕ},\n  CellularAutomatas.δδt q (t + 1) = CellularAutomatas.δδ (CellularAutomatas.δδt q t)",
  "constCategory": "Theorem"},
 {"references":
  ["False.elim",
   "Nat.casesOn",
   "Int.ctorIdx",
   "LE.le",
   "HSub.hSub",
   "noConfusion_of_Nat",
   "Int.casesOn",
   "Int.NonNeg.casesOn",
   "OfNat.ofNat"],
  "name": "_private.Init.Data.Int.Lemmas.0.Int.toNat_of_nonpos.match_1_1",
  "constType":
  "∀ (motive : (x : ℤ) → x ≤ 0 → Prop) (x : ℤ) (x_1 : x ≤ 0),\n  (∀ (x : 0 ≤ 0), motive 0 x) → (∀ (a : ℕ) (x : Int.negSucc a ≤ 0), motive (Int.negSucc a) x) → motive x x_1",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Or.casesOn",
  "constType":
  "∀ {a b : Prop} {motive : a ∨ b → Prop} (t : a ∨ b), (∀ (h : a), motive ⋯) → (∀ (h : b), motive ⋯) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["sorryAx",
   "Set",
   "Membership.mem",
   "Language",
   "HPow.hPow",
   "Subtype.val",
   "Set.Elem",
   "OfNat.ofNat",
   "Unit",
   "CellularAutomatas.CA_rt",
   "CellularAutomatas.tCellAutomaton.L",
   "setOf",
   "List.length"],
  "name": "CellularAutomatas.results_unproven.exp_word_length_rt",
  "constType": "∃ C, (↑C).L = {w | ∃ n, w.length = 2 ^ n}",
  "constCategory": "Theorem"},
 {"references":
  ["rfl",
   "Eq.symm",
   "List.eq_nil_of_length_eq_zero",
   "OfNat.ofNat",
   "List.length"],
  "name": "List.length_eq_zero_iff",
  "constType": "∀ {α : Type u_1} {l : List α}, l.length = 0 ↔ l = []",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.trans",
   "Int.Linear.Poly.denote",
   "HMul.hMul",
   "Int.Linear.Poly.norm",
   "Int.Linear.Poly.insert",
   "congrArg",
   "HAdd.hAdd",
   "Int.Linear.Poly.denote_insert",
   "eq_self",
   "Int.Linear.Var.denote",
   "Int.Linear.Context",
   "of_eq_true",
   "congr",
   "Int.add_comm",
   "Int.Linear.Var"],
  "name": "Int.Linear.Poly.denote_norm",
  "constType":
  "∀ (ctx : Int.Linear.Context) (p : Int.Linear.Poly), Int.Linear.Poly.denote ctx p.norm = Int.Linear.Poly.denote ctx p",
  "constCategory": "Theorem"},
 {"references":
  ["HMod.hMod",
   "Int.neg_mul_neg",
   "Nat.cast",
   "Neg.neg",
   "HMul.hMul",
   "_private.Init.Data.Int.DivMod.Bootstrap.0.Int.emod_add_mul_ediv.match_1_1",
   "OfNat.ofNat",
   "congrArg",
   "HAdd.hAdd",
   "HDiv.hDiv",
   "Nat.mod_add_div",
   "_private.Init.Data.Int.DivMod.Bootstrap.0.Int.emod_add_mul_ediv.aux",
   "id",
   "Int.emod_zero",
   "Int.natAbs",
   "Eq.mpr"],
  "name": "Int.emod_add_mul_ediv",
  "constType": "∀ (a b : ℤ), a % b + b * (a / b) = a",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.Linear.Context",
   "Nat.mul",
   "Nat.add",
   "Nat.Linear.Expr.brecOn",
   "Nat.Linear.Var.denote",
   "Nat.Linear.Expr.denote.match_1",
   "Nat.Linear.Expr.below",
   "Nat.Linear.Var"],
  "name": "Nat.Linear.Expr.denote",
  "constType": "Nat.Linear.Context → Nat.Linear.Expr → ℕ",
  "constCategory": "Definition"},
 {"references": ["CellularAutomatas.t_2n", "CellularAutomatas.OCAr"],
  "name": "CellularAutomatas.OCAr_2n",
  "constType": "(α : Type) → Set (CellularAutomatas.tCellAutomaton α)",
  "constCategory": "Definition"},
 {"references": ["Option.casesOn"],
  "name": "Option.or.match_1",
  "constType":
  "{α : Type u_1} →\n  (motive : Option α → Option α → Sort u_2) →\n    (x x_1 : Option α) →\n      ((a : α) → (x : Option α) → motive (some a) x) → ((b : Option α) → motive none b) → motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["HMod.hMod",
   "Nat.cast",
   "Fin.intCast",
   "CellularAutomatas.speedup_factor_k.compress",
   "HMul.hMul",
   "CellularAutomatas.Config",
   "CellularAutomatas.speedup_factor_k.compress_decompress._proof_1_1",
   "CellularAutomatas.speedup_factor_k.intCastEq",
   "congrArg",
   "HDiv.hDiv",
   "HAdd.hAdd",
   "Fin.val",
   "CellularAutomatas.speedup_factor_k.decompress",
   "funext",
   "HSub.hSub",
   "id",
   "Eq.mpr",
   "Int.emod_def"],
  "name": "CellularAutomatas.speedup_factor_k.compress_decompress",
  "constType":
  "∀ {Q : Type} (k : ℕ) [inst : NeZero k] (c : CellularAutomatas.Config Q),\n  CellularAutomatas.speedup_factor_k.decompress k (CellularAutomatas.speedup_factor_k.compress k c) = c",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Lean.InductiveVal.ctors",
  "constType": "InductiveVal → List Name",
  "constCategory": "Definition"},
 {"references": ["rfl", "List.length"],
  "name": "List.length_nil",
  "constType": "∀ {α : Type u}, [].length = 0",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "Int.zero_sub",
   "Lean.Omega.Int.add_le_iff_le_sub",
   "Neg.neg",
   "LE.le",
   "id",
   "HSub.hSub",
   "Eq.mpr",
   "Iff.rfl",
   "propext",
   "OfNat.ofNat",
   "congrArg"],
  "name": "Lean.Omega.Int.add_le_zero_iff_le_neg",
  "constType": "∀ {a b : ℤ}, a + b ≤ 0 ↔ a ≤ -b",
  "constCategory": "Theorem"},
 {"references": ["EIO"],
  "name": "IO",
  "constType": "Type → Type",
  "constCategory": "Definition"},
 {"references":
  ["Int.toNat",
   "Set",
   "Neg.neg",
   "Membership.mem",
   "HMul.hMul",
   "OfNat.ofNat",
   "Lean.Grind.nestedProof",
   "CellularAutomatas.ca_id_comp_p0._proof_1_5",
   "LT.lt",
   "HAdd.hAdd",
   "NatCast.natCast",
   "LE.le",
   "Fin.isLt",
   "setOf",
   "List.length"],
  "name": "CellularAutomatas.ca_id_comp_p0._proof_1_7",
  "constType":
  "∀ {t : ℕ} {α : Type} {w : List α} (h_2 : ↑t ∈ {i | -1 * i ≤ 0 ∧ i + -1 * ↑w.length + 1 ≤ 0}),\n  ↑⟨(↑t).toNat, ⋯⟩ < w.length",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Grind.AC.Seq.sort'.induct_unfolding",
   "Lean.Grind.AC.Seq.insert",
   "Eq.trans",
   "Lean.Grind.AC.Var.denote",
   "Lean.Grind.AC.Context.op",
   "congrArg",
   "Lean.Grind.AC.Var",
   "Lean.Grind.AC.Seq.denote_insert",
   "eq_self",
   "of_eq_true",
   "Std.Commutative.comm",
   "Eq.symm",
   "id",
   "Lean.Grind.AC.Seq.denote",
   "Eq.mpr",
   "Lean.Grind.AC.Seq.sort'",
   "Std.Associative.assoc"],
  "name": "Lean.Grind.AC.Seq.denote_sort'",
  "constType":
  "∀ {α : Sort u_1} (ctx : Grind.AC.Context α) {inst₁ : Associative ctx.op} {inst₂ : Commutative ctx.op}\n  (s acc : Grind.AC.Seq),\n  Grind.AC.Seq.denote ctx (s.sort' acc) = ctx.op (Grind.AC.Seq.denote ctx s) (Grind.AC.Seq.denote ctx acc)",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "AddLECancellable",
   "AddLECancellable.le_add_tsub_swap",
   "LE.le",
   "id",
   "HSub.hSub",
   "Eq.mpr",
   "add_comm",
   "congrArg"],
  "name": "AddLECancellable.le_add_tsub",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] [inst_1 : AddCommSemigroup α] [inst_2 : Sub α] [OrderedSub α] {a b : α},\n  AddLECancellable b → a ≤ a + b - b",
  "constCategory": "Theorem"},
 {"references": ["CellularAutomatas.OCA", "CellularAutomatas.t_rt"],
  "name": "CellularAutomatas.OCA_rt",
  "constType": "(α : Type) → Set (CellularAutomatas.tCellAutomaton α)",
  "constCategory": "Definition"},
 {"references": ["Eq.symm", "Eq.ndrec"],
  "name": "Lean.Grind.Order.eq_mp",
  "constType": "∀ {p q : Prop}, p = q → p → q",
  "constCategory": "Theorem"}]